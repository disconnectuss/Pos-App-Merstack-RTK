import {
  require_react_dom
} from "./chunk-KBCON5KN.js";
import {
  __commonJS,
  __export,
  __toESM,
  require_react
} from "./chunk-7HP44VBA.js";

// node_modules/color-name/index.js
var require_color_name = __commonJS({
  "node_modules/color-name/index.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      "aliceblue": [240, 248, 255],
      "antiquewhite": [250, 235, 215],
      "aqua": [0, 255, 255],
      "aquamarine": [127, 255, 212],
      "azure": [240, 255, 255],
      "beige": [245, 245, 220],
      "bisque": [255, 228, 196],
      "black": [0, 0, 0],
      "blanchedalmond": [255, 235, 205],
      "blue": [0, 0, 255],
      "blueviolet": [138, 43, 226],
      "brown": [165, 42, 42],
      "burlywood": [222, 184, 135],
      "cadetblue": [95, 158, 160],
      "chartreuse": [127, 255, 0],
      "chocolate": [210, 105, 30],
      "coral": [255, 127, 80],
      "cornflowerblue": [100, 149, 237],
      "cornsilk": [255, 248, 220],
      "crimson": [220, 20, 60],
      "cyan": [0, 255, 255],
      "darkblue": [0, 0, 139],
      "darkcyan": [0, 139, 139],
      "darkgoldenrod": [184, 134, 11],
      "darkgray": [169, 169, 169],
      "darkgreen": [0, 100, 0],
      "darkgrey": [169, 169, 169],
      "darkkhaki": [189, 183, 107],
      "darkmagenta": [139, 0, 139],
      "darkolivegreen": [85, 107, 47],
      "darkorange": [255, 140, 0],
      "darkorchid": [153, 50, 204],
      "darkred": [139, 0, 0],
      "darksalmon": [233, 150, 122],
      "darkseagreen": [143, 188, 143],
      "darkslateblue": [72, 61, 139],
      "darkslategray": [47, 79, 79],
      "darkslategrey": [47, 79, 79],
      "darkturquoise": [0, 206, 209],
      "darkviolet": [148, 0, 211],
      "deeppink": [255, 20, 147],
      "deepskyblue": [0, 191, 255],
      "dimgray": [105, 105, 105],
      "dimgrey": [105, 105, 105],
      "dodgerblue": [30, 144, 255],
      "firebrick": [178, 34, 34],
      "floralwhite": [255, 250, 240],
      "forestgreen": [34, 139, 34],
      "fuchsia": [255, 0, 255],
      "gainsboro": [220, 220, 220],
      "ghostwhite": [248, 248, 255],
      "gold": [255, 215, 0],
      "goldenrod": [218, 165, 32],
      "gray": [128, 128, 128],
      "green": [0, 128, 0],
      "greenyellow": [173, 255, 47],
      "grey": [128, 128, 128],
      "honeydew": [240, 255, 240],
      "hotpink": [255, 105, 180],
      "indianred": [205, 92, 92],
      "indigo": [75, 0, 130],
      "ivory": [255, 255, 240],
      "khaki": [240, 230, 140],
      "lavender": [230, 230, 250],
      "lavenderblush": [255, 240, 245],
      "lawngreen": [124, 252, 0],
      "lemonchiffon": [255, 250, 205],
      "lightblue": [173, 216, 230],
      "lightcoral": [240, 128, 128],
      "lightcyan": [224, 255, 255],
      "lightgoldenrodyellow": [250, 250, 210],
      "lightgray": [211, 211, 211],
      "lightgreen": [144, 238, 144],
      "lightgrey": [211, 211, 211],
      "lightpink": [255, 182, 193],
      "lightsalmon": [255, 160, 122],
      "lightseagreen": [32, 178, 170],
      "lightskyblue": [135, 206, 250],
      "lightslategray": [119, 136, 153],
      "lightslategrey": [119, 136, 153],
      "lightsteelblue": [176, 196, 222],
      "lightyellow": [255, 255, 224],
      "lime": [0, 255, 0],
      "limegreen": [50, 205, 50],
      "linen": [250, 240, 230],
      "magenta": [255, 0, 255],
      "maroon": [128, 0, 0],
      "mediumaquamarine": [102, 205, 170],
      "mediumblue": [0, 0, 205],
      "mediumorchid": [186, 85, 211],
      "mediumpurple": [147, 112, 219],
      "mediumseagreen": [60, 179, 113],
      "mediumslateblue": [123, 104, 238],
      "mediumspringgreen": [0, 250, 154],
      "mediumturquoise": [72, 209, 204],
      "mediumvioletred": [199, 21, 133],
      "midnightblue": [25, 25, 112],
      "mintcream": [245, 255, 250],
      "mistyrose": [255, 228, 225],
      "moccasin": [255, 228, 181],
      "navajowhite": [255, 222, 173],
      "navy": [0, 0, 128],
      "oldlace": [253, 245, 230],
      "olive": [128, 128, 0],
      "olivedrab": [107, 142, 35],
      "orange": [255, 165, 0],
      "orangered": [255, 69, 0],
      "orchid": [218, 112, 214],
      "palegoldenrod": [238, 232, 170],
      "palegreen": [152, 251, 152],
      "paleturquoise": [175, 238, 238],
      "palevioletred": [219, 112, 147],
      "papayawhip": [255, 239, 213],
      "peachpuff": [255, 218, 185],
      "peru": [205, 133, 63],
      "pink": [255, 192, 203],
      "plum": [221, 160, 221],
      "powderblue": [176, 224, 230],
      "purple": [128, 0, 128],
      "rebeccapurple": [102, 51, 153],
      "red": [255, 0, 0],
      "rosybrown": [188, 143, 143],
      "royalblue": [65, 105, 225],
      "saddlebrown": [139, 69, 19],
      "salmon": [250, 128, 114],
      "sandybrown": [244, 164, 96],
      "seagreen": [46, 139, 87],
      "seashell": [255, 245, 238],
      "sienna": [160, 82, 45],
      "silver": [192, 192, 192],
      "skyblue": [135, 206, 235],
      "slateblue": [106, 90, 205],
      "slategray": [112, 128, 144],
      "slategrey": [112, 128, 144],
      "snow": [255, 250, 250],
      "springgreen": [0, 255, 127],
      "steelblue": [70, 130, 180],
      "tan": [210, 180, 140],
      "teal": [0, 128, 128],
      "thistle": [216, 191, 216],
      "tomato": [255, 99, 71],
      "turquoise": [64, 224, 208],
      "violet": [238, 130, 238],
      "wheat": [245, 222, 179],
      "white": [255, 255, 255],
      "whitesmoke": [245, 245, 245],
      "yellow": [255, 255, 0],
      "yellowgreen": [154, 205, 50]
    };
  }
});

// node_modules/is-arrayish/index.js
var require_is_arrayish = __commonJS({
  "node_modules/is-arrayish/index.js"(exports2, module2) {
    module2.exports = function isArrayish(obj) {
      if (!obj || typeof obj === "string") {
        return false;
      }
      return obj instanceof Array || Array.isArray(obj) || obj.length >= 0 && (obj.splice instanceof Function || Object.getOwnPropertyDescriptor(obj, obj.length - 1) && obj.constructor.name !== "String");
    };
  }
});

// node_modules/simple-swizzle/index.js
var require_simple_swizzle = __commonJS({
  "node_modules/simple-swizzle/index.js"(exports2, module2) {
    "use strict";
    var isArrayish = require_is_arrayish();
    var concat2 = Array.prototype.concat;
    var slice4 = Array.prototype.slice;
    var swizzle = module2.exports = function swizzle2(args) {
      var results = [];
      for (var i = 0, len5 = args.length; i < len5; i++) {
        var arg = args[i];
        if (isArrayish(arg)) {
          results = concat2.call(results, slice4.call(arg));
        } else {
          results.push(arg);
        }
      }
      return results;
    };
    swizzle.wrap = function(fn) {
      return function() {
        return fn(swizzle(arguments));
      };
    };
  }
});

// node_modules/color-string/index.js
var require_color_string = __commonJS({
  "node_modules/color-string/index.js"(exports2, module2) {
    var colorNames = require_color_name();
    var swizzle = require_simple_swizzle();
    var hasOwnProperty27 = Object.hasOwnProperty;
    var reverseNames = /* @__PURE__ */ Object.create(null);
    for (name2 in colorNames) {
      if (hasOwnProperty27.call(colorNames, name2)) {
        reverseNames[colorNames[name2]] = name2;
      }
    }
    var name2;
    var cs = module2.exports = {
      to: {},
      get: {}
    };
    cs.get = function(string) {
      var prefix = string.substring(0, 3).toLowerCase();
      var val;
      var model;
      switch (prefix) {
        case "hsl":
          val = cs.get.hsl(string);
          model = "hsl";
          break;
        case "hwb":
          val = cs.get.hwb(string);
          model = "hwb";
          break;
        default:
          val = cs.get.rgb(string);
          model = "rgb";
          break;
      }
      if (!val) {
        return null;
      }
      return { model, value: val };
    };
    cs.get.rgb = function(string) {
      if (!string) {
        return null;
      }
      var abbr = /^#([a-f0-9]{3,4})$/i;
      var hex2 = /^#([a-f0-9]{6})([a-f0-9]{2})?$/i;
      var rgba2 = /^rgba?\(\s*([+-]?\d+)(?=[\s,])\s*(?:,\s*)?([+-]?\d+)(?=[\s,])\s*(?:,\s*)?([+-]?\d+)\s*(?:[,|\/]\s*([+-]?[\d\.]+)(%?)\s*)?\)$/;
      var per = /^rgba?\(\s*([+-]?[\d\.]+)\%\s*,?\s*([+-]?[\d\.]+)\%\s*,?\s*([+-]?[\d\.]+)\%\s*(?:[,|\/]\s*([+-]?[\d\.]+)(%?)\s*)?\)$/;
      var keyword = /^(\w+)$/;
      var rgb2 = [0, 0, 0, 1];
      var match;
      var i;
      var hexAlpha;
      if (match = string.match(hex2)) {
        hexAlpha = match[2];
        match = match[1];
        for (i = 0; i < 3; i++) {
          var i2 = i * 2;
          rgb2[i] = parseInt(match.slice(i2, i2 + 2), 16);
        }
        if (hexAlpha) {
          rgb2[3] = parseInt(hexAlpha, 16) / 255;
        }
      } else if (match = string.match(abbr)) {
        match = match[1];
        hexAlpha = match[3];
        for (i = 0; i < 3; i++) {
          rgb2[i] = parseInt(match[i] + match[i], 16);
        }
        if (hexAlpha) {
          rgb2[3] = parseInt(hexAlpha + hexAlpha, 16) / 255;
        }
      } else if (match = string.match(rgba2)) {
        for (i = 0; i < 3; i++) {
          rgb2[i] = parseInt(match[i + 1], 0);
        }
        if (match[4]) {
          if (match[5]) {
            rgb2[3] = parseFloat(match[4]) * 0.01;
          } else {
            rgb2[3] = parseFloat(match[4]);
          }
        }
      } else if (match = string.match(per)) {
        for (i = 0; i < 3; i++) {
          rgb2[i] = Math.round(parseFloat(match[i + 1]) * 2.55);
        }
        if (match[4]) {
          if (match[5]) {
            rgb2[3] = parseFloat(match[4]) * 0.01;
          } else {
            rgb2[3] = parseFloat(match[4]);
          }
        }
      } else if (match = string.match(keyword)) {
        if (match[1] === "transparent") {
          return [0, 0, 0, 0];
        }
        if (!hasOwnProperty27.call(colorNames, match[1])) {
          return null;
        }
        rgb2 = colorNames[match[1]];
        rgb2[3] = 1;
        return rgb2;
      } else {
        return null;
      }
      for (i = 0; i < 3; i++) {
        rgb2[i] = clamp4(rgb2[i], 0, 255);
      }
      rgb2[3] = clamp4(rgb2[3], 0, 1);
      return rgb2;
    };
    cs.get.hsl = function(string) {
      if (!string) {
        return null;
      }
      var hsl3 = /^hsla?\(\s*([+-]?(?:\d{0,3}\.)?\d+)(?:deg)?\s*,?\s*([+-]?[\d\.]+)%\s*,?\s*([+-]?[\d\.]+)%\s*(?:[,|\/]\s*([+-]?(?=\.\d|\d)(?:0|[1-9]\d*)?(?:\.\d*)?(?:[eE][+-]?\d+)?)\s*)?\)$/;
      var match = string.match(hsl3);
      if (match) {
        var alpha = parseFloat(match[4]);
        var h = (parseFloat(match[1]) % 360 + 360) % 360;
        var s2 = clamp4(parseFloat(match[2]), 0, 100);
        var l = clamp4(parseFloat(match[3]), 0, 100);
        var a4 = clamp4(isNaN(alpha) ? 1 : alpha, 0, 1);
        return [h, s2, l, a4];
      }
      return null;
    };
    cs.get.hwb = function(string) {
      if (!string) {
        return null;
      }
      var hwb = /^hwb\(\s*([+-]?\d{0,3}(?:\.\d+)?)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?(?=\.\d|\d)(?:0|[1-9]\d*)?(?:\.\d*)?(?:[eE][+-]?\d+)?)\s*)?\)$/;
      var match = string.match(hwb);
      if (match) {
        var alpha = parseFloat(match[4]);
        var h = (parseFloat(match[1]) % 360 + 360) % 360;
        var w = clamp4(parseFloat(match[2]), 0, 100);
        var b = clamp4(parseFloat(match[3]), 0, 100);
        var a4 = clamp4(isNaN(alpha) ? 1 : alpha, 0, 1);
        return [h, w, b, a4];
      }
      return null;
    };
    cs.to.hex = function() {
      var rgba2 = swizzle(arguments);
      return "#" + hexDouble(rgba2[0]) + hexDouble(rgba2[1]) + hexDouble(rgba2[2]) + (rgba2[3] < 1 ? hexDouble(Math.round(rgba2[3] * 255)) : "");
    };
    cs.to.rgb = function() {
      var rgba2 = swizzle(arguments);
      return rgba2.length < 4 || rgba2[3] === 1 ? "rgb(" + Math.round(rgba2[0]) + ", " + Math.round(rgba2[1]) + ", " + Math.round(rgba2[2]) + ")" : "rgba(" + Math.round(rgba2[0]) + ", " + Math.round(rgba2[1]) + ", " + Math.round(rgba2[2]) + ", " + rgba2[3] + ")";
    };
    cs.to.rgb.percent = function() {
      var rgba2 = swizzle(arguments);
      var r = Math.round(rgba2[0] / 255 * 100);
      var g = Math.round(rgba2[1] / 255 * 100);
      var b = Math.round(rgba2[2] / 255 * 100);
      return rgba2.length < 4 || rgba2[3] === 1 ? "rgb(" + r + "%, " + g + "%, " + b + "%)" : "rgba(" + r + "%, " + g + "%, " + b + "%, " + rgba2[3] + ")";
    };
    cs.to.hsl = function() {
      var hsla2 = swizzle(arguments);
      return hsla2.length < 4 || hsla2[3] === 1 ? "hsl(" + hsla2[0] + ", " + hsla2[1] + "%, " + hsla2[2] + "%)" : "hsla(" + hsla2[0] + ", " + hsla2[1] + "%, " + hsla2[2] + "%, " + hsla2[3] + ")";
    };
    cs.to.hwb = function() {
      var hwba = swizzle(arguments);
      var a4 = "";
      if (hwba.length >= 4 && hwba[3] !== 1) {
        a4 = ", " + hwba[3];
      }
      return "hwb(" + hwba[0] + ", " + hwba[1] + "%, " + hwba[2] + "%" + a4 + ")";
    };
    cs.to.keyword = function(rgb2) {
      return reverseNames[rgb2.slice(0, 3)];
    };
    function clamp4(num, min11, max11) {
      return Math.min(Math.max(min11, num), max11);
    }
    function hexDouble(num) {
      var str7 = Math.round(num).toString(16).toUpperCase();
      return str7.length < 2 ? "0" + str7 : str7;
    }
  }
});

// node_modules/eventemitter3/index.js
var require_eventemitter3 = __commonJS({
  "node_modules/eventemitter3/index.js"(exports2, module2) {
    "use strict";
    var has2 = Object.prototype.hasOwnProperty;
    var prefix = "~";
    function Events() {
    }
    if (Object.create) {
      Events.prototype = /* @__PURE__ */ Object.create(null);
      if (!new Events().__proto__)
        prefix = false;
    }
    function EE(fn, context, once2) {
      this.fn = fn;
      this.context = context;
      this.once = once2 || false;
    }
    function addListener(emitter, event, fn, context, once2) {
      if (typeof fn !== "function") {
        throw new TypeError("The listener must be a function");
      }
      var listener = new EE(fn, context || emitter, once2), evt = prefix ? prefix + event : event;
      if (!emitter._events[evt])
        emitter._events[evt] = listener, emitter._eventsCount++;
      else if (!emitter._events[evt].fn)
        emitter._events[evt].push(listener);
      else
        emitter._events[evt] = [emitter._events[evt], listener];
      return emitter;
    }
    function clearEvent(emitter, evt) {
      if (--emitter._eventsCount === 0)
        emitter._events = new Events();
      else
        delete emitter._events[evt];
    }
    function EventEmitter3() {
      this._events = new Events();
      this._eventsCount = 0;
    }
    EventEmitter3.prototype.eventNames = function eventNames() {
      var names = [], events, name2;
      if (this._eventsCount === 0)
        return names;
      for (name2 in events = this._events) {
        if (has2.call(events, name2))
          names.push(prefix ? name2.slice(1) : name2);
      }
      if (Object.getOwnPropertySymbols) {
        return names.concat(Object.getOwnPropertySymbols(events));
      }
      return names;
    };
    EventEmitter3.prototype.listeners = function listeners(event) {
      var evt = prefix ? prefix + event : event, handlers = this._events[evt];
      if (!handlers)
        return [];
      if (handlers.fn)
        return [handlers.fn];
      for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {
        ee[i] = handlers[i].fn;
      }
      return ee;
    };
    EventEmitter3.prototype.listenerCount = function listenerCount(event) {
      var evt = prefix ? prefix + event : event, listeners = this._events[evt];
      if (!listeners)
        return 0;
      if (listeners.fn)
        return 1;
      return listeners.length;
    };
    EventEmitter3.prototype.emit = function emit(event, a1, a22, a32, a4, a5) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt])
        return false;
      var listeners = this._events[evt], len5 = arguments.length, args, i;
      if (listeners.fn) {
        if (listeners.once)
          this.removeListener(event, listeners.fn, void 0, true);
        switch (len5) {
          case 1:
            return listeners.fn.call(listeners.context), true;
          case 2:
            return listeners.fn.call(listeners.context, a1), true;
          case 3:
            return listeners.fn.call(listeners.context, a1, a22), true;
          case 4:
            return listeners.fn.call(listeners.context, a1, a22, a32), true;
          case 5:
            return listeners.fn.call(listeners.context, a1, a22, a32, a4), true;
          case 6:
            return listeners.fn.call(listeners.context, a1, a22, a32, a4, a5), true;
        }
        for (i = 1, args = new Array(len5 - 1); i < len5; i++) {
          args[i - 1] = arguments[i];
        }
        listeners.fn.apply(listeners.context, args);
      } else {
        var length5 = listeners.length, j;
        for (i = 0; i < length5; i++) {
          if (listeners[i].once)
            this.removeListener(event, listeners[i].fn, void 0, true);
          switch (len5) {
            case 1:
              listeners[i].fn.call(listeners[i].context);
              break;
            case 2:
              listeners[i].fn.call(listeners[i].context, a1);
              break;
            case 3:
              listeners[i].fn.call(listeners[i].context, a1, a22);
              break;
            case 4:
              listeners[i].fn.call(listeners[i].context, a1, a22, a32);
              break;
            default:
              if (!args)
                for (j = 1, args = new Array(len5 - 1); j < len5; j++) {
                  args[j - 1] = arguments[j];
                }
              listeners[i].fn.apply(listeners[i].context, args);
          }
        }
      }
      return true;
    };
    EventEmitter3.prototype.on = function on(event, fn, context) {
      return addListener(this, event, fn, context, false);
    };
    EventEmitter3.prototype.once = function once2(event, fn, context) {
      return addListener(this, event, fn, context, true);
    };
    EventEmitter3.prototype.removeListener = function removeListener(event, fn, context, once2) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt])
        return this;
      if (!fn) {
        clearEvent(this, evt);
        return this;
      }
      var listeners = this._events[evt];
      if (listeners.fn) {
        if (listeners.fn === fn && (!once2 || listeners.once) && (!context || listeners.context === context)) {
          clearEvent(this, evt);
        }
      } else {
        for (var i = 0, events = [], length5 = listeners.length; i < length5; i++) {
          if (listeners[i].fn !== fn || once2 && !listeners[i].once || context && listeners[i].context !== context) {
            events.push(listeners[i]);
          }
        }
        if (events.length)
          this._events[evt] = events.length === 1 ? events[0] : events;
        else
          clearEvent(this, evt);
      }
      return this;
    };
    EventEmitter3.prototype.removeAllListeners = function removeAllListeners(event) {
      var evt;
      if (event) {
        evt = prefix ? prefix + event : event;
        if (this._events[evt])
          clearEvent(this, evt);
      } else {
        this._events = new Events();
        this._eventsCount = 0;
      }
      return this;
    };
    EventEmitter3.prototype.off = EventEmitter3.prototype.removeListener;
    EventEmitter3.prototype.addListener = EventEmitter3.prototype.on;
    EventEmitter3.prefixed = prefix;
    EventEmitter3.EventEmitter = EventEmitter3;
    if ("undefined" !== typeof module2) {
      module2.exports = EventEmitter3;
    }
  }
});

// node_modules/svg-path-parser/parser.js
var require_parser = __commonJS({
  "node_modules/svg-path-parser/parser.js"(exports2, module2) {
    "use strict";
    function peg$subclass(child, parent2) {
      function ctor() {
        this.constructor = child;
      }
      ctor.prototype = parent2.prototype;
      child.prototype = new ctor();
    }
    function peg$SyntaxError(message, expected, found, location) {
      this.message = message;
      this.expected = expected;
      this.found = found;
      this.location = location;
      this.name = "SyntaxError";
      if (typeof Error.captureStackTrace === "function") {
        Error.captureStackTrace(this, peg$SyntaxError);
      }
    }
    peg$subclass(peg$SyntaxError, Error);
    peg$SyntaxError.buildMessage = function(expected, found) {
      var DESCRIBE_EXPECTATION_FNS = {
        literal: function(expectation) {
          return '"' + literalEscape(expectation.text) + '"';
        },
        "class": function(expectation) {
          var escapedParts = "", i;
          for (i = 0; i < expectation.parts.length; i++) {
            escapedParts += expectation.parts[i] instanceof Array ? classEscape(expectation.parts[i][0]) + "-" + classEscape(expectation.parts[i][1]) : classEscape(expectation.parts[i]);
          }
          return "[" + (expectation.inverted ? "^" : "") + escapedParts + "]";
        },
        any: function(expectation) {
          return "any character";
        },
        end: function(expectation) {
          return "end of input";
        },
        other: function(expectation) {
          return expectation.description;
        }
      };
      function hex2(ch2) {
        return ch2.charCodeAt(0).toString(16).toUpperCase();
      }
      function literalEscape(s2) {
        return s2.replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch2) {
          return "\\x0" + hex2(ch2);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch2) {
          return "\\x" + hex2(ch2);
        });
      }
      function classEscape(s2) {
        return s2.replace(/\\/g, "\\\\").replace(/\]/g, "\\]").replace(/\^/g, "\\^").replace(/-/g, "\\-").replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch2) {
          return "\\x0" + hex2(ch2);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch2) {
          return "\\x" + hex2(ch2);
        });
      }
      function describeExpectation(expectation) {
        return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
      }
      function describeExpected(expected2) {
        var descriptions = new Array(expected2.length), i, j;
        for (i = 0; i < expected2.length; i++) {
          descriptions[i] = describeExpectation(expected2[i]);
        }
        descriptions.sort();
        if (descriptions.length > 0) {
          for (i = 1, j = 1; i < descriptions.length; i++) {
            if (descriptions[i - 1] !== descriptions[i]) {
              descriptions[j] = descriptions[i];
              j++;
            }
          }
          descriptions.length = j;
        }
        switch (descriptions.length) {
          case 1:
            return descriptions[0];
          case 2:
            return descriptions[0] + " or " + descriptions[1];
          default:
            return descriptions.slice(0, -1).join(", ") + ", or " + descriptions[descriptions.length - 1];
        }
      }
      function describeFound(found2) {
        return found2 ? '"' + literalEscape(found2) + '"' : "end of input";
      }
      return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
    };
    function peg$parse(input, options) {
      options = options !== void 0 ? options : {};
      var peg$FAILED = {}, peg$startRuleFunctions = { svg_path: peg$parsesvg_path }, peg$startRuleFunction = peg$parsesvg_path, peg$c0 = function(data2) {
        if (!data2)
          return [];
        for (var cmds2 = [], i = 0; i < data2.length; i++)
          cmds2 = cmds2.concat.apply(cmds2, data2[i]);
        var first3 = cmds2[0];
        if (first3 && first3.code == "m") {
          delete first3.relative;
          first3.code = "M";
        }
        return cmds2;
      }, peg$c1 = function(first3, more) {
        return merge3(first3, more);
      }, peg$c2 = /^[Mm]/, peg$c3 = peg$classExpectation(["M", "m"], false, false), peg$c4 = function(c5, first3, more) {
        var move = commands(c5, [first3]);
        if (more)
          move = move.concat(commands(c5 == "M" ? "L" : "l", more[1]));
        return move;
      }, peg$c5 = /^[Zz]/, peg$c6 = peg$classExpectation(["Z", "z"], false, false), peg$c7 = function() {
        return commands("Z");
      }, peg$c8 = /^[Ll]/, peg$c9 = peg$classExpectation(["L", "l"], false, false), peg$c10 = function(c5, args) {
        return commands(c5, args);
      }, peg$c11 = /^[Hh]/, peg$c12 = peg$classExpectation(["H", "h"], false, false), peg$c13 = function(c5, args) {
        return commands(c5, args.map(function(x3) {
          return { x: x3 };
        }));
      }, peg$c14 = /^[Vv]/, peg$c15 = peg$classExpectation(["V", "v"], false, false), peg$c16 = function(c5, args) {
        return commands(c5, args.map(function(y3) {
          return { y: y3 };
        }));
      }, peg$c17 = /^[Cc]/, peg$c18 = peg$classExpectation(["C", "c"], false, false), peg$c19 = function(a4, b, c5) {
        return { x1: a4.x, y1: a4.y, x2: b.x, y2: b.y, x: c5.x, y: c5.y };
      }, peg$c20 = /^[Ss]/, peg$c21 = peg$classExpectation(["S", "s"], false, false), peg$c22 = function(b, c5) {
        return { x2: b.x, y2: b.y, x: c5.x, y: c5.y };
      }, peg$c23 = /^[Qq]/, peg$c24 = peg$classExpectation(["Q", "q"], false, false), peg$c25 = function(a4, b) {
        return { x1: a4.x, y1: a4.y, x: b.x, y: b.y };
      }, peg$c26 = /^[Tt]/, peg$c27 = peg$classExpectation(["T", "t"], false, false), peg$c28 = /^[Aa]/, peg$c29 = peg$classExpectation(["A", "a"], false, false), peg$c30 = function(rx, ry, xrot, large, sweep, xy) {
        return { rx, ry, xAxisRotation: xrot, largeArc: large, sweep, x: xy.x, y: xy.y };
      }, peg$c31 = function(x3, y3) {
        return { x: x3, y: y3 };
      }, peg$c32 = function(n) {
        return n * 1;
      }, peg$c33 = function(parts) {
        return parts.join("") * 1;
      }, peg$c34 = /^[01]/, peg$c35 = peg$classExpectation(["0", "1"], false, false), peg$c36 = function(bit) {
        return bit == "1";
      }, peg$c37 = function() {
        return "";
      }, peg$c38 = ",", peg$c39 = peg$literalExpectation(",", false), peg$c40 = function(parts) {
        return parts.join("");
      }, peg$c41 = ".", peg$c42 = peg$literalExpectation(".", false), peg$c43 = /^[eE]/, peg$c44 = peg$classExpectation(["e", "E"], false, false), peg$c45 = /^[+\-]/, peg$c46 = peg$classExpectation(["+", "-"], false, false), peg$c47 = /^[0-9]/, peg$c48 = peg$classExpectation([["0", "9"]], false, false), peg$c49 = function(digits) {
        return digits.join("");
      }, peg$c50 = /^[ \t\n\r]/, peg$c51 = peg$classExpectation([" ", "	", "\n", "\r"], false, false), peg$currPos = 0, peg$savedPos = 0, peg$posDetailsCache = [{ line: 1, column: 1 }], peg$maxFailPos = 0, peg$maxFailExpected = [], peg$silentFails = 0, peg$result;
      if ("startRule" in options) {
        if (!(options.startRule in peg$startRuleFunctions)) {
          throw new Error(`Can't start parsing from rule "` + options.startRule + '".');
        }
        peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
      }
      function text() {
        return input.substring(peg$savedPos, peg$currPos);
      }
      function location() {
        return peg$computeLocation(peg$savedPos, peg$currPos);
      }
      function expected(description, location2) {
        location2 = location2 !== void 0 ? location2 : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildStructuredError(
          [peg$otherExpectation(description)],
          input.substring(peg$savedPos, peg$currPos),
          location2
        );
      }
      function error3(message, location2) {
        location2 = location2 !== void 0 ? location2 : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildSimpleError(message, location2);
      }
      function peg$literalExpectation(text2, ignoreCase) {
        return { type: "literal", text: text2, ignoreCase };
      }
      function peg$classExpectation(parts, inverted, ignoreCase) {
        return { type: "class", parts, inverted, ignoreCase };
      }
      function peg$anyExpectation() {
        return { type: "any" };
      }
      function peg$endExpectation() {
        return { type: "end" };
      }
      function peg$otherExpectation(description) {
        return { type: "other", description };
      }
      function peg$computePosDetails(pos) {
        var details = peg$posDetailsCache[pos], p2;
        if (details) {
          return details;
        } else {
          p2 = pos - 1;
          while (!peg$posDetailsCache[p2]) {
            p2--;
          }
          details = peg$posDetailsCache[p2];
          details = {
            line: details.line,
            column: details.column
          };
          while (p2 < pos) {
            if (input.charCodeAt(p2) === 10) {
              details.line++;
              details.column = 1;
            } else {
              details.column++;
            }
            p2++;
          }
          peg$posDetailsCache[pos] = details;
          return details;
        }
      }
      function peg$computeLocation(startPos, endPos) {
        var startPosDetails = peg$computePosDetails(startPos), endPosDetails = peg$computePosDetails(endPos);
        return {
          start: {
            offset: startPos,
            line: startPosDetails.line,
            column: startPosDetails.column
          },
          end: {
            offset: endPos,
            line: endPosDetails.line,
            column: endPosDetails.column
          }
        };
      }
      function peg$fail(expected2) {
        if (peg$currPos < peg$maxFailPos) {
          return;
        }
        if (peg$currPos > peg$maxFailPos) {
          peg$maxFailPos = peg$currPos;
          peg$maxFailExpected = [];
        }
        peg$maxFailExpected.push(expected2);
      }
      function peg$buildSimpleError(message, location2) {
        return new peg$SyntaxError(message, null, null, location2);
      }
      function peg$buildStructuredError(expected2, found, location2) {
        return new peg$SyntaxError(
          peg$SyntaxError.buildMessage(expected2, found),
          expected2,
          found,
          location2
        );
      }
      function peg$parsesvg_path() {
        var s0, s1, s2, s3, s4;
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parsewsp();
        while (s2 !== peg$FAILED) {
          s1.push(s2);
          s2 = peg$parsewsp();
        }
        if (s1 !== peg$FAILED) {
          s2 = peg$parsemoveTo_drawTo_commandGroups();
          if (s2 === peg$FAILED) {
            s2 = null;
          }
          if (s2 !== peg$FAILED) {
            s3 = [];
            s4 = peg$parsewsp();
            while (s4 !== peg$FAILED) {
              s3.push(s4);
              s4 = peg$parsewsp();
            }
            if (s3 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c0(s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsemoveTo_drawTo_commandGroups() {
        var s0, s1, s2, s3, s4, s5;
        s0 = peg$currPos;
        s1 = peg$parsemoveTo_drawTo_commandGroup();
        if (s1 !== peg$FAILED) {
          s2 = [];
          s3 = peg$currPos;
          s4 = [];
          s5 = peg$parsewsp();
          while (s5 !== peg$FAILED) {
            s4.push(s5);
            s5 = peg$parsewsp();
          }
          if (s4 !== peg$FAILED) {
            s5 = peg$parsemoveTo_drawTo_commandGroup();
            if (s5 !== peg$FAILED) {
              s4 = [s4, s5];
              s3 = s4;
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
          while (s3 !== peg$FAILED) {
            s2.push(s3);
            s3 = peg$currPos;
            s4 = [];
            s5 = peg$parsewsp();
            while (s5 !== peg$FAILED) {
              s4.push(s5);
              s5 = peg$parsewsp();
            }
            if (s4 !== peg$FAILED) {
              s5 = peg$parsemoveTo_drawTo_commandGroup();
              if (s5 !== peg$FAILED) {
                s4 = [s4, s5];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          }
          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c1(s1, s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsemoveTo_drawTo_commandGroup() {
        var s0, s1, s2, s3, s4, s5;
        s0 = peg$currPos;
        s1 = peg$parsemoveto();
        if (s1 !== peg$FAILED) {
          s2 = [];
          s3 = peg$currPos;
          s4 = [];
          s5 = peg$parsewsp();
          while (s5 !== peg$FAILED) {
            s4.push(s5);
            s5 = peg$parsewsp();
          }
          if (s4 !== peg$FAILED) {
            s5 = peg$parsedrawto_command();
            if (s5 !== peg$FAILED) {
              s4 = [s4, s5];
              s3 = s4;
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
          while (s3 !== peg$FAILED) {
            s2.push(s3);
            s3 = peg$currPos;
            s4 = [];
            s5 = peg$parsewsp();
            while (s5 !== peg$FAILED) {
              s4.push(s5);
              s5 = peg$parsewsp();
            }
            if (s4 !== peg$FAILED) {
              s5 = peg$parsedrawto_command();
              if (s5 !== peg$FAILED) {
                s4 = [s4, s5];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          }
          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c1(s1, s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsedrawto_command() {
        var s0;
        s0 = peg$parseclosepath();
        if (s0 === peg$FAILED) {
          s0 = peg$parselineto();
          if (s0 === peg$FAILED) {
            s0 = peg$parsehorizontal_lineto();
            if (s0 === peg$FAILED) {
              s0 = peg$parsevertical_lineto();
              if (s0 === peg$FAILED) {
                s0 = peg$parsecurveto();
                if (s0 === peg$FAILED) {
                  s0 = peg$parsesmooth_curveto();
                  if (s0 === peg$FAILED) {
                    s0 = peg$parsequadratic_bezier_curveto();
                    if (s0 === peg$FAILED) {
                      s0 = peg$parsesmooth_quadratic_bezier_curveto();
                      if (s0 === peg$FAILED) {
                        s0 = peg$parseelliptical_arc();
                      }
                    }
                  }
                }
              }
            }
          }
        }
        return s0;
      }
      function peg$parsemoveto() {
        var s0, s1, s2, s3, s4, s5, s6;
        s0 = peg$currPos;
        if (peg$c2.test(input.charAt(peg$currPos))) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c3);
          }
        }
        if (s1 !== peg$FAILED) {
          s2 = [];
          s3 = peg$parsewsp();
          while (s3 !== peg$FAILED) {
            s2.push(s3);
            s3 = peg$parsewsp();
          }
          if (s2 !== peg$FAILED) {
            s3 = peg$parsecoordinate_pair();
            if (s3 !== peg$FAILED) {
              s4 = peg$currPos;
              s5 = peg$parsecomma_wsp();
              if (s5 === peg$FAILED) {
                s5 = null;
              }
              if (s5 !== peg$FAILED) {
                s6 = peg$parselineto_argument_sequence();
                if (s6 !== peg$FAILED) {
                  s5 = [s5, s6];
                  s4 = s5;
                } else {
                  peg$currPos = s4;
                  s4 = peg$FAILED;
                }
              } else {
                peg$currPos = s4;
                s4 = peg$FAILED;
              }
              if (s4 === peg$FAILED) {
                s4 = null;
              }
              if (s4 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c4(s1, s3, s4);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseclosepath() {
        var s0, s1;
        s0 = peg$currPos;
        if (peg$c5.test(input.charAt(peg$currPos))) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c6);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c7();
        }
        s0 = s1;
        return s0;
      }
      function peg$parselineto() {
        var s0, s1, s2, s3;
        s0 = peg$currPos;
        if (peg$c8.test(input.charAt(peg$currPos))) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c9);
          }
        }
        if (s1 !== peg$FAILED) {
          s2 = [];
          s3 = peg$parsewsp();
          while (s3 !== peg$FAILED) {
            s2.push(s3);
            s3 = peg$parsewsp();
          }
          if (s2 !== peg$FAILED) {
            s3 = peg$parselineto_argument_sequence();
            if (s3 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c10(s1, s3);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parselineto_argument_sequence() {
        var s0, s1, s2, s3, s4, s5;
        s0 = peg$currPos;
        s1 = peg$parsecoordinate_pair();
        if (s1 !== peg$FAILED) {
          s2 = [];
          s3 = peg$currPos;
          s4 = peg$parsecomma_wsp();
          if (s4 === peg$FAILED) {
            s4 = null;
          }
          if (s4 !== peg$FAILED) {
            s5 = peg$parsecoordinate_pair();
            if (s5 !== peg$FAILED) {
              s4 = [s4, s5];
              s3 = s4;
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
          while (s3 !== peg$FAILED) {
            s2.push(s3);
            s3 = peg$currPos;
            s4 = peg$parsecomma_wsp();
            if (s4 === peg$FAILED) {
              s4 = null;
            }
            if (s4 !== peg$FAILED) {
              s5 = peg$parsecoordinate_pair();
              if (s5 !== peg$FAILED) {
                s4 = [s4, s5];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          }
          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c1(s1, s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsehorizontal_lineto() {
        var s0, s1, s2, s3;
        s0 = peg$currPos;
        if (peg$c11.test(input.charAt(peg$currPos))) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c12);
          }
        }
        if (s1 !== peg$FAILED) {
          s2 = [];
          s3 = peg$parsewsp();
          while (s3 !== peg$FAILED) {
            s2.push(s3);
            s3 = peg$parsewsp();
          }
          if (s2 !== peg$FAILED) {
            s3 = peg$parsecoordinate_sequence();
            if (s3 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c13(s1, s3);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsecoordinate_sequence() {
        var s0, s1, s2, s3, s4, s5;
        s0 = peg$currPos;
        s1 = peg$parsenumber();
        if (s1 !== peg$FAILED) {
          s2 = [];
          s3 = peg$currPos;
          s4 = peg$parsecomma_wsp();
          if (s4 === peg$FAILED) {
            s4 = null;
          }
          if (s4 !== peg$FAILED) {
            s5 = peg$parsenumber();
            if (s5 !== peg$FAILED) {
              s4 = [s4, s5];
              s3 = s4;
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
          while (s3 !== peg$FAILED) {
            s2.push(s3);
            s3 = peg$currPos;
            s4 = peg$parsecomma_wsp();
            if (s4 === peg$FAILED) {
              s4 = null;
            }
            if (s4 !== peg$FAILED) {
              s5 = peg$parsenumber();
              if (s5 !== peg$FAILED) {
                s4 = [s4, s5];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          }
          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c1(s1, s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsevertical_lineto() {
        var s0, s1, s2, s3;
        s0 = peg$currPos;
        if (peg$c14.test(input.charAt(peg$currPos))) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c15);
          }
        }
        if (s1 !== peg$FAILED) {
          s2 = [];
          s3 = peg$parsewsp();
          while (s3 !== peg$FAILED) {
            s2.push(s3);
            s3 = peg$parsewsp();
          }
          if (s2 !== peg$FAILED) {
            s3 = peg$parsecoordinate_sequence();
            if (s3 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c16(s1, s3);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsecurveto() {
        var s0, s1, s2, s3;
        s0 = peg$currPos;
        if (peg$c17.test(input.charAt(peg$currPos))) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c18);
          }
        }
        if (s1 !== peg$FAILED) {
          s2 = [];
          s3 = peg$parsewsp();
          while (s3 !== peg$FAILED) {
            s2.push(s3);
            s3 = peg$parsewsp();
          }
          if (s2 !== peg$FAILED) {
            s3 = peg$parsecurveto_argument_sequence();
            if (s3 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c10(s1, s3);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsecurveto_argument_sequence() {
        var s0, s1, s2, s3, s4, s5;
        s0 = peg$currPos;
        s1 = peg$parsecurveto_argument();
        if (s1 !== peg$FAILED) {
          s2 = [];
          s3 = peg$currPos;
          s4 = peg$parsecomma_wsp();
          if (s4 === peg$FAILED) {
            s4 = null;
          }
          if (s4 !== peg$FAILED) {
            s5 = peg$parsecurveto_argument();
            if (s5 !== peg$FAILED) {
              s4 = [s4, s5];
              s3 = s4;
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
          while (s3 !== peg$FAILED) {
            s2.push(s3);
            s3 = peg$currPos;
            s4 = peg$parsecomma_wsp();
            if (s4 === peg$FAILED) {
              s4 = null;
            }
            if (s4 !== peg$FAILED) {
              s5 = peg$parsecurveto_argument();
              if (s5 !== peg$FAILED) {
                s4 = [s4, s5];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          }
          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c1(s1, s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsecurveto_argument() {
        var s0, s1, s2, s3, s4, s5;
        s0 = peg$currPos;
        s1 = peg$parsecoordinate_pair();
        if (s1 !== peg$FAILED) {
          s2 = peg$parsecomma_wsp();
          if (s2 === peg$FAILED) {
            s2 = null;
          }
          if (s2 !== peg$FAILED) {
            s3 = peg$parsecoordinate_pair();
            if (s3 !== peg$FAILED) {
              s4 = peg$parsecomma_wsp();
              if (s4 === peg$FAILED) {
                s4 = null;
              }
              if (s4 !== peg$FAILED) {
                s5 = peg$parsecoordinate_pair();
                if (s5 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s1 = peg$c19(s1, s3, s5);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsesmooth_curveto() {
        var s0, s1, s2, s3;
        s0 = peg$currPos;
        if (peg$c20.test(input.charAt(peg$currPos))) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c21);
          }
        }
        if (s1 !== peg$FAILED) {
          s2 = [];
          s3 = peg$parsewsp();
          while (s3 !== peg$FAILED) {
            s2.push(s3);
            s3 = peg$parsewsp();
          }
          if (s2 !== peg$FAILED) {
            s3 = peg$parsesmooth_curveto_argument_sequence();
            if (s3 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c10(s1, s3);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsesmooth_curveto_argument_sequence() {
        var s0, s1, s2, s3, s4, s5;
        s0 = peg$currPos;
        s1 = peg$parsesmooth_curveto_argument();
        if (s1 !== peg$FAILED) {
          s2 = [];
          s3 = peg$currPos;
          s4 = peg$parsecomma_wsp();
          if (s4 === peg$FAILED) {
            s4 = null;
          }
          if (s4 !== peg$FAILED) {
            s5 = peg$parsesmooth_curveto_argument();
            if (s5 !== peg$FAILED) {
              s4 = [s4, s5];
              s3 = s4;
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
          while (s3 !== peg$FAILED) {
            s2.push(s3);
            s3 = peg$currPos;
            s4 = peg$parsecomma_wsp();
            if (s4 === peg$FAILED) {
              s4 = null;
            }
            if (s4 !== peg$FAILED) {
              s5 = peg$parsesmooth_curveto_argument();
              if (s5 !== peg$FAILED) {
                s4 = [s4, s5];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          }
          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c1(s1, s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsesmooth_curveto_argument() {
        var s0, s1, s2, s3;
        s0 = peg$currPos;
        s1 = peg$parsecoordinate_pair();
        if (s1 !== peg$FAILED) {
          s2 = peg$parsecomma_wsp();
          if (s2 === peg$FAILED) {
            s2 = null;
          }
          if (s2 !== peg$FAILED) {
            s3 = peg$parsecoordinate_pair();
            if (s3 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c22(s1, s3);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsequadratic_bezier_curveto() {
        var s0, s1, s2, s3;
        s0 = peg$currPos;
        if (peg$c23.test(input.charAt(peg$currPos))) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c24);
          }
        }
        if (s1 !== peg$FAILED) {
          s2 = [];
          s3 = peg$parsewsp();
          while (s3 !== peg$FAILED) {
            s2.push(s3);
            s3 = peg$parsewsp();
          }
          if (s2 !== peg$FAILED) {
            s3 = peg$parsequadratic_bezier_curveto_argument_sequence();
            if (s3 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c10(s1, s3);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsequadratic_bezier_curveto_argument_sequence() {
        var s0, s1, s2, s3, s4, s5;
        s0 = peg$currPos;
        s1 = peg$parsequadratic_bezier_curveto_argument();
        if (s1 !== peg$FAILED) {
          s2 = [];
          s3 = peg$currPos;
          s4 = peg$parsecomma_wsp();
          if (s4 === peg$FAILED) {
            s4 = null;
          }
          if (s4 !== peg$FAILED) {
            s5 = peg$parsequadratic_bezier_curveto_argument();
            if (s5 !== peg$FAILED) {
              s4 = [s4, s5];
              s3 = s4;
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
          while (s3 !== peg$FAILED) {
            s2.push(s3);
            s3 = peg$currPos;
            s4 = peg$parsecomma_wsp();
            if (s4 === peg$FAILED) {
              s4 = null;
            }
            if (s4 !== peg$FAILED) {
              s5 = peg$parsequadratic_bezier_curveto_argument();
              if (s5 !== peg$FAILED) {
                s4 = [s4, s5];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          }
          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c1(s1, s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsequadratic_bezier_curveto_argument() {
        var s0, s1, s2, s3;
        s0 = peg$currPos;
        s1 = peg$parsecoordinate_pair();
        if (s1 !== peg$FAILED) {
          s2 = peg$parsecomma_wsp();
          if (s2 === peg$FAILED) {
            s2 = null;
          }
          if (s2 !== peg$FAILED) {
            s3 = peg$parsecoordinate_pair();
            if (s3 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c25(s1, s3);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsesmooth_quadratic_bezier_curveto() {
        var s0, s1, s2, s3;
        s0 = peg$currPos;
        if (peg$c26.test(input.charAt(peg$currPos))) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c27);
          }
        }
        if (s1 !== peg$FAILED) {
          s2 = [];
          s3 = peg$parsewsp();
          while (s3 !== peg$FAILED) {
            s2.push(s3);
            s3 = peg$parsewsp();
          }
          if (s2 !== peg$FAILED) {
            s3 = peg$parsesmooth_quadratic_bezier_curveto_argument_sequence();
            if (s3 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c10(s1, s3);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsesmooth_quadratic_bezier_curveto_argument_sequence() {
        var s0, s1, s2, s3, s4, s5;
        s0 = peg$currPos;
        s1 = peg$parsecoordinate_pair();
        if (s1 !== peg$FAILED) {
          s2 = [];
          s3 = peg$currPos;
          s4 = peg$parsecomma_wsp();
          if (s4 === peg$FAILED) {
            s4 = null;
          }
          if (s4 !== peg$FAILED) {
            s5 = peg$parsecoordinate_pair();
            if (s5 !== peg$FAILED) {
              s4 = [s4, s5];
              s3 = s4;
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
          while (s3 !== peg$FAILED) {
            s2.push(s3);
            s3 = peg$currPos;
            s4 = peg$parsecomma_wsp();
            if (s4 === peg$FAILED) {
              s4 = null;
            }
            if (s4 !== peg$FAILED) {
              s5 = peg$parsecoordinate_pair();
              if (s5 !== peg$FAILED) {
                s4 = [s4, s5];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          }
          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c1(s1, s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseelliptical_arc() {
        var s0, s1, s2, s3;
        s0 = peg$currPos;
        if (peg$c28.test(input.charAt(peg$currPos))) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c29);
          }
        }
        if (s1 !== peg$FAILED) {
          s2 = [];
          s3 = peg$parsewsp();
          while (s3 !== peg$FAILED) {
            s2.push(s3);
            s3 = peg$parsewsp();
          }
          if (s2 !== peg$FAILED) {
            s3 = peg$parseelliptical_arc_argument_sequence();
            if (s3 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c10(s1, s3);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseelliptical_arc_argument_sequence() {
        var s0, s1, s2, s3, s4, s5;
        s0 = peg$currPos;
        s1 = peg$parseelliptical_arc_argument();
        if (s1 !== peg$FAILED) {
          s2 = [];
          s3 = peg$currPos;
          s4 = peg$parsecomma_wsp();
          if (s4 === peg$FAILED) {
            s4 = null;
          }
          if (s4 !== peg$FAILED) {
            s5 = peg$parseelliptical_arc_argument();
            if (s5 !== peg$FAILED) {
              s4 = [s4, s5];
              s3 = s4;
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
          while (s3 !== peg$FAILED) {
            s2.push(s3);
            s3 = peg$currPos;
            s4 = peg$parsecomma_wsp();
            if (s4 === peg$FAILED) {
              s4 = null;
            }
            if (s4 !== peg$FAILED) {
              s5 = peg$parseelliptical_arc_argument();
              if (s5 !== peg$FAILED) {
                s4 = [s4, s5];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          }
          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c1(s1, s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseelliptical_arc_argument() {
        var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11;
        s0 = peg$currPos;
        s1 = peg$parsenonnegative_number();
        if (s1 !== peg$FAILED) {
          s2 = peg$parsecomma_wsp();
          if (s2 === peg$FAILED) {
            s2 = null;
          }
          if (s2 !== peg$FAILED) {
            s3 = peg$parsenonnegative_number();
            if (s3 !== peg$FAILED) {
              s4 = peg$parsecomma_wsp();
              if (s4 === peg$FAILED) {
                s4 = null;
              }
              if (s4 !== peg$FAILED) {
                s5 = peg$parsenumber();
                if (s5 !== peg$FAILED) {
                  s6 = peg$parsecomma_wsp();
                  if (s6 !== peg$FAILED) {
                    s7 = peg$parseflag();
                    if (s7 !== peg$FAILED) {
                      s8 = peg$parsecomma_wsp();
                      if (s8 === peg$FAILED) {
                        s8 = null;
                      }
                      if (s8 !== peg$FAILED) {
                        s9 = peg$parseflag();
                        if (s9 !== peg$FAILED) {
                          s10 = peg$parsecomma_wsp();
                          if (s10 === peg$FAILED) {
                            s10 = null;
                          }
                          if (s10 !== peg$FAILED) {
                            s11 = peg$parsecoordinate_pair();
                            if (s11 !== peg$FAILED) {
                              peg$savedPos = s0;
                              s1 = peg$c30(s1, s3, s5, s7, s9, s11);
                              s0 = s1;
                            } else {
                              peg$currPos = s0;
                              s0 = peg$FAILED;
                            }
                          } else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                          }
                        } else {
                          peg$currPos = s0;
                          s0 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsecoordinate_pair() {
        var s0, s1, s2, s3;
        s0 = peg$currPos;
        s1 = peg$parsenumber();
        if (s1 !== peg$FAILED) {
          s2 = peg$parsecomma_wsp();
          if (s2 === peg$FAILED) {
            s2 = null;
          }
          if (s2 !== peg$FAILED) {
            s3 = peg$parsenumber();
            if (s3 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c31(s1, s3);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsenonnegative_number() {
        var s0, s1;
        s0 = peg$currPos;
        s1 = peg$parsefloating_point_constant();
        if (s1 === peg$FAILED) {
          s1 = peg$parsedigit_sequence();
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c32(s1);
        }
        s0 = s1;
        return s0;
      }
      function peg$parsenumber() {
        var s0, s1, s2, s3;
        s0 = peg$currPos;
        s1 = peg$currPos;
        s2 = peg$parsesign();
        if (s2 === peg$FAILED) {
          s2 = null;
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parsefloating_point_constant();
          if (s3 !== peg$FAILED) {
            s2 = [s2, s3];
            s1 = s2;
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
        if (s1 === peg$FAILED) {
          s1 = peg$currPos;
          s2 = peg$parsesign();
          if (s2 === peg$FAILED) {
            s2 = null;
          }
          if (s2 !== peg$FAILED) {
            s3 = peg$parsedigit_sequence();
            if (s3 !== peg$FAILED) {
              s2 = [s2, s3];
              s1 = s2;
            } else {
              peg$currPos = s1;
              s1 = peg$FAILED;
            }
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c33(s1);
        }
        s0 = s1;
        return s0;
      }
      function peg$parseflag() {
        var s0, s1;
        s0 = peg$currPos;
        if (peg$c34.test(input.charAt(peg$currPos))) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c35);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c36(s1);
        }
        s0 = s1;
        return s0;
      }
      function peg$parsecomma_wsp() {
        var s0, s1, s2, s3, s4;
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parsewsp();
        if (s2 !== peg$FAILED) {
          while (s2 !== peg$FAILED) {
            s1.push(s2);
            s2 = peg$parsewsp();
          }
        } else {
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          s2 = peg$parsecomma();
          if (s2 === peg$FAILED) {
            s2 = null;
          }
          if (s2 !== peg$FAILED) {
            s3 = [];
            s4 = peg$parsewsp();
            while (s4 !== peg$FAILED) {
              s3.push(s4);
              s4 = peg$parsewsp();
            }
            if (s3 !== peg$FAILED) {
              s1 = [s1, s2, s3];
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$currPos;
          s2 = peg$parsecomma();
          if (s2 !== peg$FAILED) {
            s3 = [];
            s4 = peg$parsewsp();
            while (s4 !== peg$FAILED) {
              s3.push(s4);
              s4 = peg$parsewsp();
            }
            if (s3 !== peg$FAILED) {
              s2 = [s2, s3];
              s1 = s2;
            } else {
              peg$currPos = s1;
              s1 = peg$FAILED;
            }
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c37();
          }
          s0 = s1;
        }
        return s0;
      }
      function peg$parsecomma() {
        var s0;
        if (input.charCodeAt(peg$currPos) === 44) {
          s0 = peg$c38;
          peg$currPos++;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c39);
          }
        }
        return s0;
      }
      function peg$parsefloating_point_constant() {
        var s0, s1, s2, s3;
        s0 = peg$currPos;
        s1 = peg$currPos;
        s2 = peg$parsefractional_constant();
        if (s2 !== peg$FAILED) {
          s3 = peg$parseexponent();
          if (s3 === peg$FAILED) {
            s3 = null;
          }
          if (s3 !== peg$FAILED) {
            s2 = [s2, s3];
            s1 = s2;
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
        if (s1 === peg$FAILED) {
          s1 = peg$currPos;
          s2 = peg$parsedigit_sequence();
          if (s2 !== peg$FAILED) {
            s3 = peg$parseexponent();
            if (s3 !== peg$FAILED) {
              s2 = [s2, s3];
              s1 = s2;
            } else {
              peg$currPos = s1;
              s1 = peg$FAILED;
            }
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c40(s1);
        }
        s0 = s1;
        return s0;
      }
      function peg$parsefractional_constant() {
        var s0, s1, s2, s3, s4;
        s0 = peg$currPos;
        s1 = peg$currPos;
        s2 = peg$parsedigit_sequence();
        if (s2 === peg$FAILED) {
          s2 = null;
        }
        if (s2 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 46) {
            s3 = peg$c41;
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c42);
            }
          }
          if (s3 !== peg$FAILED) {
            s4 = peg$parsedigit_sequence();
            if (s4 !== peg$FAILED) {
              s2 = [s2, s3, s4];
              s1 = s2;
            } else {
              peg$currPos = s1;
              s1 = peg$FAILED;
            }
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
        if (s1 === peg$FAILED) {
          s1 = peg$currPos;
          s2 = peg$parsedigit_sequence();
          if (s2 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 46) {
              s3 = peg$c41;
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c42);
              }
            }
            if (s3 !== peg$FAILED) {
              s2 = [s2, s3];
              s1 = s2;
            } else {
              peg$currPos = s1;
              s1 = peg$FAILED;
            }
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c40(s1);
        }
        s0 = s1;
        return s0;
      }
      function peg$parseexponent() {
        var s0, s1, s2, s3, s4;
        s0 = peg$currPos;
        s1 = peg$currPos;
        if (peg$c43.test(input.charAt(peg$currPos))) {
          s2 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c44);
          }
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parsesign();
          if (s3 === peg$FAILED) {
            s3 = null;
          }
          if (s3 !== peg$FAILED) {
            s4 = peg$parsedigit_sequence();
            if (s4 !== peg$FAILED) {
              s2 = [s2, s3, s4];
              s1 = s2;
            } else {
              peg$currPos = s1;
              s1 = peg$FAILED;
            }
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c40(s1);
        }
        s0 = s1;
        return s0;
      }
      function peg$parsesign() {
        var s0;
        if (peg$c45.test(input.charAt(peg$currPos))) {
          s0 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c46);
          }
        }
        return s0;
      }
      function peg$parsedigit_sequence() {
        var s0, s1, s2;
        s0 = peg$currPos;
        s1 = [];
        if (peg$c47.test(input.charAt(peg$currPos))) {
          s2 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c48);
          }
        }
        if (s2 !== peg$FAILED) {
          while (s2 !== peg$FAILED) {
            s1.push(s2);
            if (peg$c47.test(input.charAt(peg$currPos))) {
              s2 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s2 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c48);
              }
            }
          }
        } else {
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c49(s1);
        }
        s0 = s1;
        return s0;
      }
      function peg$parsewsp() {
        var s0, s1;
        s0 = peg$currPos;
        if (peg$c50.test(input.charAt(peg$currPos))) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c51);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c37();
        }
        s0 = s1;
        return s0;
      }
      function merge3(first3, more) {
        if (!more)
          return [first3];
        for (var a4 = [first3], i = 0, l = more.length; i < l; i++)
          a4[i + 1] = more[i][1];
        return a4;
      }
      var cmds = { m: "moveto", l: "lineto", h: "horizontal lineto", v: "vertical lineto", c: "curveto", s: "smooth curveto", q: "quadratic curveto", t: "smooth quadratic curveto", a: "elliptical arc", z: "closepath" };
      for (var code in cmds)
        cmds[code.toUpperCase()] = cmds[code];
      function commands(code2, args) {
        if (!args)
          args = [{}];
        for (var i = args.length; i--; ) {
          var cmd = { code: code2, command: cmds[code2] };
          if (code2 == code2.toLowerCase())
            cmd.relative = true;
          for (var k2 in args[i])
            cmd[k2] = args[i][k2];
          args[i] = cmd;
        }
        return args;
      }
      peg$result = peg$startRuleFunction();
      if (peg$result !== peg$FAILED && peg$currPos === input.length) {
        return peg$result;
      } else {
        if (peg$result !== peg$FAILED && peg$currPos < input.length) {
          peg$fail(peg$endExpectation());
        }
        throw peg$buildStructuredError(
          peg$maxFailExpected,
          peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,
          peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)
        );
      }
    }
    module2.exports = {
      SyntaxError: peg$SyntaxError,
      parse: peg$parse
    };
  }
});

// node_modules/svg-path-parser/index.js
var require_svg_path_parser = __commonJS({
  "node_modules/svg-path-parser/index.js"(exports2, module2) {
    var parserFunction = require_parser().parse;
    parserFunction.parseSVG = parserFunction;
    parserFunction.makeAbsolute = makeSVGPathCommandsAbsolute;
    module2.exports = parserFunction;
    function makeSVGPathCommandsAbsolute(commands) {
      var subpathStart, prevCmd = { x: 0, y: 0 };
      var attr2 = { x: "x0", y: "y0", x1: "x0", y1: "y0", x2: "x0", y2: "y0" };
      commands.forEach(function(cmd) {
        if (cmd.command === "moveto")
          subpathStart = cmd;
        cmd.x0 = prevCmd.x;
        cmd.y0 = prevCmd.y;
        for (var a4 in attr2)
          if (a4 in cmd)
            cmd[a4] += cmd.relative ? cmd[attr2[a4]] : 0;
        if (!("x" in cmd))
          cmd.x = prevCmd.x;
        if (!("y" in cmd))
          cmd.y = prevCmd.y;
        cmd.relative = false;
        cmd.code = cmd.code.toUpperCase();
        if (cmd.command == "closepath") {
          cmd.x = subpathStart.x;
          cmd.y = subpathStart.y;
        }
        prevCmd = cmd;
      });
      return commands;
    }
  }
});

// node_modules/pdfast/src/helper.js
var require_helper = __commonJS({
  "node_modules/pdfast/src/helper.js"(exports2, module2) {
    "use strict";
    var self2 = module2.exports;
    module2.exports.isNumber = function(x3) {
      return typeof x3 === "number";
    };
    module2.exports.findMin = function(arr) {
      if (arr.length === 0) {
        return Infinity;
      }
      var curr = arr[0];
      for (var i = 1; i < arr.length; i++) {
        curr = Math.min(curr, arr[i]);
      }
      return curr;
    };
    module2.exports.findMax = function(arr) {
      if (arr.length === 0) {
        return -Infinity;
      }
      var curr = arr[0];
      for (var i = 1; i < arr.length; i++) {
        curr = Math.max(curr, arr[i]);
      }
      return curr;
    };
    module2.exports.findMinMulti = function(arr) {
      var curr = self2.findMin(arr[0]);
      for (var i = 1; i < arr.length; i++) {
        curr = Math.min(curr, self2.findMin(arr[i]));
      }
      return curr;
    };
    module2.exports.findMaxMulti = function(arr) {
      var curr = self2.findMax(arr[0]);
      for (var i = 1; i < arr.length; i++) {
        curr = Math.max(curr, self2.findMax(arr[i]));
      }
      return curr;
    };
    module2.exports.inside = function(min11, max11, x3) {
      return min11 <= x3 && x3 <= max11;
    };
  }
});

// node_modules/pdfast/src/index.js
var require_src = __commonJS({
  "node_modules/pdfast/src/index.js"(exports2, module2) {
    "use strict";
    var DEFAULT_SIZE = 50;
    var DEFAULT_WIDTH = 2;
    var LN_2 = Math.log(2);
    var self2 = module2.exports;
    var helper = require_helper();
    function kernel(x3) {
      return 1 - Math.abs(x3);
    }
    module2.exports.getUnifiedMinMax = function(arr, options) {
      return self2.getUnifiedMinMaxMulti([arr], options);
    };
    module2.exports.getUnifiedMinMaxMulti = function(arrMulti, options) {
      options = options || {};
      var relaxMin = false;
      var relaxMax = false;
      var width = helper.isNumber(options.width) ? options.width : DEFAULT_WIDTH;
      var size5 = helper.isNumber(options.size) ? options.size : DEFAULT_SIZE;
      var min11 = helper.isNumber(options.min) ? options.min : (relaxMin = true, helper.findMinMulti(arrMulti));
      var max11 = helper.isNumber(options.max) ? options.max : (relaxMax = true, helper.findMaxMulti(arrMulti));
      var range4 = max11 - min11;
      var step2 = range4 / (size5 - 1);
      if (relaxMin) {
        min11 = min11 - 2 * width * step2;
      }
      if (relaxMax) {
        max11 = max11 + 2 * width * step2;
      }
      return {
        min: min11,
        max: max11
      };
    };
    module2.exports.create = function(arr, options) {
      options = options || {};
      if (!arr || arr.length === 0) {
        return [];
      }
      var size5 = helper.isNumber(options.size) ? options.size : DEFAULT_SIZE;
      var width = helper.isNumber(options.width) ? options.width : DEFAULT_WIDTH;
      var normalizedMinMax = self2.getUnifiedMinMax(arr, {
        size: size5,
        width,
        min: options.min,
        max: options.max
      });
      var min11 = normalizedMinMax.min;
      var max11 = normalizedMinMax.max;
      var range4 = max11 - min11;
      var step2 = range4 / (size5 - 1);
      if (range4 === 0) {
        return [{ x: min11, y: 1 }];
      }
      var buckets = [];
      for (var i = 0; i < size5; i++) {
        buckets.push({
          x: min11 + i * step2,
          y: 0
        });
      }
      var xToBucket = function(x3) {
        return Math.floor((x3 - min11) / step2);
      };
      var partialArea = generatePartialAreas(kernel, width);
      var fullArea = partialArea[width];
      var c5 = partialArea[width - 1] - partialArea[width - 2];
      var initalValue = 0;
      arr.forEach(function(x3) {
        var bucket = xToBucket(x3);
        if (bucket + width < 0 || bucket - width >= buckets.length) {
          return;
        }
        var start = Math.max(bucket - width, 0);
        var mid2 = bucket;
        var end = Math.min(bucket + width, buckets.length - 1);
        var leftBlockCount = start - (bucket - width);
        var rightBlockCount = bucket + width - end;
        var spilledAreaLeft = partialArea[-width - 1 + leftBlockCount] || 0;
        var spilledAreaRight = partialArea[-width - 1 + rightBlockCount] || 0;
        var weight2 = fullArea / (fullArea - spilledAreaLeft - spilledAreaRight);
        if (leftBlockCount > 0) {
          initalValue += weight2 * (leftBlockCount - 1) * c5;
        }
        var startGradPos = Math.max(0, bucket - width + 1);
        if (helper.inside(0, buckets.length - 1, startGradPos)) {
          buckets[startGradPos].y += weight2 * 1 * c5;
        }
        if (helper.inside(0, buckets.length - 1, mid2 + 1)) {
          buckets[mid2 + 1].y -= weight2 * 2 * c5;
        }
        if (helper.inside(0, buckets.length - 1, end + 1)) {
          buckets[end + 1].y += weight2 * 1 * c5;
        }
      });
      var accumulator = initalValue;
      var gradAccumulator = 0;
      var area2 = 0;
      buckets.forEach(function(bucket) {
        gradAccumulator += bucket.y;
        accumulator += gradAccumulator;
        bucket.y = accumulator;
        area2 += accumulator;
      });
      if (area2 > 0) {
        buckets.forEach(function(bucket) {
          bucket.y /= area2;
        });
      }
      return buckets;
    };
    function generatePartialAreas(kernel2, width) {
      var partialAreas = {};
      var accumulator = 0;
      for (var i = -width; i <= width; i++) {
        accumulator += kernel2(i / width);
        partialAreas[i] = accumulator;
      }
      return partialAreas;
    }
    module2.exports.getExpectedValueFromPdf = function(pdf2) {
      if (!pdf2 || pdf2.length === 0) {
        return void 0;
      }
      var expected = 0;
      pdf2.forEach(function(obj) {
        expected += obj.x * obj.y;
      });
      return expected;
    };
    module2.exports.getXWithLeftTailArea = function(pdf2, area2) {
      if (!pdf2 || pdf2.length === 0) {
        return void 0;
      }
      var accumulator = 0;
      var last7 = 0;
      for (var i = 0; i < pdf2.length; i++) {
        last7 = i;
        accumulator += pdf2[i].y;
        if (accumulator >= area2) {
          break;
        }
      }
      return pdf2[last7].x;
    };
    module2.exports.getPerplexity = function(pdf2) {
      if (!pdf2 || pdf2.length === 0) {
        return void 0;
      }
      var entropy = 0;
      pdf2.forEach(function(obj) {
        var ln2 = Math.log(obj.y);
        if (isFinite(ln2)) {
          entropy += obj.y * ln2;
        }
      });
      entropy = -entropy / LN_2;
      return Math.pow(2, entropy);
    };
  }
});

// node_modules/@antv/g2/esm/index.js
var esm_exports = {};
__export(esm_exports, {
  AREA_CLASS_NAME: () => AREA_CLASS_NAME,
  Academy: () => Academy,
  Bin: () => Bin,
  BinX: () => BinX,
  COMPONENT_CLASS_NAME: () => COMPONENT_CLASS_NAME,
  Chart: () => Chart2,
  ChartEvent: () => ChartEvent,
  Classic: () => Classic,
  ClassicDark: () => ClassicDark,
  Dark: () => Dark,
  DiffY: () => DiffY,
  DodgeX: () => DodgeX,
  ELEMENT_CLASS_NAME: () => ELEMENT_CLASS_NAME,
  Filter: () => Filter,
  FlexX: () => FlexX,
  Group: () => Group,
  GroupColor: () => GroupColor,
  GroupX: () => GroupX,
  GroupY: () => GroupY,
  Jitter: () => Jitter,
  JitterX: () => JitterX,
  JitterY: () => JitterY,
  LABEL_CLASS_NAME: () => LABEL_CLASS_NAME,
  LABEL_LAYER_CLASS_NAME: () => LABEL_LAYER_CLASS_NAME,
  Light: () => Light,
  LinearAxis: () => LinearAxis,
  MAIN_LAYER_CLASS_NAME: () => MAIN_LAYER_CLASS_NAME,
  MASK_CLASS_NAME: () => MASK_CLASS_NAME,
  MaybeDefaultX: () => MaybeDefaultX,
  MaybeDefaultY: () => MaybeDefaultY,
  MaybeFunctionAttribute: () => MaybeFunctionAttribute,
  MaybeGradient: () => MaybeGradient,
  MaybeIdentityX: () => MaybeIdentityX,
  MaybeIdentityY: () => MaybeIdentityY,
  MaybeKey: () => MaybeKey,
  MaybeSeries: () => MaybeSeries,
  MaybeSize: () => MaybeSize,
  MaybeStackY: () => MaybeStackY,
  MaybeTitle: () => MaybeTitle,
  MaybeTooltip: () => MaybeTooltip,
  MaybeTuple: () => MaybeTuple,
  MaybeTupleX: () => MaybeTupleX,
  MaybeTupleY: () => MaybeTupleY,
  MaybeVisualPosition: () => MaybeVisualPosition,
  MaybeZeroPadding: () => MaybeZeroPadding,
  MaybeZeroX: () => MaybeZeroX,
  MaybeZeroY: () => MaybeZeroY,
  MaybeZeroY1: () => MaybeZeroY1,
  MaybeZeroZ: () => MaybeZeroZ,
  NormalizeY: () => NormalizeY,
  PLOT_CLASS_NAME: () => PLOT_CLASS_NAME,
  Pack: () => Pack,
  Runtime: () => Runtime,
  Sample: () => Sample,
  Select: () => Select,
  SelectX: () => SelectX,
  SelectY: () => SelectY,
  Selection: () => Selection,
  SortColor: () => SortColor,
  SortX: () => SortX,
  SortY: () => SortY,
  StackEnter: () => StackEnter,
  StackY: () => StackY,
  SymmetryY: () => SymmetryY,
  VIEW_CLASS_NAME: () => VIEW_CLASS_NAME,
  corelib: () => corelib,
  extend: () => extend4,
  geolib: () => geolib,
  graphlib: () => graphlib,
  plotlib: () => plotlib,
  register: () => register,
  render: () => render,
  renderToMountedElement: () => renderToMountedElement,
  select: () => select,
  stdlib: () => stdlib
});

// node_modules/@antv/g2/esm/coordinate/cartesian.js
var Cartesian = () => [["cartesian"]];
Cartesian.props = {};

// node_modules/@antv/g2/esm/coordinate/polar.js
var getPolarOptions = (options = {}) => {
  const defaultOptions = {
    startAngle: -Math.PI / 2,
    endAngle: Math.PI * 3 / 2,
    innerRadius: 0,
    outerRadius: 1
  };
  return Object.assign(Object.assign({}, defaultOptions), options);
};
var Polar = (options) => {
  const { startAngle, endAngle, innerRadius, outerRadius } = getPolarOptions(options);
  return [
    ["translate", 0, 0.5],
    ["reflect.y"],
    ["translate", 0, -0.5],
    ["polar", startAngle, endAngle, innerRadius, outerRadius]
  ];
};
Polar.props = {};

// node_modules/@antv/g2/esm/coordinate/helix.js
var Helix = ({ startAngle = 0, endAngle = Math.PI * 6, innerRadius = 0, outerRadius = 1 }) => [
  ["translate", 0.5, 0.5],
  ["reflect.y"],
  ["translate", -0.5, -0.5],
  ["helix", startAngle, endAngle, innerRadius, outerRadius]
];
Helix.props = {};

// node_modules/@antv/g2/esm/coordinate/transpose.js
var Transpose = () => [
  ["transpose"],
  ["translate", 0.5, 0.5],
  ["reflect.x"],
  ["translate", -0.5, -0.5]
];
Transpose.props = { transform: true };

// node_modules/@antv/g2/esm/coordinate/theta.js
var getThetaOptions = (options = {}) => {
  const defaultOptions = {
    startAngle: -Math.PI / 2,
    endAngle: Math.PI * 3 / 2,
    innerRadius: 0,
    outerRadius: 1
  };
  return Object.assign(Object.assign({}, defaultOptions), options);
};
var Theta = (options) => {
  const { startAngle, endAngle, innerRadius, outerRadius } = getThetaOptions(options);
  return [
    ...Transpose(),
    ...Polar({ startAngle, endAngle, innerRadius, outerRadius })
  ];
};
Theta.props = {};

// node_modules/@antv/g2/esm/coordinate/radial.js
var getRadialOptions = (options = {}) => {
  const defaultOptions = {
    startAngle: -Math.PI / 2,
    endAngle: Math.PI * 3 / 2,
    innerRadius: 0,
    outerRadius: 1
  };
  return Object.assign(Object.assign({}, defaultOptions), options);
};
var Radial = (options) => {
  const { startAngle, endAngle, innerRadius, outerRadius } = getRadialOptions(options);
  return [
    ["transpose"],
    ["translate", 0.5, 0.5],
    ["reflect"],
    ["translate", -0.5, -0.5],
    ...Polar({ startAngle, endAngle, innerRadius, outerRadius })
  ];
};
Radial.props = {};

// node_modules/@antv/g2/esm/coordinate/parallel.js
var Parallel = () => [["parallel", 0, 1, 0, 1]];
Parallel.props = {};

// node_modules/@antv/g2/esm/coordinate/fisheye.js
var Fisheye = ({ focusX = 0, focusY = 0, distortionX = 2, distortionY = 2, visual = false }) => [["fisheye", focusX, focusY, distortionX, distortionY, visual]];
Fisheye.props = { transform: true };

// node_modules/@antv/g2/esm/coordinate/radar.js
var Radar = (options) => {
  const { startAngle = -Math.PI / 2, endAngle = Math.PI * 3 / 2, innerRadius = 0, outerRadius = 1 } = options;
  return [
    ...Parallel(),
    ...Polar({ startAngle, endAngle, innerRadius, outerRadius })
  ];
};
Radar.props = {};

// node_modules/@antv/g2/esm/encode/constant.js
var Constant = ({ value: value2 }) => {
  return (data2) => data2.map(() => value2);
};
Constant.props = {};

// node_modules/@antv/g2/esm/encode/transform.js
var Transform = ({ value: value2 }) => {
  return (data2) => data2.map(value2);
};
Transform.props = {};

// node_modules/@antv/g2/esm/encode/field.js
var Field = ({ value: value2 }) => {
  return (data2) => data2.map((d2) => d2[value2]);
};
Field.props = {};

// node_modules/@antv/g2/esm/encode/column.js
var Column = ({ value: value2 }) => {
  return () => value2;
};
Column.props = {};

// node_modules/@antv/util/esm/color/arr2rgb.js
function toHex(value2) {
  var x16Value = Math.round(value2).toString(16);
  return x16Value.length === 1 ? "0" + x16Value : x16Value;
}
function arr2rgb(arr) {
  return "#" + toHex(arr[0]) + toHex(arr[1]) + toHex(arr[2]);
}

// node_modules/@antv/util/esm/lodash/is-array-like.js
var isArrayLike = function(value2) {
  return value2 !== null && typeof value2 !== "function" && isFinite(value2.length);
};
var is_array_like_default = isArrayLike;

// node_modules/@antv/util/esm/lodash/filter.js
var filter = function(arr, func) {
  if (!is_array_like_default(arr)) {
    return arr;
  }
  var result2 = [];
  for (var index3 = 0; index3 < arr.length; index3++) {
    var value2 = arr[index3];
    if (func(value2, index3)) {
      result2.push(value2);
    }
  }
  return result2;
};
var filter_default = filter;

// node_modules/@antv/util/esm/lodash/is-function.js
var is_function_default = function(value2) {
  return typeof value2 === "function";
};

// node_modules/@antv/util/esm/lodash/is-nil.js
var isNil = function(value2) {
  return value2 === null || value2 === void 0;
};
var is_nil_default = isNil;

// node_modules/@antv/util/esm/lodash/is-type.js
var toString = {}.toString;
var isType = function(value2, type) {
  return toString.call(value2) === "[object " + type + "]";
};
var is_type_default = isType;

// node_modules/@antv/util/esm/lodash/is-array.js
var is_array_default = function(value2) {
  return Array.isArray ? Array.isArray(value2) : is_type_default(value2, "Array");
};

// node_modules/@antv/util/esm/lodash/is-object.js
var is_object_default = function(value2) {
  var type = typeof value2;
  return value2 !== null && type === "object" || type === "function";
};

// node_modules/@antv/util/esm/lodash/each.js
function each(elements, func) {
  if (!elements) {
    return;
  }
  var rst;
  if (is_array_default(elements)) {
    for (var i = 0, len5 = elements.length; i < len5; i++) {
      rst = func(elements[i], i);
      if (rst === false) {
        break;
      }
    }
  } else if (is_object_default(elements)) {
    for (var k2 in elements) {
      if (elements.hasOwnProperty(k2)) {
        rst = func(elements[k2], k2);
        if (rst === false) {
          break;
        }
      }
    }
  }
}
var each_default = each;

// node_modules/@antv/util/esm/lodash/keys.js
var keys = Object.keys ? function(obj) {
  return Object.keys(obj);
} : function(obj) {
  var result2 = [];
  each_default(obj, function(value2, key) {
    if (!(is_function_default(obj) && key === "prototype")) {
      result2.push(key);
    }
  });
  return result2;
};
var keys_default = keys;

// node_modules/@antv/util/esm/lodash/is-object-like.js
var isObjectLike = function(value2) {
  return typeof value2 === "object" && value2 !== null;
};
var is_object_like_default = isObjectLike;

// node_modules/@antv/util/esm/lodash/is-plain-object.js
var isPlainObject = function(value2) {
  if (!is_object_like_default(value2) || !is_type_default(value2, "Object")) {
    return false;
  }
  if (Object.getPrototypeOf(value2) === null) {
    return true;
  }
  var proto = value2;
  while (Object.getPrototypeOf(proto) !== null) {
    proto = Object.getPrototypeOf(proto);
  }
  return Object.getPrototypeOf(value2) === proto;
};
var is_plain_object_default = isPlainObject;

// node_modules/@antv/util/esm/lodash/max.js
var max_default = function(arr) {
  if (!is_array_default(arr)) {
    return void 0;
  }
  return arr.reduce(function(prev, curr) {
    return Math.max(prev, curr);
  }, arr[0]);
};

// node_modules/@antv/util/esm/lodash/min.js
var min_default = function(arr) {
  if (!is_array_default(arr)) {
    return void 0;
  }
  return arr.reduce(function(prev, curr) {
    return Math.min(prev, curr);
  }, arr[0]);
};

// node_modules/@antv/util/esm/lodash/pull.js
var arrPrototype = Array.prototype;
var splice = arrPrototype.splice;
var indexOf = arrPrototype.indexOf;

// node_modules/@antv/util/esm/lodash/pull-at.js
var splice2 = Array.prototype.splice;

// node_modules/@antv/util/esm/lodash/reduce.js
var reduce = function(arr, fn, init) {
  if (!is_array_default(arr) && !is_plain_object_default(arr)) {
    return arr;
  }
  var result2 = init;
  each_default(arr, function(data2, i) {
    result2 = fn(result2, data2, i);
  });
  return result2;
};
var reduce_default = reduce;

// node_modules/@antv/util/esm/lodash/is-string.js
var is_string_default = function(str7) {
  return is_type_default(str7, "String");
};

// node_modules/@antv/util/esm/lodash/last.js
function last(o) {
  if (is_array_like_default(o)) {
    var arr = o;
    return arr[arr.length - 1];
  }
  return void 0;
}

// node_modules/@antv/util/esm/lodash/clamp.js
var clamp = function(a4, min11, max11) {
  if (a4 < min11) {
    return min11;
  } else if (a4 > max11) {
    return max11;
  }
  return a4;
};
var clamp_default = clamp;

// node_modules/@antv/util/esm/lodash/is-number.js
var isNumber = function(value2) {
  return is_type_default(value2, "Number");
};
var is_number_default = isNumber;

// node_modules/@antv/util/esm/lodash/is-integer.js
var isInteger = Number.isInteger ? Number.isInteger : function(num) {
  return is_number_default(num) && num % 1 === 0;
};

// node_modules/@antv/util/esm/lodash/is-number-equal.js
var PRECISION = 1e-5;
function isNumberEqual(a4, b, precision) {
  if (precision === void 0) {
    precision = PRECISION;
  }
  return Math.abs(a4 - b) < precision;
}

// node_modules/@antv/util/esm/lodash/max-by.js
var max_by_default = function(arr, fn) {
  if (!is_array_default(arr)) {
    return void 0;
  }
  var maxItem;
  var max11 = -Infinity;
  for (var i = 0; i < arr.length; i++) {
    var item = arr[i];
    var v = is_function_default(fn) ? fn(item) : item[fn];
    if (v > max11) {
      maxItem = item;
      max11 = v;
    }
  }
  return maxItem;
};

// node_modules/@antv/util/esm/lodash/min-by.js
var min_by_default = function(arr, fn) {
  if (!is_array_default(arr)) {
    return void 0;
  }
  var minItem;
  var min11 = Infinity;
  for (var i = 0; i < arr.length; i++) {
    var item = arr[i];
    var v = is_function_default(fn) ? fn(item) : item[fn];
    if (v < min11) {
      minItem = item;
      min11 = v;
    }
  }
  return minItem;
};

// node_modules/@antv/util/esm/lodash/mod.js
var mod = function(n, m3) {
  return (n % m3 + m3) % m3;
};
var mod_default = mod;

// node_modules/@antv/util/esm/lodash/to-degree.js
var DEGREE = 180 / Math.PI;

// node_modules/@antv/util/esm/lodash/to-radian.js
var RADIAN = Math.PI / 180;

// node_modules/@antv/util/esm/lodash/to-string.js
var to_string_default = function(value2) {
  if (is_nil_default(value2))
    return "";
  return value2.toString();
};

// node_modules/@antv/util/esm/lodash/lower-first.js
var lowerFirst = function(value2) {
  var str7 = to_string_default(value2);
  return str7.charAt(0).toLowerCase() + str7.substring(1);
};
var lower_first_default = lowerFirst;

// node_modules/@antv/util/esm/lodash/substitute.js
function substitute(str7, o) {
  if (!str7 || !o) {
    return str7;
  }
  return str7.replace(/\\?\{([^{}]+)\}/g, function(match, name2) {
    if (match.charAt(0) === "\\") {
      return match.slice(1);
    }
    return o[name2] === void 0 ? "" : o[name2];
  });
}
var substitute_default = substitute;

// node_modules/@antv/util/esm/lodash/upper-first.js
var upperFirst = function(value2) {
  var str7 = to_string_default(value2);
  return str7.charAt(0).toUpperCase() + str7.substring(1);
};
var upper_first_default = upperFirst;

// node_modules/@antv/util/esm/lodash/get-type.js
var toString2 = {}.toString;

// node_modules/@antv/util/esm/lodash/is-boolean.js
var isBoolean = function(value2) {
  return is_type_default(value2, "Boolean");
};
var is_boolean_default = isBoolean;

// node_modules/@antv/util/esm/lodash/is-prototype.js
var objectProto = Object.prototype;

// node_modules/@antv/util/esm/lodash/is-undefined.js
var isUndefined = function(value2) {
  return value2 === void 0;
};
var is_undefined_default = isUndefined;

// node_modules/@antv/util/esm/lodash/is-element.js
var isElement = function(o) {
  return o instanceof Element || o instanceof Document;
};
var is_element_default = isElement;

// node_modules/@antv/util/esm/lodash/mix.js
function _mix(dist5, obj) {
  for (var key in obj) {
    if (obj.hasOwnProperty(key) && key !== "constructor" && obj[key] !== void 0) {
      dist5[key] = obj[key];
    }
  }
}
function mix(dist5, src1, src2, src3) {
  if (src1)
    _mix(dist5, src1);
  if (src2)
    _mix(dist5, src2);
  if (src3)
    _mix(dist5, src3);
  return dist5;
}

// node_modules/@antv/util/esm/lodash/clone.js
var clone = function(obj) {
  if (typeof obj !== "object" || obj === null) {
    return obj;
  }
  var rst;
  if (is_array_default(obj)) {
    rst = [];
    for (var i = 0, l = obj.length; i < l; i++) {
      if (typeof obj[i] === "object" && obj[i] != null) {
        rst[i] = clone(obj[i]);
      } else {
        rst[i] = obj[i];
      }
    }
  } else {
    rst = {};
    for (var k2 in obj) {
      if (typeof obj[k2] === "object" && obj[k2] != null) {
        rst[k2] = clone(obj[k2]);
      } else {
        rst[k2] = obj[k2];
      }
    }
  }
  return rst;
};
var clone_default = clone;

// node_modules/@antv/util/esm/lodash/debounce.js
function debounce(func, wait, immediate) {
  var timeout2;
  return function() {
    var context = this, args = arguments;
    var later = function() {
      timeout2 = null;
      if (!immediate) {
        func.apply(context, args);
      }
    };
    var callNow = immediate && !timeout2;
    clearTimeout(timeout2);
    timeout2 = setTimeout(later, wait);
    if (callNow) {
      func.apply(context, args);
    }
  };
}
var debounce_default = debounce;

// node_modules/flru/dist/flru.mjs
function flru_default(max11) {
  var num, curr, prev;
  var limit = max11 || 1;
  function keep(key, value2) {
    if (++num > limit) {
      prev = curr;
      reset(1);
      ++num;
    }
    curr[key] = value2;
  }
  function reset(isPartial) {
    num = 0;
    curr = /* @__PURE__ */ Object.create(null);
    isPartial || (prev = /* @__PURE__ */ Object.create(null));
  }
  reset();
  return {
    clear: reset,
    has: function(key) {
      return curr[key] !== void 0 || prev[key] !== void 0;
    },
    get: function(key) {
      var val = curr[key];
      if (val !== void 0)
        return val;
      if ((val = prev[key]) !== void 0) {
        keep(key, val);
        return val;
      }
    },
    set: function(key, value2) {
      if (curr[key] !== void 0) {
        curr[key] = value2;
      } else {
        keep(key, value2);
      }
    }
  };
}

// node_modules/@antv/util/esm/lodash/memoize.js
var memoize_default = function(f, resolver, maxSize) {
  if (maxSize === void 0) {
    maxSize = 128;
  }
  if (!is_function_default(f)) {
    throw new TypeError("Expected a function");
  }
  var memoized = function() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    var key = resolver ? resolver.apply(this, args) : args[0];
    var cache2 = memoized.cache;
    if (cache2.has(key)) {
      return cache2.get(key);
    }
    var result2 = f.apply(this, args);
    cache2.set(key, result2);
    return result2;
  };
  memoized.cache = flru_default(maxSize);
  return memoized;
};

// node_modules/@antv/util/esm/lodash/deep-mix.js
var MAX_MIX_LEVEL = 5;
function hasOwn(object, property2) {
  if (Object.hasOwn) {
    return Object.hasOwn(object, property2);
  }
  if (object == null) {
    throw new TypeError("Cannot convert undefined or null to object");
  }
  return Object.prototype.hasOwnProperty.call(Object(object), property2);
}
function _deepMix(dist5, src, level, maxLevel) {
  level = level || 0;
  maxLevel = maxLevel || MAX_MIX_LEVEL;
  for (var key in src) {
    if (hasOwn(src, key)) {
      var value2 = src[key];
      if (value2 !== null && is_plain_object_default(value2)) {
        if (!is_plain_object_default(dist5[key])) {
          dist5[key] = {};
        }
        if (level < maxLevel) {
          _deepMix(dist5[key], value2, level + 1, maxLevel);
        } else {
          dist5[key] = src[key];
        }
      } else if (is_array_default(value2)) {
        dist5[key] = [];
        dist5[key] = dist5[key].concat(value2);
      } else if (value2 !== void 0) {
        dist5[key] = value2;
      }
    }
  }
}
var deepMix = function(rst) {
  var args = [];
  for (var _i = 1; _i < arguments.length; _i++) {
    args[_i - 1] = arguments[_i];
  }
  for (var i = 0; i < args.length; i += 1) {
    _deepMix(rst, args[i]);
  }
  return rst;
};
var deep_mix_default = deepMix;

// node_modules/@antv/util/esm/lodash/is-equal.js
var isEqual = function(value2, other) {
  if (value2 === other) {
    return true;
  }
  if (!value2 || !other) {
    return false;
  }
  if (is_string_default(value2) || is_string_default(other)) {
    return false;
  }
  if (is_array_like_default(value2) || is_array_like_default(other)) {
    if (value2.length !== other.length) {
      return false;
    }
    var rst = true;
    for (var i = 0; i < value2.length; i++) {
      rst = isEqual(value2[i], other[i]);
      if (!rst) {
        break;
      }
    }
    return rst;
  }
  if (is_object_like_default(value2) || is_object_like_default(other)) {
    var valueKeys = Object.keys(value2);
    var otherKeys = Object.keys(other);
    if (valueKeys.length !== otherKeys.length) {
      return false;
    }
    var rst = true;
    for (var i = 0; i < valueKeys.length; i++) {
      rst = isEqual(value2[valueKeys[i]], other[valueKeys[i]]);
      if (!rst) {
        break;
      }
    }
    return rst;
  }
  return false;
};
var is_equal_default = isEqual;

// node_modules/@antv/util/esm/lodash/get.js
var get_default = function(obj, key, defaultValue) {
  var p2 = 0;
  var keyArr = is_string_default(key) ? key.split(".") : key;
  while (obj && p2 < keyArr.length) {
    obj = obj[keyArr[p2++]];
  }
  return obj === void 0 || p2 < keyArr.length ? defaultValue : obj;
};

// node_modules/@antv/util/esm/lodash/set.js
var set_default = function(obj, path2, value2) {
  var o = obj;
  var keyArr = is_string_default(path2) ? path2.split(".") : path2;
  keyArr.forEach(function(key, idx) {
    if (idx < keyArr.length - 1) {
      if (!is_object_default(o[key])) {
        o[key] = is_number_default(keyArr[idx + 1]) ? [] : {};
      }
      o = o[key];
    } else {
      o[key] = value2;
    }
  });
  return obj;
};

// node_modules/@antv/util/esm/lodash/pick.js
var hasOwnProperty = Object.prototype.hasOwnProperty;
var pick_default = function(object, keys3) {
  if (object === null || !is_plain_object_default(object)) {
    return {};
  }
  var result2 = {};
  each_default(keys3, function(key) {
    if (hasOwnProperty.call(object, key)) {
      result2[key] = object[key];
    }
  });
  return result2;
};

// node_modules/@antv/util/esm/lodash/omit.js
var omit_default = function(obj, keys3) {
  return reduce_default(obj, function(r, curr, key) {
    if (!keys3.includes(key)) {
      r[key] = curr;
    }
    return r;
  }, {});
};

// node_modules/@antv/util/esm/lodash/throttle.js
var throttle_default = function(func, wait, options) {
  var timeout2, context, args, result2;
  var previous = 0;
  if (!options)
    options = {};
  var later = function() {
    previous = options.leading === false ? 0 : Date.now();
    timeout2 = null;
    result2 = func.apply(context, args);
    if (!timeout2)
      context = args = null;
  };
  var throttled = function() {
    var now3 = Date.now();
    if (!previous && options.leading === false)
      previous = now3;
    var remaining = wait - (now3 - previous);
    context = this;
    args = arguments;
    if (remaining <= 0 || remaining > wait) {
      if (timeout2) {
        clearTimeout(timeout2);
        timeout2 = null;
      }
      previous = now3;
      result2 = func.apply(context, args);
      if (!timeout2)
        context = args = null;
    } else if (!timeout2 && options.trailing !== false) {
      timeout2 = setTimeout(later, remaining);
    }
    return result2;
  };
  throttled.cancel = function() {
    clearTimeout(timeout2);
    previous = 0;
    timeout2 = context = args = null;
  };
  return throttled;
};

// node_modules/@antv/util/esm/lodash/noop.js
var noop_default = function() {
};

// node_modules/@antv/util/esm/lodash/size.js
function size(o) {
  if (is_nil_default(o)) {
    return 0;
  }
  if (is_array_like_default(o)) {
    return o.length;
  }
  return Object.keys(o).length;
}

// node_modules/@antv/util/esm/lodash/cache.js
var default_1 = (
  /** @class */
  function() {
    function default_14() {
      this.map = {};
    }
    default_14.prototype.has = function(key) {
      return this.map[key] !== void 0;
    };
    default_14.prototype.get = function(key, def) {
      var v = this.map[key];
      return v === void 0 ? def : v;
    };
    default_14.prototype.set = function(key, value2) {
      this.map[key] = value2;
    };
    default_14.prototype.clear = function() {
      this.map = {};
    };
    default_14.prototype.delete = function(key) {
      delete this.map[key];
    };
    default_14.prototype.size = function() {
      return Object.keys(this.map).length;
    };
    return default_14;
  }()
);

// node_modules/@antv/util/esm/color/torgb.js
var RGB_REG = /rgba?\(([\s.,0-9]+)\)/;
function createTmp() {
  var i = document.createElement("i");
  i.title = "Web Colour Picker";
  i.style.display = "none";
  document.body.appendChild(i);
  return i;
}
var iEl;
function toRGBString(color2) {
  if (color2[0] === "#" && color2.length === 7) {
    return color2;
  }
  if (!iEl) {
    iEl = createTmp();
  }
  iEl.style.color = color2;
  var rst = document.defaultView.getComputedStyle(iEl, "").getPropertyValue("color");
  var matches2 = RGB_REG.exec(rst);
  var cArray = matches2[1].split(/\s*,\s*/).map(function(s2) {
    return Number(s2);
  });
  rst = arr2rgb(cArray);
  return rst;
}
var toRGB = memoize_default(toRGBString, function(color2) {
  return color2;
}, 256);

// node_modules/gl-matrix/esm/common.js
var EPSILON = 1e-6;
var ARRAY_TYPE = typeof Float32Array !== "undefined" ? Float32Array : Array;
var RANDOM = Math.random;
var degree = Math.PI / 180;
if (!Math.hypot)
  Math.hypot = function() {
    var y3 = 0, i = arguments.length;
    while (i--) {
      y3 += arguments[i] * arguments[i];
    }
    return Math.sqrt(y3);
  };

// node_modules/gl-matrix/esm/mat3.js
var mat3_exports = {};
__export(mat3_exports, {
  add: () => add,
  adjoint: () => adjoint,
  clone: () => clone2,
  copy: () => copy,
  create: () => create,
  determinant: () => determinant,
  equals: () => equals,
  exactEquals: () => exactEquals,
  frob: () => frob,
  fromMat2d: () => fromMat2d,
  fromMat4: () => fromMat4,
  fromQuat: () => fromQuat,
  fromRotation: () => fromRotation,
  fromScaling: () => fromScaling,
  fromTranslation: () => fromTranslation,
  fromValues: () => fromValues,
  identity: () => identity,
  invert: () => invert,
  mul: () => mul,
  multiply: () => multiply,
  multiplyScalar: () => multiplyScalar,
  multiplyScalarAndAdd: () => multiplyScalarAndAdd,
  normalFromMat4: () => normalFromMat4,
  projection: () => projection,
  rotate: () => rotate,
  scale: () => scale,
  set: () => set,
  str: () => str,
  sub: () => sub,
  subtract: () => subtract,
  translate: () => translate,
  transpose: () => transpose
});
function create() {
  var out = new ARRAY_TYPE(9);
  if (ARRAY_TYPE != Float32Array) {
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[5] = 0;
    out[6] = 0;
    out[7] = 0;
  }
  out[0] = 1;
  out[4] = 1;
  out[8] = 1;
  return out;
}
function fromMat4(out, a4) {
  out[0] = a4[0];
  out[1] = a4[1];
  out[2] = a4[2];
  out[3] = a4[4];
  out[4] = a4[5];
  out[5] = a4[6];
  out[6] = a4[8];
  out[7] = a4[9];
  out[8] = a4[10];
  return out;
}
function clone2(a4) {
  var out = new ARRAY_TYPE(9);
  out[0] = a4[0];
  out[1] = a4[1];
  out[2] = a4[2];
  out[3] = a4[3];
  out[4] = a4[4];
  out[5] = a4[5];
  out[6] = a4[6];
  out[7] = a4[7];
  out[8] = a4[8];
  return out;
}
function copy(out, a4) {
  out[0] = a4[0];
  out[1] = a4[1];
  out[2] = a4[2];
  out[3] = a4[3];
  out[4] = a4[4];
  out[5] = a4[5];
  out[6] = a4[6];
  out[7] = a4[7];
  out[8] = a4[8];
  return out;
}
function fromValues(m00, m01, m02, m10, m11, m12, m20, m21, m22) {
  var out = new ARRAY_TYPE(9);
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m10;
  out[4] = m11;
  out[5] = m12;
  out[6] = m20;
  out[7] = m21;
  out[8] = m22;
  return out;
}
function set(out, m00, m01, m02, m10, m11, m12, m20, m21, m22) {
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m10;
  out[4] = m11;
  out[5] = m12;
  out[6] = m20;
  out[7] = m21;
  out[8] = m22;
  return out;
}
function identity(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 1;
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  out[8] = 1;
  return out;
}
function transpose(out, a4) {
  if (out === a4) {
    var a01 = a4[1], a02 = a4[2], a12 = a4[5];
    out[1] = a4[3];
    out[2] = a4[6];
    out[3] = a01;
    out[5] = a4[7];
    out[6] = a02;
    out[7] = a12;
  } else {
    out[0] = a4[0];
    out[1] = a4[3];
    out[2] = a4[6];
    out[3] = a4[1];
    out[4] = a4[4];
    out[5] = a4[7];
    out[6] = a4[2];
    out[7] = a4[5];
    out[8] = a4[8];
  }
  return out;
}
function invert(out, a4) {
  var a00 = a4[0], a01 = a4[1], a02 = a4[2];
  var a10 = a4[3], a11 = a4[4], a12 = a4[5];
  var a20 = a4[6], a21 = a4[7], a22 = a4[8];
  var b01 = a22 * a11 - a12 * a21;
  var b11 = -a22 * a10 + a12 * a20;
  var b21 = a21 * a10 - a11 * a20;
  var det = a00 * b01 + a01 * b11 + a02 * b21;
  if (!det) {
    return null;
  }
  det = 1 / det;
  out[0] = b01 * det;
  out[1] = (-a22 * a01 + a02 * a21) * det;
  out[2] = (a12 * a01 - a02 * a11) * det;
  out[3] = b11 * det;
  out[4] = (a22 * a00 - a02 * a20) * det;
  out[5] = (-a12 * a00 + a02 * a10) * det;
  out[6] = b21 * det;
  out[7] = (-a21 * a00 + a01 * a20) * det;
  out[8] = (a11 * a00 - a01 * a10) * det;
  return out;
}
function adjoint(out, a4) {
  var a00 = a4[0], a01 = a4[1], a02 = a4[2];
  var a10 = a4[3], a11 = a4[4], a12 = a4[5];
  var a20 = a4[6], a21 = a4[7], a22 = a4[8];
  out[0] = a11 * a22 - a12 * a21;
  out[1] = a02 * a21 - a01 * a22;
  out[2] = a01 * a12 - a02 * a11;
  out[3] = a12 * a20 - a10 * a22;
  out[4] = a00 * a22 - a02 * a20;
  out[5] = a02 * a10 - a00 * a12;
  out[6] = a10 * a21 - a11 * a20;
  out[7] = a01 * a20 - a00 * a21;
  out[8] = a00 * a11 - a01 * a10;
  return out;
}
function determinant(a4) {
  var a00 = a4[0], a01 = a4[1], a02 = a4[2];
  var a10 = a4[3], a11 = a4[4], a12 = a4[5];
  var a20 = a4[6], a21 = a4[7], a22 = a4[8];
  return a00 * (a22 * a11 - a12 * a21) + a01 * (-a22 * a10 + a12 * a20) + a02 * (a21 * a10 - a11 * a20);
}
function multiply(out, a4, b) {
  var a00 = a4[0], a01 = a4[1], a02 = a4[2];
  var a10 = a4[3], a11 = a4[4], a12 = a4[5];
  var a20 = a4[6], a21 = a4[7], a22 = a4[8];
  var b00 = b[0], b01 = b[1], b02 = b[2];
  var b10 = b[3], b11 = b[4], b12 = b[5];
  var b20 = b[6], b21 = b[7], b22 = b[8];
  out[0] = b00 * a00 + b01 * a10 + b02 * a20;
  out[1] = b00 * a01 + b01 * a11 + b02 * a21;
  out[2] = b00 * a02 + b01 * a12 + b02 * a22;
  out[3] = b10 * a00 + b11 * a10 + b12 * a20;
  out[4] = b10 * a01 + b11 * a11 + b12 * a21;
  out[5] = b10 * a02 + b11 * a12 + b12 * a22;
  out[6] = b20 * a00 + b21 * a10 + b22 * a20;
  out[7] = b20 * a01 + b21 * a11 + b22 * a21;
  out[8] = b20 * a02 + b21 * a12 + b22 * a22;
  return out;
}
function translate(out, a4, v) {
  var a00 = a4[0], a01 = a4[1], a02 = a4[2], a10 = a4[3], a11 = a4[4], a12 = a4[5], a20 = a4[6], a21 = a4[7], a22 = a4[8], x3 = v[0], y3 = v[1];
  out[0] = a00;
  out[1] = a01;
  out[2] = a02;
  out[3] = a10;
  out[4] = a11;
  out[5] = a12;
  out[6] = x3 * a00 + y3 * a10 + a20;
  out[7] = x3 * a01 + y3 * a11 + a21;
  out[8] = x3 * a02 + y3 * a12 + a22;
  return out;
}
function rotate(out, a4, rad) {
  var a00 = a4[0], a01 = a4[1], a02 = a4[2], a10 = a4[3], a11 = a4[4], a12 = a4[5], a20 = a4[6], a21 = a4[7], a22 = a4[8], s2 = Math.sin(rad), c5 = Math.cos(rad);
  out[0] = c5 * a00 + s2 * a10;
  out[1] = c5 * a01 + s2 * a11;
  out[2] = c5 * a02 + s2 * a12;
  out[3] = c5 * a10 - s2 * a00;
  out[4] = c5 * a11 - s2 * a01;
  out[5] = c5 * a12 - s2 * a02;
  out[6] = a20;
  out[7] = a21;
  out[8] = a22;
  return out;
}
function scale(out, a4, v) {
  var x3 = v[0], y3 = v[1];
  out[0] = x3 * a4[0];
  out[1] = x3 * a4[1];
  out[2] = x3 * a4[2];
  out[3] = y3 * a4[3];
  out[4] = y3 * a4[4];
  out[5] = y3 * a4[5];
  out[6] = a4[6];
  out[7] = a4[7];
  out[8] = a4[8];
  return out;
}
function fromTranslation(out, v) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 1;
  out[5] = 0;
  out[6] = v[0];
  out[7] = v[1];
  out[8] = 1;
  return out;
}
function fromRotation(out, rad) {
  var s2 = Math.sin(rad), c5 = Math.cos(rad);
  out[0] = c5;
  out[1] = s2;
  out[2] = 0;
  out[3] = -s2;
  out[4] = c5;
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  out[8] = 1;
  return out;
}
function fromScaling(out, v) {
  out[0] = v[0];
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = v[1];
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  out[8] = 1;
  return out;
}
function fromMat2d(out, a4) {
  out[0] = a4[0];
  out[1] = a4[1];
  out[2] = 0;
  out[3] = a4[2];
  out[4] = a4[3];
  out[5] = 0;
  out[6] = a4[4];
  out[7] = a4[5];
  out[8] = 1;
  return out;
}
function fromQuat(out, q) {
  var x3 = q[0], y3 = q[1], z = q[2], w = q[3];
  var x22 = x3 + x3;
  var y22 = y3 + y3;
  var z2 = z + z;
  var xx = x3 * x22;
  var yx = y3 * x22;
  var yy = y3 * y22;
  var zx = z * x22;
  var zy = z * y22;
  var zz = z * z2;
  var wx = w * x22;
  var wy = w * y22;
  var wz = w * z2;
  out[0] = 1 - yy - zz;
  out[3] = yx - wz;
  out[6] = zx + wy;
  out[1] = yx + wz;
  out[4] = 1 - xx - zz;
  out[7] = zy - wx;
  out[2] = zx - wy;
  out[5] = zy + wx;
  out[8] = 1 - xx - yy;
  return out;
}
function normalFromMat4(out, a4) {
  var a00 = a4[0], a01 = a4[1], a02 = a4[2], a03 = a4[3];
  var a10 = a4[4], a11 = a4[5], a12 = a4[6], a13 = a4[7];
  var a20 = a4[8], a21 = a4[9], a22 = a4[10], a23 = a4[11];
  var a30 = a4[12], a31 = a4[13], a32 = a4[14], a33 = a4[15];
  var b00 = a00 * a11 - a01 * a10;
  var b01 = a00 * a12 - a02 * a10;
  var b02 = a00 * a13 - a03 * a10;
  var b03 = a01 * a12 - a02 * a11;
  var b04 = a01 * a13 - a03 * a11;
  var b05 = a02 * a13 - a03 * a12;
  var b06 = a20 * a31 - a21 * a30;
  var b07 = a20 * a32 - a22 * a30;
  var b08 = a20 * a33 - a23 * a30;
  var b09 = a21 * a32 - a22 * a31;
  var b10 = a21 * a33 - a23 * a31;
  var b11 = a22 * a33 - a23 * a32;
  var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
  if (!det) {
    return null;
  }
  det = 1 / det;
  out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
  out[1] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
  out[2] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
  out[3] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
  out[4] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
  out[5] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
  out[6] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
  out[7] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
  out[8] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
  return out;
}
function projection(out, width, height) {
  out[0] = 2 / width;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = -2 / height;
  out[5] = 0;
  out[6] = -1;
  out[7] = 1;
  out[8] = 1;
  return out;
}
function str(a4) {
  return "mat3(" + a4[0] + ", " + a4[1] + ", " + a4[2] + ", " + a4[3] + ", " + a4[4] + ", " + a4[5] + ", " + a4[6] + ", " + a4[7] + ", " + a4[8] + ")";
}
function frob(a4) {
  return Math.hypot(a4[0], a4[1], a4[2], a4[3], a4[4], a4[5], a4[6], a4[7], a4[8]);
}
function add(out, a4, b) {
  out[0] = a4[0] + b[0];
  out[1] = a4[1] + b[1];
  out[2] = a4[2] + b[2];
  out[3] = a4[3] + b[3];
  out[4] = a4[4] + b[4];
  out[5] = a4[5] + b[5];
  out[6] = a4[6] + b[6];
  out[7] = a4[7] + b[7];
  out[8] = a4[8] + b[8];
  return out;
}
function subtract(out, a4, b) {
  out[0] = a4[0] - b[0];
  out[1] = a4[1] - b[1];
  out[2] = a4[2] - b[2];
  out[3] = a4[3] - b[3];
  out[4] = a4[4] - b[4];
  out[5] = a4[5] - b[5];
  out[6] = a4[6] - b[6];
  out[7] = a4[7] - b[7];
  out[8] = a4[8] - b[8];
  return out;
}
function multiplyScalar(out, a4, b) {
  out[0] = a4[0] * b;
  out[1] = a4[1] * b;
  out[2] = a4[2] * b;
  out[3] = a4[3] * b;
  out[4] = a4[4] * b;
  out[5] = a4[5] * b;
  out[6] = a4[6] * b;
  out[7] = a4[7] * b;
  out[8] = a4[8] * b;
  return out;
}
function multiplyScalarAndAdd(out, a4, b, scale10) {
  out[0] = a4[0] + b[0] * scale10;
  out[1] = a4[1] + b[1] * scale10;
  out[2] = a4[2] + b[2] * scale10;
  out[3] = a4[3] + b[3] * scale10;
  out[4] = a4[4] + b[4] * scale10;
  out[5] = a4[5] + b[5] * scale10;
  out[6] = a4[6] + b[6] * scale10;
  out[7] = a4[7] + b[7] * scale10;
  out[8] = a4[8] + b[8] * scale10;
  return out;
}
function exactEquals(a4, b) {
  return a4[0] === b[0] && a4[1] === b[1] && a4[2] === b[2] && a4[3] === b[3] && a4[4] === b[4] && a4[5] === b[5] && a4[6] === b[6] && a4[7] === b[7] && a4[8] === b[8];
}
function equals(a4, b) {
  var a0 = a4[0], a1 = a4[1], a22 = a4[2], a32 = a4[3], a42 = a4[4], a5 = a4[5], a6 = a4[6], a7 = a4[7], a8 = a4[8];
  var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3], b4 = b[4], b5 = b[5], b6 = b[6], b7 = b[7], b8 = b[8];
  return Math.abs(a0 - b0) <= EPSILON * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1, Math.abs(a1), Math.abs(b1)) && Math.abs(a22 - b2) <= EPSILON * Math.max(1, Math.abs(a22), Math.abs(b2)) && Math.abs(a32 - b3) <= EPSILON * Math.max(1, Math.abs(a32), Math.abs(b3)) && Math.abs(a42 - b4) <= EPSILON * Math.max(1, Math.abs(a42), Math.abs(b4)) && Math.abs(a5 - b5) <= EPSILON * Math.max(1, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= EPSILON * Math.max(1, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= EPSILON * Math.max(1, Math.abs(a7), Math.abs(b7)) && Math.abs(a8 - b8) <= EPSILON * Math.max(1, Math.abs(a8), Math.abs(b8));
}
var mul = multiply;
var sub = subtract;

// node_modules/gl-matrix/esm/mat4.js
var mat4_exports = {};
__export(mat4_exports, {
  add: () => add2,
  adjoint: () => adjoint2,
  clone: () => clone3,
  copy: () => copy2,
  create: () => create2,
  determinant: () => determinant2,
  equals: () => equals2,
  exactEquals: () => exactEquals2,
  frob: () => frob2,
  fromQuat: () => fromQuat3,
  fromQuat2: () => fromQuat2,
  fromRotation: () => fromRotation2,
  fromRotationTranslation: () => fromRotationTranslation,
  fromRotationTranslationScale: () => fromRotationTranslationScale,
  fromRotationTranslationScaleOrigin: () => fromRotationTranslationScaleOrigin,
  fromScaling: () => fromScaling2,
  fromTranslation: () => fromTranslation2,
  fromValues: () => fromValues2,
  fromXRotation: () => fromXRotation,
  fromYRotation: () => fromYRotation,
  fromZRotation: () => fromZRotation,
  frustum: () => frustum,
  getRotation: () => getRotation,
  getScaling: () => getScaling,
  getTranslation: () => getTranslation,
  identity: () => identity2,
  invert: () => invert2,
  lookAt: () => lookAt,
  mul: () => mul2,
  multiply: () => multiply2,
  multiplyScalar: () => multiplyScalar2,
  multiplyScalarAndAdd: () => multiplyScalarAndAdd2,
  ortho: () => ortho,
  orthoNO: () => orthoNO,
  orthoZO: () => orthoZO,
  perspective: () => perspective,
  perspectiveFromFieldOfView: () => perspectiveFromFieldOfView,
  perspectiveNO: () => perspectiveNO,
  perspectiveZO: () => perspectiveZO,
  rotate: () => rotate2,
  rotateX: () => rotateX,
  rotateY: () => rotateY,
  rotateZ: () => rotateZ,
  scale: () => scale2,
  set: () => set2,
  str: () => str2,
  sub: () => sub2,
  subtract: () => subtract2,
  targetTo: () => targetTo,
  translate: () => translate2,
  transpose: () => transpose2
});
function create2() {
  var out = new ARRAY_TYPE(16);
  if (ARRAY_TYPE != Float32Array) {
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
  }
  out[0] = 1;
  out[5] = 1;
  out[10] = 1;
  out[15] = 1;
  return out;
}
function clone3(a4) {
  var out = new ARRAY_TYPE(16);
  out[0] = a4[0];
  out[1] = a4[1];
  out[2] = a4[2];
  out[3] = a4[3];
  out[4] = a4[4];
  out[5] = a4[5];
  out[6] = a4[6];
  out[7] = a4[7];
  out[8] = a4[8];
  out[9] = a4[9];
  out[10] = a4[10];
  out[11] = a4[11];
  out[12] = a4[12];
  out[13] = a4[13];
  out[14] = a4[14];
  out[15] = a4[15];
  return out;
}
function copy2(out, a4) {
  out[0] = a4[0];
  out[1] = a4[1];
  out[2] = a4[2];
  out[3] = a4[3];
  out[4] = a4[4];
  out[5] = a4[5];
  out[6] = a4[6];
  out[7] = a4[7];
  out[8] = a4[8];
  out[9] = a4[9];
  out[10] = a4[10];
  out[11] = a4[11];
  out[12] = a4[12];
  out[13] = a4[13];
  out[14] = a4[14];
  out[15] = a4[15];
  return out;
}
function fromValues2(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
  var out = new ARRAY_TYPE(16);
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m03;
  out[4] = m10;
  out[5] = m11;
  out[6] = m12;
  out[7] = m13;
  out[8] = m20;
  out[9] = m21;
  out[10] = m22;
  out[11] = m23;
  out[12] = m30;
  out[13] = m31;
  out[14] = m32;
  out[15] = m33;
  return out;
}
function set2(out, m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m03;
  out[4] = m10;
  out[5] = m11;
  out[6] = m12;
  out[7] = m13;
  out[8] = m20;
  out[9] = m21;
  out[10] = m22;
  out[11] = m23;
  out[12] = m30;
  out[13] = m31;
  out[14] = m32;
  out[15] = m33;
  return out;
}
function identity2(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
function transpose2(out, a4) {
  if (out === a4) {
    var a01 = a4[1], a02 = a4[2], a03 = a4[3];
    var a12 = a4[6], a13 = a4[7];
    var a23 = a4[11];
    out[1] = a4[4];
    out[2] = a4[8];
    out[3] = a4[12];
    out[4] = a01;
    out[6] = a4[9];
    out[7] = a4[13];
    out[8] = a02;
    out[9] = a12;
    out[11] = a4[14];
    out[12] = a03;
    out[13] = a13;
    out[14] = a23;
  } else {
    out[0] = a4[0];
    out[1] = a4[4];
    out[2] = a4[8];
    out[3] = a4[12];
    out[4] = a4[1];
    out[5] = a4[5];
    out[6] = a4[9];
    out[7] = a4[13];
    out[8] = a4[2];
    out[9] = a4[6];
    out[10] = a4[10];
    out[11] = a4[14];
    out[12] = a4[3];
    out[13] = a4[7];
    out[14] = a4[11];
    out[15] = a4[15];
  }
  return out;
}
function invert2(out, a4) {
  var a00 = a4[0], a01 = a4[1], a02 = a4[2], a03 = a4[3];
  var a10 = a4[4], a11 = a4[5], a12 = a4[6], a13 = a4[7];
  var a20 = a4[8], a21 = a4[9], a22 = a4[10], a23 = a4[11];
  var a30 = a4[12], a31 = a4[13], a32 = a4[14], a33 = a4[15];
  var b00 = a00 * a11 - a01 * a10;
  var b01 = a00 * a12 - a02 * a10;
  var b02 = a00 * a13 - a03 * a10;
  var b03 = a01 * a12 - a02 * a11;
  var b04 = a01 * a13 - a03 * a11;
  var b05 = a02 * a13 - a03 * a12;
  var b06 = a20 * a31 - a21 * a30;
  var b07 = a20 * a32 - a22 * a30;
  var b08 = a20 * a33 - a23 * a30;
  var b09 = a21 * a32 - a22 * a31;
  var b10 = a21 * a33 - a23 * a31;
  var b11 = a22 * a33 - a23 * a32;
  var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
  if (!det) {
    return null;
  }
  det = 1 / det;
  out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
  out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
  out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
  out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
  out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
  out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
  out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
  out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
  out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
  out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
  out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
  out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
  out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
  out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
  out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
  out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;
  return out;
}
function adjoint2(out, a4) {
  var a00 = a4[0], a01 = a4[1], a02 = a4[2], a03 = a4[3];
  var a10 = a4[4], a11 = a4[5], a12 = a4[6], a13 = a4[7];
  var a20 = a4[8], a21 = a4[9], a22 = a4[10], a23 = a4[11];
  var a30 = a4[12], a31 = a4[13], a32 = a4[14], a33 = a4[15];
  out[0] = a11 * (a22 * a33 - a23 * a32) - a21 * (a12 * a33 - a13 * a32) + a31 * (a12 * a23 - a13 * a22);
  out[1] = -(a01 * (a22 * a33 - a23 * a32) - a21 * (a02 * a33 - a03 * a32) + a31 * (a02 * a23 - a03 * a22));
  out[2] = a01 * (a12 * a33 - a13 * a32) - a11 * (a02 * a33 - a03 * a32) + a31 * (a02 * a13 - a03 * a12);
  out[3] = -(a01 * (a12 * a23 - a13 * a22) - a11 * (a02 * a23 - a03 * a22) + a21 * (a02 * a13 - a03 * a12));
  out[4] = -(a10 * (a22 * a33 - a23 * a32) - a20 * (a12 * a33 - a13 * a32) + a30 * (a12 * a23 - a13 * a22));
  out[5] = a00 * (a22 * a33 - a23 * a32) - a20 * (a02 * a33 - a03 * a32) + a30 * (a02 * a23 - a03 * a22);
  out[6] = -(a00 * (a12 * a33 - a13 * a32) - a10 * (a02 * a33 - a03 * a32) + a30 * (a02 * a13 - a03 * a12));
  out[7] = a00 * (a12 * a23 - a13 * a22) - a10 * (a02 * a23 - a03 * a22) + a20 * (a02 * a13 - a03 * a12);
  out[8] = a10 * (a21 * a33 - a23 * a31) - a20 * (a11 * a33 - a13 * a31) + a30 * (a11 * a23 - a13 * a21);
  out[9] = -(a00 * (a21 * a33 - a23 * a31) - a20 * (a01 * a33 - a03 * a31) + a30 * (a01 * a23 - a03 * a21));
  out[10] = a00 * (a11 * a33 - a13 * a31) - a10 * (a01 * a33 - a03 * a31) + a30 * (a01 * a13 - a03 * a11);
  out[11] = -(a00 * (a11 * a23 - a13 * a21) - a10 * (a01 * a23 - a03 * a21) + a20 * (a01 * a13 - a03 * a11));
  out[12] = -(a10 * (a21 * a32 - a22 * a31) - a20 * (a11 * a32 - a12 * a31) + a30 * (a11 * a22 - a12 * a21));
  out[13] = a00 * (a21 * a32 - a22 * a31) - a20 * (a01 * a32 - a02 * a31) + a30 * (a01 * a22 - a02 * a21);
  out[14] = -(a00 * (a11 * a32 - a12 * a31) - a10 * (a01 * a32 - a02 * a31) + a30 * (a01 * a12 - a02 * a11));
  out[15] = a00 * (a11 * a22 - a12 * a21) - a10 * (a01 * a22 - a02 * a21) + a20 * (a01 * a12 - a02 * a11);
  return out;
}
function determinant2(a4) {
  var a00 = a4[0], a01 = a4[1], a02 = a4[2], a03 = a4[3];
  var a10 = a4[4], a11 = a4[5], a12 = a4[6], a13 = a4[7];
  var a20 = a4[8], a21 = a4[9], a22 = a4[10], a23 = a4[11];
  var a30 = a4[12], a31 = a4[13], a32 = a4[14], a33 = a4[15];
  var b00 = a00 * a11 - a01 * a10;
  var b01 = a00 * a12 - a02 * a10;
  var b02 = a00 * a13 - a03 * a10;
  var b03 = a01 * a12 - a02 * a11;
  var b04 = a01 * a13 - a03 * a11;
  var b05 = a02 * a13 - a03 * a12;
  var b06 = a20 * a31 - a21 * a30;
  var b07 = a20 * a32 - a22 * a30;
  var b08 = a20 * a33 - a23 * a30;
  var b09 = a21 * a32 - a22 * a31;
  var b10 = a21 * a33 - a23 * a31;
  var b11 = a22 * a33 - a23 * a32;
  return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
}
function multiply2(out, a4, b) {
  var a00 = a4[0], a01 = a4[1], a02 = a4[2], a03 = a4[3];
  var a10 = a4[4], a11 = a4[5], a12 = a4[6], a13 = a4[7];
  var a20 = a4[8], a21 = a4[9], a22 = a4[10], a23 = a4[11];
  var a30 = a4[12], a31 = a4[13], a32 = a4[14], a33 = a4[15];
  var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
  out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  b0 = b[4];
  b1 = b[5];
  b2 = b[6];
  b3 = b[7];
  out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  b0 = b[8];
  b1 = b[9];
  b2 = b[10];
  b3 = b[11];
  out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  b0 = b[12];
  b1 = b[13];
  b2 = b[14];
  b3 = b[15];
  out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  return out;
}
function translate2(out, a4, v) {
  var x3 = v[0], y3 = v[1], z = v[2];
  var a00, a01, a02, a03;
  var a10, a11, a12, a13;
  var a20, a21, a22, a23;
  if (a4 === out) {
    out[12] = a4[0] * x3 + a4[4] * y3 + a4[8] * z + a4[12];
    out[13] = a4[1] * x3 + a4[5] * y3 + a4[9] * z + a4[13];
    out[14] = a4[2] * x3 + a4[6] * y3 + a4[10] * z + a4[14];
    out[15] = a4[3] * x3 + a4[7] * y3 + a4[11] * z + a4[15];
  } else {
    a00 = a4[0];
    a01 = a4[1];
    a02 = a4[2];
    a03 = a4[3];
    a10 = a4[4];
    a11 = a4[5];
    a12 = a4[6];
    a13 = a4[7];
    a20 = a4[8];
    a21 = a4[9];
    a22 = a4[10];
    a23 = a4[11];
    out[0] = a00;
    out[1] = a01;
    out[2] = a02;
    out[3] = a03;
    out[4] = a10;
    out[5] = a11;
    out[6] = a12;
    out[7] = a13;
    out[8] = a20;
    out[9] = a21;
    out[10] = a22;
    out[11] = a23;
    out[12] = a00 * x3 + a10 * y3 + a20 * z + a4[12];
    out[13] = a01 * x3 + a11 * y3 + a21 * z + a4[13];
    out[14] = a02 * x3 + a12 * y3 + a22 * z + a4[14];
    out[15] = a03 * x3 + a13 * y3 + a23 * z + a4[15];
  }
  return out;
}
function scale2(out, a4, v) {
  var x3 = v[0], y3 = v[1], z = v[2];
  out[0] = a4[0] * x3;
  out[1] = a4[1] * x3;
  out[2] = a4[2] * x3;
  out[3] = a4[3] * x3;
  out[4] = a4[4] * y3;
  out[5] = a4[5] * y3;
  out[6] = a4[6] * y3;
  out[7] = a4[7] * y3;
  out[8] = a4[8] * z;
  out[9] = a4[9] * z;
  out[10] = a4[10] * z;
  out[11] = a4[11] * z;
  out[12] = a4[12];
  out[13] = a4[13];
  out[14] = a4[14];
  out[15] = a4[15];
  return out;
}
function rotate2(out, a4, rad, axis) {
  var x3 = axis[0], y3 = axis[1], z = axis[2];
  var len5 = Math.hypot(x3, y3, z);
  var s2, c5, t;
  var a00, a01, a02, a03;
  var a10, a11, a12, a13;
  var a20, a21, a22, a23;
  var b00, b01, b02;
  var b10, b11, b12;
  var b20, b21, b22;
  if (len5 < EPSILON) {
    return null;
  }
  len5 = 1 / len5;
  x3 *= len5;
  y3 *= len5;
  z *= len5;
  s2 = Math.sin(rad);
  c5 = Math.cos(rad);
  t = 1 - c5;
  a00 = a4[0];
  a01 = a4[1];
  a02 = a4[2];
  a03 = a4[3];
  a10 = a4[4];
  a11 = a4[5];
  a12 = a4[6];
  a13 = a4[7];
  a20 = a4[8];
  a21 = a4[9];
  a22 = a4[10];
  a23 = a4[11];
  b00 = x3 * x3 * t + c5;
  b01 = y3 * x3 * t + z * s2;
  b02 = z * x3 * t - y3 * s2;
  b10 = x3 * y3 * t - z * s2;
  b11 = y3 * y3 * t + c5;
  b12 = z * y3 * t + x3 * s2;
  b20 = x3 * z * t + y3 * s2;
  b21 = y3 * z * t - x3 * s2;
  b22 = z * z * t + c5;
  out[0] = a00 * b00 + a10 * b01 + a20 * b02;
  out[1] = a01 * b00 + a11 * b01 + a21 * b02;
  out[2] = a02 * b00 + a12 * b01 + a22 * b02;
  out[3] = a03 * b00 + a13 * b01 + a23 * b02;
  out[4] = a00 * b10 + a10 * b11 + a20 * b12;
  out[5] = a01 * b10 + a11 * b11 + a21 * b12;
  out[6] = a02 * b10 + a12 * b11 + a22 * b12;
  out[7] = a03 * b10 + a13 * b11 + a23 * b12;
  out[8] = a00 * b20 + a10 * b21 + a20 * b22;
  out[9] = a01 * b20 + a11 * b21 + a21 * b22;
  out[10] = a02 * b20 + a12 * b21 + a22 * b22;
  out[11] = a03 * b20 + a13 * b21 + a23 * b22;
  if (a4 !== out) {
    out[12] = a4[12];
    out[13] = a4[13];
    out[14] = a4[14];
    out[15] = a4[15];
  }
  return out;
}
function rotateX(out, a4, rad) {
  var s2 = Math.sin(rad);
  var c5 = Math.cos(rad);
  var a10 = a4[4];
  var a11 = a4[5];
  var a12 = a4[6];
  var a13 = a4[7];
  var a20 = a4[8];
  var a21 = a4[9];
  var a22 = a4[10];
  var a23 = a4[11];
  if (a4 !== out) {
    out[0] = a4[0];
    out[1] = a4[1];
    out[2] = a4[2];
    out[3] = a4[3];
    out[12] = a4[12];
    out[13] = a4[13];
    out[14] = a4[14];
    out[15] = a4[15];
  }
  out[4] = a10 * c5 + a20 * s2;
  out[5] = a11 * c5 + a21 * s2;
  out[6] = a12 * c5 + a22 * s2;
  out[7] = a13 * c5 + a23 * s2;
  out[8] = a20 * c5 - a10 * s2;
  out[9] = a21 * c5 - a11 * s2;
  out[10] = a22 * c5 - a12 * s2;
  out[11] = a23 * c5 - a13 * s2;
  return out;
}
function rotateY(out, a4, rad) {
  var s2 = Math.sin(rad);
  var c5 = Math.cos(rad);
  var a00 = a4[0];
  var a01 = a4[1];
  var a02 = a4[2];
  var a03 = a4[3];
  var a20 = a4[8];
  var a21 = a4[9];
  var a22 = a4[10];
  var a23 = a4[11];
  if (a4 !== out) {
    out[4] = a4[4];
    out[5] = a4[5];
    out[6] = a4[6];
    out[7] = a4[7];
    out[12] = a4[12];
    out[13] = a4[13];
    out[14] = a4[14];
    out[15] = a4[15];
  }
  out[0] = a00 * c5 - a20 * s2;
  out[1] = a01 * c5 - a21 * s2;
  out[2] = a02 * c5 - a22 * s2;
  out[3] = a03 * c5 - a23 * s2;
  out[8] = a00 * s2 + a20 * c5;
  out[9] = a01 * s2 + a21 * c5;
  out[10] = a02 * s2 + a22 * c5;
  out[11] = a03 * s2 + a23 * c5;
  return out;
}
function rotateZ(out, a4, rad) {
  var s2 = Math.sin(rad);
  var c5 = Math.cos(rad);
  var a00 = a4[0];
  var a01 = a4[1];
  var a02 = a4[2];
  var a03 = a4[3];
  var a10 = a4[4];
  var a11 = a4[5];
  var a12 = a4[6];
  var a13 = a4[7];
  if (a4 !== out) {
    out[8] = a4[8];
    out[9] = a4[9];
    out[10] = a4[10];
    out[11] = a4[11];
    out[12] = a4[12];
    out[13] = a4[13];
    out[14] = a4[14];
    out[15] = a4[15];
  }
  out[0] = a00 * c5 + a10 * s2;
  out[1] = a01 * c5 + a11 * s2;
  out[2] = a02 * c5 + a12 * s2;
  out[3] = a03 * c5 + a13 * s2;
  out[4] = a10 * c5 - a00 * s2;
  out[5] = a11 * c5 - a01 * s2;
  out[6] = a12 * c5 - a02 * s2;
  out[7] = a13 * c5 - a03 * s2;
  return out;
}
function fromTranslation2(out, v) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = v[0];
  out[13] = v[1];
  out[14] = v[2];
  out[15] = 1;
  return out;
}
function fromScaling2(out, v) {
  out[0] = v[0];
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = v[1];
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = v[2];
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
function fromRotation2(out, rad, axis) {
  var x3 = axis[0], y3 = axis[1], z = axis[2];
  var len5 = Math.hypot(x3, y3, z);
  var s2, c5, t;
  if (len5 < EPSILON) {
    return null;
  }
  len5 = 1 / len5;
  x3 *= len5;
  y3 *= len5;
  z *= len5;
  s2 = Math.sin(rad);
  c5 = Math.cos(rad);
  t = 1 - c5;
  out[0] = x3 * x3 * t + c5;
  out[1] = y3 * x3 * t + z * s2;
  out[2] = z * x3 * t - y3 * s2;
  out[3] = 0;
  out[4] = x3 * y3 * t - z * s2;
  out[5] = y3 * y3 * t + c5;
  out[6] = z * y3 * t + x3 * s2;
  out[7] = 0;
  out[8] = x3 * z * t + y3 * s2;
  out[9] = y3 * z * t - x3 * s2;
  out[10] = z * z * t + c5;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
function fromXRotation(out, rad) {
  var s2 = Math.sin(rad);
  var c5 = Math.cos(rad);
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = c5;
  out[6] = s2;
  out[7] = 0;
  out[8] = 0;
  out[9] = -s2;
  out[10] = c5;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
function fromYRotation(out, rad) {
  var s2 = Math.sin(rad);
  var c5 = Math.cos(rad);
  out[0] = c5;
  out[1] = 0;
  out[2] = -s2;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = s2;
  out[9] = 0;
  out[10] = c5;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
function fromZRotation(out, rad) {
  var s2 = Math.sin(rad);
  var c5 = Math.cos(rad);
  out[0] = c5;
  out[1] = s2;
  out[2] = 0;
  out[3] = 0;
  out[4] = -s2;
  out[5] = c5;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
function fromRotationTranslation(out, q, v) {
  var x3 = q[0], y3 = q[1], z = q[2], w = q[3];
  var x22 = x3 + x3;
  var y22 = y3 + y3;
  var z2 = z + z;
  var xx = x3 * x22;
  var xy = x3 * y22;
  var xz = x3 * z2;
  var yy = y3 * y22;
  var yz = y3 * z2;
  var zz = z * z2;
  var wx = w * x22;
  var wy = w * y22;
  var wz = w * z2;
  out[0] = 1 - (yy + zz);
  out[1] = xy + wz;
  out[2] = xz - wy;
  out[3] = 0;
  out[4] = xy - wz;
  out[5] = 1 - (xx + zz);
  out[6] = yz + wx;
  out[7] = 0;
  out[8] = xz + wy;
  out[9] = yz - wx;
  out[10] = 1 - (xx + yy);
  out[11] = 0;
  out[12] = v[0];
  out[13] = v[1];
  out[14] = v[2];
  out[15] = 1;
  return out;
}
function fromQuat2(out, a4) {
  var translation = new ARRAY_TYPE(3);
  var bx = -a4[0], by = -a4[1], bz = -a4[2], bw = a4[3], ax = a4[4], ay = a4[5], az = a4[6], aw = a4[7];
  var magnitude = bx * bx + by * by + bz * bz + bw * bw;
  if (magnitude > 0) {
    translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2 / magnitude;
    translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2 / magnitude;
    translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2 / magnitude;
  } else {
    translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2;
    translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2;
    translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2;
  }
  fromRotationTranslation(out, a4, translation);
  return out;
}
function getTranslation(out, mat) {
  out[0] = mat[12];
  out[1] = mat[13];
  out[2] = mat[14];
  return out;
}
function getScaling(out, mat) {
  var m11 = mat[0];
  var m12 = mat[1];
  var m13 = mat[2];
  var m21 = mat[4];
  var m22 = mat[5];
  var m23 = mat[6];
  var m31 = mat[8];
  var m32 = mat[9];
  var m33 = mat[10];
  out[0] = Math.hypot(m11, m12, m13);
  out[1] = Math.hypot(m21, m22, m23);
  out[2] = Math.hypot(m31, m32, m33);
  return out;
}
function getRotation(out, mat) {
  var scaling = new ARRAY_TYPE(3);
  getScaling(scaling, mat);
  var is1 = 1 / scaling[0];
  var is2 = 1 / scaling[1];
  var is3 = 1 / scaling[2];
  var sm11 = mat[0] * is1;
  var sm12 = mat[1] * is2;
  var sm13 = mat[2] * is3;
  var sm21 = mat[4] * is1;
  var sm22 = mat[5] * is2;
  var sm23 = mat[6] * is3;
  var sm31 = mat[8] * is1;
  var sm32 = mat[9] * is2;
  var sm33 = mat[10] * is3;
  var trace = sm11 + sm22 + sm33;
  var S = 0;
  if (trace > 0) {
    S = Math.sqrt(trace + 1) * 2;
    out[3] = 0.25 * S;
    out[0] = (sm23 - sm32) / S;
    out[1] = (sm31 - sm13) / S;
    out[2] = (sm12 - sm21) / S;
  } else if (sm11 > sm22 && sm11 > sm33) {
    S = Math.sqrt(1 + sm11 - sm22 - sm33) * 2;
    out[3] = (sm23 - sm32) / S;
    out[0] = 0.25 * S;
    out[1] = (sm12 + sm21) / S;
    out[2] = (sm31 + sm13) / S;
  } else if (sm22 > sm33) {
    S = Math.sqrt(1 + sm22 - sm11 - sm33) * 2;
    out[3] = (sm31 - sm13) / S;
    out[0] = (sm12 + sm21) / S;
    out[1] = 0.25 * S;
    out[2] = (sm23 + sm32) / S;
  } else {
    S = Math.sqrt(1 + sm33 - sm11 - sm22) * 2;
    out[3] = (sm12 - sm21) / S;
    out[0] = (sm31 + sm13) / S;
    out[1] = (sm23 + sm32) / S;
    out[2] = 0.25 * S;
  }
  return out;
}
function fromRotationTranslationScale(out, q, v, s2) {
  var x3 = q[0], y3 = q[1], z = q[2], w = q[3];
  var x22 = x3 + x3;
  var y22 = y3 + y3;
  var z2 = z + z;
  var xx = x3 * x22;
  var xy = x3 * y22;
  var xz = x3 * z2;
  var yy = y3 * y22;
  var yz = y3 * z2;
  var zz = z * z2;
  var wx = w * x22;
  var wy = w * y22;
  var wz = w * z2;
  var sx = s2[0];
  var sy = s2[1];
  var sz = s2[2];
  out[0] = (1 - (yy + zz)) * sx;
  out[1] = (xy + wz) * sx;
  out[2] = (xz - wy) * sx;
  out[3] = 0;
  out[4] = (xy - wz) * sy;
  out[5] = (1 - (xx + zz)) * sy;
  out[6] = (yz + wx) * sy;
  out[7] = 0;
  out[8] = (xz + wy) * sz;
  out[9] = (yz - wx) * sz;
  out[10] = (1 - (xx + yy)) * sz;
  out[11] = 0;
  out[12] = v[0];
  out[13] = v[1];
  out[14] = v[2];
  out[15] = 1;
  return out;
}
function fromRotationTranslationScaleOrigin(out, q, v, s2, o) {
  var x3 = q[0], y3 = q[1], z = q[2], w = q[3];
  var x22 = x3 + x3;
  var y22 = y3 + y3;
  var z2 = z + z;
  var xx = x3 * x22;
  var xy = x3 * y22;
  var xz = x3 * z2;
  var yy = y3 * y22;
  var yz = y3 * z2;
  var zz = z * z2;
  var wx = w * x22;
  var wy = w * y22;
  var wz = w * z2;
  var sx = s2[0];
  var sy = s2[1];
  var sz = s2[2];
  var ox = o[0];
  var oy = o[1];
  var oz = o[2];
  var out0 = (1 - (yy + zz)) * sx;
  var out1 = (xy + wz) * sx;
  var out2 = (xz - wy) * sx;
  var out4 = (xy - wz) * sy;
  var out5 = (1 - (xx + zz)) * sy;
  var out6 = (yz + wx) * sy;
  var out8 = (xz + wy) * sz;
  var out9 = (yz - wx) * sz;
  var out10 = (1 - (xx + yy)) * sz;
  out[0] = out0;
  out[1] = out1;
  out[2] = out2;
  out[3] = 0;
  out[4] = out4;
  out[5] = out5;
  out[6] = out6;
  out[7] = 0;
  out[8] = out8;
  out[9] = out9;
  out[10] = out10;
  out[11] = 0;
  out[12] = v[0] + ox - (out0 * ox + out4 * oy + out8 * oz);
  out[13] = v[1] + oy - (out1 * ox + out5 * oy + out9 * oz);
  out[14] = v[2] + oz - (out2 * ox + out6 * oy + out10 * oz);
  out[15] = 1;
  return out;
}
function fromQuat3(out, q) {
  var x3 = q[0], y3 = q[1], z = q[2], w = q[3];
  var x22 = x3 + x3;
  var y22 = y3 + y3;
  var z2 = z + z;
  var xx = x3 * x22;
  var yx = y3 * x22;
  var yy = y3 * y22;
  var zx = z * x22;
  var zy = z * y22;
  var zz = z * z2;
  var wx = w * x22;
  var wy = w * y22;
  var wz = w * z2;
  out[0] = 1 - yy - zz;
  out[1] = yx + wz;
  out[2] = zx - wy;
  out[3] = 0;
  out[4] = yx - wz;
  out[5] = 1 - xx - zz;
  out[6] = zy + wx;
  out[7] = 0;
  out[8] = zx + wy;
  out[9] = zy - wx;
  out[10] = 1 - xx - yy;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
function frustum(out, left2, right2, bottom, top, near, far) {
  var rl = 1 / (right2 - left2);
  var tb = 1 / (top - bottom);
  var nf = 1 / (near - far);
  out[0] = near * 2 * rl;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = near * 2 * tb;
  out[6] = 0;
  out[7] = 0;
  out[8] = (right2 + left2) * rl;
  out[9] = (top + bottom) * tb;
  out[10] = (far + near) * nf;
  out[11] = -1;
  out[12] = 0;
  out[13] = 0;
  out[14] = far * near * 2 * nf;
  out[15] = 0;
  return out;
}
function perspectiveNO(out, fovy, aspect, near, far) {
  var f = 1 / Math.tan(fovy / 2), nf;
  out[0] = f / aspect;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = f;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[11] = -1;
  out[12] = 0;
  out[13] = 0;
  out[15] = 0;
  if (far != null && far !== Infinity) {
    nf = 1 / (near - far);
    out[10] = (far + near) * nf;
    out[14] = 2 * far * near * nf;
  } else {
    out[10] = -1;
    out[14] = -2 * near;
  }
  return out;
}
var perspective = perspectiveNO;
function perspectiveZO(out, fovy, aspect, near, far) {
  var f = 1 / Math.tan(fovy / 2), nf;
  out[0] = f / aspect;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = f;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[11] = -1;
  out[12] = 0;
  out[13] = 0;
  out[15] = 0;
  if (far != null && far !== Infinity) {
    nf = 1 / (near - far);
    out[10] = far * nf;
    out[14] = far * near * nf;
  } else {
    out[10] = -1;
    out[14] = -near;
  }
  return out;
}
function perspectiveFromFieldOfView(out, fov, near, far) {
  var upTan = Math.tan(fov.upDegrees * Math.PI / 180);
  var downTan = Math.tan(fov.downDegrees * Math.PI / 180);
  var leftTan = Math.tan(fov.leftDegrees * Math.PI / 180);
  var rightTan = Math.tan(fov.rightDegrees * Math.PI / 180);
  var xScale = 2 / (leftTan + rightTan);
  var yScale = 2 / (upTan + downTan);
  out[0] = xScale;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = yScale;
  out[6] = 0;
  out[7] = 0;
  out[8] = -((leftTan - rightTan) * xScale * 0.5);
  out[9] = (upTan - downTan) * yScale * 0.5;
  out[10] = far / (near - far);
  out[11] = -1;
  out[12] = 0;
  out[13] = 0;
  out[14] = far * near / (near - far);
  out[15] = 0;
  return out;
}
function orthoNO(out, left2, right2, bottom, top, near, far) {
  var lr = 1 / (left2 - right2);
  var bt = 1 / (bottom - top);
  var nf = 1 / (near - far);
  out[0] = -2 * lr;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = -2 * bt;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 2 * nf;
  out[11] = 0;
  out[12] = (left2 + right2) * lr;
  out[13] = (top + bottom) * bt;
  out[14] = (far + near) * nf;
  out[15] = 1;
  return out;
}
var ortho = orthoNO;
function orthoZO(out, left2, right2, bottom, top, near, far) {
  var lr = 1 / (left2 - right2);
  var bt = 1 / (bottom - top);
  var nf = 1 / (near - far);
  out[0] = -2 * lr;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = -2 * bt;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = nf;
  out[11] = 0;
  out[12] = (left2 + right2) * lr;
  out[13] = (top + bottom) * bt;
  out[14] = near * nf;
  out[15] = 1;
  return out;
}
function lookAt(out, eye, center2, up) {
  var x05, x12, x22, y05, y12, y22, z0, z1, z2, len5;
  var eyex = eye[0];
  var eyey = eye[1];
  var eyez = eye[2];
  var upx = up[0];
  var upy = up[1];
  var upz = up[2];
  var centerx = center2[0];
  var centery = center2[1];
  var centerz = center2[2];
  if (Math.abs(eyex - centerx) < EPSILON && Math.abs(eyey - centery) < EPSILON && Math.abs(eyez - centerz) < EPSILON) {
    return identity2(out);
  }
  z0 = eyex - centerx;
  z1 = eyey - centery;
  z2 = eyez - centerz;
  len5 = 1 / Math.hypot(z0, z1, z2);
  z0 *= len5;
  z1 *= len5;
  z2 *= len5;
  x05 = upy * z2 - upz * z1;
  x12 = upz * z0 - upx * z2;
  x22 = upx * z1 - upy * z0;
  len5 = Math.hypot(x05, x12, x22);
  if (!len5) {
    x05 = 0;
    x12 = 0;
    x22 = 0;
  } else {
    len5 = 1 / len5;
    x05 *= len5;
    x12 *= len5;
    x22 *= len5;
  }
  y05 = z1 * x22 - z2 * x12;
  y12 = z2 * x05 - z0 * x22;
  y22 = z0 * x12 - z1 * x05;
  len5 = Math.hypot(y05, y12, y22);
  if (!len5) {
    y05 = 0;
    y12 = 0;
    y22 = 0;
  } else {
    len5 = 1 / len5;
    y05 *= len5;
    y12 *= len5;
    y22 *= len5;
  }
  out[0] = x05;
  out[1] = y05;
  out[2] = z0;
  out[3] = 0;
  out[4] = x12;
  out[5] = y12;
  out[6] = z1;
  out[7] = 0;
  out[8] = x22;
  out[9] = y22;
  out[10] = z2;
  out[11] = 0;
  out[12] = -(x05 * eyex + x12 * eyey + x22 * eyez);
  out[13] = -(y05 * eyex + y12 * eyey + y22 * eyez);
  out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);
  out[15] = 1;
  return out;
}
function targetTo(out, eye, target, up) {
  var eyex = eye[0], eyey = eye[1], eyez = eye[2], upx = up[0], upy = up[1], upz = up[2];
  var z0 = eyex - target[0], z1 = eyey - target[1], z2 = eyez - target[2];
  var len5 = z0 * z0 + z1 * z1 + z2 * z2;
  if (len5 > 0) {
    len5 = 1 / Math.sqrt(len5);
    z0 *= len5;
    z1 *= len5;
    z2 *= len5;
  }
  var x05 = upy * z2 - upz * z1, x12 = upz * z0 - upx * z2, x22 = upx * z1 - upy * z0;
  len5 = x05 * x05 + x12 * x12 + x22 * x22;
  if (len5 > 0) {
    len5 = 1 / Math.sqrt(len5);
    x05 *= len5;
    x12 *= len5;
    x22 *= len5;
  }
  out[0] = x05;
  out[1] = x12;
  out[2] = x22;
  out[3] = 0;
  out[4] = z1 * x22 - z2 * x12;
  out[5] = z2 * x05 - z0 * x22;
  out[6] = z0 * x12 - z1 * x05;
  out[7] = 0;
  out[8] = z0;
  out[9] = z1;
  out[10] = z2;
  out[11] = 0;
  out[12] = eyex;
  out[13] = eyey;
  out[14] = eyez;
  out[15] = 1;
  return out;
}
function str2(a4) {
  return "mat4(" + a4[0] + ", " + a4[1] + ", " + a4[2] + ", " + a4[3] + ", " + a4[4] + ", " + a4[5] + ", " + a4[6] + ", " + a4[7] + ", " + a4[8] + ", " + a4[9] + ", " + a4[10] + ", " + a4[11] + ", " + a4[12] + ", " + a4[13] + ", " + a4[14] + ", " + a4[15] + ")";
}
function frob2(a4) {
  return Math.hypot(a4[0], a4[1], a4[2], a4[3], a4[4], a4[5], a4[6], a4[7], a4[8], a4[9], a4[10], a4[11], a4[12], a4[13], a4[14], a4[15]);
}
function add2(out, a4, b) {
  out[0] = a4[0] + b[0];
  out[1] = a4[1] + b[1];
  out[2] = a4[2] + b[2];
  out[3] = a4[3] + b[3];
  out[4] = a4[4] + b[4];
  out[5] = a4[5] + b[5];
  out[6] = a4[6] + b[6];
  out[7] = a4[7] + b[7];
  out[8] = a4[8] + b[8];
  out[9] = a4[9] + b[9];
  out[10] = a4[10] + b[10];
  out[11] = a4[11] + b[11];
  out[12] = a4[12] + b[12];
  out[13] = a4[13] + b[13];
  out[14] = a4[14] + b[14];
  out[15] = a4[15] + b[15];
  return out;
}
function subtract2(out, a4, b) {
  out[0] = a4[0] - b[0];
  out[1] = a4[1] - b[1];
  out[2] = a4[2] - b[2];
  out[3] = a4[3] - b[3];
  out[4] = a4[4] - b[4];
  out[5] = a4[5] - b[5];
  out[6] = a4[6] - b[6];
  out[7] = a4[7] - b[7];
  out[8] = a4[8] - b[8];
  out[9] = a4[9] - b[9];
  out[10] = a4[10] - b[10];
  out[11] = a4[11] - b[11];
  out[12] = a4[12] - b[12];
  out[13] = a4[13] - b[13];
  out[14] = a4[14] - b[14];
  out[15] = a4[15] - b[15];
  return out;
}
function multiplyScalar2(out, a4, b) {
  out[0] = a4[0] * b;
  out[1] = a4[1] * b;
  out[2] = a4[2] * b;
  out[3] = a4[3] * b;
  out[4] = a4[4] * b;
  out[5] = a4[5] * b;
  out[6] = a4[6] * b;
  out[7] = a4[7] * b;
  out[8] = a4[8] * b;
  out[9] = a4[9] * b;
  out[10] = a4[10] * b;
  out[11] = a4[11] * b;
  out[12] = a4[12] * b;
  out[13] = a4[13] * b;
  out[14] = a4[14] * b;
  out[15] = a4[15] * b;
  return out;
}
function multiplyScalarAndAdd2(out, a4, b, scale10) {
  out[0] = a4[0] + b[0] * scale10;
  out[1] = a4[1] + b[1] * scale10;
  out[2] = a4[2] + b[2] * scale10;
  out[3] = a4[3] + b[3] * scale10;
  out[4] = a4[4] + b[4] * scale10;
  out[5] = a4[5] + b[5] * scale10;
  out[6] = a4[6] + b[6] * scale10;
  out[7] = a4[7] + b[7] * scale10;
  out[8] = a4[8] + b[8] * scale10;
  out[9] = a4[9] + b[9] * scale10;
  out[10] = a4[10] + b[10] * scale10;
  out[11] = a4[11] + b[11] * scale10;
  out[12] = a4[12] + b[12] * scale10;
  out[13] = a4[13] + b[13] * scale10;
  out[14] = a4[14] + b[14] * scale10;
  out[15] = a4[15] + b[15] * scale10;
  return out;
}
function exactEquals2(a4, b) {
  return a4[0] === b[0] && a4[1] === b[1] && a4[2] === b[2] && a4[3] === b[3] && a4[4] === b[4] && a4[5] === b[5] && a4[6] === b[6] && a4[7] === b[7] && a4[8] === b[8] && a4[9] === b[9] && a4[10] === b[10] && a4[11] === b[11] && a4[12] === b[12] && a4[13] === b[13] && a4[14] === b[14] && a4[15] === b[15];
}
function equals2(a4, b) {
  var a0 = a4[0], a1 = a4[1], a22 = a4[2], a32 = a4[3];
  var a42 = a4[4], a5 = a4[5], a6 = a4[6], a7 = a4[7];
  var a8 = a4[8], a9 = a4[9], a10 = a4[10], a11 = a4[11];
  var a12 = a4[12], a13 = a4[13], a14 = a4[14], a15 = a4[15];
  var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
  var b4 = b[4], b5 = b[5], b6 = b[6], b7 = b[7];
  var b8 = b[8], b9 = b[9], b10 = b[10], b11 = b[11];
  var b12 = b[12], b13 = b[13], b14 = b[14], b15 = b[15];
  return Math.abs(a0 - b0) <= EPSILON * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1, Math.abs(a1), Math.abs(b1)) && Math.abs(a22 - b2) <= EPSILON * Math.max(1, Math.abs(a22), Math.abs(b2)) && Math.abs(a32 - b3) <= EPSILON * Math.max(1, Math.abs(a32), Math.abs(b3)) && Math.abs(a42 - b4) <= EPSILON * Math.max(1, Math.abs(a42), Math.abs(b4)) && Math.abs(a5 - b5) <= EPSILON * Math.max(1, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= EPSILON * Math.max(1, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= EPSILON * Math.max(1, Math.abs(a7), Math.abs(b7)) && Math.abs(a8 - b8) <= EPSILON * Math.max(1, Math.abs(a8), Math.abs(b8)) && Math.abs(a9 - b9) <= EPSILON * Math.max(1, Math.abs(a9), Math.abs(b9)) && Math.abs(a10 - b10) <= EPSILON * Math.max(1, Math.abs(a10), Math.abs(b10)) && Math.abs(a11 - b11) <= EPSILON * Math.max(1, Math.abs(a11), Math.abs(b11)) && Math.abs(a12 - b12) <= EPSILON * Math.max(1, Math.abs(a12), Math.abs(b12)) && Math.abs(a13 - b13) <= EPSILON * Math.max(1, Math.abs(a13), Math.abs(b13)) && Math.abs(a14 - b14) <= EPSILON * Math.max(1, Math.abs(a14), Math.abs(b14)) && Math.abs(a15 - b15) <= EPSILON * Math.max(1, Math.abs(a15), Math.abs(b15));
}
var mul2 = multiply2;
var sub2 = subtract2;

// node_modules/gl-matrix/esm/quat.js
var quat_exports = {};
__export(quat_exports, {
  add: () => add5,
  calculateW: () => calculateW,
  clone: () => clone6,
  conjugate: () => conjugate,
  copy: () => copy5,
  create: () => create5,
  dot: () => dot3,
  equals: () => equals5,
  exactEquals: () => exactEquals5,
  exp: () => exp,
  fromEuler: () => fromEuler,
  fromMat3: () => fromMat3,
  fromValues: () => fromValues5,
  getAngle: () => getAngle,
  getAxisAngle: () => getAxisAngle,
  identity: () => identity3,
  invert: () => invert3,
  len: () => len3,
  length: () => length3,
  lerp: () => lerp3,
  ln: () => ln,
  mul: () => mul5,
  multiply: () => multiply5,
  normalize: () => normalize3,
  pow: () => pow,
  random: () => random3,
  rotateX: () => rotateX3,
  rotateY: () => rotateY3,
  rotateZ: () => rotateZ3,
  rotationTo: () => rotationTo,
  scale: () => scale5,
  set: () => set5,
  setAxes: () => setAxes,
  setAxisAngle: () => setAxisAngle,
  slerp: () => slerp,
  sqlerp: () => sqlerp,
  sqrLen: () => sqrLen3,
  squaredLength: () => squaredLength3,
  str: () => str5
});

// node_modules/gl-matrix/esm/vec3.js
var vec3_exports = {};
__export(vec3_exports, {
  add: () => add3,
  angle: () => angle,
  bezier: () => bezier,
  ceil: () => ceil,
  clone: () => clone4,
  copy: () => copy3,
  create: () => create3,
  cross: () => cross,
  dist: () => dist,
  distance: () => distance,
  div: () => div,
  divide: () => divide,
  dot: () => dot,
  equals: () => equals3,
  exactEquals: () => exactEquals3,
  floor: () => floor,
  forEach: () => forEach,
  fromValues: () => fromValues3,
  hermite: () => hermite,
  inverse: () => inverse,
  len: () => len,
  length: () => length,
  lerp: () => lerp,
  max: () => max,
  min: () => min,
  mul: () => mul3,
  multiply: () => multiply3,
  negate: () => negate,
  normalize: () => normalize,
  random: () => random,
  rotateX: () => rotateX2,
  rotateY: () => rotateY2,
  rotateZ: () => rotateZ2,
  round: () => round,
  scale: () => scale3,
  scaleAndAdd: () => scaleAndAdd,
  set: () => set3,
  sqrDist: () => sqrDist,
  sqrLen: () => sqrLen,
  squaredDistance: () => squaredDistance,
  squaredLength: () => squaredLength,
  str: () => str3,
  sub: () => sub3,
  subtract: () => subtract3,
  transformMat3: () => transformMat3,
  transformMat4: () => transformMat4,
  transformQuat: () => transformQuat,
  zero: () => zero
});
function create3() {
  var out = new ARRAY_TYPE(3);
  if (ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
  }
  return out;
}
function clone4(a4) {
  var out = new ARRAY_TYPE(3);
  out[0] = a4[0];
  out[1] = a4[1];
  out[2] = a4[2];
  return out;
}
function length(a4) {
  var x3 = a4[0];
  var y3 = a4[1];
  var z = a4[2];
  return Math.hypot(x3, y3, z);
}
function fromValues3(x3, y3, z) {
  var out = new ARRAY_TYPE(3);
  out[0] = x3;
  out[1] = y3;
  out[2] = z;
  return out;
}
function copy3(out, a4) {
  out[0] = a4[0];
  out[1] = a4[1];
  out[2] = a4[2];
  return out;
}
function set3(out, x3, y3, z) {
  out[0] = x3;
  out[1] = y3;
  out[2] = z;
  return out;
}
function add3(out, a4, b) {
  out[0] = a4[0] + b[0];
  out[1] = a4[1] + b[1];
  out[2] = a4[2] + b[2];
  return out;
}
function subtract3(out, a4, b) {
  out[0] = a4[0] - b[0];
  out[1] = a4[1] - b[1];
  out[2] = a4[2] - b[2];
  return out;
}
function multiply3(out, a4, b) {
  out[0] = a4[0] * b[0];
  out[1] = a4[1] * b[1];
  out[2] = a4[2] * b[2];
  return out;
}
function divide(out, a4, b) {
  out[0] = a4[0] / b[0];
  out[1] = a4[1] / b[1];
  out[2] = a4[2] / b[2];
  return out;
}
function ceil(out, a4) {
  out[0] = Math.ceil(a4[0]);
  out[1] = Math.ceil(a4[1]);
  out[2] = Math.ceil(a4[2]);
  return out;
}
function floor(out, a4) {
  out[0] = Math.floor(a4[0]);
  out[1] = Math.floor(a4[1]);
  out[2] = Math.floor(a4[2]);
  return out;
}
function min(out, a4, b) {
  out[0] = Math.min(a4[0], b[0]);
  out[1] = Math.min(a4[1], b[1]);
  out[2] = Math.min(a4[2], b[2]);
  return out;
}
function max(out, a4, b) {
  out[0] = Math.max(a4[0], b[0]);
  out[1] = Math.max(a4[1], b[1]);
  out[2] = Math.max(a4[2], b[2]);
  return out;
}
function round(out, a4) {
  out[0] = Math.round(a4[0]);
  out[1] = Math.round(a4[1]);
  out[2] = Math.round(a4[2]);
  return out;
}
function scale3(out, a4, b) {
  out[0] = a4[0] * b;
  out[1] = a4[1] * b;
  out[2] = a4[2] * b;
  return out;
}
function scaleAndAdd(out, a4, b, scale10) {
  out[0] = a4[0] + b[0] * scale10;
  out[1] = a4[1] + b[1] * scale10;
  out[2] = a4[2] + b[2] * scale10;
  return out;
}
function distance(a4, b) {
  var x3 = b[0] - a4[0];
  var y3 = b[1] - a4[1];
  var z = b[2] - a4[2];
  return Math.hypot(x3, y3, z);
}
function squaredDistance(a4, b) {
  var x3 = b[0] - a4[0];
  var y3 = b[1] - a4[1];
  var z = b[2] - a4[2];
  return x3 * x3 + y3 * y3 + z * z;
}
function squaredLength(a4) {
  var x3 = a4[0];
  var y3 = a4[1];
  var z = a4[2];
  return x3 * x3 + y3 * y3 + z * z;
}
function negate(out, a4) {
  out[0] = -a4[0];
  out[1] = -a4[1];
  out[2] = -a4[2];
  return out;
}
function inverse(out, a4) {
  out[0] = 1 / a4[0];
  out[1] = 1 / a4[1];
  out[2] = 1 / a4[2];
  return out;
}
function normalize(out, a4) {
  var x3 = a4[0];
  var y3 = a4[1];
  var z = a4[2];
  var len5 = x3 * x3 + y3 * y3 + z * z;
  if (len5 > 0) {
    len5 = 1 / Math.sqrt(len5);
  }
  out[0] = a4[0] * len5;
  out[1] = a4[1] * len5;
  out[2] = a4[2] * len5;
  return out;
}
function dot(a4, b) {
  return a4[0] * b[0] + a4[1] * b[1] + a4[2] * b[2];
}
function cross(out, a4, b) {
  var ax = a4[0], ay = a4[1], az = a4[2];
  var bx = b[0], by = b[1], bz = b[2];
  out[0] = ay * bz - az * by;
  out[1] = az * bx - ax * bz;
  out[2] = ax * by - ay * bx;
  return out;
}
function lerp(out, a4, b, t) {
  var ax = a4[0];
  var ay = a4[1];
  var az = a4[2];
  out[0] = ax + t * (b[0] - ax);
  out[1] = ay + t * (b[1] - ay);
  out[2] = az + t * (b[2] - az);
  return out;
}
function hermite(out, a4, b, c5, d2, t) {
  var factorTimes2 = t * t;
  var factor1 = factorTimes2 * (2 * t - 3) + 1;
  var factor2 = factorTimes2 * (t - 2) + t;
  var factor3 = factorTimes2 * (t - 1);
  var factor4 = factorTimes2 * (3 - 2 * t);
  out[0] = a4[0] * factor1 + b[0] * factor2 + c5[0] * factor3 + d2[0] * factor4;
  out[1] = a4[1] * factor1 + b[1] * factor2 + c5[1] * factor3 + d2[1] * factor4;
  out[2] = a4[2] * factor1 + b[2] * factor2 + c5[2] * factor3 + d2[2] * factor4;
  return out;
}
function bezier(out, a4, b, c5, d2, t) {
  var inverseFactor = 1 - t;
  var inverseFactorTimesTwo = inverseFactor * inverseFactor;
  var factorTimes2 = t * t;
  var factor1 = inverseFactorTimesTwo * inverseFactor;
  var factor2 = 3 * t * inverseFactorTimesTwo;
  var factor3 = 3 * factorTimes2 * inverseFactor;
  var factor4 = factorTimes2 * t;
  out[0] = a4[0] * factor1 + b[0] * factor2 + c5[0] * factor3 + d2[0] * factor4;
  out[1] = a4[1] * factor1 + b[1] * factor2 + c5[1] * factor3 + d2[1] * factor4;
  out[2] = a4[2] * factor1 + b[2] * factor2 + c5[2] * factor3 + d2[2] * factor4;
  return out;
}
function random(out, scale10) {
  scale10 = scale10 || 1;
  var r = RANDOM() * 2 * Math.PI;
  var z = RANDOM() * 2 - 1;
  var zScale = Math.sqrt(1 - z * z) * scale10;
  out[0] = Math.cos(r) * zScale;
  out[1] = Math.sin(r) * zScale;
  out[2] = z * scale10;
  return out;
}
function transformMat4(out, a4, m3) {
  var x3 = a4[0], y3 = a4[1], z = a4[2];
  var w = m3[3] * x3 + m3[7] * y3 + m3[11] * z + m3[15];
  w = w || 1;
  out[0] = (m3[0] * x3 + m3[4] * y3 + m3[8] * z + m3[12]) / w;
  out[1] = (m3[1] * x3 + m3[5] * y3 + m3[9] * z + m3[13]) / w;
  out[2] = (m3[2] * x3 + m3[6] * y3 + m3[10] * z + m3[14]) / w;
  return out;
}
function transformMat3(out, a4, m3) {
  var x3 = a4[0], y3 = a4[1], z = a4[2];
  out[0] = x3 * m3[0] + y3 * m3[3] + z * m3[6];
  out[1] = x3 * m3[1] + y3 * m3[4] + z * m3[7];
  out[2] = x3 * m3[2] + y3 * m3[5] + z * m3[8];
  return out;
}
function transformQuat(out, a4, q) {
  var qx = q[0], qy = q[1], qz = q[2], qw = q[3];
  var x3 = a4[0], y3 = a4[1], z = a4[2];
  var uvx = qy * z - qz * y3, uvy = qz * x3 - qx * z, uvz = qx * y3 - qy * x3;
  var uuvx = qy * uvz - qz * uvy, uuvy = qz * uvx - qx * uvz, uuvz = qx * uvy - qy * uvx;
  var w2 = qw * 2;
  uvx *= w2;
  uvy *= w2;
  uvz *= w2;
  uuvx *= 2;
  uuvy *= 2;
  uuvz *= 2;
  out[0] = x3 + uvx + uuvx;
  out[1] = y3 + uvy + uuvy;
  out[2] = z + uvz + uuvz;
  return out;
}
function rotateX2(out, a4, b, rad) {
  var p2 = [], r = [];
  p2[0] = a4[0] - b[0];
  p2[1] = a4[1] - b[1];
  p2[2] = a4[2] - b[2];
  r[0] = p2[0];
  r[1] = p2[1] * Math.cos(rad) - p2[2] * Math.sin(rad);
  r[2] = p2[1] * Math.sin(rad) + p2[2] * Math.cos(rad);
  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];
  return out;
}
function rotateY2(out, a4, b, rad) {
  var p2 = [], r = [];
  p2[0] = a4[0] - b[0];
  p2[1] = a4[1] - b[1];
  p2[2] = a4[2] - b[2];
  r[0] = p2[2] * Math.sin(rad) + p2[0] * Math.cos(rad);
  r[1] = p2[1];
  r[2] = p2[2] * Math.cos(rad) - p2[0] * Math.sin(rad);
  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];
  return out;
}
function rotateZ2(out, a4, b, rad) {
  var p2 = [], r = [];
  p2[0] = a4[0] - b[0];
  p2[1] = a4[1] - b[1];
  p2[2] = a4[2] - b[2];
  r[0] = p2[0] * Math.cos(rad) - p2[1] * Math.sin(rad);
  r[1] = p2[0] * Math.sin(rad) + p2[1] * Math.cos(rad);
  r[2] = p2[2];
  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];
  return out;
}
function angle(a4, b) {
  var ax = a4[0], ay = a4[1], az = a4[2], bx = b[0], by = b[1], bz = b[2], mag1 = Math.sqrt(ax * ax + ay * ay + az * az), mag2 = Math.sqrt(bx * bx + by * by + bz * bz), mag = mag1 * mag2, cosine = mag && dot(a4, b) / mag;
  return Math.acos(Math.min(Math.max(cosine, -1), 1));
}
function zero(out) {
  out[0] = 0;
  out[1] = 0;
  out[2] = 0;
  return out;
}
function str3(a4) {
  return "vec3(" + a4[0] + ", " + a4[1] + ", " + a4[2] + ")";
}
function exactEquals3(a4, b) {
  return a4[0] === b[0] && a4[1] === b[1] && a4[2] === b[2];
}
function equals3(a4, b) {
  var a0 = a4[0], a1 = a4[1], a22 = a4[2];
  var b0 = b[0], b1 = b[1], b2 = b[2];
  return Math.abs(a0 - b0) <= EPSILON * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1, Math.abs(a1), Math.abs(b1)) && Math.abs(a22 - b2) <= EPSILON * Math.max(1, Math.abs(a22), Math.abs(b2));
}
var sub3 = subtract3;
var mul3 = multiply3;
var div = divide;
var dist = distance;
var sqrDist = squaredDistance;
var len = length;
var sqrLen = squaredLength;
var forEach = function() {
  var vec = create3();
  return function(a4, stride, offset2, count4, fn, arg) {
    var i, l;
    if (!stride) {
      stride = 3;
    }
    if (!offset2) {
      offset2 = 0;
    }
    if (count4) {
      l = Math.min(count4 * stride + offset2, a4.length);
    } else {
      l = a4.length;
    }
    for (i = offset2; i < l; i += stride) {
      vec[0] = a4[i];
      vec[1] = a4[i + 1];
      vec[2] = a4[i + 2];
      fn(vec, vec, arg);
      a4[i] = vec[0];
      a4[i + 1] = vec[1];
      a4[i + 2] = vec[2];
    }
    return a4;
  };
}();

// node_modules/gl-matrix/esm/vec4.js
var vec4_exports = {};
__export(vec4_exports, {
  add: () => add4,
  ceil: () => ceil2,
  clone: () => clone5,
  copy: () => copy4,
  create: () => create4,
  cross: () => cross2,
  dist: () => dist2,
  distance: () => distance2,
  div: () => div2,
  divide: () => divide2,
  dot: () => dot2,
  equals: () => equals4,
  exactEquals: () => exactEquals4,
  floor: () => floor2,
  forEach: () => forEach2,
  fromValues: () => fromValues4,
  inverse: () => inverse2,
  len: () => len2,
  length: () => length2,
  lerp: () => lerp2,
  max: () => max2,
  min: () => min2,
  mul: () => mul4,
  multiply: () => multiply4,
  negate: () => negate2,
  normalize: () => normalize2,
  random: () => random2,
  round: () => round2,
  scale: () => scale4,
  scaleAndAdd: () => scaleAndAdd2,
  set: () => set4,
  sqrDist: () => sqrDist2,
  sqrLen: () => sqrLen2,
  squaredDistance: () => squaredDistance2,
  squaredLength: () => squaredLength2,
  str: () => str4,
  sub: () => sub4,
  subtract: () => subtract4,
  transformMat4: () => transformMat42,
  transformQuat: () => transformQuat2,
  zero: () => zero2
});
function create4() {
  var out = new ARRAY_TYPE(4);
  if (ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
  }
  return out;
}
function clone5(a4) {
  var out = new ARRAY_TYPE(4);
  out[0] = a4[0];
  out[1] = a4[1];
  out[2] = a4[2];
  out[3] = a4[3];
  return out;
}
function fromValues4(x3, y3, z, w) {
  var out = new ARRAY_TYPE(4);
  out[0] = x3;
  out[1] = y3;
  out[2] = z;
  out[3] = w;
  return out;
}
function copy4(out, a4) {
  out[0] = a4[0];
  out[1] = a4[1];
  out[2] = a4[2];
  out[3] = a4[3];
  return out;
}
function set4(out, x3, y3, z, w) {
  out[0] = x3;
  out[1] = y3;
  out[2] = z;
  out[3] = w;
  return out;
}
function add4(out, a4, b) {
  out[0] = a4[0] + b[0];
  out[1] = a4[1] + b[1];
  out[2] = a4[2] + b[2];
  out[3] = a4[3] + b[3];
  return out;
}
function subtract4(out, a4, b) {
  out[0] = a4[0] - b[0];
  out[1] = a4[1] - b[1];
  out[2] = a4[2] - b[2];
  out[3] = a4[3] - b[3];
  return out;
}
function multiply4(out, a4, b) {
  out[0] = a4[0] * b[0];
  out[1] = a4[1] * b[1];
  out[2] = a4[2] * b[2];
  out[3] = a4[3] * b[3];
  return out;
}
function divide2(out, a4, b) {
  out[0] = a4[0] / b[0];
  out[1] = a4[1] / b[1];
  out[2] = a4[2] / b[2];
  out[3] = a4[3] / b[3];
  return out;
}
function ceil2(out, a4) {
  out[0] = Math.ceil(a4[0]);
  out[1] = Math.ceil(a4[1]);
  out[2] = Math.ceil(a4[2]);
  out[3] = Math.ceil(a4[3]);
  return out;
}
function floor2(out, a4) {
  out[0] = Math.floor(a4[0]);
  out[1] = Math.floor(a4[1]);
  out[2] = Math.floor(a4[2]);
  out[3] = Math.floor(a4[3]);
  return out;
}
function min2(out, a4, b) {
  out[0] = Math.min(a4[0], b[0]);
  out[1] = Math.min(a4[1], b[1]);
  out[2] = Math.min(a4[2], b[2]);
  out[3] = Math.min(a4[3], b[3]);
  return out;
}
function max2(out, a4, b) {
  out[0] = Math.max(a4[0], b[0]);
  out[1] = Math.max(a4[1], b[1]);
  out[2] = Math.max(a4[2], b[2]);
  out[3] = Math.max(a4[3], b[3]);
  return out;
}
function round2(out, a4) {
  out[0] = Math.round(a4[0]);
  out[1] = Math.round(a4[1]);
  out[2] = Math.round(a4[2]);
  out[3] = Math.round(a4[3]);
  return out;
}
function scale4(out, a4, b) {
  out[0] = a4[0] * b;
  out[1] = a4[1] * b;
  out[2] = a4[2] * b;
  out[3] = a4[3] * b;
  return out;
}
function scaleAndAdd2(out, a4, b, scale10) {
  out[0] = a4[0] + b[0] * scale10;
  out[1] = a4[1] + b[1] * scale10;
  out[2] = a4[2] + b[2] * scale10;
  out[3] = a4[3] + b[3] * scale10;
  return out;
}
function distance2(a4, b) {
  var x3 = b[0] - a4[0];
  var y3 = b[1] - a4[1];
  var z = b[2] - a4[2];
  var w = b[3] - a4[3];
  return Math.hypot(x3, y3, z, w);
}
function squaredDistance2(a4, b) {
  var x3 = b[0] - a4[0];
  var y3 = b[1] - a4[1];
  var z = b[2] - a4[2];
  var w = b[3] - a4[3];
  return x3 * x3 + y3 * y3 + z * z + w * w;
}
function length2(a4) {
  var x3 = a4[0];
  var y3 = a4[1];
  var z = a4[2];
  var w = a4[3];
  return Math.hypot(x3, y3, z, w);
}
function squaredLength2(a4) {
  var x3 = a4[0];
  var y3 = a4[1];
  var z = a4[2];
  var w = a4[3];
  return x3 * x3 + y3 * y3 + z * z + w * w;
}
function negate2(out, a4) {
  out[0] = -a4[0];
  out[1] = -a4[1];
  out[2] = -a4[2];
  out[3] = -a4[3];
  return out;
}
function inverse2(out, a4) {
  out[0] = 1 / a4[0];
  out[1] = 1 / a4[1];
  out[2] = 1 / a4[2];
  out[3] = 1 / a4[3];
  return out;
}
function normalize2(out, a4) {
  var x3 = a4[0];
  var y3 = a4[1];
  var z = a4[2];
  var w = a4[3];
  var len5 = x3 * x3 + y3 * y3 + z * z + w * w;
  if (len5 > 0) {
    len5 = 1 / Math.sqrt(len5);
  }
  out[0] = x3 * len5;
  out[1] = y3 * len5;
  out[2] = z * len5;
  out[3] = w * len5;
  return out;
}
function dot2(a4, b) {
  return a4[0] * b[0] + a4[1] * b[1] + a4[2] * b[2] + a4[3] * b[3];
}
function cross2(out, u, v, w) {
  var A5 = v[0] * w[1] - v[1] * w[0], B3 = v[0] * w[2] - v[2] * w[0], C3 = v[0] * w[3] - v[3] * w[0], D2 = v[1] * w[2] - v[2] * w[1], E2 = v[1] * w[3] - v[3] * w[1], F = v[2] * w[3] - v[3] * w[2];
  var G = u[0];
  var H = u[1];
  var I = u[2];
  var J = u[3];
  out[0] = H * F - I * E2 + J * D2;
  out[1] = -(G * F) + I * C3 - J * B3;
  out[2] = G * E2 - H * C3 + J * A5;
  out[3] = -(G * D2) + H * B3 - I * A5;
  return out;
}
function lerp2(out, a4, b, t) {
  var ax = a4[0];
  var ay = a4[1];
  var az = a4[2];
  var aw = a4[3];
  out[0] = ax + t * (b[0] - ax);
  out[1] = ay + t * (b[1] - ay);
  out[2] = az + t * (b[2] - az);
  out[3] = aw + t * (b[3] - aw);
  return out;
}
function random2(out, scale10) {
  scale10 = scale10 || 1;
  var v1, v2, v3, v4;
  var s1, s2;
  do {
    v1 = RANDOM() * 2 - 1;
    v2 = RANDOM() * 2 - 1;
    s1 = v1 * v1 + v2 * v2;
  } while (s1 >= 1);
  do {
    v3 = RANDOM() * 2 - 1;
    v4 = RANDOM() * 2 - 1;
    s2 = v3 * v3 + v4 * v4;
  } while (s2 >= 1);
  var d2 = Math.sqrt((1 - s1) / s2);
  out[0] = scale10 * v1;
  out[1] = scale10 * v2;
  out[2] = scale10 * v3 * d2;
  out[3] = scale10 * v4 * d2;
  return out;
}
function transformMat42(out, a4, m3) {
  var x3 = a4[0], y3 = a4[1], z = a4[2], w = a4[3];
  out[0] = m3[0] * x3 + m3[4] * y3 + m3[8] * z + m3[12] * w;
  out[1] = m3[1] * x3 + m3[5] * y3 + m3[9] * z + m3[13] * w;
  out[2] = m3[2] * x3 + m3[6] * y3 + m3[10] * z + m3[14] * w;
  out[3] = m3[3] * x3 + m3[7] * y3 + m3[11] * z + m3[15] * w;
  return out;
}
function transformQuat2(out, a4, q) {
  var x3 = a4[0], y3 = a4[1], z = a4[2];
  var qx = q[0], qy = q[1], qz = q[2], qw = q[3];
  var ix = qw * x3 + qy * z - qz * y3;
  var iy = qw * y3 + qz * x3 - qx * z;
  var iz = qw * z + qx * y3 - qy * x3;
  var iw = -qx * x3 - qy * y3 - qz * z;
  out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;
  out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;
  out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;
  out[3] = a4[3];
  return out;
}
function zero2(out) {
  out[0] = 0;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  return out;
}
function str4(a4) {
  return "vec4(" + a4[0] + ", " + a4[1] + ", " + a4[2] + ", " + a4[3] + ")";
}
function exactEquals4(a4, b) {
  return a4[0] === b[0] && a4[1] === b[1] && a4[2] === b[2] && a4[3] === b[3];
}
function equals4(a4, b) {
  var a0 = a4[0], a1 = a4[1], a22 = a4[2], a32 = a4[3];
  var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
  return Math.abs(a0 - b0) <= EPSILON * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1, Math.abs(a1), Math.abs(b1)) && Math.abs(a22 - b2) <= EPSILON * Math.max(1, Math.abs(a22), Math.abs(b2)) && Math.abs(a32 - b3) <= EPSILON * Math.max(1, Math.abs(a32), Math.abs(b3));
}
var sub4 = subtract4;
var mul4 = multiply4;
var div2 = divide2;
var dist2 = distance2;
var sqrDist2 = squaredDistance2;
var len2 = length2;
var sqrLen2 = squaredLength2;
var forEach2 = function() {
  var vec = create4();
  return function(a4, stride, offset2, count4, fn, arg) {
    var i, l;
    if (!stride) {
      stride = 4;
    }
    if (!offset2) {
      offset2 = 0;
    }
    if (count4) {
      l = Math.min(count4 * stride + offset2, a4.length);
    } else {
      l = a4.length;
    }
    for (i = offset2; i < l; i += stride) {
      vec[0] = a4[i];
      vec[1] = a4[i + 1];
      vec[2] = a4[i + 2];
      vec[3] = a4[i + 3];
      fn(vec, vec, arg);
      a4[i] = vec[0];
      a4[i + 1] = vec[1];
      a4[i + 2] = vec[2];
      a4[i + 3] = vec[3];
    }
    return a4;
  };
}();

// node_modules/gl-matrix/esm/quat.js
function create5() {
  var out = new ARRAY_TYPE(4);
  if (ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
  }
  out[3] = 1;
  return out;
}
function identity3(out) {
  out[0] = 0;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  return out;
}
function setAxisAngle(out, axis, rad) {
  rad = rad * 0.5;
  var s2 = Math.sin(rad);
  out[0] = s2 * axis[0];
  out[1] = s2 * axis[1];
  out[2] = s2 * axis[2];
  out[3] = Math.cos(rad);
  return out;
}
function getAxisAngle(out_axis, q) {
  var rad = Math.acos(q[3]) * 2;
  var s2 = Math.sin(rad / 2);
  if (s2 > EPSILON) {
    out_axis[0] = q[0] / s2;
    out_axis[1] = q[1] / s2;
    out_axis[2] = q[2] / s2;
  } else {
    out_axis[0] = 1;
    out_axis[1] = 0;
    out_axis[2] = 0;
  }
  return rad;
}
function getAngle(a4, b) {
  var dotproduct = dot3(a4, b);
  return Math.acos(2 * dotproduct * dotproduct - 1);
}
function multiply5(out, a4, b) {
  var ax = a4[0], ay = a4[1], az = a4[2], aw = a4[3];
  var bx = b[0], by = b[1], bz = b[2], bw = b[3];
  out[0] = ax * bw + aw * bx + ay * bz - az * by;
  out[1] = ay * bw + aw * by + az * bx - ax * bz;
  out[2] = az * bw + aw * bz + ax * by - ay * bx;
  out[3] = aw * bw - ax * bx - ay * by - az * bz;
  return out;
}
function rotateX3(out, a4, rad) {
  rad *= 0.5;
  var ax = a4[0], ay = a4[1], az = a4[2], aw = a4[3];
  var bx = Math.sin(rad), bw = Math.cos(rad);
  out[0] = ax * bw + aw * bx;
  out[1] = ay * bw + az * bx;
  out[2] = az * bw - ay * bx;
  out[3] = aw * bw - ax * bx;
  return out;
}
function rotateY3(out, a4, rad) {
  rad *= 0.5;
  var ax = a4[0], ay = a4[1], az = a4[2], aw = a4[3];
  var by = Math.sin(rad), bw = Math.cos(rad);
  out[0] = ax * bw - az * by;
  out[1] = ay * bw + aw * by;
  out[2] = az * bw + ax * by;
  out[3] = aw * bw - ay * by;
  return out;
}
function rotateZ3(out, a4, rad) {
  rad *= 0.5;
  var ax = a4[0], ay = a4[1], az = a4[2], aw = a4[3];
  var bz = Math.sin(rad), bw = Math.cos(rad);
  out[0] = ax * bw + ay * bz;
  out[1] = ay * bw - ax * bz;
  out[2] = az * bw + aw * bz;
  out[3] = aw * bw - az * bz;
  return out;
}
function calculateW(out, a4) {
  var x3 = a4[0], y3 = a4[1], z = a4[2];
  out[0] = x3;
  out[1] = y3;
  out[2] = z;
  out[3] = Math.sqrt(Math.abs(1 - x3 * x3 - y3 * y3 - z * z));
  return out;
}
function exp(out, a4) {
  var x3 = a4[0], y3 = a4[1], z = a4[2], w = a4[3];
  var r = Math.sqrt(x3 * x3 + y3 * y3 + z * z);
  var et = Math.exp(w);
  var s2 = r > 0 ? et * Math.sin(r) / r : 0;
  out[0] = x3 * s2;
  out[1] = y3 * s2;
  out[2] = z * s2;
  out[3] = et * Math.cos(r);
  return out;
}
function ln(out, a4) {
  var x3 = a4[0], y3 = a4[1], z = a4[2], w = a4[3];
  var r = Math.sqrt(x3 * x3 + y3 * y3 + z * z);
  var t = r > 0 ? Math.atan2(r, w) / r : 0;
  out[0] = x3 * t;
  out[1] = y3 * t;
  out[2] = z * t;
  out[3] = 0.5 * Math.log(x3 * x3 + y3 * y3 + z * z + w * w);
  return out;
}
function pow(out, a4, b) {
  ln(out, a4);
  scale5(out, out, b);
  exp(out, out);
  return out;
}
function slerp(out, a4, b, t) {
  var ax = a4[0], ay = a4[1], az = a4[2], aw = a4[3];
  var bx = b[0], by = b[1], bz = b[2], bw = b[3];
  var omega, cosom, sinom, scale0, scale1;
  cosom = ax * bx + ay * by + az * bz + aw * bw;
  if (cosom < 0) {
    cosom = -cosom;
    bx = -bx;
    by = -by;
    bz = -bz;
    bw = -bw;
  }
  if (1 - cosom > EPSILON) {
    omega = Math.acos(cosom);
    sinom = Math.sin(omega);
    scale0 = Math.sin((1 - t) * omega) / sinom;
    scale1 = Math.sin(t * omega) / sinom;
  } else {
    scale0 = 1 - t;
    scale1 = t;
  }
  out[0] = scale0 * ax + scale1 * bx;
  out[1] = scale0 * ay + scale1 * by;
  out[2] = scale0 * az + scale1 * bz;
  out[3] = scale0 * aw + scale1 * bw;
  return out;
}
function random3(out) {
  var u1 = RANDOM();
  var u2 = RANDOM();
  var u3 = RANDOM();
  var sqrt1MinusU1 = Math.sqrt(1 - u1);
  var sqrtU1 = Math.sqrt(u1);
  out[0] = sqrt1MinusU1 * Math.sin(2 * Math.PI * u2);
  out[1] = sqrt1MinusU1 * Math.cos(2 * Math.PI * u2);
  out[2] = sqrtU1 * Math.sin(2 * Math.PI * u3);
  out[3] = sqrtU1 * Math.cos(2 * Math.PI * u3);
  return out;
}
function invert3(out, a4) {
  var a0 = a4[0], a1 = a4[1], a22 = a4[2], a32 = a4[3];
  var dot9 = a0 * a0 + a1 * a1 + a22 * a22 + a32 * a32;
  var invDot = dot9 ? 1 / dot9 : 0;
  out[0] = -a0 * invDot;
  out[1] = -a1 * invDot;
  out[2] = -a22 * invDot;
  out[3] = a32 * invDot;
  return out;
}
function conjugate(out, a4) {
  out[0] = -a4[0];
  out[1] = -a4[1];
  out[2] = -a4[2];
  out[3] = a4[3];
  return out;
}
function fromMat3(out, m3) {
  var fTrace = m3[0] + m3[4] + m3[8];
  var fRoot;
  if (fTrace > 0) {
    fRoot = Math.sqrt(fTrace + 1);
    out[3] = 0.5 * fRoot;
    fRoot = 0.5 / fRoot;
    out[0] = (m3[5] - m3[7]) * fRoot;
    out[1] = (m3[6] - m3[2]) * fRoot;
    out[2] = (m3[1] - m3[3]) * fRoot;
  } else {
    var i = 0;
    if (m3[4] > m3[0])
      i = 1;
    if (m3[8] > m3[i * 3 + i])
      i = 2;
    var j = (i + 1) % 3;
    var k2 = (i + 2) % 3;
    fRoot = Math.sqrt(m3[i * 3 + i] - m3[j * 3 + j] - m3[k2 * 3 + k2] + 1);
    out[i] = 0.5 * fRoot;
    fRoot = 0.5 / fRoot;
    out[3] = (m3[j * 3 + k2] - m3[k2 * 3 + j]) * fRoot;
    out[j] = (m3[j * 3 + i] + m3[i * 3 + j]) * fRoot;
    out[k2] = (m3[k2 * 3 + i] + m3[i * 3 + k2]) * fRoot;
  }
  return out;
}
function fromEuler(out, x3, y3, z) {
  var halfToRad = 0.5 * Math.PI / 180;
  x3 *= halfToRad;
  y3 *= halfToRad;
  z *= halfToRad;
  var sx = Math.sin(x3);
  var cx = Math.cos(x3);
  var sy = Math.sin(y3);
  var cy = Math.cos(y3);
  var sz = Math.sin(z);
  var cz = Math.cos(z);
  out[0] = sx * cy * cz - cx * sy * sz;
  out[1] = cx * sy * cz + sx * cy * sz;
  out[2] = cx * cy * sz - sx * sy * cz;
  out[3] = cx * cy * cz + sx * sy * sz;
  return out;
}
function str5(a4) {
  return "quat(" + a4[0] + ", " + a4[1] + ", " + a4[2] + ", " + a4[3] + ")";
}
var clone6 = clone5;
var fromValues5 = fromValues4;
var copy5 = copy4;
var set5 = set4;
var add5 = add4;
var mul5 = multiply5;
var scale5 = scale4;
var dot3 = dot2;
var lerp3 = lerp2;
var length3 = length2;
var len3 = length3;
var squaredLength3 = squaredLength2;
var sqrLen3 = squaredLength3;
var normalize3 = normalize2;
var exactEquals5 = exactEquals4;
var equals5 = equals4;
var rotationTo = function() {
  var tmpvec3 = create3();
  var xUnitVec3 = fromValues3(1, 0, 0);
  var yUnitVec3 = fromValues3(0, 1, 0);
  return function(out, a4, b) {
    var dot9 = dot(a4, b);
    if (dot9 < -0.999999) {
      cross(tmpvec3, xUnitVec3, a4);
      if (len(tmpvec3) < 1e-6)
        cross(tmpvec3, yUnitVec3, a4);
      normalize(tmpvec3, tmpvec3);
      setAxisAngle(out, tmpvec3, Math.PI);
      return out;
    } else if (dot9 > 0.999999) {
      out[0] = 0;
      out[1] = 0;
      out[2] = 0;
      out[3] = 1;
      return out;
    } else {
      cross(tmpvec3, a4, b);
      out[0] = tmpvec3[0];
      out[1] = tmpvec3[1];
      out[2] = tmpvec3[2];
      out[3] = 1 + dot9;
      return normalize3(out, out);
    }
  };
}();
var sqlerp = function() {
  var temp1 = create5();
  var temp2 = create5();
  return function(out, a4, b, c5, d2, t) {
    slerp(temp1, a4, d2, t);
    slerp(temp2, b, c5, t);
    slerp(out, temp1, temp2, 2 * t * (1 - t));
    return out;
  };
}();
var setAxes = function() {
  var matr = create();
  return function(out, view, right2, up) {
    matr[0] = right2[0];
    matr[3] = right2[1];
    matr[6] = right2[2];
    matr[1] = up[0];
    matr[4] = up[1];
    matr[7] = up[2];
    matr[2] = -view[0];
    matr[5] = -view[1];
    matr[8] = -view[2];
    return normalize3(out, fromMat3(out, matr));
  };
}();

// node_modules/gl-matrix/esm/vec2.js
var vec2_exports = {};
__export(vec2_exports, {
  add: () => add6,
  angle: () => angle2,
  ceil: () => ceil3,
  clone: () => clone7,
  copy: () => copy6,
  create: () => create6,
  cross: () => cross3,
  dist: () => dist3,
  distance: () => distance3,
  div: () => div3,
  divide: () => divide3,
  dot: () => dot4,
  equals: () => equals6,
  exactEquals: () => exactEquals6,
  floor: () => floor3,
  forEach: () => forEach3,
  fromValues: () => fromValues6,
  inverse: () => inverse3,
  len: () => len4,
  length: () => length4,
  lerp: () => lerp4,
  max: () => max3,
  min: () => min3,
  mul: () => mul6,
  multiply: () => multiply6,
  negate: () => negate3,
  normalize: () => normalize4,
  random: () => random4,
  rotate: () => rotate3,
  round: () => round3,
  scale: () => scale6,
  scaleAndAdd: () => scaleAndAdd3,
  set: () => set6,
  sqrDist: () => sqrDist3,
  sqrLen: () => sqrLen4,
  squaredDistance: () => squaredDistance3,
  squaredLength: () => squaredLength4,
  str: () => str6,
  sub: () => sub5,
  subtract: () => subtract5,
  transformMat2: () => transformMat2,
  transformMat2d: () => transformMat2d,
  transformMat3: () => transformMat32,
  transformMat4: () => transformMat43,
  zero: () => zero3
});
function create6() {
  var out = new ARRAY_TYPE(2);
  if (ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
  }
  return out;
}
function clone7(a4) {
  var out = new ARRAY_TYPE(2);
  out[0] = a4[0];
  out[1] = a4[1];
  return out;
}
function fromValues6(x3, y3) {
  var out = new ARRAY_TYPE(2);
  out[0] = x3;
  out[1] = y3;
  return out;
}
function copy6(out, a4) {
  out[0] = a4[0];
  out[1] = a4[1];
  return out;
}
function set6(out, x3, y3) {
  out[0] = x3;
  out[1] = y3;
  return out;
}
function add6(out, a4, b) {
  out[0] = a4[0] + b[0];
  out[1] = a4[1] + b[1];
  return out;
}
function subtract5(out, a4, b) {
  out[0] = a4[0] - b[0];
  out[1] = a4[1] - b[1];
  return out;
}
function multiply6(out, a4, b) {
  out[0] = a4[0] * b[0];
  out[1] = a4[1] * b[1];
  return out;
}
function divide3(out, a4, b) {
  out[0] = a4[0] / b[0];
  out[1] = a4[1] / b[1];
  return out;
}
function ceil3(out, a4) {
  out[0] = Math.ceil(a4[0]);
  out[1] = Math.ceil(a4[1]);
  return out;
}
function floor3(out, a4) {
  out[0] = Math.floor(a4[0]);
  out[1] = Math.floor(a4[1]);
  return out;
}
function min3(out, a4, b) {
  out[0] = Math.min(a4[0], b[0]);
  out[1] = Math.min(a4[1], b[1]);
  return out;
}
function max3(out, a4, b) {
  out[0] = Math.max(a4[0], b[0]);
  out[1] = Math.max(a4[1], b[1]);
  return out;
}
function round3(out, a4) {
  out[0] = Math.round(a4[0]);
  out[1] = Math.round(a4[1]);
  return out;
}
function scale6(out, a4, b) {
  out[0] = a4[0] * b;
  out[1] = a4[1] * b;
  return out;
}
function scaleAndAdd3(out, a4, b, scale10) {
  out[0] = a4[0] + b[0] * scale10;
  out[1] = a4[1] + b[1] * scale10;
  return out;
}
function distance3(a4, b) {
  var x3 = b[0] - a4[0], y3 = b[1] - a4[1];
  return Math.hypot(x3, y3);
}
function squaredDistance3(a4, b) {
  var x3 = b[0] - a4[0], y3 = b[1] - a4[1];
  return x3 * x3 + y3 * y3;
}
function length4(a4) {
  var x3 = a4[0], y3 = a4[1];
  return Math.hypot(x3, y3);
}
function squaredLength4(a4) {
  var x3 = a4[0], y3 = a4[1];
  return x3 * x3 + y3 * y3;
}
function negate3(out, a4) {
  out[0] = -a4[0];
  out[1] = -a4[1];
  return out;
}
function inverse3(out, a4) {
  out[0] = 1 / a4[0];
  out[1] = 1 / a4[1];
  return out;
}
function normalize4(out, a4) {
  var x3 = a4[0], y3 = a4[1];
  var len5 = x3 * x3 + y3 * y3;
  if (len5 > 0) {
    len5 = 1 / Math.sqrt(len5);
  }
  out[0] = a4[0] * len5;
  out[1] = a4[1] * len5;
  return out;
}
function dot4(a4, b) {
  return a4[0] * b[0] + a4[1] * b[1];
}
function cross3(out, a4, b) {
  var z = a4[0] * b[1] - a4[1] * b[0];
  out[0] = out[1] = 0;
  out[2] = z;
  return out;
}
function lerp4(out, a4, b, t) {
  var ax = a4[0], ay = a4[1];
  out[0] = ax + t * (b[0] - ax);
  out[1] = ay + t * (b[1] - ay);
  return out;
}
function random4(out, scale10) {
  scale10 = scale10 || 1;
  var r = RANDOM() * 2 * Math.PI;
  out[0] = Math.cos(r) * scale10;
  out[1] = Math.sin(r) * scale10;
  return out;
}
function transformMat2(out, a4, m3) {
  var x3 = a4[0], y3 = a4[1];
  out[0] = m3[0] * x3 + m3[2] * y3;
  out[1] = m3[1] * x3 + m3[3] * y3;
  return out;
}
function transformMat2d(out, a4, m3) {
  var x3 = a4[0], y3 = a4[1];
  out[0] = m3[0] * x3 + m3[2] * y3 + m3[4];
  out[1] = m3[1] * x3 + m3[3] * y3 + m3[5];
  return out;
}
function transformMat32(out, a4, m3) {
  var x3 = a4[0], y3 = a4[1];
  out[0] = m3[0] * x3 + m3[3] * y3 + m3[6];
  out[1] = m3[1] * x3 + m3[4] * y3 + m3[7];
  return out;
}
function transformMat43(out, a4, m3) {
  var x3 = a4[0];
  var y3 = a4[1];
  out[0] = m3[0] * x3 + m3[4] * y3 + m3[12];
  out[1] = m3[1] * x3 + m3[5] * y3 + m3[13];
  return out;
}
function rotate3(out, a4, b, rad) {
  var p0 = a4[0] - b[0], p1 = a4[1] - b[1], sinC = Math.sin(rad), cosC = Math.cos(rad);
  out[0] = p0 * cosC - p1 * sinC + b[0];
  out[1] = p0 * sinC + p1 * cosC + b[1];
  return out;
}
function angle2(a4, b) {
  var x12 = a4[0], y12 = a4[1], x22 = b[0], y22 = b[1], mag = Math.sqrt(x12 * x12 + y12 * y12) * Math.sqrt(x22 * x22 + y22 * y22), cosine = mag && (x12 * x22 + y12 * y22) / mag;
  return Math.acos(Math.min(Math.max(cosine, -1), 1));
}
function zero3(out) {
  out[0] = 0;
  out[1] = 0;
  return out;
}
function str6(a4) {
  return "vec2(" + a4[0] + ", " + a4[1] + ")";
}
function exactEquals6(a4, b) {
  return a4[0] === b[0] && a4[1] === b[1];
}
function equals6(a4, b) {
  var a0 = a4[0], a1 = a4[1];
  var b0 = b[0], b1 = b[1];
  return Math.abs(a0 - b0) <= EPSILON * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1, Math.abs(a1), Math.abs(b1));
}
var len4 = length4;
var sub5 = subtract5;
var mul6 = multiply6;
var div3 = divide3;
var dist3 = distance3;
var sqrDist3 = squaredDistance3;
var sqrLen4 = squaredLength4;
var forEach3 = function() {
  var vec = create6();
  return function(a4, stride, offset2, count4, fn, arg) {
    var i, l;
    if (!stride) {
      stride = 2;
    }
    if (!offset2) {
      offset2 = 0;
    }
    if (count4) {
      l = Math.min(count4 * stride + offset2, a4.length);
    } else {
      l = a4.length;
    }
    for (i = offset2; i < l; i += stride) {
      vec[0] = a4[i];
      vec[1] = a4[i + 1];
      fn(vec, vec, arg);
      a4[i] = vec[0];
      a4[i + 1] = vec[1];
    }
    return a4;
  };
}();

// node_modules/tslib/tslib.es6.mjs
var extendStatics = function(d2, b) {
  extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b2) {
    d3.__proto__ = b2;
  } || function(d3, b2) {
    for (var p2 in b2)
      if (Object.prototype.hasOwnProperty.call(b2, p2))
        d3[p2] = b2[p2];
  };
  return extendStatics(d2, b);
};
function __extends(d2, b) {
  if (typeof b !== "function" && b !== null)
    throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
  extendStatics(d2, b);
  function __() {
    this.constructor = d2;
  }
  d2.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
var __assign = function() {
  __assign = Object.assign || function __assign56(t) {
    for (var s2, i = 1, n = arguments.length; i < n; i++) {
      s2 = arguments[i];
      for (var p2 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p2))
          t[p2] = s2[p2];
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
function __rest(s2, e) {
  var t = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
      t[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t[p2[i]] = s2[p2[i]];
    }
  return t;
}
function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value2) {
    return value2 instanceof P ? value2 : new P(function(resolve) {
      resolve(value2);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject2) {
    function fulfilled(value2) {
      try {
        step2(generator.next(value2));
      } catch (e) {
        reject2(e);
      }
    }
    function rejected(value2) {
      try {
        step2(generator["throw"](value2));
      } catch (e) {
        reject2(e);
      }
    }
    function step2(result2) {
      result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
    }
    step2((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __generator(thisArg, body) {
  var _2 = { label: 0, sent: function() {
    if (t[0] & 1)
      throw t[1];
    return t[1];
  }, trys: [], ops: [] }, f, y3, t, g;
  return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v) {
      return step2([n, v]);
    };
  }
  function step2(op) {
    if (f)
      throw new TypeError("Generator is already executing.");
    while (g && (g = 0, op[0] && (_2 = 0)), _2)
      try {
        if (f = 1, y3 && (t = op[0] & 2 ? y3["return"] : op[0] ? y3["throw"] || ((t = y3["return"]) && t.call(y3), 0) : y3.next) && !(t = t.call(y3, op[1])).done)
          return t;
        if (y3 = 0, t)
          op = [op[0] & 2, t.value];
        switch (op[0]) {
          case 0:
          case 1:
            t = op;
            break;
          case 4:
            _2.label++;
            return { value: op[1], done: false };
          case 5:
            _2.label++;
            y3 = op[1];
            op = [0];
            continue;
          case 7:
            op = _2.ops.pop();
            _2.trys.pop();
            continue;
          default:
            if (!(t = _2.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _2 = 0;
              continue;
            }
            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
              _2.label = op[1];
              break;
            }
            if (op[0] === 6 && _2.label < t[1]) {
              _2.label = t[1];
              t = op;
              break;
            }
            if (t && _2.label < t[2]) {
              _2.label = t[2];
              _2.ops.push(op);
              break;
            }
            if (t[2])
              _2.ops.pop();
            _2.trys.pop();
            continue;
        }
        op = body.call(thisArg, _2);
      } catch (e) {
        op = [6, e];
        y3 = 0;
      } finally {
        f = t = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
}
function __values(o) {
  var s2 = typeof Symbol === "function" && Symbol.iterator, m3 = s2 && o[s2], i = 0;
  if (m3)
    return m3.call(o);
  if (o && typeof o.length === "number")
    return {
      next: function() {
        if (o && i >= o.length)
          o = void 0;
        return { value: o && o[i++], done: !o };
      }
    };
  throw new TypeError(s2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __read(o, n) {
  var m3 = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m3)
    return o;
  var i = m3.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
      ar.push(r.value);
  } catch (error3) {
    e = { error: error3 };
  } finally {
    try {
      if (r && !r.done && (m3 = i["return"]))
        m3.call(i);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
}
function __spreadArrays() {
  for (var s2 = 0, i = 0, il = arguments.length; i < il; i++)
    s2 += arguments[i].length;
  for (var r = Array(s2), k2 = 0, i = 0; i < il; i++)
    for (var a4 = arguments[i], j = 0, jl = a4.length; j < jl; j++, k2++)
      r[k2] = a4[j];
  return r;
}
function __spreadArray(to, from, pack3) {
  if (pack3 || arguments.length === 2)
    for (var i = 0, l = from.length, ar; i < l; i++) {
      if (ar || !(i in from)) {
        if (!ar)
          ar = Array.prototype.slice.call(from, 0, i);
        ar[i] = from[i];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from));
}
function __classPrivateFieldGet(receiver, state, kind, f) {
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
}

// node_modules/@antv/util/esm/path/parser/params-parser.js
var paramsParser = {
  x1: 0,
  y1: 0,
  x2: 0,
  y2: 0,
  x: 0,
  y: 0,
  qx: null,
  qy: null
};

// node_modules/@antv/util/esm/path/process/fix-arc.js
function fixArc(pathArray, allPathCommands, i) {
  if (pathArray[i].length > 7) {
    pathArray[i].shift();
    var pi4 = pathArray[i];
    var ni = i;
    while (pi4.length) {
      allPathCommands[i] = "A";
      pathArray.splice(ni += 1, 0, ["C"].concat(pi4.splice(0, 6)));
    }
    pathArray.splice(i, 1);
  }
}

// node_modules/@antv/util/esm/path/parser/params-count.js
var paramsCount = {
  a: 7,
  c: 6,
  h: 1,
  l: 2,
  m: 2,
  r: 4,
  q: 4,
  s: 4,
  t: 2,
  v: 1,
  z: 0
};

// node_modules/@antv/util/esm/path/util/is-path-array.js
function isPathArray(path2) {
  return Array.isArray(path2) && path2.every(function(seg) {
    var lk = seg[0].toLowerCase();
    return paramsCount[lk] === seg.length - 1 && "achlmqstvz".includes(lk);
  });
}

// node_modules/@antv/util/esm/path/util/is-absolute-array.js
function isAbsoluteArray(path2) {
  return isPathArray(path2) && // @ts-ignore -- `isPathArray` also checks if it's `Array`
  path2.every(function(_a2) {
    var x3 = _a2[0];
    return x3 === x3.toUpperCase();
  });
}

// node_modules/@antv/util/esm/path/util/is-normalized-array.js
function isNormalizedArray(path2) {
  return isAbsoluteArray(path2) && path2.every(function(_a2) {
    var pc = _a2[0];
    return "ACLMQZ".includes(pc);
  });
}

// node_modules/@antv/util/esm/path/parser/finalize-segment.js
function finalizeSegment(path2) {
  var pathCommand = path2.pathValue[path2.segmentStart];
  var LK = pathCommand.toLowerCase();
  var data2 = path2.data;
  while (data2.length >= paramsCount[LK]) {
    if (LK === "m" && data2.length > 2) {
      path2.segments.push([pathCommand].concat(data2.splice(0, 2)));
      LK = "l";
      pathCommand = pathCommand === "m" ? "l" : "L";
    } else {
      path2.segments.push([pathCommand].concat(data2.splice(0, paramsCount[LK])));
    }
    if (!paramsCount[LK]) {
      break;
    }
  }
}

// node_modules/@antv/util/esm/path/parser/scan-flag.js
function scanFlag(path2) {
  var index3 = path2.index, pathValue = path2.pathValue;
  var code = pathValue.charCodeAt(index3);
  if (code === 48) {
    path2.param = 0;
    path2.index += 1;
    return;
  }
  if (code === 49) {
    path2.param = 1;
    path2.index += 1;
    return;
  }
  path2.err = '[path-util]: invalid Arc flag "' + pathValue[index3] + '", expecting 0 or 1 at index ' + index3;
}

// node_modules/@antv/util/esm/path/parser/is-digit-start.js
function isDigitStart(code) {
  return code >= 48 && code <= 57 || code === 43 || code === 45 || code === 46;
}
function isDigit(code) {
  return code >= 48 && code <= 57;
}

// node_modules/@antv/util/esm/path/parser/scan-param.js
function scanParam(path2) {
  var max11 = path2.max, pathValue = path2.pathValue, start = path2.index;
  var index3 = start;
  var zeroFirst = false;
  var hasCeiling = false;
  var hasDecimal = false;
  var hasDot = false;
  var ch2;
  if (index3 >= max11) {
    path2.err = "[path-util]: Invalid path value at index " + index3 + ', "pathValue" is missing param';
    return;
  }
  ch2 = pathValue.charCodeAt(index3);
  if (ch2 === 43 || ch2 === 45) {
    index3 += 1;
    ch2 = pathValue.charCodeAt(index3);
  }
  if (!isDigit(ch2) && ch2 !== 46) {
    path2.err = "[path-util]: Invalid path value at index " + index3 + ', "' + pathValue[index3] + '" is not a number';
    return;
  }
  if (ch2 !== 46) {
    zeroFirst = ch2 === 48;
    index3 += 1;
    ch2 = pathValue.charCodeAt(index3);
    if (zeroFirst && index3 < max11) {
      if (ch2 && isDigit(ch2)) {
        path2.err = "[path-util]: Invalid path value at index " + start + ', "' + pathValue[start] + '" illegal number';
        return;
      }
    }
    while (index3 < max11 && isDigit(pathValue.charCodeAt(index3))) {
      index3 += 1;
      hasCeiling = true;
    }
    ch2 = pathValue.charCodeAt(index3);
  }
  if (ch2 === 46) {
    hasDot = true;
    index3 += 1;
    while (isDigit(pathValue.charCodeAt(index3))) {
      index3 += 1;
      hasDecimal = true;
    }
    ch2 = pathValue.charCodeAt(index3);
  }
  if (ch2 === 101 || ch2 === 69) {
    if (hasDot && !hasCeiling && !hasDecimal) {
      path2.err = "[path-util]: Invalid path value at index " + index3 + ', "' + pathValue[index3] + '" invalid float exponent';
      return;
    }
    index3 += 1;
    ch2 = pathValue.charCodeAt(index3);
    if (ch2 === 43 || ch2 === 45) {
      index3 += 1;
    }
    if (index3 < max11 && isDigit(pathValue.charCodeAt(index3))) {
      while (index3 < max11 && isDigit(pathValue.charCodeAt(index3))) {
        index3 += 1;
      }
    } else {
      path2.err = "[path-util]: Invalid path value at index " + index3 + ', "' + pathValue[index3] + '" invalid integer exponent';
      return;
    }
  }
  path2.index = index3;
  path2.param = +path2.pathValue.slice(start, index3);
}

// node_modules/@antv/util/esm/path/parser/is-space.js
function isSpace(ch2) {
  var specialSpaces = [
    5760,
    6158,
    8192,
    8193,
    8194,
    8195,
    8196,
    8197,
    8198,
    8199,
    8200,
    8201,
    8202,
    8239,
    8287,
    12288,
    65279
  ];
  return ch2 === 10 || ch2 === 13 || ch2 === 8232 || ch2 === 8233 || // Line terminators
  // White spaces
  ch2 === 32 || ch2 === 9 || ch2 === 11 || ch2 === 12 || ch2 === 160 || ch2 >= 5760 && specialSpaces.includes(ch2);
}

// node_modules/@antv/util/esm/path/parser/skip-spaces.js
function skipSpaces(path2) {
  var pathValue = path2.pathValue, max11 = path2.max;
  while (path2.index < max11 && isSpace(pathValue.charCodeAt(path2.index))) {
    path2.index += 1;
  }
}

// node_modules/@antv/util/esm/path/parser/is-path-command.js
function isPathCommand(code) {
  switch (code | 32) {
    case 109:
    case 122:
    case 108:
    case 104:
    case 118:
    case 99:
    case 115:
    case 113:
    case 116:
    case 97:
      return true;
    default:
      return false;
  }
}

// node_modules/@antv/util/esm/path/parser/is-arc-command.js
function isArcCommand(code) {
  return (code | 32) === 97;
}

// node_modules/@antv/util/esm/path/parser/scan-segment.js
function scanSegment(path2) {
  var max11 = path2.max, pathValue = path2.pathValue, index3 = path2.index;
  var cmdCode = pathValue.charCodeAt(index3);
  var reqParams = paramsCount[pathValue[index3].toLowerCase()];
  path2.segmentStart = index3;
  if (!isPathCommand(cmdCode)) {
    path2.err = '[path-util]: Invalid path value "' + pathValue[index3] + '" is not a path command';
    return;
  }
  path2.index += 1;
  skipSpaces(path2);
  path2.data = [];
  if (!reqParams) {
    finalizeSegment(path2);
    return;
  }
  for (; ; ) {
    for (var i = reqParams; i > 0; i -= 1) {
      if (isArcCommand(cmdCode) && (i === 3 || i === 4))
        scanFlag(path2);
      else
        scanParam(path2);
      if (path2.err.length) {
        return;
      }
      path2.data.push(path2.param);
      skipSpaces(path2);
      if (path2.index < max11 && pathValue.charCodeAt(path2.index) === 44) {
        path2.index += 1;
        skipSpaces(path2);
      }
    }
    if (path2.index >= path2.max) {
      break;
    }
    if (!isDigitStart(pathValue.charCodeAt(path2.index))) {
      break;
    }
  }
  finalizeSegment(path2);
}

// node_modules/@antv/util/esm/path/parser/path-parser.js
var PathParser = (
  /** @class */
  function() {
    function PathParser2(pathString) {
      this.pathValue = pathString;
      this.segments = [];
      this.max = pathString.length;
      this.index = 0;
      this.param = 0;
      this.segmentStart = 0;
      this.data = [];
      this.err = "";
    }
    return PathParser2;
  }()
);

// node_modules/@antv/util/esm/path/parser/parse-path-string.js
function parsePathString(pathInput) {
  if (isPathArray(pathInput)) {
    return [].concat(pathInput);
  }
  var path2 = new PathParser(pathInput);
  skipSpaces(path2);
  while (path2.index < path2.max && !path2.err.length) {
    scanSegment(path2);
  }
  return path2.err ? path2.err : path2.segments;
}

// node_modules/@antv/util/esm/path/convert/path-2-absolute.js
function path2Absolute(pathInput) {
  if (isAbsoluteArray(pathInput)) {
    return [].concat(pathInput);
  }
  var path2 = parsePathString(pathInput);
  var x3 = 0;
  var y3 = 0;
  var mx = 0;
  var my = 0;
  return path2.map(function(segment) {
    var values4 = segment.slice(1).map(Number);
    var pathCommand = segment[0];
    var absCommand = pathCommand.toUpperCase();
    if (pathCommand === "M") {
      x3 = values4[0], y3 = values4[1];
      mx = x3;
      my = y3;
      return ["M", x3, y3];
    }
    var absoluteSegment;
    if (pathCommand !== absCommand) {
      switch (absCommand) {
        case "A":
          absoluteSegment = [
            absCommand,
            values4[0],
            values4[1],
            values4[2],
            values4[3],
            values4[4],
            values4[5] + x3,
            values4[6] + y3
          ];
          break;
        case "V":
          absoluteSegment = [absCommand, values4[0] + y3];
          break;
        case "H":
          absoluteSegment = [absCommand, values4[0] + x3];
          break;
        default: {
          var absValues = values4.map(function(n, j) {
            return n + (j % 2 ? y3 : x3);
          });
          absoluteSegment = [absCommand].concat(absValues);
        }
      }
    } else {
      absoluteSegment = [absCommand].concat(values4);
    }
    var segLength = absoluteSegment.length;
    switch (absCommand) {
      case "Z":
        x3 = mx;
        y3 = my;
        break;
      case "H":
        x3 = absoluteSegment[1];
        break;
      case "V":
        y3 = absoluteSegment[1];
        break;
      default:
        x3 = absoluteSegment[segLength - 2];
        y3 = absoluteSegment[segLength - 1];
        if (absCommand === "M") {
          mx = x3;
          my = y3;
        }
    }
    return absoluteSegment;
  });
}

// node_modules/@antv/util/esm/path/process/normalize-segment.js
function normalizeSegment(segment, params) {
  var pathCommand = segment[0];
  var px1 = params.x1, py1 = params.y1, px2 = params.x2, py2 = params.y2;
  var values4 = segment.slice(1).map(Number);
  var result2 = segment;
  if (!"TQ".includes(pathCommand)) {
    params.qx = null;
    params.qy = null;
  }
  if (pathCommand === "H") {
    result2 = ["L", segment[1], py1];
  } else if (pathCommand === "V") {
    result2 = ["L", px1, segment[1]];
  } else if (pathCommand === "S") {
    var x12 = px1 * 2 - px2;
    var y12 = py1 * 2 - py2;
    params.x1 = x12;
    params.y1 = y12;
    result2 = ["C", x12, y12].concat(values4);
  } else if (pathCommand === "T") {
    var qx = px1 * 2 - params.qx;
    var qy = py1 * 2 - params.qy;
    params.qx = qx;
    params.qy = qy;
    result2 = ["Q", qx, qy].concat(values4);
  } else if (pathCommand === "Q") {
    var nqx = values4[0], nqy = values4[1];
    params.qx = nqx;
    params.qy = nqy;
  }
  return result2;
}

// node_modules/@antv/util/esm/path/process/normalize-path.js
function normalizePath(pathInput) {
  if (isNormalizedArray(pathInput)) {
    return [].concat(pathInput);
  }
  var path2 = path2Absolute(pathInput);
  var params = __assign({}, paramsParser);
  for (var i = 0; i < path2.length; i += 1) {
    path2[i] = normalizeSegment(path2[i], params);
    var segment = path2[i];
    var seglen = segment.length;
    params.x1 = +segment[seglen - 2];
    params.y1 = +segment[seglen - 1];
    params.x2 = +segment[seglen - 4] || params.x1;
    params.y2 = +segment[seglen - 3] || params.y1;
  }
  return path2;
}

// node_modules/@antv/util/esm/path/util/is-curve-array.js
function isCurveArray(path2) {
  return isNormalizedArray(path2) && path2.every(function(_a2) {
    var pc = _a2[0];
    return "MC".includes(pc);
  });
}

// node_modules/@antv/util/esm/path/util/rotate-vector.js
function rotateVector(x3, y3, rad) {
  var X = x3 * Math.cos(rad) - y3 * Math.sin(rad);
  var Y = x3 * Math.sin(rad) + y3 * Math.cos(rad);
  return { x: X, y: Y };
}

// node_modules/@antv/util/esm/path/process/arc-2-cubic.js
function arcToCubic(X12, Y12, RX, RY, angle4, LAF, SF, X22, Y22, recursive) {
  var x12 = X12;
  var y12 = Y12;
  var rx = RX;
  var ry = RY;
  var x22 = X22;
  var y22 = Y22;
  var d120 = Math.PI * 120 / 180;
  var rad = Math.PI / 180 * (+angle4 || 0);
  var res = [];
  var xy;
  var f1;
  var f2;
  var cx;
  var cy;
  if (!recursive) {
    xy = rotateVector(x12, y12, -rad);
    x12 = xy.x;
    y12 = xy.y;
    xy = rotateVector(x22, y22, -rad);
    x22 = xy.x;
    y22 = xy.y;
    var x3 = (x12 - x22) / 2;
    var y3 = (y12 - y22) / 2;
    var h = x3 * x3 / (rx * rx) + y3 * y3 / (ry * ry);
    if (h > 1) {
      h = Math.sqrt(h);
      rx *= h;
      ry *= h;
    }
    var rx2 = rx * rx;
    var ry2 = ry * ry;
    var k2 = (LAF === SF ? -1 : 1) * Math.sqrt(Math.abs((rx2 * ry2 - rx2 * y3 * y3 - ry2 * x3 * x3) / (rx2 * y3 * y3 + ry2 * x3 * x3)));
    cx = k2 * rx * y3 / ry + (x12 + x22) / 2;
    cy = k2 * -ry * x3 / rx + (y12 + y22) / 2;
    f1 = Math.asin(((y12 - cy) / ry * Math.pow(10, 9) >> 0) / Math.pow(10, 9));
    f2 = Math.asin(((y22 - cy) / ry * Math.pow(10, 9) >> 0) / Math.pow(10, 9));
    f1 = x12 < cx ? Math.PI - f1 : f1;
    f2 = x22 < cx ? Math.PI - f2 : f2;
    if (f1 < 0)
      f1 = Math.PI * 2 + f1;
    if (f2 < 0)
      f2 = Math.PI * 2 + f2;
    if (SF && f1 > f2) {
      f1 -= Math.PI * 2;
    }
    if (!SF && f2 > f1) {
      f2 -= Math.PI * 2;
    }
  } else {
    f1 = recursive[0], f2 = recursive[1], cx = recursive[2], cy = recursive[3];
  }
  var df = f2 - f1;
  if (Math.abs(df) > d120) {
    var f2old = f2;
    var x2old = x22;
    var y2old = y22;
    f2 = f1 + d120 * (SF && f2 > f1 ? 1 : -1);
    x22 = cx + rx * Math.cos(f2);
    y22 = cy + ry * Math.sin(f2);
    res = arcToCubic(x22, y22, rx, ry, angle4, 0, SF, x2old, y2old, [f2, f2old, cx, cy]);
  }
  df = f2 - f1;
  var c1 = Math.cos(f1);
  var s1 = Math.sin(f1);
  var c22 = Math.cos(f2);
  var s2 = Math.sin(f2);
  var t = Math.tan(df / 4);
  var hx = 4 / 3 * rx * t;
  var hy = 4 / 3 * ry * t;
  var m1 = [x12, y12];
  var m22 = [x12 + hx * s1, y12 - hy * c1];
  var m3 = [x22 + hx * s2, y22 - hy * c22];
  var m4 = [x22, y22];
  m22[0] = 2 * m1[0] - m22[0];
  m22[1] = 2 * m1[1] - m22[1];
  if (recursive) {
    return m22.concat(m3, m4, res);
  }
  res = m22.concat(m3, m4, res);
  var newres = [];
  for (var i = 0, ii = res.length; i < ii; i += 1) {
    newres[i] = i % 2 ? rotateVector(res[i - 1], res[i], rad).y : rotateVector(res[i], res[i + 1], rad).x;
  }
  return newres;
}

// node_modules/@antv/util/esm/path/process/quad-2-cubic.js
function quadToCubic(x12, y12, qx, qy, x22, y22) {
  var r13 = 1 / 3;
  var r23 = 2 / 3;
  return [
    r13 * x12 + r23 * qx,
    r13 * y12 + r23 * qy,
    r13 * x22 + r23 * qx,
    r13 * y22 + r23 * qy,
    x22,
    y22
    // x,y
  ];
}

// node_modules/@antv/util/esm/path/util/mid-point.js
function midPoint(a4, b, t) {
  var ax = a4[0];
  var ay = a4[1];
  var bx = b[0];
  var by = b[1];
  return [ax + (bx - ax) * t, ay + (by - ay) * t];
}

// node_modules/@antv/util/esm/path/process/line-2-cubic.js
var lineToCubic = function(x12, y12, x22, y22) {
  var t = 0.5;
  var mid2 = midPoint([x12, y12], [x22, y22], t);
  return __spreadArray(__spreadArray([], mid2, true), [x22, y22, x22, y22], false);
};

// node_modules/@antv/util/esm/path/process/segment-2-cubic.js
function segmentToCubic(segment, params) {
  var pathCommand = segment[0];
  var values4 = segment.slice(1).map(Number);
  var x3 = values4[0], y3 = values4[1];
  var args;
  var px1 = params.x1, py1 = params.y1, px = params.x, py = params.y;
  if (!"TQ".includes(pathCommand)) {
    params.qx = null;
    params.qy = null;
  }
  switch (pathCommand) {
    case "M":
      params.x = x3;
      params.y = y3;
      return segment;
    case "A":
      args = [px1, py1].concat(values4);
      return ["C"].concat(arcToCubic(args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7], args[8], args[9]));
    case "Q":
      params.qx = x3;
      params.qy = y3;
      args = [px1, py1].concat(values4);
      return ["C"].concat(quadToCubic(args[0], args[1], args[2], args[3], args[4], args[5]));
    case "L":
      return ["C"].concat(lineToCubic(px1, py1, x3, y3));
    case "Z":
      if (px1 === px && py1 === py) {
        return ["C", px1, py1, px, py, px, py];
      }
      return ["C"].concat(lineToCubic(px1, py1, px, py));
    default:
  }
  return segment;
}

// node_modules/@antv/util/esm/path/convert/path-2-curve.js
function path2Curve(pathInput, needZCommandIndexes) {
  if (needZCommandIndexes === void 0) {
    needZCommandIndexes = false;
  }
  if (isCurveArray(pathInput)) {
    var cloned = [].concat(pathInput);
    if (needZCommandIndexes) {
      return [cloned, []];
    } else {
      return cloned;
    }
  }
  var path2 = normalizePath(pathInput);
  var params = __assign({}, paramsParser);
  var allPathCommands = [];
  var pathCommand = "";
  var ii = path2.length;
  var segment;
  var seglen;
  var zCommandIndexes = [];
  for (var i = 0; i < ii; i += 1) {
    if (path2[i])
      pathCommand = path2[i][0];
    allPathCommands[i] = pathCommand;
    var curveSegment = segmentToCubic(path2[i], params);
    path2[i] = curveSegment;
    fixArc(path2, allPathCommands, i);
    ii = path2.length;
    if (pathCommand === "Z") {
      zCommandIndexes.push(i);
    }
    segment = path2[i];
    seglen = segment.length;
    params.x1 = +segment[seglen - 2];
    params.y1 = +segment[seglen - 1];
    params.x2 = +segment[seglen - 4] || params.x1;
    params.y2 = +segment[seglen - 3] || params.y1;
  }
  if (needZCommandIndexes) {
    return [path2, zCommandIndexes];
  } else {
    return path2;
  }
}

// node_modules/@antv/util/esm/path/process/clone-path.js
function clonePath(path2) {
  return path2.map(function(x3) {
    return Array.isArray(x3) ? [].concat(x3) : x3;
  });
}

// node_modules/@antv/util/esm/path/process/reverse-curve.js
function reverseCurve(pathArray) {
  var rotatedCurve = pathArray.slice(1).map(function(x3, i, curveOnly) {
    return !i ? pathArray[0].slice(1).concat(x3.slice(1)) : curveOnly[i - 1].slice(-2).concat(x3.slice(1));
  }).map(function(x3) {
    return x3.map(function(y3, i) {
      return x3[x3.length - i - 2 * (1 - i % 2)];
    });
  }).reverse();
  return [["M"].concat(rotatedCurve[0].slice(0, 2))].concat(rotatedCurve.map(function(x3) {
    return ["C"].concat(x3.slice(2));
  }));
}

// node_modules/@antv/util/esm/path/util/distance-square-root.js
function distanceSquareRoot(a4, b) {
  return Math.sqrt((a4[0] - b[0]) * (a4[0] - b[0]) + (a4[1] - b[1]) * (a4[1] - b[1]));
}

// node_modules/@antv/util/esm/path/util/segment-line-factory.js
function segmentLineFactory(x12, y12, x22, y22, distance7) {
  var length5 = distanceSquareRoot([x12, y12], [x22, y22]);
  var point7 = { x: 0, y: 0 };
  if (typeof distance7 === "number") {
    if (distance7 <= 0) {
      point7 = { x: x12, y: y12 };
    } else if (distance7 >= length5) {
      point7 = { x: x22, y: y22 };
    } else {
      var _a2 = midPoint([x12, y12], [x22, y22], distance7 / length5), x3 = _a2[0], y3 = _a2[1];
      point7 = { x: x3, y: y3 };
    }
  }
  return {
    length: length5,
    point: point7,
    min: {
      x: Math.min(x12, x22),
      y: Math.min(y12, y22)
    },
    max: {
      x: Math.max(x12, x22),
      y: Math.max(y12, y22)
    }
  };
}

// node_modules/@antv/util/esm/path/util/segment-arc-factory.js
function angleBetween(v0, v1) {
  var v0x = v0.x, v0y = v0.y;
  var v1x = v1.x, v1y = v1.y;
  var p2 = v0x * v1x + v0y * v1y;
  var n = Math.sqrt((Math.pow(v0x, 2) + Math.pow(v0y, 2)) * (Math.pow(v1x, 2) + Math.pow(v1y, 2)));
  var sign3 = v0x * v1y - v0y * v1x < 0 ? -1 : 1;
  var angle4 = sign3 * Math.acos(p2 / n);
  return angle4;
}
function getPointAtArcSegmentLength(x12, y12, RX, RY, angle4, LAF, SF, x3, y3, t) {
  var abs3 = Math.abs, sin3 = Math.sin, cos4 = Math.cos, sqrt4 = Math.sqrt, PI = Math.PI;
  var rx = abs3(RX);
  var ry = abs3(RY);
  var xRot = (angle4 % 360 + 360) % 360;
  var xRotRad = xRot * (PI / 180);
  if (x12 === x3 && y12 === y3) {
    return { x: x12, y: y12 };
  }
  if (rx === 0 || ry === 0) {
    return segmentLineFactory(x12, y12, x3, y3, t).point;
  }
  var dx = (x12 - x3) / 2;
  var dy = (y12 - y3) / 2;
  var transformedPoint = {
    x: cos4(xRotRad) * dx + sin3(xRotRad) * dy,
    y: -sin3(xRotRad) * dx + cos4(xRotRad) * dy
  };
  var radiiCheck = Math.pow(transformedPoint.x, 2) / Math.pow(rx, 2) + Math.pow(transformedPoint.y, 2) / Math.pow(ry, 2);
  if (radiiCheck > 1) {
    rx *= sqrt4(radiiCheck);
    ry *= sqrt4(radiiCheck);
  }
  var cSquareNumerator = Math.pow(rx, 2) * Math.pow(ry, 2) - Math.pow(rx, 2) * Math.pow(transformedPoint.y, 2) - Math.pow(ry, 2) * Math.pow(transformedPoint.x, 2);
  var cSquareRootDenom = Math.pow(rx, 2) * Math.pow(transformedPoint.y, 2) + Math.pow(ry, 2) * Math.pow(transformedPoint.x, 2);
  var cRadicand = cSquareNumerator / cSquareRootDenom;
  cRadicand = cRadicand < 0 ? 0 : cRadicand;
  var cCoef = (LAF !== SF ? 1 : -1) * sqrt4(cRadicand);
  var transformedCenter = {
    x: cCoef * (rx * transformedPoint.y / ry),
    y: cCoef * (-(ry * transformedPoint.x) / rx)
  };
  var center2 = {
    x: cos4(xRotRad) * transformedCenter.x - sin3(xRotRad) * transformedCenter.y + (x12 + x3) / 2,
    y: sin3(xRotRad) * transformedCenter.x + cos4(xRotRad) * transformedCenter.y + (y12 + y3) / 2
  };
  var startVector = {
    x: (transformedPoint.x - transformedCenter.x) / rx,
    y: (transformedPoint.y - transformedCenter.y) / ry
  };
  var startAngle = angleBetween({ x: 1, y: 0 }, startVector);
  var endVector = {
    x: (-transformedPoint.x - transformedCenter.x) / rx,
    y: (-transformedPoint.y - transformedCenter.y) / ry
  };
  var sweepAngle = angleBetween(startVector, endVector);
  if (!SF && sweepAngle > 0) {
    sweepAngle -= 2 * PI;
  } else if (SF && sweepAngle < 0) {
    sweepAngle += 2 * PI;
  }
  sweepAngle %= 2 * PI;
  var alpha = startAngle + sweepAngle * t;
  var ellipseComponentX = rx * cos4(alpha);
  var ellipseComponentY = ry * sin3(alpha);
  var point7 = {
    x: cos4(xRotRad) * ellipseComponentX - sin3(xRotRad) * ellipseComponentY + center2.x,
    y: sin3(xRotRad) * ellipseComponentX + cos4(xRotRad) * ellipseComponentY + center2.y
  };
  return point7;
}
function segmentArcFactory(X12, Y12, RX, RY, angle4, LAF, SF, X22, Y22, distance7, options) {
  var _a2;
  var _b = options.bbox, bbox = _b === void 0 ? true : _b, _c = options.length, length5 = _c === void 0 ? true : _c, _d = options.sampleSize, sampleSize2 = _d === void 0 ? 30 : _d;
  var distanceIsNumber = typeof distance7 === "number";
  var x3 = X12;
  var y3 = Y12;
  var LENGTH = 0;
  var prev = [x3, y3, LENGTH];
  var cur = [x3, y3];
  var t = 0;
  var POINT = { x: 0, y: 0 };
  var POINTS = [{ x: x3, y: y3 }];
  if (distanceIsNumber && distance7 <= 0) {
    POINT = { x: x3, y: y3 };
  }
  for (var j = 0; j <= sampleSize2; j += 1) {
    t = j / sampleSize2;
    _a2 = getPointAtArcSegmentLength(X12, Y12, RX, RY, angle4, LAF, SF, X22, Y22, t), x3 = _a2.x, y3 = _a2.y;
    if (bbox) {
      POINTS.push({ x: x3, y: y3 });
    }
    if (length5) {
      LENGTH += distanceSquareRoot(cur, [x3, y3]);
    }
    cur = [x3, y3];
    if (distanceIsNumber && LENGTH >= distance7 && distance7 > prev[2]) {
      var dv = (LENGTH - distance7) / (LENGTH - prev[2]);
      POINT = {
        x: cur[0] * (1 - dv) + prev[0] * dv,
        y: cur[1] * (1 - dv) + prev[1] * dv
      };
    }
    prev = [x3, y3, LENGTH];
  }
  if (distanceIsNumber && distance7 >= LENGTH) {
    POINT = { x: X22, y: Y22 };
  }
  return {
    length: LENGTH,
    point: POINT,
    min: {
      x: Math.min.apply(null, POINTS.map(function(n) {
        return n.x;
      })),
      y: Math.min.apply(null, POINTS.map(function(n) {
        return n.y;
      }))
    },
    max: {
      x: Math.max.apply(null, POINTS.map(function(n) {
        return n.x;
      })),
      y: Math.max.apply(null, POINTS.map(function(n) {
        return n.y;
      }))
    }
  };
}

// node_modules/@antv/util/esm/path/util/segment-cubic-factory.js
function getPointAtCubicSegmentLength(x12, y12, c1x, c1y, c2x, c2y, x22, y22, t) {
  var t12 = 1 - t;
  return {
    x: Math.pow(t12, 3) * x12 + 3 * Math.pow(t12, 2) * t * c1x + 3 * t12 * Math.pow(t, 2) * c2x + Math.pow(t, 3) * x22,
    y: Math.pow(t12, 3) * y12 + 3 * Math.pow(t12, 2) * t * c1y + 3 * t12 * Math.pow(t, 2) * c2y + Math.pow(t, 3) * y22
  };
}
function segmentCubicFactory(x12, y12, c1x, c1y, c2x, c2y, x22, y22, distance7, options) {
  var _a2;
  var _b = options.bbox, bbox = _b === void 0 ? true : _b, _c = options.length, length5 = _c === void 0 ? true : _c, _d = options.sampleSize, sampleSize2 = _d === void 0 ? 10 : _d;
  var distanceIsNumber = typeof distance7 === "number";
  var x3 = x12;
  var y3 = y12;
  var LENGTH = 0;
  var prev = [x3, y3, LENGTH];
  var cur = [x3, y3];
  var t = 0;
  var POINT = { x: 0, y: 0 };
  var POINTS = [{ x: x3, y: y3 }];
  if (distanceIsNumber && distance7 <= 0) {
    POINT = { x: x3, y: y3 };
  }
  for (var j = 0; j <= sampleSize2; j += 1) {
    t = j / sampleSize2;
    _a2 = getPointAtCubicSegmentLength(x12, y12, c1x, c1y, c2x, c2y, x22, y22, t), x3 = _a2.x, y3 = _a2.y;
    if (bbox) {
      POINTS.push({ x: x3, y: y3 });
    }
    if (length5) {
      LENGTH += distanceSquareRoot(cur, [x3, y3]);
    }
    cur = [x3, y3];
    if (distanceIsNumber && LENGTH >= distance7 && distance7 > prev[2]) {
      var dv = (LENGTH - distance7) / (LENGTH - prev[2]);
      POINT = {
        x: cur[0] * (1 - dv) + prev[0] * dv,
        y: cur[1] * (1 - dv) + prev[1] * dv
      };
    }
    prev = [x3, y3, LENGTH];
  }
  if (distanceIsNumber && distance7 >= LENGTH) {
    POINT = { x: x22, y: y22 };
  }
  return {
    length: LENGTH,
    point: POINT,
    min: {
      x: Math.min.apply(null, POINTS.map(function(n) {
        return n.x;
      })),
      y: Math.min.apply(null, POINTS.map(function(n) {
        return n.y;
      }))
    },
    max: {
      x: Math.max.apply(null, POINTS.map(function(n) {
        return n.x;
      })),
      y: Math.max.apply(null, POINTS.map(function(n) {
        return n.y;
      }))
    }
  };
}

// node_modules/@antv/util/esm/path/util/segment-quad-factory.js
function getPointAtQuadSegmentLength(x12, y12, cx, cy, x22, y22, t) {
  var t12 = 1 - t;
  return {
    x: Math.pow(t12, 2) * x12 + 2 * t12 * t * cx + Math.pow(t, 2) * x22,
    y: Math.pow(t12, 2) * y12 + 2 * t12 * t * cy + Math.pow(t, 2) * y22
  };
}
function segmentQuadFactory(x12, y12, qx, qy, x22, y22, distance7, options) {
  var _a2;
  var _b = options.bbox, bbox = _b === void 0 ? true : _b, _c = options.length, length5 = _c === void 0 ? true : _c, _d = options.sampleSize, sampleSize2 = _d === void 0 ? 10 : _d;
  var distanceIsNumber = typeof distance7 === "number";
  var x3 = x12;
  var y3 = y12;
  var LENGTH = 0;
  var prev = [x3, y3, LENGTH];
  var cur = [x3, y3];
  var t = 0;
  var POINT = { x: 0, y: 0 };
  var POINTS = [{ x: x3, y: y3 }];
  if (distanceIsNumber && distance7 <= 0) {
    POINT = { x: x3, y: y3 };
  }
  for (var j = 0; j <= sampleSize2; j += 1) {
    t = j / sampleSize2;
    _a2 = getPointAtQuadSegmentLength(x12, y12, qx, qy, x22, y22, t), x3 = _a2.x, y3 = _a2.y;
    if (bbox) {
      POINTS.push({ x: x3, y: y3 });
    }
    if (length5) {
      LENGTH += distanceSquareRoot(cur, [x3, y3]);
    }
    cur = [x3, y3];
    if (distanceIsNumber && LENGTH >= distance7 && distance7 > prev[2]) {
      var dv = (LENGTH - distance7) / (LENGTH - prev[2]);
      POINT = {
        x: cur[0] * (1 - dv) + prev[0] * dv,
        y: cur[1] * (1 - dv) + prev[1] * dv
      };
    }
    prev = [x3, y3, LENGTH];
  }
  if (distanceIsNumber && distance7 >= LENGTH) {
    POINT = { x: x22, y: y22 };
  }
  return {
    length: LENGTH,
    point: POINT,
    min: {
      x: Math.min.apply(null, POINTS.map(function(n) {
        return n.x;
      })),
      y: Math.min.apply(null, POINTS.map(function(n) {
        return n.y;
      }))
    },
    max: {
      x: Math.max.apply(null, POINTS.map(function(n) {
        return n.x;
      })),
      y: Math.max.apply(null, POINTS.map(function(n) {
        return n.y;
      }))
    }
  };
}

// node_modules/@antv/util/esm/path/util/path-length-factory.js
function pathLengthFactory(pathInput, distance7, options) {
  var _a2, _b, _c, _d, _e, _f;
  var path2 = normalizePath(pathInput);
  var distanceIsNumber = typeof distance7 === "number";
  var isM;
  var data2 = [];
  var pathCommand;
  var x3 = 0;
  var y3 = 0;
  var mx = 0;
  var my = 0;
  var seg;
  var MIN = [];
  var MAX = [];
  var length5 = 0;
  var min11 = { x: 0, y: 0 };
  var max11 = min11;
  var point7 = min11;
  var POINT = min11;
  var LENGTH = 0;
  for (var i = 0, ll = path2.length; i < ll; i += 1) {
    seg = path2[i];
    pathCommand = seg[0];
    isM = pathCommand === "M";
    data2 = !isM ? [x3, y3].concat(seg.slice(1)) : data2;
    if (isM) {
      mx = seg[1], my = seg[2];
      min11 = { x: mx, y: my };
      max11 = min11;
      length5 = 0;
      if (distanceIsNumber && distance7 < 1e-3) {
        POINT = min11;
      }
    } else if (pathCommand === "L") {
      _a2 = segmentLineFactory(data2[0], data2[1], data2[2], data2[3], (distance7 || 0) - LENGTH), length5 = _a2.length, min11 = _a2.min, max11 = _a2.max, point7 = _a2.point;
    } else if (pathCommand === "A") {
      _b = segmentArcFactory(data2[0], data2[1], data2[2], data2[3], data2[4], data2[5], data2[6], data2[7], data2[8], (distance7 || 0) - LENGTH, options || {}), length5 = _b.length, min11 = _b.min, max11 = _b.max, point7 = _b.point;
    } else if (pathCommand === "C") {
      _c = segmentCubicFactory(data2[0], data2[1], data2[2], data2[3], data2[4], data2[5], data2[6], data2[7], (distance7 || 0) - LENGTH, options || {}), length5 = _c.length, min11 = _c.min, max11 = _c.max, point7 = _c.point;
    } else if (pathCommand === "Q") {
      _d = segmentQuadFactory(data2[0], data2[1], data2[2], data2[3], data2[4], data2[5], (distance7 || 0) - LENGTH, options || {}), length5 = _d.length, min11 = _d.min, max11 = _d.max, point7 = _d.point;
    } else if (pathCommand === "Z") {
      data2 = [x3, y3, mx, my];
      _e = segmentLineFactory(data2[0], data2[1], data2[2], data2[3], (distance7 || 0) - LENGTH), length5 = _e.length, min11 = _e.min, max11 = _e.max, point7 = _e.point;
    }
    if (distanceIsNumber && LENGTH < distance7 && LENGTH + length5 >= distance7) {
      POINT = point7;
    }
    MAX.push(max11);
    MIN.push(min11);
    LENGTH += length5;
    _f = pathCommand !== "Z" ? seg.slice(-2) : [mx, my], x3 = _f[0], y3 = _f[1];
  }
  if (distanceIsNumber && distance7 >= LENGTH) {
    POINT = { x: x3, y: y3 };
  }
  return {
    length: LENGTH,
    point: POINT,
    min: {
      x: Math.min.apply(null, MIN.map(function(n) {
        return n.x;
      })),
      y: Math.min.apply(null, MIN.map(function(n) {
        return n.y;
      }))
    },
    max: {
      x: Math.max.apply(null, MAX.map(function(n) {
        return n.x;
      })),
      y: Math.max.apply(null, MAX.map(function(n) {
        return n.y;
      }))
    }
  };
}

// node_modules/@antv/util/esm/path/util/get-total-length.js
function getTotalLength(pathInput, options) {
  return pathLengthFactory(pathInput, void 0, __assign(__assign({}, options), { bbox: false, length: true })).length;
}

// node_modules/@antv/util/esm/path/util/get-rotated-curve.js
function getRotations(a4) {
  var segCount = a4.length;
  var pointCount = segCount - 1;
  return a4.map(function(f, idx) {
    return a4.map(function(p2, i) {
      var oldSegIdx = idx + i;
      var seg;
      if (i === 0 || a4[oldSegIdx] && a4[oldSegIdx][0] === "M") {
        seg = a4[oldSegIdx];
        return ["M"].concat(seg.slice(-2));
      }
      if (oldSegIdx >= segCount)
        oldSegIdx -= pointCount;
      return a4[oldSegIdx];
    });
  });
}
function getRotatedCurve(a4, b) {
  var segCount = a4.length - 1;
  var lineLengths = [];
  var computedIndex = 0;
  var sumLensSqrd = 0;
  var rotations = getRotations(a4);
  rotations.forEach(function(r, i) {
    a4.slice(1).forEach(function(s2, j) {
      sumLensSqrd += distanceSquareRoot(a4[(i + j) % segCount].slice(-2), b[j % segCount].slice(-2));
    });
    lineLengths[i] = sumLensSqrd;
    sumLensSqrd = 0;
  });
  computedIndex = lineLengths.indexOf(Math.min.apply(null, lineLengths));
  return rotations[computedIndex];
}

// node_modules/@antv/util/esm/path/util/get-path-area.js
function getCubicSegArea(x12, y12, c1x, c1y, c2x, c2y, x22, y22) {
  return 3 * ((y22 - y12) * (c1x + c2x) - (x22 - x12) * (c1y + c2y) + c1y * (x12 - c2x) - c1x * (y12 - c2y) + y22 * (c2x + x12 / 3) - x22 * (c2y + y12 / 3)) / 20;
}
function getPathArea(path2) {
  var x3 = 0;
  var y3 = 0;
  var len5 = 0;
  return path2Curve(path2).map(function(seg) {
    var _a2;
    switch (seg[0]) {
      case "M":
        x3 = seg[1], y3 = seg[2];
        return 0;
      default:
        var _b = seg.slice(1), c1x = _b[0], c1y = _b[1], c2x = _b[2], c2y = _b[3], x22 = _b[4], y22 = _b[5];
        len5 = getCubicSegArea(x3, y3, c1x, c1y, c2x, c2y, x22, y22);
        _a2 = seg.slice(-2), x3 = _a2[0], y3 = _a2[1];
        return len5;
    }
  }).reduce(function(a4, b) {
    return a4 + b;
  }, 0);
}

// node_modules/@antv/util/esm/path/util/get-draw-direction.js
function getDrawDirection(pathArray) {
  return getPathArea(pathArray) >= 0;
}

// node_modules/@antv/util/esm/path/util/get-point-at-length.js
function getPointAtLength(pathInput, distance7, options) {
  return pathLengthFactory(pathInput, distance7, __assign(__assign({}, options), { bbox: false, length: true })).point;
}

// node_modules/@antv/util/esm/path/util/equalize-segments.js
function splitCubic(pts, t) {
  if (t === void 0) {
    t = 0.5;
  }
  var p0 = pts.slice(0, 2);
  var p1 = pts.slice(2, 4);
  var p2 = pts.slice(4, 6);
  var p3 = pts.slice(6, 8);
  var p4 = midPoint(p0, p1, t);
  var p5 = midPoint(p1, p2, t);
  var p6 = midPoint(p2, p3, t);
  var p7 = midPoint(p4, p5, t);
  var p8 = midPoint(p5, p6, t);
  var p9 = midPoint(p7, p8, t);
  return [
    // @ts-ignore
    ["C"].concat(p4, p7, p9),
    // @ts-ignore
    ["C"].concat(p8, p6, p3)
  ];
}
function getCurveArray(segments) {
  return segments.map(function(segment, i, pathArray) {
    var segmentData = i && pathArray[i - 1].slice(-2).concat(segment.slice(1));
    var curveLength = i ? segmentCubicFactory(segmentData[0], segmentData[1], segmentData[2], segmentData[3], segmentData[4], segmentData[5], segmentData[6], segmentData[7], segmentData[8], { bbox: false }).length : 0;
    var subsegs;
    if (i) {
      subsegs = curveLength ? splitCubic(segmentData) : [segment, segment];
    } else {
      subsegs = [segment];
    }
    return {
      s: segment,
      ss: subsegs,
      l: curveLength
    };
  });
}
function equalizeSegments(path1, path2, TL) {
  var c1 = getCurveArray(path1);
  var c22 = getCurveArray(path2);
  var L1 = c1.length;
  var L2 = c22.length;
  var l1 = c1.filter(function(x3) {
    return x3.l;
  }).length;
  var l2 = c22.filter(function(x3) {
    return x3.l;
  }).length;
  var m1 = c1.filter(function(x3) {
    return x3.l;
  }).reduce(function(a4, _a2) {
    var l = _a2.l;
    return a4 + l;
  }, 0) / l1 || 0;
  var m22 = c22.filter(function(x3) {
    return x3.l;
  }).reduce(function(a4, _a2) {
    var l = _a2.l;
    return a4 + l;
  }, 0) / l2 || 0;
  var tl = TL || Math.max(L1, L2);
  var mm = [m1, m22];
  var dif = [tl - L1, tl - L2];
  var canSplit = 0;
  var result2 = [c1, c22].map(function(x3, i) {
    return x3.l === tl ? x3.map(function(y3) {
      return y3.s;
    }) : x3.map(function(y3, j) {
      canSplit = j && dif[i] && y3.l >= mm[i];
      dif[i] -= canSplit ? 1 : 0;
      return canSplit ? y3.ss : [y3.s];
    }).flat();
  });
  return result2[0].length === result2[1].length ? result2 : equalizeSegments(result2[0], result2[1], tl);
}

// node_modules/@antv/util/esm/dom/create-dom.js
function createDOM(str7) {
  var container = document.createElement("div");
  container.innerHTML = str7;
  var dom2 = container.childNodes[0];
  if (dom2 && container.contains(dom2)) {
    container.removeChild(dom2);
  }
  return dom2;
}

// node_modules/@antv/g2/esm/transform/utils/helper.js
function column(value2, field3) {
  if (value2 === null)
    return void 0;
  return { type: "column", value: value2, field: field3 };
}
function inferredColumn(value2, field3) {
  const c5 = column(value2, field3);
  return Object.assign(Object.assign({}, c5), { inferred: true });
}
function visualColumn(value2, field3) {
  if (value2 === null)
    return void 0;
  return { type: "column", value: value2, field: field3, visual: true };
}
function nonConstantColumn(value2, field3) {
  const c5 = column(value2, field3);
  return Object.assign(Object.assign({}, c5), { constant: false });
}
function constant(I, value2) {
  const array2 = [];
  for (const i of I)
    array2[i] = value2;
  return array2;
}
function columnOf(encode, key) {
  const channel = encode[key];
  if (!channel)
    return [null, null];
  const { value: value2, field: field3 = null } = channel;
  return [value2, field3];
}
function maybeColumnOf(encode, ...K2) {
  for (const key of K2) {
    if (typeof key === "string") {
      const [KV, fv] = columnOf(encode, key);
      if (KV !== null)
        return [KV, fv];
    } else {
      return [key, null];
    }
  }
  return [null, null];
}
function isObject(d2) {
  if (d2 instanceof Date)
    return false;
  return typeof d2 === "object";
}

// node_modules/@antv/g2/esm/transform/maybeZeroY1.js
var MaybeZeroY1 = () => {
  return (I, mark2) => {
    const { encode } = mark2;
    const { y1: y12 } = encode;
    if (y12 !== void 0)
      return [I, mark2];
    return [
      I,
      deep_mix_default({}, mark2, {
        encode: { y1: inferredColumn(constant(I, 0)) }
      })
    ];
  };
};
MaybeZeroY1.props = {};

// node_modules/d3-array/src/ascending.js
function ascending(a4, b) {
  return a4 == null || b == null ? NaN : a4 < b ? -1 : a4 > b ? 1 : a4 >= b ? 0 : NaN;
}

// node_modules/d3-array/src/descending.js
function descending(a4, b) {
  return a4 == null || b == null ? NaN : b < a4 ? -1 : b > a4 ? 1 : b >= a4 ? 0 : NaN;
}

// node_modules/d3-array/src/bisector.js
function bisector(f) {
  let compare1, compare2, delta;
  if (f.length !== 2) {
    compare1 = ascending;
    compare2 = (d2, x3) => ascending(f(d2), x3);
    delta = (d2, x3) => f(d2) - x3;
  } else {
    compare1 = f === ascending || f === descending ? f : zero4;
    compare2 = f;
    delta = f;
  }
  function left2(a4, x3, lo = 0, hi = a4.length) {
    if (lo < hi) {
      if (compare1(x3, x3) !== 0)
        return hi;
      do {
        const mid2 = lo + hi >>> 1;
        if (compare2(a4[mid2], x3) < 0)
          lo = mid2 + 1;
        else
          hi = mid2;
      } while (lo < hi);
    }
    return lo;
  }
  function right2(a4, x3, lo = 0, hi = a4.length) {
    if (lo < hi) {
      if (compare1(x3, x3) !== 0)
        return hi;
      do {
        const mid2 = lo + hi >>> 1;
        if (compare2(a4[mid2], x3) <= 0)
          lo = mid2 + 1;
        else
          hi = mid2;
      } while (lo < hi);
    }
    return lo;
  }
  function center2(a4, x3, lo = 0, hi = a4.length) {
    const i = left2(a4, x3, lo, hi - 1);
    return i > lo && delta(a4[i - 1], x3) > -delta(a4[i], x3) ? i - 1 : i;
  }
  return { left: left2, center: center2, right: right2 };
}
function zero4() {
  return 0;
}

// node_modules/d3-array/src/number.js
function number(x3) {
  return x3 === null ? NaN : +x3;
}
function* numbers(values4, valueof2) {
  if (valueof2 === void 0) {
    for (let value2 of values4) {
      if (value2 != null && (value2 = +value2) >= value2) {
        yield value2;
      }
    }
  } else {
    let index3 = -1;
    for (let value2 of values4) {
      if ((value2 = valueof2(value2, ++index3, values4)) != null && (value2 = +value2) >= value2) {
        yield value2;
      }
    }
  }
}

// node_modules/d3-array/src/bisect.js
var ascendingBisect = bisector(ascending);
var bisectRight = ascendingBisect.right;
var bisectLeft = ascendingBisect.left;
var bisectCenter = bisector(number).center;
var bisect_default = bisectRight;

// node_modules/d3-array/src/blur.js
var blur2 = Blur2(blurf);
var blurImage = Blur2(blurfImage);
function Blur2(blur3) {
  return function(data2, rx, ry = rx) {
    if (!((rx = +rx) >= 0))
      throw new RangeError("invalid rx");
    if (!((ry = +ry) >= 0))
      throw new RangeError("invalid ry");
    let { data: values4, width, height } = data2;
    if (!((width = Math.floor(width)) >= 0))
      throw new RangeError("invalid width");
    if (!((height = Math.floor(height !== void 0 ? height : values4.length / width)) >= 0))
      throw new RangeError("invalid height");
    if (!width || !height || !rx && !ry)
      return data2;
    const blurx = rx && blur3(rx);
    const blury = ry && blur3(ry);
    const temp = values4.slice();
    if (blurx && blury) {
      blurh(blurx, temp, values4, width, height);
      blurh(blurx, values4, temp, width, height);
      blurh(blurx, temp, values4, width, height);
      blurv(blury, values4, temp, width, height);
      blurv(blury, temp, values4, width, height);
      blurv(blury, values4, temp, width, height);
    } else if (blurx) {
      blurh(blurx, values4, temp, width, height);
      blurh(blurx, temp, values4, width, height);
      blurh(blurx, values4, temp, width, height);
    } else if (blury) {
      blurv(blury, values4, temp, width, height);
      blurv(blury, temp, values4, width, height);
      blurv(blury, values4, temp, width, height);
    }
    return data2;
  };
}
function blurh(blur3, T, S, w, h) {
  for (let y3 = 0, n = w * h; y3 < n; ) {
    blur3(T, S, y3, y3 += w, 1);
  }
}
function blurv(blur3, T, S, w, h) {
  for (let x3 = 0, n = w * h; x3 < w; ++x3) {
    blur3(T, S, x3, x3 + n, w);
  }
}
function blurfImage(radius) {
  const blur3 = blurf(radius);
  return (T, S, start, stop, step2) => {
    start <<= 2, stop <<= 2, step2 <<= 2;
    blur3(T, S, start + 0, stop + 0, step2);
    blur3(T, S, start + 1, stop + 1, step2);
    blur3(T, S, start + 2, stop + 2, step2);
    blur3(T, S, start + 3, stop + 3, step2);
  };
}
function blurf(radius) {
  const radius0 = Math.floor(radius);
  if (radius0 === radius)
    return bluri(radius);
  const t = radius - radius0;
  const w = 2 * radius + 1;
  return (T, S, start, stop, step2) => {
    if (!((stop -= step2) >= start))
      return;
    let sum5 = radius0 * S[start];
    const s0 = step2 * radius0;
    const s1 = s0 + step2;
    for (let i = start, j = start + s0; i < j; i += step2) {
      sum5 += S[Math.min(stop, i)];
    }
    for (let i = start, j = stop; i <= j; i += step2) {
      sum5 += S[Math.min(stop, i + s0)];
      T[i] = (sum5 + t * (S[Math.max(start, i - s1)] + S[Math.min(stop, i + s1)])) / w;
      sum5 -= S[Math.max(start, i - s0)];
    }
  };
}
function bluri(radius) {
  const w = 2 * radius + 1;
  return (T, S, start, stop, step2) => {
    if (!((stop -= step2) >= start))
      return;
    let sum5 = radius * S[start];
    const s2 = step2 * radius;
    for (let i = start, j = start + s2; i < j; i += step2) {
      sum5 += S[Math.min(stop, i)];
    }
    for (let i = start, j = stop; i <= j; i += step2) {
      sum5 += S[Math.min(stop, i + s2)];
      T[i] = sum5 / w;
      sum5 -= S[Math.max(start, i - s2)];
    }
  };
}

// node_modules/d3-array/src/count.js
function count(values4, valueof2) {
  let count4 = 0;
  if (valueof2 === void 0) {
    for (let value2 of values4) {
      if (value2 != null && (value2 = +value2) >= value2) {
        ++count4;
      }
    }
  } else {
    let index3 = -1;
    for (let value2 of values4) {
      if ((value2 = valueof2(value2, ++index3, values4)) != null && (value2 = +value2) >= value2) {
        ++count4;
      }
    }
  }
  return count4;
}

// node_modules/d3-array/src/variance.js
function variance(values4, valueof2) {
  let count4 = 0;
  let delta;
  let mean4 = 0;
  let sum5 = 0;
  if (valueof2 === void 0) {
    for (let value2 of values4) {
      if (value2 != null && (value2 = +value2) >= value2) {
        delta = value2 - mean4;
        mean4 += delta / ++count4;
        sum5 += delta * (value2 - mean4);
      }
    }
  } else {
    let index3 = -1;
    for (let value2 of values4) {
      if ((value2 = valueof2(value2, ++index3, values4)) != null && (value2 = +value2) >= value2) {
        delta = value2 - mean4;
        mean4 += delta / ++count4;
        sum5 += delta * (value2 - mean4);
      }
    }
  }
  if (count4 > 1)
    return sum5 / (count4 - 1);
}

// node_modules/d3-array/src/deviation.js
function deviation(values4, valueof2) {
  const v = variance(values4, valueof2);
  return v ? Math.sqrt(v) : v;
}

// node_modules/d3-array/src/extent.js
function extent(values4, valueof2) {
  let min11;
  let max11;
  if (valueof2 === void 0) {
    for (const value2 of values4) {
      if (value2 != null) {
        if (min11 === void 0) {
          if (value2 >= value2)
            min11 = max11 = value2;
        } else {
          if (min11 > value2)
            min11 = value2;
          if (max11 < value2)
            max11 = value2;
        }
      }
    }
  } else {
    let index3 = -1;
    for (let value2 of values4) {
      if ((value2 = valueof2(value2, ++index3, values4)) != null) {
        if (min11 === void 0) {
          if (value2 >= value2)
            min11 = max11 = value2;
        } else {
          if (min11 > value2)
            min11 = value2;
          if (max11 < value2)
            max11 = value2;
        }
      }
    }
  }
  return [min11, max11];
}

// node_modules/d3-array/src/fsum.js
var Adder = class {
  constructor() {
    this._partials = new Float64Array(32);
    this._n = 0;
  }
  add(x3) {
    const p2 = this._partials;
    let i = 0;
    for (let j = 0; j < this._n && j < 32; j++) {
      const y3 = p2[j], hi = x3 + y3, lo = Math.abs(x3) < Math.abs(y3) ? x3 - (hi - y3) : y3 - (hi - x3);
      if (lo)
        p2[i++] = lo;
      x3 = hi;
    }
    p2[i] = x3;
    this._n = i + 1;
    return this;
  }
  valueOf() {
    const p2 = this._partials;
    let n = this._n, x3, y3, lo, hi = 0;
    if (n > 0) {
      hi = p2[--n];
      while (n > 0) {
        x3 = hi;
        y3 = p2[--n];
        hi = x3 + y3;
        lo = y3 - (hi - x3);
        if (lo)
          break;
      }
      if (n > 0 && (lo < 0 && p2[n - 1] < 0 || lo > 0 && p2[n - 1] > 0)) {
        y3 = lo * 2;
        x3 = hi + y3;
        if (y3 == x3 - hi)
          hi = x3;
      }
    }
    return hi;
  }
};

// node_modules/internmap/src/index.js
var InternMap = class extends Map {
  constructor(entries, key = keyof) {
    super();
    Object.defineProperties(this, { _intern: { value: /* @__PURE__ */ new Map() }, _key: { value: key } });
    if (entries != null)
      for (const [key2, value2] of entries)
        this.set(key2, value2);
  }
  get(key) {
    return super.get(intern_get(this, key));
  }
  has(key) {
    return super.has(intern_get(this, key));
  }
  set(key, value2) {
    return super.set(intern_set(this, key), value2);
  }
  delete(key) {
    return super.delete(intern_delete(this, key));
  }
};
function intern_get({ _intern, _key }, value2) {
  const key = _key(value2);
  return _intern.has(key) ? _intern.get(key) : value2;
}
function intern_set({ _intern, _key }, value2) {
  const key = _key(value2);
  if (_intern.has(key))
    return _intern.get(key);
  _intern.set(key, value2);
  return value2;
}
function intern_delete({ _intern, _key }, value2) {
  const key = _key(value2);
  if (_intern.has(key)) {
    value2 = _intern.get(key);
    _intern.delete(key);
  }
  return value2;
}
function keyof(value2) {
  return value2 !== null && typeof value2 === "object" ? value2.valueOf() : value2;
}

// node_modules/d3-array/src/identity.js
function identity4(x3) {
  return x3;
}

// node_modules/d3-array/src/group.js
function group(values4, ...keys3) {
  return nest(values4, identity4, identity4, keys3);
}
function groups(values4, ...keys3) {
  return nest(values4, Array.from, identity4, keys3);
}
function rollup(values4, reduce4, ...keys3) {
  return nest(values4, identity4, reduce4, keys3);
}
function rollups(values4, reduce4, ...keys3) {
  return nest(values4, Array.from, reduce4, keys3);
}
function nest(values4, map5, reduce4, keys3) {
  return function regroup(values5, i) {
    if (i >= keys3.length)
      return reduce4(values5);
    const groups2 = new InternMap();
    const keyof3 = keys3[i++];
    let index3 = -1;
    for (const value2 of values5) {
      const key = keyof3(value2, ++index3, values5);
      const group3 = groups2.get(key);
      if (group3)
        group3.push(value2);
      else
        groups2.set(key, [value2]);
    }
    for (const [key, values6] of groups2) {
      groups2.set(key, regroup(values6, i));
    }
    return map5(groups2);
  }(values4, 0);
}

// node_modules/d3-array/src/permute.js
function permute(source, keys3) {
  return Array.from(keys3, (key) => source[key]);
}

// node_modules/d3-array/src/sort.js
function sort(values4, ...F) {
  if (typeof values4[Symbol.iterator] !== "function")
    throw new TypeError("values is not iterable");
  values4 = Array.from(values4);
  let [f] = F;
  if (f && f.length !== 2 || F.length > 1) {
    const index3 = Uint32Array.from(values4, (d2, i) => i);
    if (F.length > 1) {
      F = F.map((f2) => values4.map(f2));
      index3.sort((i, j) => {
        for (const f2 of F) {
          const c5 = ascendingDefined(f2[i], f2[j]);
          if (c5)
            return c5;
        }
      });
    } else {
      f = values4.map(f);
      index3.sort((i, j) => ascendingDefined(f[i], f[j]));
    }
    return permute(values4, index3);
  }
  return values4.sort(compareDefined(f));
}
function compareDefined(compare = ascending) {
  if (compare === ascending)
    return ascendingDefined;
  if (typeof compare !== "function")
    throw new TypeError("compare is not a function");
  return (a4, b) => {
    const x3 = compare(a4, b);
    if (x3 || x3 === 0)
      return x3;
    return (compare(b, b) === 0) - (compare(a4, a4) === 0);
  };
}
function ascendingDefined(a4, b) {
  return (a4 == null || !(a4 >= a4)) - (b == null || !(b >= b)) || (a4 < b ? -1 : a4 > b ? 1 : 0);
}

// node_modules/d3-array/src/groupSort.js
function groupSort(values4, reduce4, key) {
  return (reduce4.length !== 2 ? sort(rollup(values4, reduce4, key), ([ak, av], [bk, bv]) => ascending(av, bv) || ascending(ak, bk)) : sort(group(values4, key), ([ak, av], [bk, bv]) => reduce4(av, bv) || ascending(ak, bk))).map(([key2]) => key2);
}

// node_modules/d3-array/src/array.js
var array = Array.prototype;
var slice = array.slice;
var map = array.map;

// node_modules/d3-array/src/constant.js
function constant2(x3) {
  return () => x3;
}

// node_modules/d3-array/src/ticks.js
var e10 = Math.sqrt(50);
var e5 = Math.sqrt(10);
var e2 = Math.sqrt(2);
function tickSpec(start, stop, count4) {
  const step2 = (stop - start) / Math.max(0, count4), power = Math.floor(Math.log10(step2)), error3 = step2 / Math.pow(10, power), factor = error3 >= e10 ? 10 : error3 >= e5 ? 5 : error3 >= e2 ? 2 : 1;
  let i1, i2, inc;
  if (power < 0) {
    inc = Math.pow(10, -power) / factor;
    i1 = Math.round(start * inc);
    i2 = Math.round(stop * inc);
    if (i1 / inc < start)
      ++i1;
    if (i2 / inc > stop)
      --i2;
    inc = -inc;
  } else {
    inc = Math.pow(10, power) * factor;
    i1 = Math.round(start / inc);
    i2 = Math.round(stop / inc);
    if (i1 * inc < start)
      ++i1;
    if (i2 * inc > stop)
      --i2;
  }
  if (i2 < i1 && 0.5 <= count4 && count4 < 2)
    return tickSpec(start, stop, count4 * 2);
  return [i1, i2, inc];
}
function ticks(start, stop, count4) {
  stop = +stop, start = +start, count4 = +count4;
  if (!(count4 > 0))
    return [];
  if (start === stop)
    return [start];
  const reverse3 = stop < start, [i1, i2, inc] = reverse3 ? tickSpec(stop, start, count4) : tickSpec(start, stop, count4);
  if (!(i2 >= i1))
    return [];
  const n = i2 - i1 + 1, ticks2 = new Array(n);
  if (reverse3) {
    if (inc < 0)
      for (let i = 0; i < n; ++i)
        ticks2[i] = (i2 - i) / -inc;
    else
      for (let i = 0; i < n; ++i)
        ticks2[i] = (i2 - i) * inc;
  } else {
    if (inc < 0)
      for (let i = 0; i < n; ++i)
        ticks2[i] = (i1 + i) / -inc;
    else
      for (let i = 0; i < n; ++i)
        ticks2[i] = (i1 + i) * inc;
  }
  return ticks2;
}
function tickIncrement(start, stop, count4) {
  stop = +stop, start = +start, count4 = +count4;
  return tickSpec(start, stop, count4)[2];
}

// node_modules/d3-array/src/nice.js
function nice(start, stop, count4) {
  let prestep;
  while (true) {
    const step2 = tickIncrement(start, stop, count4);
    if (step2 === prestep || step2 === 0 || !isFinite(step2)) {
      return [start, stop];
    } else if (step2 > 0) {
      start = Math.floor(start / step2) * step2;
      stop = Math.ceil(stop / step2) * step2;
    } else if (step2 < 0) {
      start = Math.ceil(start * step2) / step2;
      stop = Math.floor(stop * step2) / step2;
    }
    prestep = step2;
  }
}

// node_modules/d3-array/src/threshold/sturges.js
function thresholdSturges(values4) {
  return Math.max(1, Math.ceil(Math.log(count(values4)) / Math.LN2) + 1);
}

// node_modules/d3-array/src/bin.js
function bin() {
  var value2 = identity4, domain = extent, threshold = thresholdSturges;
  function histogram(data2) {
    if (!Array.isArray(data2))
      data2 = Array.from(data2);
    var i, n = data2.length, x3, step2, values4 = new Array(n);
    for (i = 0; i < n; ++i) {
      values4[i] = value2(data2[i], i, data2);
    }
    var xz = domain(values4), x05 = xz[0], x12 = xz[1], tz = threshold(values4, x05, x12);
    if (!Array.isArray(tz)) {
      const max11 = x12, tn = +tz;
      if (domain === extent)
        [x05, x12] = nice(x05, x12, tn);
      tz = ticks(x05, x12, tn);
      if (tz[0] <= x05)
        step2 = tickIncrement(x05, x12, tn);
      if (tz[tz.length - 1] >= x12) {
        if (max11 >= x12 && domain === extent) {
          const step3 = tickIncrement(x05, x12, tn);
          if (isFinite(step3)) {
            if (step3 > 0) {
              x12 = (Math.floor(x12 / step3) + 1) * step3;
            } else if (step3 < 0) {
              x12 = (Math.ceil(x12 * -step3) + 1) / -step3;
            }
          }
        } else {
          tz.pop();
        }
      }
    }
    var m3 = tz.length, a4 = 0, b = m3;
    while (tz[a4] <= x05)
      ++a4;
    while (tz[b - 1] > x12)
      --b;
    if (a4 || b < m3)
      tz = tz.slice(a4, b), m3 = b - a4;
    var bins = new Array(m3 + 1), bin2;
    for (i = 0; i <= m3; ++i) {
      bin2 = bins[i] = [];
      bin2.x0 = i > 0 ? tz[i - 1] : x05;
      bin2.x1 = i < m3 ? tz[i] : x12;
    }
    if (isFinite(step2)) {
      if (step2 > 0) {
        for (i = 0; i < n; ++i) {
          if ((x3 = values4[i]) != null && x05 <= x3 && x3 <= x12) {
            bins[Math.min(m3, Math.floor((x3 - x05) / step2))].push(data2[i]);
          }
        }
      } else if (step2 < 0) {
        for (i = 0; i < n; ++i) {
          if ((x3 = values4[i]) != null && x05 <= x3 && x3 <= x12) {
            const j = Math.floor((x05 - x3) * step2);
            bins[Math.min(m3, j + (tz[j] <= x3))].push(data2[i]);
          }
        }
      }
    } else {
      for (i = 0; i < n; ++i) {
        if ((x3 = values4[i]) != null && x05 <= x3 && x3 <= x12) {
          bins[bisect_default(tz, x3, 0, m3)].push(data2[i]);
        }
      }
    }
    return bins;
  }
  histogram.value = function(_2) {
    return arguments.length ? (value2 = typeof _2 === "function" ? _2 : constant2(_2), histogram) : value2;
  };
  histogram.domain = function(_2) {
    return arguments.length ? (domain = typeof _2 === "function" ? _2 : constant2([_2[0], _2[1]]), histogram) : domain;
  };
  histogram.thresholds = function(_2) {
    return arguments.length ? (threshold = typeof _2 === "function" ? _2 : constant2(Array.isArray(_2) ? slice.call(_2) : _2), histogram) : threshold;
  };
  return histogram;
}

// node_modules/d3-array/src/max.js
function max4(values4, valueof2) {
  let max11;
  if (valueof2 === void 0) {
    for (const value2 of values4) {
      if (value2 != null && (max11 < value2 || max11 === void 0 && value2 >= value2)) {
        max11 = value2;
      }
    }
  } else {
    let index3 = -1;
    for (let value2 of values4) {
      if ((value2 = valueof2(value2, ++index3, values4)) != null && (max11 < value2 || max11 === void 0 && value2 >= value2)) {
        max11 = value2;
      }
    }
  }
  return max11;
}

// node_modules/d3-array/src/maxIndex.js
function maxIndex(values4, valueof2) {
  let max11;
  let maxIndex2 = -1;
  let index3 = -1;
  if (valueof2 === void 0) {
    for (const value2 of values4) {
      ++index3;
      if (value2 != null && (max11 < value2 || max11 === void 0 && value2 >= value2)) {
        max11 = value2, maxIndex2 = index3;
      }
    }
  } else {
    for (let value2 of values4) {
      if ((value2 = valueof2(value2, ++index3, values4)) != null && (max11 < value2 || max11 === void 0 && value2 >= value2)) {
        max11 = value2, maxIndex2 = index3;
      }
    }
  }
  return maxIndex2;
}

// node_modules/d3-array/src/min.js
function min4(values4, valueof2) {
  let min11;
  if (valueof2 === void 0) {
    for (const value2 of values4) {
      if (value2 != null && (min11 > value2 || min11 === void 0 && value2 >= value2)) {
        min11 = value2;
      }
    }
  } else {
    let index3 = -1;
    for (let value2 of values4) {
      if ((value2 = valueof2(value2, ++index3, values4)) != null && (min11 > value2 || min11 === void 0 && value2 >= value2)) {
        min11 = value2;
      }
    }
  }
  return min11;
}

// node_modules/d3-array/src/minIndex.js
function minIndex(values4, valueof2) {
  let min11;
  let minIndex2 = -1;
  let index3 = -1;
  if (valueof2 === void 0) {
    for (const value2 of values4) {
      ++index3;
      if (value2 != null && (min11 > value2 || min11 === void 0 && value2 >= value2)) {
        min11 = value2, minIndex2 = index3;
      }
    }
  } else {
    for (let value2 of values4) {
      if ((value2 = valueof2(value2, ++index3, values4)) != null && (min11 > value2 || min11 === void 0 && value2 >= value2)) {
        min11 = value2, minIndex2 = index3;
      }
    }
  }
  return minIndex2;
}

// node_modules/d3-array/src/quickselect.js
function quickselect(array2, k2, left2 = 0, right2 = Infinity, compare) {
  k2 = Math.floor(k2);
  left2 = Math.floor(Math.max(0, left2));
  right2 = Math.floor(Math.min(array2.length - 1, right2));
  if (!(left2 <= k2 && k2 <= right2))
    return array2;
  compare = compare === void 0 ? ascendingDefined : compareDefined(compare);
  while (right2 > left2) {
    if (right2 - left2 > 600) {
      const n = right2 - left2 + 1;
      const m3 = k2 - left2 + 1;
      const z = Math.log(n);
      const s2 = 0.5 * Math.exp(2 * z / 3);
      const sd = 0.5 * Math.sqrt(z * s2 * (n - s2) / n) * (m3 - n / 2 < 0 ? -1 : 1);
      const newLeft = Math.max(left2, Math.floor(k2 - m3 * s2 / n + sd));
      const newRight = Math.min(right2, Math.floor(k2 + (n - m3) * s2 / n + sd));
      quickselect(array2, k2, newLeft, newRight, compare);
    }
    const t = array2[k2];
    let i = left2;
    let j = right2;
    swap(array2, left2, k2);
    if (compare(array2[right2], t) > 0)
      swap(array2, left2, right2);
    while (i < j) {
      swap(array2, i, j), ++i, --j;
      while (compare(array2[i], t) < 0)
        ++i;
      while (compare(array2[j], t) > 0)
        --j;
    }
    if (compare(array2[left2], t) === 0)
      swap(array2, left2, j);
    else
      ++j, swap(array2, j, right2);
    if (j <= k2)
      left2 = j + 1;
    if (k2 <= j)
      right2 = j - 1;
  }
  return array2;
}
function swap(array2, i, j) {
  const t = array2[i];
  array2[i] = array2[j];
  array2[j] = t;
}

// node_modules/d3-array/src/greatest.js
function greatest(values4, compare = ascending) {
  let max11;
  let defined4 = false;
  if (compare.length === 1) {
    let maxValue;
    for (const element of values4) {
      const value2 = compare(element);
      if (defined4 ? ascending(value2, maxValue) > 0 : ascending(value2, value2) === 0) {
        max11 = element;
        maxValue = value2;
        defined4 = true;
      }
    }
  } else {
    for (const value2 of values4) {
      if (defined4 ? compare(value2, max11) > 0 : compare(value2, value2) === 0) {
        max11 = value2;
        defined4 = true;
      }
    }
  }
  return max11;
}

// node_modules/d3-array/src/quantile.js
function quantile(values4, p2, valueof2) {
  values4 = Float64Array.from(numbers(values4, valueof2));
  if (!(n = values4.length) || isNaN(p2 = +p2))
    return;
  if (p2 <= 0 || n < 2)
    return min4(values4);
  if (p2 >= 1)
    return max4(values4);
  var n, i = (n - 1) * p2, i0 = Math.floor(i), value0 = max4(quickselect(values4, i0).subarray(0, i0 + 1)), value1 = min4(values4.subarray(i0 + 1));
  return value0 + (value1 - value0) * (i - i0);
}
function quantileIndex(values4, p2, valueof2 = number) {
  if (isNaN(p2 = +p2))
    return;
  numbers2 = Float64Array.from(values4, (_2, i2) => number(valueof2(values4[i2], i2, values4)));
  if (p2 <= 0)
    return minIndex(numbers2);
  if (p2 >= 1)
    return maxIndex(numbers2);
  var numbers2, index3 = Uint32Array.from(values4, (_2, i2) => i2), j = numbers2.length - 1, i = Math.floor(j * p2);
  quickselect(index3, i, 0, j, (i2, j2) => ascendingDefined(numbers2[i2], numbers2[j2]));
  i = greatest(index3.subarray(0, i + 1), (i2) => numbers2[i2]);
  return i >= 0 ? i : -1;
}

// node_modules/d3-array/src/threshold/scott.js
function thresholdScott(values4, min11, max11) {
  const c5 = count(values4), d2 = deviation(values4);
  return c5 && d2 ? Math.ceil((max11 - min11) * Math.cbrt(c5) / (3.49 * d2)) : 1;
}

// node_modules/d3-array/src/mean.js
function mean(values4, valueof2) {
  let count4 = 0;
  let sum5 = 0;
  if (valueof2 === void 0) {
    for (let value2 of values4) {
      if (value2 != null && (value2 = +value2) >= value2) {
        ++count4, sum5 += value2;
      }
    }
  } else {
    let index3 = -1;
    for (let value2 of values4) {
      if ((value2 = valueof2(value2, ++index3, values4)) != null && (value2 = +value2) >= value2) {
        ++count4, sum5 += value2;
      }
    }
  }
  if (count4)
    return sum5 / count4;
}

// node_modules/d3-array/src/median.js
function median(values4, valueof2) {
  return quantile(values4, 0.5, valueof2);
}
function medianIndex(values4, valueof2) {
  return quantileIndex(values4, 0.5, valueof2);
}

// node_modules/d3-array/src/merge.js
function* flatten(arrays) {
  for (const array2 of arrays) {
    yield* array2;
  }
}
function merge(arrays) {
  return Array.from(flatten(arrays));
}

// node_modules/d3-array/src/range.js
function range(start, stop, step2) {
  start = +start, stop = +stop, step2 = (n = arguments.length) < 2 ? (stop = start, start = 0, 1) : n < 3 ? 1 : +step2;
  var i = -1, n = Math.max(0, Math.ceil((stop - start) / step2)) | 0, range4 = new Array(n);
  while (++i < n) {
    range4[i] = start + i * step2;
  }
  return range4;
}

// node_modules/d3-array/src/shuffle.js
var shuffle_default = shuffler(Math.random);
function shuffler(random6) {
  return function shuffle3(array2, i0 = 0, i1 = array2.length) {
    let m3 = i1 - (i0 = +i0);
    while (m3) {
      const i = random6() * m3-- | 0, t = array2[m3 + i0];
      array2[m3 + i0] = array2[i + i0];
      array2[i + i0] = t;
    }
    return array2;
  };
}

// node_modules/d3-array/src/sum.js
function sum(values4, valueof2) {
  let sum5 = 0;
  if (valueof2 === void 0) {
    for (let value2 of values4) {
      if (value2 = +value2) {
        sum5 += value2;
      }
    }
  } else {
    let index3 = -1;
    for (let value2 of values4) {
      if (value2 = +valueof2(value2, ++index3, values4)) {
        sum5 += value2;
      }
    }
  }
  return sum5;
}

// node_modules/@antv/g2/esm/utils/helper.js
var __awaiter2 = function(thisArg, _arguments, P, generator) {
  function adopt(value2) {
    return value2 instanceof P ? value2 : new P(function(resolve) {
      resolve(value2);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject2) {
    function fulfilled(value2) {
      try {
        step2(generator.next(value2));
      } catch (e) {
        reject2(e);
      }
    }
    function rejected(value2) {
      try {
        step2(generator["throw"](value2));
      } catch (e) {
        reject2(e);
      }
    }
    function step2(result2) {
      result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
    }
    step2((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
function identity5(x3) {
  return x3;
}
function compose(fns) {
  return fns.reduce((composed, fn) => (x3, ...args) => fn(composed(x3, ...args), ...args), identity5);
}
function composeAsync(fns) {
  return fns.reduce((composed, fn) => (x3) => __awaiter2(this, void 0, void 0, function* () {
    const value2 = yield composed(x3);
    return fn(value2);
  }), identity5);
}
function capitalizeFirst(str7) {
  return str7.replace(/( |^)[a-z]/g, (L) => L.toUpperCase());
}
function error(message = "") {
  throw new Error(message);
}
function copyAttributes(target, source) {
  const { attributes } = source;
  const exclude2 = /* @__PURE__ */ new Set(["id", "className"]);
  for (const [key, value2] of Object.entries(attributes)) {
    if (!exclude2.has(key)) {
      if (key === "transform") {
        target.attr(key, "");
        target.attr(key, value2);
      } else {
        target.attr(key, value2);
      }
    }
  }
}
function defined(x3) {
  return x3 !== void 0 && x3 !== null && !Number.isNaN(x3);
}
function useMemo(compute) {
  const map5 = /* @__PURE__ */ new Map();
  return (key) => {
    if (map5.has(key))
      return map5.get(key);
    const value2 = compute(key);
    map5.set(key, value2);
    return value2;
  };
}
function appendTransform(node, transform3) {
  const { transform: preTransform } = node.style;
  const unset2 = (d2) => d2 === "none" || d2 === void 0;
  const prefix = unset2(preTransform) ? "" : preTransform;
  node.style.transform = `${prefix} ${transform3}`.trimStart();
}
function subObject(obj, prefix) {
  return maybeSubObject(obj, prefix) || {};
}
function maybeSubObject(obj, prefix) {
  const entries = Object.entries(obj || {}).filter(([key]) => key.startsWith(prefix)).map(([key, value2]) => [lower_first_default(key.replace(prefix, "").trim()), value2]).filter(([key]) => !!key);
  return entries.length === 0 ? null : Object.fromEntries(entries);
}
function filterPrefixObject(obj, prefix) {
  return Object.fromEntries(Object.entries(obj).filter(([key]) => prefix.find((p2) => key.startsWith(p2))));
}
function omitPrefixObject(obj, ...prefixes2) {
  return Object.fromEntries(Object.entries(obj).filter(([key]) => prefixes2.every((prefix) => !key.startsWith(prefix))));
}
function maybePercentage(x3, size5) {
  if (x3 === void 0)
    return null;
  if (typeof x3 === "number")
    return x3;
  const px = +x3.replace("%", "");
  return Number.isNaN(px) ? null : px / 100 * size5;
}
function isStrictObject(d2) {
  return typeof d2 === "object" && !(d2 instanceof Date) && d2 !== null && !Array.isArray(d2);
}
function isUnset(value2) {
  return value2 === null || value2 === false;
}
function deepAssign(dist5, src, maxLevel = 5, level = 0) {
  if (level >= maxLevel)
    return;
  for (const key of Object.keys(src)) {
    const value2 = src[key];
    if (!is_plain_object_default(value2) || !is_plain_object_default(dist5[key])) {
      dist5[key] = value2;
    } else {
      deepAssign(dist5[key], value2, maxLevel, level + 1);
    }
  }
  return dist5;
}

// node_modules/@antv/g2/esm/utils/array.js
function mapObject(object, callbackfn) {
  return Object.entries(object).reduce((obj, [key, value2]) => {
    obj[key] = callbackfn(value2, key, object);
    return obj;
  }, {});
}
function indexOf2(array2) {
  return array2.map((_2, i) => i);
}
function firstOf(array2) {
  return array2[0];
}
function lastOf(array2) {
  return array2[array2.length - 1];
}
function unique(array2) {
  return Array.from(new Set(array2));
}
function divide4(array2, callbackfn) {
  const result2 = [[], []];
  array2.forEach((item) => {
    result2[callbackfn(item) ? 0 : 1].push(item);
  });
  return result2;
}
function comb(array2, len5 = array2.length) {
  if (len5 === 1)
    return array2.map((item) => [item]);
  const result2 = [];
  for (let i = 0; i < array2.length; i++) {
    const rest2 = array2.slice(i + 1);
    const restComb = comb(rest2, len5 - 1);
    restComb.forEach((comb2) => {
      result2.push([array2[i], ...comb2]);
    });
  }
  return result2;
}
function combine(array2) {
  if (array2.length === 1)
    return [array2];
  const result2 = [];
  for (let i = 1; i <= array2.length; i++) {
    result2.push(...comb(array2, i));
  }
  return result2;
}

// node_modules/@antv/g2/esm/transform/utils/order.js
function createGroups(groupBy3, I, mark2) {
  const { encode } = mark2;
  if (groupBy3 === null)
    return [I];
  const G = normalizeGroupBy(groupBy3).map((k2) => {
    var _a2;
    return [k2, (_a2 = columnOf(encode, k2)) === null || _a2 === void 0 ? void 0 : _a2[0]];
  }).filter(([, column2]) => defined(column2));
  const key = (i) => G.map(([, V]) => V[i]).join("-");
  return Array.from(group(I, key).values());
}
function normalizeComparator(order) {
  if (Array.isArray(order))
    return createFieldsOrder(order);
  if (typeof order === "function")
    return createFunctionOrder(order);
  if (order === "series")
    return createSeriesOrder;
  if (order === "value")
    return createValueOrder;
  if (order === "sum")
    return createSumOrder;
  if (order === "maxIndex")
    return createMaxIndexOrder;
  return () => null;
}
function applyOrder(groups2, comparator) {
  for (const group3 of groups2) {
    group3.sort(comparator);
  }
}
function domainOf(value2, scale10) {
  return (scale10 === null || scale10 === void 0 ? void 0 : scale10.domain) || Array.from(new Set(value2));
}
function normalizeGroupBy(groupBy3) {
  if (Array.isArray(groupBy3))
    return groupBy3;
  return [groupBy3];
}
function createSeriesOrder(data2, Y, S) {
  return ascendingComparator((i) => S[i]);
}
function createFunctionOrder(order) {
  return (data2, Y, S) => {
    return ascendingComparator((i) => order(data2[i]));
  };
}
function createFieldsOrder(order) {
  return (data2, Y, S) => {
    return (i, j) => order.reduce((eq2, f) => eq2 !== 0 ? eq2 : ascending(data2[i][f], data2[j][f]), 0);
  };
}
function createValueOrder(data2, Y, S) {
  return ascendingComparator((i) => Y[i]);
}
function createSumOrder(data2, Y, S) {
  const I = indexOf2(data2);
  const groups2 = Array.from(group(I, (i) => S[+i]).entries());
  const seriesSum = new Map(groups2.map(([k2, GI]) => [k2, GI.reduce((s2, i) => s2 + +Y[i])]));
  return ascendingComparator((i) => seriesSum.get(S[i]));
}
function createMaxIndexOrder(data2, Y, S) {
  const I = indexOf2(data2);
  const groups2 = Array.from(group(I, (i) => S[+i]).entries());
  const seriesMaxIndex = new Map(groups2.map(([k2, GI]) => [k2, maxIndex(GI, (i) => Y[i])]));
  return ascendingComparator((i) => seriesMaxIndex.get(S[i]));
}
function ascendingComparator(order) {
  return (i, j) => ascending(order(i), order(j));
}

// node_modules/@antv/g2/esm/transform/stackY.js
var StackY = (options = {}) => {
  const { groupBy: groupBy3 = "x", orderBy: orderBy2 = null, reverse: reverse3 = false, y: fromY = "y", y1: fromY1 = "y1", series = true } = options;
  return (I, mark2) => {
    const { data: data2, encode, style = {} } = mark2;
    const [Y, fy] = columnOf(encode, "y");
    const [Y12, fy1] = columnOf(encode, "y1");
    const [S] = series ? maybeColumnOf(encode, "series", "color") : columnOf(encode, "color");
    const groups2 = createGroups(groupBy3, I, mark2);
    const createComparator = normalizeComparator(orderBy2);
    const comparator = createComparator(data2, Y, S);
    if (comparator)
      applyOrder(groups2, comparator);
    const newY = new Array(I.length);
    const newY1 = new Array(I.length);
    const TY = new Array(I.length);
    const F = [];
    const L = [];
    for (const G of groups2) {
      if (reverse3)
        G.reverse();
      const start = Y12 ? +Y12[G[0]] : 0;
      const PG = [];
      const NG = [];
      for (const i2 of G) {
        const y3 = TY[i2] = +Y[i2] - start;
        if (y3 < 0)
          NG.push(i2);
        else if (y3 >= 0)
          PG.push(i2);
      }
      const FG = PG.length > 0 ? PG : NG;
      const LG = NG.length > 0 ? NG : PG;
      let i = PG.length - 1;
      let j = 0;
      while (i > 0 && Y[FG[i]] === 0)
        i--;
      while (j < LG.length - 1 && Y[LG[j]] === 0)
        j++;
      F.push(FG[i]);
      L.push(LG[j]);
      let ny = start;
      for (const i2 of NG.reverse()) {
        const y3 = TY[i2];
        ny = newY[i2] = (newY1[i2] = ny) + y3;
      }
      let py = start;
      for (const i2 of PG) {
        const y3 = TY[i2];
        if (y3 > 0)
          py = newY[i2] = (newY1[i2] = py) + y3;
        else
          newY[i2] = newY1[i2] = py;
      }
    }
    const FS = new Set(F);
    const LS = new Set(L);
    const V = fromY === "y" ? newY : newY1;
    const V1 = fromY1 === "y" ? newY : newY1;
    return [
      I,
      deep_mix_default({}, mark2, {
        encode: {
          y0: inferredColumn(Y, fy),
          y: column(V, fy),
          y1: column(V1, fy1)
        },
        style: Object.assign({ first: (_2, i) => FS.has(i), last: (_2, i) => LS.has(i) }, style)
      })
    ];
  };
};
StackY.props = {};

// node_modules/@antv/g2/esm/transform/maybeStackY.js
function exclude(transform3) {
  const { type } = transform3;
  const excludes = ["stackY", "dodgeX", "groupX"];
  return typeof type === "string" && excludes.includes(type);
}
var MaybeStackY = (options) => {
  return (I, mark2, context) => {
    const { encode, transform: transform3 = [] } = mark2;
    if (transform3.some(exclude))
      return [I, mark2];
    const { x: x3, y: y3 } = encode;
    if (x3 === void 0 || y3 === void 0)
      return [I, mark2];
    const { series } = options;
    const groupBy3 = series ? ["x", "series"] : "x";
    return StackY({ groupBy: groupBy3 })(I, mark2, context);
  };
};
MaybeStackY.props = {};

// node_modules/@antv/g2/esm/utils/dateFormat.js
function fillZero(digit) {
  if (Math.abs(digit) > 10)
    return String(digit);
  return digit.toString().padStart(2, "0");
}
function dynamicFormatDateTime(date) {
  const year2 = date.getFullYear();
  const month2 = fillZero(date.getMonth() + 1);
  const day2 = fillZero(date.getDate());
  const yyyyMMDD = `${year2}-${month2}-${day2}`;
  const hour2 = date.getHours();
  const minutes = date.getMinutes();
  const seconds = date.getSeconds();
  if (hour2 || minutes || seconds)
    return `${yyyyMMDD} ${fillZero(hour2)}:${fillZero(minutes)}:${fillZero(seconds)}`;
  return yyyyMMDD;
}

// node_modules/@antv/g2/esm/transform/maybeTitle.js
var MaybeTitle = (options = {}) => {
  const { channel = "x" } = options;
  return (I, mark2) => {
    const { encode } = mark2;
    const { tooltip: tooltip2 } = mark2;
    if (isUnset(tooltip2))
      return [I, mark2];
    const { title } = tooltip2;
    if (title !== void 0)
      return [I, mark2];
    const titles = Object.keys(encode).filter((key) => key.startsWith(channel)).filter((key) => !encode[key].inferred).map((key) => columnOf(encode, key)).filter(([T2]) => T2).map((d2) => d2[0]);
    if (titles.length === 0)
      return [I, mark2];
    const T = [];
    for (const i of I) {
      T[i] = {
        value: titles.map((t) => t[i] instanceof Date ? dynamicFormatDateTime(t[i]) : t[i]).join(", ")
      };
    }
    return [
      I,
      deep_mix_default({}, mark2, {
        tooltip: {
          title: T
        }
      })
    ];
  };
};
MaybeTitle.props = {};

// node_modules/@antv/g2/esm/transform/maybeZeroX.js
var MaybeZeroX = () => {
  return (I, mark2) => {
    const { encode } = mark2;
    const { x: x3 } = encode;
    if (x3 !== void 0)
      return [I, mark2];
    return [
      I,
      deep_mix_default({}, mark2, {
        encode: { x: inferredColumn(constant(I, 0)) },
        scale: { x: { guide: null } }
      })
    ];
  };
};
MaybeZeroX.props = {};

// node_modules/@antv/g2/esm/transform/maybeZeroY.js
var MaybeZeroY = () => {
  return (I, mark2) => {
    const { encode } = mark2;
    const { y: y3 } = encode;
    if (y3 !== void 0)
      return [I, mark2];
    return [
      I,
      deep_mix_default({}, mark2, {
        encode: { y: inferredColumn(constant(I, 0)) },
        scale: { y: { guide: null } }
      })
    ];
  };
};
MaybeZeroY.props = {};

// node_modules/@antv/g2/esm/transform/maybeZeroZ.js
var MaybeZeroZ = () => {
  return (I, mark2) => {
    const { encode } = mark2;
    const { z } = encode;
    if (z !== void 0)
      return [I, mark2];
    return [
      I,
      deep_mix_default({}, mark2, {
        encode: { z: inferredColumn(constant(I, 0)) },
        scale: { z: { guide: null } }
      })
    ];
  };
};
MaybeZeroZ.props = {};

// node_modules/@antv/g2/esm/transform/maybeSize.js
var MaybeSize = () => {
  return (I, mark2) => {
    const { encode } = mark2;
    const { size: size5 } = encode;
    if (size5 !== void 0)
      return [I, mark2];
    return [
      I,
      deep_mix_default({}, mark2, { encode: { size: visualColumn(constant(I, 3)) } })
    ];
  };
};
MaybeSize.props = {};

// node_modules/@antv/g2/esm/transform/maybeKey.js
var __rest2 = function(s2, e) {
  var t = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
      t[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t[p2[i]] = s2[p2[i]];
    }
  return t;
};
var MaybeKey = () => {
  return (I, mark2) => {
    const { encode } = mark2;
    const { key } = encode, rest2 = __rest2(encode, ["key"]);
    if (key !== void 0)
      return [I, mark2];
    const values4 = Object.values(rest2).map(({ value: value2 }) => value2);
    const K2 = I.map((i) => values4.filter(Array.isArray).map((V) => V[i]).join("-"));
    return [I, deep_mix_default({}, mark2, { encode: { key: column(K2) } })];
  };
};
MaybeKey.props = {};

// node_modules/@antv/g2/esm/transform/maybeSeries.js
var MaybeSeries = () => {
  return (I, mark2) => {
    const { encode } = mark2;
    const { series, color: color2 } = encode;
    if (series !== void 0 || color2 === void 0)
      return [I, mark2];
    const [C3, fc] = columnOf(encode, "color");
    return [I, deep_mix_default({}, mark2, { encode: { series: column(C3, fc) } })];
  };
};
MaybeSeries.props = {};

// node_modules/@antv/g2/esm/transform/maybeTupleY.js
var MaybeTupleY = () => {
  return (I, mark2) => {
    const { data: data2 } = mark2;
    if (!Array.isArray(data2) || data2.some(isObject))
      return [I, mark2];
    return [I, deep_mix_default({}, mark2, { encode: { y: column(data2) } })];
  };
};
MaybeTupleY.props = {};

// node_modules/@antv/g2/esm/transform/maybeTupleX.js
var MaybeTupleX = () => {
  return (I, mark2) => {
    const { data: data2 } = mark2;
    if (!Array.isArray(data2) || data2.some(isObject))
      return [I, mark2];
    return [I, deep_mix_default({}, mark2, { encode: { x: column(data2) } })];
  };
};
MaybeTupleX.props = {};

// node_modules/@antv/g2/esm/transform/maybeIdentityY.js
var MaybeIdentityY = () => {
  return (I, mark2) => {
    const { encode } = mark2;
    const { y1: y12 } = encode;
    if (y12)
      return [I, mark2];
    const [Y] = columnOf(encode, "y");
    return [I, deep_mix_default({}, mark2, { encode: { y1: column([...Y]) } })];
  };
};
MaybeIdentityY.props = {};

// node_modules/@antv/g2/esm/transform/maybeIdentityX.js
var MaybeIdentityX = () => {
  return (I, mark2) => {
    const { encode } = mark2;
    const { x1: x12 } = encode;
    if (x12)
      return [I, mark2];
    const [X] = columnOf(encode, "x");
    return [I, deep_mix_default({}, mark2, { encode: { x1: column([...X]) } })];
  };
};
MaybeIdentityX.props = {};

// node_modules/@antv/g2/esm/transform/maybeDefaultX.js
var MaybeDefaultX = () => {
  return (I, mark2) => {
    const { data: data2 } = mark2;
    if (Array.isArray(data2) && (data2.every(Array.isArray) || !data2.some(isObject))) {
      const extractX = (data3, index3) => Array.isArray(data3[0]) ? data3.map((item) => item[index3]) : [data3[index3]];
      return [
        I,
        deep_mix_default({}, mark2, {
          encode: {
            x: column(extractX(data2, 0)),
            x1: column(extractX(data2, 1))
          }
        })
      ];
    }
    return [I, mark2];
  };
};
MaybeDefaultX.props = {};

// node_modules/@antv/g2/esm/transform/maybeDefaultY.js
var MaybeDefaultY = () => {
  return (I, mark2) => {
    const { data: data2 } = mark2;
    if (Array.isArray(data2) && (data2.every(Array.isArray) || !data2.some(isObject))) {
      const extractY = (data3, index3) => Array.isArray(data3[0]) ? data3.map((item) => item[index3]) : [data3[index3]];
      return [
        I,
        deep_mix_default({}, mark2, {
          encode: {
            y: column(extractY(data2, 0)),
            y1: column(extractY(data2, 1))
          }
        })
      ];
    }
    return [I, mark2];
  };
};
MaybeDefaultY.props = {};

// node_modules/@antv/g2/esm/transform/maybeTooltip.js
var MaybeTooltip = (options) => {
  const { channel } = options;
  return (I, mark2) => {
    const { encode, tooltip: tooltip2 } = mark2;
    if (isUnset(tooltip2))
      return [I, mark2];
    const { items = [] } = tooltip2;
    if (!items || items.length > 0)
      return [I, mark2];
    const channels = Array.isArray(channel) ? channel : [channel];
    const newItems = channels.flatMap((channel2) => Object.keys(encode).filter((key) => key.startsWith(channel2)).map((key) => {
      const { field: field3, value: value2, inferred = false, aggregate } = encode[key];
      if (inferred)
        return null;
      if (aggregate && value2)
        return { channel: key };
      if (field3)
        return { field: field3 };
      if (value2)
        return { channel: key };
      return null;
    }).filter((d2) => d2 !== null));
    return [I, deep_mix_default({}, mark2, { tooltip: { items: newItems } })];
  };
};
MaybeTooltip.props = {};

// node_modules/@antv/g2/esm/transform/maybeZeroPadding.js
var MaybeZeroPadding = () => {
  return (I, mark2) => {
    return [
      I,
      deep_mix_default({ scale: { x: { padding: 0 }, y: { padding: 0 } } }, mark2)
    ];
  };
};
MaybeZeroPadding.props = {};

// node_modules/@antv/g2/esm/transform/maybeVisualPosition.js
var __rest3 = function(s2, e) {
  var t = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
      t[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t[p2[i]] = s2[p2[i]];
    }
  return t;
};
var MaybeVisualPosition = () => {
  return (I, mark2) => {
    const { data: data2, style = {} } = mark2, restMark = __rest3(mark2, ["data", "style"]);
    const { x: x05, y: y05 } = style, rest2 = __rest3(style, ["x", "y"]);
    if (x05 == void 0 || y05 == void 0)
      return [I, mark2];
    const x3 = x05 || 0;
    const y3 = y05 || 0;
    return [
      [0],
      deep_mix_default({}, restMark, {
        data: [0],
        cartesian: true,
        encode: {
          x: column([x3]),
          y: column([y3])
        },
        scale: {
          x: { type: "identity", independent: true, guide: null },
          y: { type: "identity", independent: true, guide: null }
          // hide axis
        },
        style: rest2
      })
    ];
  };
};
MaybeVisualPosition.props = {};

// node_modules/@antv/g2/esm/transform/maybeFunctionAttribute.js
var MaybeFunctionAttribute = () => {
  return (I, mark2) => {
    const { style = {} } = mark2;
    return [
      I,
      deep_mix_default({}, mark2, {
        style: Object.assign(Object.assign({}, style), Object.fromEntries(Object.entries(style).filter(([, v]) => typeof v === "function").map(([k2, v]) => [k2, () => v])))
      })
    ];
  };
};
MaybeFunctionAttribute.props = {};

// node_modules/@antv/g2/esm/transform/maybeTuple.js
var MaybeTuple = () => {
  return (I, mark2) => {
    const { data: data2 } = mark2;
    if (!Array.isArray(data2) || data2.some(isObject))
      return [I, mark2];
    const position = Array.isArray(data2[0]) ? data2 : [data2];
    const X = position.map((d2) => d2[0]);
    const Y = position.map((d2) => d2[1]);
    return [I, deep_mix_default({}, mark2, { encode: { x: column(X), y: column(Y) } })];
  };
};
MaybeTuple.props = {};

// node_modules/@antv/g2/esm/transform/maybeGradient.js
var MaybeGradient = () => {
  return (I, mark2) => {
    const { style = {}, encode } = mark2;
    const { series } = encode;
    const { gradient: gradient2 } = style;
    if (!gradient2 || series)
      return [I, mark2];
    return [
      I,
      deep_mix_default({}, mark2, {
        encode: {
          series: visualColumn(constant(I, void 0))
        }
      })
    ];
  };
};
MaybeGradient.props = {};

// node_modules/@antv/g2/esm/transform/dodgeX.js
var __rest4 = function(s2, e) {
  var t = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
      t[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t[p2[i]] = s2[p2[i]];
    }
  return t;
};
var DodgeX = (options = {}) => {
  const { groupBy: groupBy3 = "x", reverse: reverse3 = false, orderBy: orderBy2, padding } = options, rest2 = __rest4(options, ["groupBy", "reverse", "orderBy", "padding"]);
  return (I, mark2) => {
    const { data: data2, encode, scale: scale10 } = mark2;
    const { series: scaleSeries } = scale10;
    const [Y] = columnOf(encode, "y");
    const [S] = maybeColumnOf(encode, "series", "color");
    const domainSeries = domainOf(S, scaleSeries);
    const groups2 = createGroups(groupBy3, I, mark2);
    const createComparator = normalizeComparator(orderBy2);
    const comparator = createComparator(data2, Y, S);
    if (comparator)
      applyOrder(groups2, comparator);
    const newS = new Array(I.length);
    for (const G of groups2) {
      if (reverse3)
        G.reverse();
      for (let i = 0; i < G.length; i++) {
        newS[G[i]] = domainSeries[i];
      }
    }
    return [
      I,
      deep_mix_default({}, mark2, {
        scale: {
          series: {
            domain: domainSeries,
            paddingInner: padding
          }
        },
        encode: {
          series: column(newS)
        }
      })
    ];
  };
};
DodgeX.props = {};

// node_modules/@antv/g2/esm/transform/stackEnter.js
var StackEnter = (options) => {
  const { groupBy: groupBy3 = ["x"], reducer = (I, V) => V[I[0]], orderBy: orderBy2 = null, reverse: reverse3 = false, duration } = options;
  return (I, mark2) => {
    const { encode } = mark2;
    const by = Array.isArray(groupBy3) ? groupBy3 : [groupBy3];
    const groupEntries = by.map((k2) => [k2, columnOf(encode, k2)[0]]);
    if (groupEntries.length === 0)
      return [I, mark2];
    let groups2 = [I];
    for (const [, V] of groupEntries) {
      const newGroups = [];
      for (const I2 of groups2) {
        const G = Array.from(group(I2, (i) => V[i]).values());
        newGroups.push(...G);
      }
      groups2 = newGroups;
    }
    if (orderBy2) {
      const [V] = columnOf(encode, orderBy2);
      if (V)
        groups2.sort((I2, J) => reducer(I2, V) - reducer(J, V));
      if (reverse3)
        groups2.reverse();
    }
    const t = (duration || 3e3) / groups2.length;
    const [ED2] = duration ? [constant(I, t)] : maybeColumnOf(encode, "enterDuration", constant(I, t));
    const [EDL] = maybeColumnOf(encode, "enterDelay", constant(I, 0));
    const newEnterDelay = new Array(I.length);
    for (let i = 0, pd = 0; i < groups2.length; i++) {
      const I2 = groups2[i];
      const maxDuration = max4(I2, (i2) => +ED2[i2]);
      for (const j of I2)
        newEnterDelay[j] = +EDL[j] + pd;
      pd += maxDuration;
    }
    return [
      I,
      deep_mix_default({}, mark2, {
        encode: {
          enterDuration: visualColumn(ED2),
          enterDelay: visualColumn(newEnterDelay)
        }
      })
    ];
  };
};
StackEnter.props = {};

// node_modules/@antv/g2/esm/transform/normalizeY.js
var __rest5 = function(s2, e) {
  var t = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
      t[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t[p2[i]] = s2[p2[i]];
    }
  return t;
};
function normalizeBasis(basis2) {
  if (typeof basis2 === "function")
    return basis2;
  const registry = {
    min: (I, Y) => min4(I, (i) => Y[+i]),
    max: (I, Y) => max4(I, (i) => Y[+i]),
    first: (I, Y) => Y[I[0]],
    last: (I, Y) => Y[I[I.length - 1]],
    mean: (I, Y) => mean(I, (i) => Y[+i]),
    median: (I, Y) => median(I, (i) => Y[+i]),
    sum: (I, Y) => sum(I, (i) => Y[+i]),
    deviation: (I, Y) => deviation(I, (i) => Y[+i])
  };
  return registry[basis2] || max4;
}
var NormalizeY = (options = {}) => {
  const { groupBy: groupBy3 = "x", basis: basis2 = "max" } = options;
  return (I, mark2) => {
    const { encode, tooltip: tooltip2 } = mark2;
    const { x: x3 } = encode, rest2 = __rest5(encode, ["x"]);
    const Yn2 = Object.entries(rest2).filter(([k2]) => k2.startsWith("y")).map(([k2]) => [k2, columnOf(encode, k2)[0]]);
    const [, Y] = Yn2.find(([k2]) => k2 === "y");
    const newYn = Yn2.map(([k2]) => [k2, new Array(I.length)]);
    const groups2 = createGroups(groupBy3, I, mark2);
    const basisFunction = normalizeBasis(basis2);
    for (const I2 of groups2) {
      const basisValue = basisFunction(I2, Y);
      for (const i of I2) {
        for (let j = 0; j < Yn2.length; j++) {
          const [, V] = Yn2[j];
          const [, newV] = newYn[j];
          newV[i] = +V[i] / basisValue;
        }
      }
    }
    const specifiedTooltip = isUnset(tooltip2) || (tooltip2 === null || tooltip2 === void 0 ? void 0 : tooltip2.items) && (tooltip2 === null || tooltip2 === void 0 ? void 0 : tooltip2.items.length) !== 0;
    return [
      I,
      deep_mix_default({}, mark2, Object.assign({ encode: Object.fromEntries(newYn.map(([k2, v]) => [k2, column(v, columnOf(encode, k2)[1])])) }, !specifiedTooltip && encode.y0 && {
        tooltip: { items: [{ channel: "y0" }] }
      }))
    ];
  };
};
NormalizeY.props = {};

// node_modules/@antv/scale/esm/utils/compose.js
function compose2(fn, ...rest2) {
  return rest2.reduce((pre, cur) => (x3) => pre(cur(x3)), fn);
}

// node_modules/@antv/scale/esm/utils/normalize.js
function createNormalize(a4, b) {
  return b - a4 ? (t) => (t - a4) / (b - a4) : (_2) => 0.5;
}

// node_modules/@antv/scale/esm/utils/clamp.js
function createClamp(a4, b) {
  const lo = b < a4 ? b : a4;
  const hi = a4 > b ? a4 : b;
  return (x3) => Math.min(Math.max(lo, x3), hi);
}

// node_modules/@antv/scale/esm/utils/bisect.js
function bisect(array2, x3, lo, hi, getter) {
  let i = lo || 0;
  let j = hi || array2.length;
  const get3 = getter || ((x4) => x4);
  while (i < j) {
    const mid2 = Math.floor((i + j) / 2);
    if (get3(array2[mid2]) > x3) {
      j = mid2;
    } else {
      i = mid2 + 1;
    }
  }
  return i;
}

// node_modules/@antv/scale/esm/utils/ticks.js
var e102 = Math.sqrt(50);
var e52 = Math.sqrt(10);
var e22 = Math.sqrt(2);
function tickIncrement2(start, stop, count4) {
  const step2 = (stop - start) / Math.max(0, count4);
  const power = Math.floor(Math.log(step2) / Math.LN10);
  const error3 = step2 / 10 ** power;
  if (power >= 0) {
    return (error3 >= e102 ? 10 : error3 >= e52 ? 5 : error3 >= e22 ? 2 : 1) * 10 ** power;
  }
  return -(10 ** -power) / (error3 >= e102 ? 10 : error3 >= e52 ? 5 : error3 >= e22 ? 2 : 1);
}
function tickStep2(start, stop, count4) {
  const step0 = Math.abs(stop - start) / Math.max(0, count4);
  let step1 = 10 ** Math.floor(Math.log(step0) / Math.LN10);
  const error3 = step0 / step1;
  if (error3 >= e102)
    step1 *= 10;
  else if (error3 >= e52)
    step1 *= 5;
  else if (error3 >= e22)
    step1 *= 2;
  return stop < start ? -step1 : step1;
}

// node_modules/@antv/scale/esm/utils/d3-linear-nice.js
var d3LinearNice = (min11, max11, count4 = 5) => {
  const d2 = [min11, max11];
  let i0 = 0;
  let i1 = d2.length - 1;
  let start = d2[i0];
  let stop = d2[i1];
  let step2;
  if (stop < start) {
    [start, stop] = [stop, start];
    [i0, i1] = [i1, i0];
  }
  step2 = tickIncrement2(start, stop, count4);
  if (step2 > 0) {
    start = Math.floor(start / step2) * step2;
    stop = Math.ceil(stop / step2) * step2;
    step2 = tickIncrement2(start, stop, count4);
  } else if (step2 < 0) {
    start = Math.ceil(start * step2) / step2;
    stop = Math.floor(stop * step2) / step2;
    step2 = tickIncrement2(start, stop, count4);
  }
  if (step2 > 0) {
    d2[i0] = Math.floor(start / step2) * step2;
    d2[i1] = Math.ceil(stop / step2) * step2;
  } else if (step2 < 0) {
    d2[i0] = Math.ceil(start * step2) / step2;
    d2[i1] = Math.floor(stop * step2) / step2;
  }
  return d2;
};

// node_modules/@antv/scale/esm/utils/time-interval.js
var DURATION_SECOND = 1e3;
var DURATION_MINUTE = DURATION_SECOND * 60;
var DURATION_HOUR = DURATION_MINUTE * 60;
var DURATION_DAY = DURATION_HOUR * 24;
var DURATION_WEEK = DURATION_DAY * 7;
var DURATION_MONTH = DURATION_DAY * 30;
var DURATION_YEAR = DURATION_DAY * 365;
function createInterval(duration, floorish, offseti, field3) {
  const adjust2 = (date, step2) => {
    const test = (date2) => field3(date2) % step2 === 0;
    let i = step2;
    while (i && !test(date)) {
      offseti(date, -1);
      i -= 1;
    }
    return date;
  };
  const floori = (date, step2) => {
    if (step2)
      adjust2(date, step2);
    floorish(date);
  };
  const floor5 = (date, step2) => {
    const d2 = /* @__PURE__ */ new Date(+date);
    floori(d2, step2);
    return d2;
  };
  const ceil6 = (date, step2) => {
    const d2 = new Date(+date - 1);
    floori(d2, step2);
    offseti(d2, step2);
    floori(d2);
    return d2;
  };
  const range4 = (start, stop, step2, shouldAdjust) => {
    const ticks2 = [];
    const roundStep = Math.floor(step2);
    const t = shouldAdjust ? ceil6(start, step2) : ceil6(start);
    for (let i = t; i < stop; offseti(i, roundStep), floori(i)) {
      ticks2.push(/* @__PURE__ */ new Date(+i));
    }
    return ticks2;
  };
  return {
    ceil: ceil6,
    floor: floor5,
    range: range4,
    duration
  };
}
var millisecond = createInterval(1, (date) => date, (date, step2 = 1) => {
  date.setTime(+date + step2);
}, (date) => date.getTime());
var second = createInterval(DURATION_SECOND, (date) => {
  date.setMilliseconds(0);
}, (date, step2 = 1) => {
  date.setTime(+date + DURATION_SECOND * step2);
}, (date) => date.getSeconds());
var minute = createInterval(DURATION_MINUTE, (date) => {
  date.setSeconds(0, 0);
}, (date, step2 = 1) => {
  date.setTime(+date + DURATION_MINUTE * step2);
}, (date) => date.getMinutes());
var hour = createInterval(DURATION_HOUR, (date) => {
  date.setMinutes(0, 0, 0);
}, (date, step2 = 1) => {
  date.setTime(+date + DURATION_HOUR * step2);
}, (date) => date.getHours());
var day = createInterval(DURATION_DAY, (date) => {
  date.setHours(0, 0, 0, 0);
}, (date, step2 = 1) => {
  date.setTime(+date + DURATION_DAY * step2);
}, (date) => date.getDate() - 1);
var month = createInterval(DURATION_MONTH, (date) => {
  date.setDate(1);
  date.setHours(0, 0, 0, 0);
}, (date, step2 = 1) => {
  const month2 = date.getMonth();
  date.setMonth(month2 + step2);
}, (date) => date.getMonth());
var week = createInterval(DURATION_WEEK, (date) => {
  date.setDate(date.getDate() - date.getDay() % 7);
  date.setHours(0, 0, 0, 0);
}, (date, step2 = 1) => {
  date.setDate(date.getDate() + 7 * step2);
}, (date) => {
  const start = month.floor(date);
  const end = /* @__PURE__ */ new Date(+date);
  return Math.floor((+end - +start) / DURATION_WEEK);
});
var year = createInterval(DURATION_YEAR, (date) => {
  date.setMonth(0, 1);
  date.setHours(0, 0, 0, 0);
}, (date, step2 = 1) => {
  const year2 = date.getFullYear();
  date.setFullYear(year2 + step2);
}, (date) => date.getFullYear());
var localIntervalMap = {
  millisecond,
  second,
  minute,
  hour,
  day,
  week,
  month,
  year
};

// node_modules/@antv/scale/esm/utils/utc-interval.js
var utcMillisecond = createInterval(1, (date) => date, (date, step2 = 1) => {
  date.setTime(+date + step2);
}, (date) => date.getTime());
var utcSecond = createInterval(DURATION_SECOND, (date) => {
  date.setUTCMilliseconds(0);
}, (date, step2 = 1) => {
  date.setTime(+date + DURATION_SECOND * step2);
}, (date) => date.getUTCSeconds());
var utcMinute = createInterval(DURATION_MINUTE, (date) => {
  date.setUTCSeconds(0, 0);
}, (date, step2 = 1) => {
  date.setTime(+date + DURATION_MINUTE * step2);
}, (date) => date.getUTCMinutes());
var utcHour = createInterval(DURATION_HOUR, (date) => {
  date.setUTCMinutes(0, 0, 0);
}, (date, step2 = 1) => {
  date.setTime(+date + DURATION_HOUR * step2);
}, (date) => date.getUTCHours());
var utcDay = createInterval(DURATION_DAY, (date) => {
  date.setUTCHours(0, 0, 0, 0);
}, (date, step2 = 1) => {
  date.setTime(+date + DURATION_DAY * step2);
}, (date) => date.getUTCDate() - 1);
var utcMonth = createInterval(DURATION_MONTH, (date) => {
  date.setUTCDate(1);
  date.setUTCHours(0, 0, 0, 0);
}, (date, step2 = 1) => {
  const month2 = date.getUTCMonth();
  date.setUTCMonth(month2 + step2);
}, (date) => date.getUTCMonth());
var utcWeek = createInterval(DURATION_WEEK, (date) => {
  date.setUTCDate(date.getUTCDate() - (date.getUTCDay() + 7) % 7);
  date.setUTCHours(0, 0, 0, 0);
}, (date, step2 = 1) => {
  date.setTime(+date + DURATION_WEEK * step2);
}, (date) => {
  const start = utcMonth.floor(date);
  const end = /* @__PURE__ */ new Date(+date);
  return Math.floor((+end - +start) / DURATION_WEEK);
});
var utcYear = createInterval(DURATION_YEAR, (date) => {
  date.setUTCMonth(0, 1);
  date.setUTCHours(0, 0, 0, 0);
}, (date, step2 = 1) => {
  const year2 = date.getUTCFullYear();
  date.setUTCFullYear(year2 + step2);
}, (date) => date.getUTCFullYear());
var utcIntervalMap = {
  millisecond: utcMillisecond,
  second: utcSecond,
  minute: utcMinute,
  hour: utcHour,
  day: utcDay,
  week: utcWeek,
  month: utcMonth,
  year: utcYear
};

// node_modules/@antv/scale/esm/utils/find-tick-interval.js
function chooseTickIntervals(utc) {
  const intervalMap = utc ? utcIntervalMap : localIntervalMap;
  const { year: year2, month: month2, week: week2, day: day2, hour: hour2, minute: minute2, second: second2, millisecond: millisecond2 } = intervalMap;
  const tickIntervals = [
    [second2, 1],
    [second2, 5],
    [second2, 15],
    [second2, 30],
    [minute2, 1],
    [minute2, 5],
    [minute2, 15],
    [minute2, 30],
    [hour2, 1],
    [hour2, 3],
    [hour2, 6],
    [hour2, 12],
    [day2, 1],
    [day2, 2],
    [week2, 1],
    [month2, 1],
    [month2, 3],
    [year2, 1]
  ];
  return {
    tickIntervals,
    year: year2,
    millisecond: millisecond2
  };
}
function findTickInterval(start, stop, count4, interval2, utc) {
  const lo = +start;
  const hi = +stop;
  const { tickIntervals, year: year2, millisecond: millisecond2 } = chooseTickIntervals(utc);
  const getter = ([interval3, count5]) => interval3.duration * count5;
  const targetCount = interval2 ? (hi - lo) / interval2 : count4 || 5;
  const targetInterval = interval2 || (hi - lo) / targetCount;
  const len5 = tickIntervals.length;
  const i = bisect(tickIntervals, targetInterval, 0, len5, getter);
  let matchInterval;
  if (i === len5) {
    const step2 = tickStep2(lo / year2.duration, hi / year2.duration, targetCount);
    matchInterval = [year2, step2];
  } else if (i) {
    const closeToLow = targetInterval / getter(tickIntervals[i - 1]) < getter(tickIntervals[i]) / targetInterval;
    const [timeInterval, targetStep] = closeToLow ? tickIntervals[i - 1] : tickIntervals[i];
    const step2 = interval2 ? Math.ceil(interval2 / timeInterval.duration) : targetStep;
    matchInterval = [timeInterval, step2];
  } else {
    const step2 = Math.max(tickStep2(lo, hi, targetCount), 1);
    matchInterval = [millisecond2, step2];
  }
  return matchInterval;
}

// node_modules/@antv/scale/esm/utils/d3-time-nice.js
var d3TimeNice = (min11, max11, count4, interval2, utc) => {
  const r = min11 > max11;
  const lo = r ? max11 : min11;
  const hi = r ? min11 : max11;
  const [tickInterval, step2] = findTickInterval(lo, hi, count4, interval2, utc);
  const domain = [tickInterval.floor(lo, step2), tickInterval.ceil(hi, step2)];
  return r ? domain.reverse() : domain;
};

// node_modules/@antv/scale/node_modules/@antv/util/esm/is-array-like.js
var isArrayLike2 = function(value2) {
  return value2 !== null && typeof value2 !== "function" && isFinite(value2.length);
};
var is_array_like_default2 = isArrayLike2;

// node_modules/@antv/scale/node_modules/@antv/util/esm/is-type.js
var toString3 = {}.toString;
var isType2 = function(value2, type) {
  return toString3.call(value2) === "[object " + type + "]";
};
var is_type_default2 = isType2;

// node_modules/@antv/scale/node_modules/@antv/util/esm/is-function.js
var is_function_default2 = function(value2) {
  return is_type_default2(value2, "Function");
};

// node_modules/@antv/scale/node_modules/@antv/util/esm/is-nil.js
var isNil2 = function(value2) {
  return value2 === null || value2 === void 0;
};
var is_nil_default2 = isNil2;

// node_modules/@antv/scale/node_modules/@antv/util/esm/is-array.js
var is_array_default2 = function(value2) {
  return Array.isArray ? Array.isArray(value2) : is_type_default2(value2, "Array");
};

// node_modules/@antv/scale/node_modules/@antv/util/esm/is-object.js
var is_object_default2 = function(value2) {
  var type = typeof value2;
  return value2 !== null && type === "object" || type === "function";
};

// node_modules/@antv/scale/node_modules/@antv/util/esm/each.js
function each2(elements, func) {
  if (!elements) {
    return;
  }
  var rst;
  if (is_array_default2(elements)) {
    for (var i = 0, len5 = elements.length; i < len5; i++) {
      rst = func(elements[i], i);
      if (rst === false) {
        break;
      }
    }
  } else if (is_object_default2(elements)) {
    for (var k2 in elements) {
      if (elements.hasOwnProperty(k2)) {
        rst = func(elements[k2], k2);
        if (rst === false) {
          break;
        }
      }
    }
  }
}
var each_default2 = each2;

// node_modules/@antv/scale/node_modules/@antv/util/esm/is-object-like.js
var isObjectLike2 = function(value2) {
  return typeof value2 === "object" && value2 !== null;
};
var is_object_like_default2 = isObjectLike2;

// node_modules/@antv/scale/node_modules/@antv/util/esm/is-plain-object.js
var isPlainObject2 = function(value2) {
  if (!is_object_like_default2(value2) || !is_type_default2(value2, "Object")) {
    return false;
  }
  if (Object.getPrototypeOf(value2) === null) {
    return true;
  }
  var proto = value2;
  while (Object.getPrototypeOf(proto) !== null) {
    proto = Object.getPrototypeOf(proto);
  }
  return Object.getPrototypeOf(value2) === proto;
};
var is_plain_object_default2 = isPlainObject2;

// node_modules/@antv/scale/node_modules/@antv/util/esm/pull.js
var arrPrototype2 = Array.prototype;
var splice3 = arrPrototype2.splice;
var indexOf3 = arrPrototype2.indexOf;

// node_modules/@antv/scale/node_modules/@antv/util/esm/pull-at.js
var splice4 = Array.prototype.splice;

// node_modules/@antv/scale/node_modules/@antv/util/esm/is-string.js
var is_string_default2 = function(str7) {
  return is_type_default2(str7, "String");
};

// node_modules/@antv/scale/node_modules/@antv/util/esm/is-number.js
var isNumber2 = function(value2) {
  return is_type_default2(value2, "Number");
};
var is_number_default2 = isNumber2;

// node_modules/@antv/scale/node_modules/@antv/util/esm/is-integer.js
var isInteger2 = Number.isInteger ? Number.isInteger : function(num) {
  return is_number_default2(num) && num % 1 === 0;
};

// node_modules/@antv/scale/node_modules/@antv/util/esm/to-degree.js
var DEGREE2 = 180 / Math.PI;

// node_modules/@antv/scale/node_modules/@antv/util/esm/to-radian.js
var RADIAN2 = Math.PI / 180;

// node_modules/@antv/scale/node_modules/@antv/util/esm/values.js
var values = Object.values ? function(obj) {
  return Object.values(obj);
} : function(obj) {
  var result2 = [];
  each_default2(obj, function(value2, key) {
    if (!(is_function_default2(obj) && key === "prototype")) {
      result2.push(value2);
    }
  });
  return result2;
};
var values_default2 = values;

// node_modules/@antv/scale/node_modules/@antv/util/esm/get-type.js
var toString4 = {}.toString;

// node_modules/@antv/scale/node_modules/@antv/util/esm/is-null.js
var isNull = function(value2) {
  return value2 === null;
};
var is_null_default2 = isNull;

// node_modules/@antv/scale/node_modules/@antv/util/esm/is-prototype.js
var objectProto2 = Object.prototype;

// node_modules/@antv/scale/node_modules/@antv/util/esm/is-undefined.js
var isUndefined2 = function(value2) {
  return value2 === void 0;
};
var is_undefined_default2 = isUndefined2;

// node_modules/@antv/scale/node_modules/@antv/util/esm/memoize.js
var memoize_default2 = function(f, resolver) {
  if (!is_function_default2(f)) {
    throw new TypeError("Expected a function");
  }
  var memoized = function() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    var key = resolver ? resolver.apply(this, args) : args[0];
    var cache2 = memoized.cache;
    if (cache2.has(key)) {
      return cache2.get(key);
    }
    var result2 = f.apply(this, args);
    cache2.set(key, result2);
    return result2;
  };
  memoized.cache = /* @__PURE__ */ new Map();
  return memoized;
};

// node_modules/@antv/scale/node_modules/@antv/util/esm/deep-mix.js
var MAX_MIX_LEVEL2 = 5;
function _deepMix2(dist5, src, level, maxLevel) {
  level = level || 0;
  maxLevel = maxLevel || MAX_MIX_LEVEL2;
  for (var key in src) {
    if (src.hasOwnProperty(key)) {
      var value2 = src[key];
      if (value2 !== null && is_plain_object_default2(value2)) {
        if (!is_plain_object_default2(dist5[key])) {
          dist5[key] = {};
        }
        if (level < maxLevel) {
          _deepMix2(dist5[key], value2, level + 1, maxLevel);
        } else {
          dist5[key] = src[key];
        }
      } else if (is_array_default2(value2)) {
        dist5[key] = [];
        dist5[key] = dist5[key].concat(value2);
      } else if (value2 !== void 0) {
        dist5[key] = value2;
      }
    }
  }
}
var deepMix2 = function(rst) {
  var args = [];
  for (var _i = 1; _i < arguments.length; _i++) {
    args[_i - 1] = arguments[_i];
  }
  for (var i = 0; i < args.length; i += 1) {
    _deepMix2(rst, args[i]);
  }
  return rst;
};
var deep_mix_default2 = deepMix2;

// node_modules/@antv/scale/node_modules/@antv/util/esm/index-of.js
var indexOf4 = function(arr, obj) {
  if (!is_array_like_default2(arr)) {
    return -1;
  }
  var m3 = Array.prototype.indexOf;
  if (m3) {
    return m3.call(arr, obj);
  }
  var index3 = -1;
  for (var i = 0; i < arr.length; i++) {
    if (arr[i] === obj) {
      index3 = i;
      break;
    }
  }
  return index3;
};
var index_of_default2 = indexOf4;

// node_modules/@antv/scale/node_modules/@antv/util/esm/identity.js
var identity_default2 = function(v) {
  return v;
};

// node_modules/@antv/scale/node_modules/@antv/util/esm/size.js
function size2(o) {
  if (is_nil_default2(o)) {
    return 0;
  }
  if (is_array_like_default2(o)) {
    return o.length;
  }
  return Object.keys(o).length;
}

// node_modules/@antv/scale/node_modules/@antv/util/esm/measure-text-width.js
var ctx;
var measure_text_width_default = memoize_default2(function(text, font) {
  if (font === void 0) {
    font = {};
  }
  var fontSize = font.fontSize, fontFamily = font.fontFamily, fontWeight = font.fontWeight, fontStyle = font.fontStyle, fontVariant = font.fontVariant;
  if (!ctx) {
    ctx = document.createElement("canvas").getContext("2d");
  }
  ctx.font = [fontStyle, fontVariant, fontWeight, fontSize + "px", fontFamily].join(" ");
  return ctx.measureText(is_string_default2(text) ? text : "").width;
}, function(text, font) {
  if (font === void 0) {
    font = {};
  }
  return __spreadArrays([text], values_default2(font)).join("");
});

// node_modules/@antv/scale/node_modules/@antv/util/esm/cache.js
var default_12 = (
  /** @class */
  function() {
    function default_14() {
      this.map = {};
    }
    default_14.prototype.has = function(key) {
      return this.map[key] !== void 0;
    };
    default_14.prototype.get = function(key, def) {
      var v = this.map[key];
      return v === void 0 ? def : v;
    };
    default_14.prototype.set = function(key, value2) {
      this.map[key] = value2;
    };
    default_14.prototype.clear = function() {
      this.map = {};
    };
    default_14.prototype.delete = function(key) {
      delete this.map[key];
    };
    default_14.prototype.size = function() {
      return Object.keys(this.map).length;
    };
    return default_14;
  }()
);

// node_modules/@antv/scale/esm/utils/is-valid.js
function isValid(x3) {
  return !is_undefined_default2(x3) && !is_null_default2(x3) && !Number.isNaN(x3);
}

// node_modules/@antv/scale/esm/utils/log.js
var reflect = (f) => {
  return (x3) => -f(-x3);
};
var logs = (base, shouldReflect) => {
  const baseCache = Math.log(base);
  const log2 = base === Math.E ? Math.log : base === 10 ? Math.log10 : base === 2 ? Math.log2 : (x3) => Math.log(x3) / baseCache;
  return shouldReflect ? reflect(log2) : log2;
};
var pows = (base, shouldReflect) => {
  const pow3 = base === Math.E ? Math.exp : (x3) => base ** x3;
  return shouldReflect ? reflect(pow3) : pow3;
};

// node_modules/@antv/scale/esm/utils/d3-log-nice.js
var d3LogNice = (a4, b, _2, base) => {
  const shouldReflect = a4 < 0;
  const log2 = logs(base, shouldReflect);
  const pow3 = pows(base, shouldReflect);
  const r = a4 > b;
  const min11 = r ? b : a4;
  const max11 = r ? a4 : b;
  const niceDomain = [pow3(Math.floor(log2(min11))), pow3(Math.ceil(log2(max11)))];
  return r ? niceDomain.reverse() : niceDomain;
};

// node_modules/@antv/scale/esm/utils/interpolatize.js
var createInterpolatorRound = (interpolator) => {
  return (t) => {
    const res = interpolator(t);
    return is_number_default2(res) ? Math.round(res) : res;
  };
};
function interpolatize(rangeOf5, normalizeDomain3) {
  return (Scale) => {
    Scale.prototype.rescale = function() {
      this.initRange();
      this.nice();
      const [transform3] = this.chooseTransforms();
      this.composeOutput(transform3, this.chooseClamp(transform3));
    };
    Scale.prototype.initRange = function() {
      const { interpolator } = this.options;
      this.options.range = rangeOf5(interpolator);
    };
    Scale.prototype.composeOutput = function(transform3, clamp4) {
      const { domain, interpolator, round: round6 } = this.getOptions();
      const normalize10 = normalizeDomain3(domain.map(transform3));
      const interpolate4 = round6 ? createInterpolatorRound(interpolator) : interpolator;
      this.output = compose2(interpolate4, normalize10, clamp4, transform3);
    };
    Scale.prototype.invert = void 0;
  };
}

// node_modules/@antv/scale/esm/utils/color.js
var import_color_string = __toESM(require_color_string());
function hue2rgb(p2, q, m3) {
  let t = m3;
  if (t < 0)
    t += 1;
  if (t > 1)
    t -= 1;
  if (t < 1 / 6)
    return p2 + (q - p2) * 6 * t;
  if (t < 1 / 2)
    return q;
  if (t < 2 / 3)
    return p2 + (q - p2) * (2 / 3 - t) * 6;
  return p2;
}
function hsl2rbg(hsl3) {
  const h = hsl3[0] / 360;
  const s2 = hsl3[1] / 100;
  const l = hsl3[2] / 100;
  const a4 = hsl3[3];
  if (s2 === 0)
    return [l * 255, l * 255, l * 255, a4];
  const q = l < 0.5 ? l * (1 + s2) : l + s2 - l * s2;
  const p2 = 2 * l - q;
  const r = hue2rgb(p2, q, h + 1 / 3);
  const g = hue2rgb(p2, q, h);
  const b = hue2rgb(p2, q, h - 1 / 3);
  return [r * 255, g * 255, b * 255, a4];
}
function string2rbg(s2) {
  const color2 = import_color_string.default.get(s2);
  if (!color2)
    return null;
  const { model, value: value2 } = color2;
  if (model === "rgb")
    return value2;
  if (model === "hsl")
    return hsl2rbg(value2);
  return null;
}

// node_modules/@antv/scale/esm/utils/interpolate.js
var createInterpolateNumber = (a4, b) => {
  return (t) => a4 * (1 - t) + b * t;
};
var createInterpolateColor = (a4, b) => {
  const c1 = string2rbg(a4);
  const c22 = string2rbg(b);
  if (c1 === null || c22 === null)
    return c1 ? () => a4 : () => b;
  return (t) => {
    const values4 = new Array(4);
    for (let i = 0; i < 4; i += 1) {
      const from = c1[i];
      const to = c22[i];
      values4[i] = from * (1 - t) + to * t;
    }
    const [r, g, b2, a5] = values4;
    return `rgba(${Math.round(r)}, ${Math.round(g)}, ${Math.round(b2)}, ${a5})`;
  };
};
var createInterpolateValue = (a4, b) => {
  if (typeof a4 === "number" && typeof b === "number")
    return createInterpolateNumber(a4, b);
  if (typeof a4 === "string" && typeof b === "string")
    return createInterpolateColor(a4, b);
  return () => a4;
};
var createInterpolateRound = (a4, b) => {
  const interpolateNumber = createInterpolateNumber(a4, b);
  return (t) => Math.round(interpolateNumber(t));
};

// node_modules/@antv/scale/esm/utils/choose-mask.js
function chooseNiceTimeMask(date, intervalMap) {
  const { second: second2, minute: minute2, hour: hour2, day: day2, week: week2, month: month2, year: year2 } = intervalMap;
  if (second2.floor(date) < date)
    return ".SSS";
  if (minute2.floor(date) < date)
    return ":ss";
  if (hour2.floor(date) < date)
    return "hh:mm";
  if (day2.floor(date) < date)
    return "hh A";
  if (month2.floor(date) < date) {
    if (week2.floor(date) < date)
      return "MMM DD";
    return "ddd DD";
  }
  if (year2.floor(date) < date)
    return "MMMM";
  return "YYYY";
}

// node_modules/@antv/scale/esm/utils/internMap.js
function internGet({ map: map5, initKey }, value2) {
  const key = initKey(value2);
  return map5.has(key) ? map5.get(key) : value2;
}
function internSet({ map: map5, initKey }, value2) {
  const key = initKey(value2);
  if (map5.has(key))
    return map5.get(key);
  map5.set(key, value2);
  return value2;
}
function internDelete({ map: map5, initKey }, value2) {
  const key = initKey(value2);
  if (map5.has(key)) {
    value2 = map5.get(key);
    map5.delete(key);
  }
  return value2;
}
function keyof2(value2) {
  return typeof value2 === "object" ? value2.valueOf() : value2;
}
var InternMap2 = class extends Map {
  constructor(entries) {
    super();
    this.map = /* @__PURE__ */ new Map();
    this.initKey = keyof2;
    if (entries !== null) {
      for (const [key, value2] of entries) {
        this.set(key, value2);
      }
    }
  }
  get(key) {
    return super.get(internGet({ map: this.map, initKey: this.initKey }, key));
  }
  has(key) {
    return super.has(internGet({ map: this.map, initKey: this.initKey }, key));
  }
  set(key, value2) {
    return super.set(internSet({ map: this.map, initKey: this.initKey }, key), value2);
  }
  delete(key) {
    return super.delete(internDelete({ map: this.map, initKey: this.initKey }, key));
  }
};

// node_modules/@antv/scale/esm/scales/base.js
var Base = class {
  /**
   * 
   * @param options 
   */
  constructor(options) {
    this.options = deep_mix_default2({}, this.getDefaultOptions());
    this.update(options);
  }
  /**
   * 
   * @returns 
   */
  getOptions() {
    return this.options;
  }
  /**
   * 
   * @param updateOptions 
   */
  update(updateOptions = {}) {
    this.options = deep_mix_default2({}, this.options, updateOptions);
    this.rescale(updateOptions);
  }
  /**
   *  options  options  scale 
   *  this.options  options
   * @param options  options
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  rescale(options) {
  }
};

// node_modules/@antv/scale/esm/scales/ordinal.js
var defaultUnknown = Symbol("defaultUnknown");
function updateIndexMap(target, arr, key) {
  for (let i = 0; i < arr.length; i += 1) {
    if (!target.has(arr[i])) {
      target.set(key(arr[i]), i);
    }
  }
}
function mapBetweenArrByMapIndex(options) {
  const { value: value2, from, to, mapper, notFoundReturn } = options;
  let mappedIndex = mapper.get(value2);
  if (mappedIndex === void 0) {
    if (notFoundReturn !== defaultUnknown) {
      return notFoundReturn;
    }
    mappedIndex = from.push(value2) - 1;
    mapper.set(value2, mappedIndex);
  }
  return to[mappedIndex % to.length];
}
function createKey(d2) {
  if (d2 instanceof Date)
    return (d3) => `${d3}`;
  if (typeof d2 === "object")
    return (d3) => JSON.stringify(d3);
  return (d3) => d3;
}
var Ordinal = class _Ordinal extends Base {
  // 
  getDefaultOptions() {
    return {
      domain: [],
      range: [],
      unknown: defaultUnknown
    };
  }
  //  options  OrdinalOptions O 
  constructor(options) {
    super(options);
  }
  map(x3) {
    if (this.domainIndexMap.size === 0) {
      updateIndexMap(this.domainIndexMap, this.getDomain(), this.domainKey);
    }
    return mapBetweenArrByMapIndex({
      value: this.domainKey(x3),
      mapper: this.domainIndexMap,
      from: this.getDomain(),
      to: this.getRange(),
      notFoundReturn: this.options.unknown
    });
  }
  invert(y3) {
    if (this.rangeIndexMap.size === 0) {
      updateIndexMap(this.rangeIndexMap, this.getRange(), this.rangeKey);
    }
    return mapBetweenArrByMapIndex({
      value: this.rangeKey(y3),
      mapper: this.rangeIndexMap,
      from: this.getRange(),
      to: this.getDomain(),
      notFoundReturn: this.options.unknown
    });
  }
  //  ordinal 
  rescale(options) {
    const [d2] = this.options.domain;
    const [r] = this.options.range;
    this.domainKey = createKey(d2);
    this.rangeKey = createKey(r);
    if (!this.rangeIndexMap) {
      this.rangeIndexMap = /* @__PURE__ */ new Map();
      this.domainIndexMap = /* @__PURE__ */ new Map();
      return;
    }
    if (!options || options.range) {
      this.rangeIndexMap.clear();
    }
    if (!options || options.domain || options.compare) {
      this.domainIndexMap.clear();
      this.sortedDomain = void 0;
    }
  }
  clone() {
    return new _Ordinal(this.options);
  }
  getRange() {
    return this.options.range;
  }
  getDomain() {
    if (this.sortedDomain)
      return this.sortedDomain;
    const { domain, compare } = this.options;
    this.sortedDomain = compare ? [...domain].sort(compare) : domain;
    return this.sortedDomain;
  }
};

// node_modules/@antv/scale/esm/scales/band.js
function normalize5(array2) {
  const min11 = Math.min(...array2);
  return array2.map((d2) => d2 / min11);
}
function splice5(array2, n) {
  const sn = array2.length;
  const diff = n - sn;
  return diff > 0 ? [...array2, ...new Array(diff).fill(1)] : diff < 0 ? array2.slice(0, n) : array2;
}
function pretty(n) {
  return Math.round(n * 1e12) / 1e12;
}
function computeFlexBandState(options) {
  const { domain, range: range4, paddingOuter, paddingInner, flex: F, round: round6, align } = options;
  const n = domain.length;
  const flex2 = splice5(F, n);
  const [start, end] = range4;
  const width = end - start;
  const ratio = 2 / n * paddingOuter + 1 - 1 / n * paddingInner;
  const stepSum = width / ratio;
  const PI = stepSum * paddingInner / n;
  const bandWidthSum = stepSum - n * PI;
  const normalizedFlex = normalize5(flex2);
  const flexSum = normalizedFlex.reduce((sum5, value2) => sum5 + value2);
  const minBandWidth = bandWidthSum / flexSum;
  const valueBandWidth = new InternMap2(domain.map((d2, i) => {
    const bandWidth3 = normalizedFlex[i] * minBandWidth;
    return [d2, round6 ? Math.floor(bandWidth3) : bandWidth3];
  }));
  const valueStep = new InternMap2(domain.map((d2, i) => {
    const bandWidth3 = normalizedFlex[i] * minBandWidth;
    const step2 = bandWidth3 + PI;
    return [d2, round6 ? Math.floor(step2) : step2];
  }));
  const finalStepSum = Array.from(valueStep.values()).reduce((sum5, value2) => sum5 + value2);
  const outerPaddingSum = width - (finalStepSum - finalStepSum / n * paddingInner);
  const offset2 = outerPaddingSum * align;
  const bandStart = start + offset2;
  let prev = round6 ? Math.round(bandStart) : bandStart;
  const adjustedRange = new Array(n);
  for (let i = 0; i < n; i += 1) {
    adjustedRange[i] = pretty(prev);
    const value2 = domain[i];
    prev += valueStep.get(value2);
  }
  return {
    valueBandWidth,
    valueStep,
    adjustedRange
  };
}
function computeBandState(options) {
  var _a2;
  const { domain } = options;
  const n = domain.length;
  if (n === 0) {
    return {
      valueBandWidth: void 0,
      valueStep: void 0,
      adjustedRange: []
    };
  }
  const hasFlex = !!((_a2 = options.flex) === null || _a2 === void 0 ? void 0 : _a2.length);
  if (hasFlex) {
    return computeFlexBandState(options);
  }
  const { range: range4, paddingOuter, paddingInner, round: round6, align } = options;
  let step2;
  let bandWidth3;
  let rangeStart = range4[0];
  const rangeEnd = range4[1];
  const deltaRange = rangeEnd - rangeStart;
  const outerTotal = paddingOuter * 2;
  const innerTotal = n - paddingInner;
  step2 = deltaRange / Math.max(1, outerTotal + innerTotal);
  if (round6) {
    step2 = Math.floor(step2);
  }
  rangeStart += (deltaRange - step2 * (n - paddingInner)) * align;
  bandWidth3 = step2 * (1 - paddingInner);
  if (round6) {
    rangeStart = Math.round(rangeStart);
    bandWidth3 = Math.round(bandWidth3);
  }
  const adjustedRange = new Array(n).fill(0).map((_2, i) => rangeStart + i * step2);
  return {
    valueStep: step2,
    valueBandWidth: bandWidth3,
    adjustedRange
  };
}
var Band = class _Band extends Ordinal {
  // 
  getDefaultOptions() {
    return {
      domain: [],
      range: [0, 1],
      align: 0.5,
      round: false,
      paddingInner: 0,
      paddingOuter: 0,
      padding: 0,
      unknown: defaultUnknown,
      flex: []
    };
  }
  //  options  OrdinalOptions O 
  constructor(options) {
    super(options);
  }
  clone() {
    return new _Band(this.options);
  }
  getStep(x3) {
    if (this.valueStep === void 0)
      return 1;
    if (typeof this.valueStep === "number") {
      return this.valueStep;
    }
    if (x3 === void 0)
      return Array.from(this.valueStep.values())[0];
    return this.valueStep.get(x3);
  }
  getBandWidth(x3) {
    if (this.valueBandWidth === void 0)
      return 1;
    if (typeof this.valueBandWidth === "number") {
      return this.valueBandWidth;
    }
    if (x3 === void 0)
      return Array.from(this.valueBandWidth.values())[0];
    return this.valueBandWidth.get(x3);
  }
  getRange() {
    return this.adjustedRange;
  }
  getPaddingInner() {
    const { padding, paddingInner } = this.options;
    return padding > 0 ? padding : paddingInner;
  }
  getPaddingOuter() {
    const { padding, paddingOuter } = this.options;
    return padding > 0 ? padding : paddingOuter;
  }
  rescale() {
    super.rescale();
    const { align, domain, range: range4, round: round6, flex: flex2 } = this.options;
    const { adjustedRange, valueBandWidth, valueStep } = computeBandState({
      align,
      range: range4,
      round: round6,
      flex: flex2,
      paddingInner: this.getPaddingInner(),
      paddingOuter: this.getPaddingOuter(),
      domain
    });
    this.valueStep = valueStep;
    this.valueBandWidth = valueBandWidth;
    this.adjustedRange = adjustedRange;
  }
};

// node_modules/@antv/scale/esm/tick-methods/d3-ticks.js
var d3Ticks = (begin, end, count4) => {
  let n;
  let ticks2;
  let start = begin;
  let stop = end;
  if (start === stop && count4 > 0) {
    return [start];
  }
  let step2 = tickIncrement2(start, stop, count4);
  if (step2 === 0 || !Number.isFinite(step2)) {
    return [];
  }
  if (step2 > 0) {
    start = Math.ceil(start / step2);
    stop = Math.floor(stop / step2);
    ticks2 = new Array(n = Math.ceil(stop - start + 1));
    for (let i = 0; i < n; i += 1) {
      ticks2[i] = (start + i) * step2;
    }
  } else {
    step2 = -step2;
    start = Math.ceil(start * step2);
    stop = Math.floor(stop * step2);
    ticks2 = new Array(n = Math.ceil(stop - start + 1));
    for (let i = 0; i < n; i += 1) {
      ticks2[i] = (start + i) / step2;
    }
  }
  return ticks2;
};

// node_modules/@antv/scale/esm/scales/constant.js
var Constant2 = class _Constant extends Base {
  /**
   * 
   * @returns 
   */
  getDefaultOptions() {
    return {
      range: [0],
      domain: [0, 1],
      unknown: void 0,
      tickCount: 5,
      tickMethod: d3Ticks
    };
  }
  /**
   * y = b b  options.range 
   * @param _ 
   * @returns 
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  map(_2) {
    const [v] = this.options.range;
    return v !== void 0 ? v : this.options.unknown;
  }
  /**
   *  x x === b []
   * @param x  (
   * @returns 
   */
  invert(x3) {
    const [v] = this.options.range;
    return x3 === v && v !== void 0 ? this.options.domain : [];
  }
  getTicks() {
    const { tickMethod, domain, tickCount } = this.options;
    const [a4, b] = domain;
    if (!is_number_default2(a4) || !is_number_default2(b))
      return [];
    return tickMethod(a4, b, tickCount);
  }
  /**
   *  Constant Scale
   * @returns  Constant Scale
   */
  clone() {
    return new _Constant(this.options);
  }
};

// node_modules/@antv/scale/esm/utils/pretty-number.js
function prettyNumber(n) {
  return Math.abs(n) < 1e-14 ? n : parseFloat(n.toFixed(14));
}

// node_modules/@antv/scale/esm/tick-methods/wilkinson-extended.js
var DEFAULT_Q = [1, 5, 2, 2.5, 4, 3];
var eps = Number.EPSILON * 100;
function mod2(n, m3) {
  return (n % m3 + m3) % m3;
}
function round4(n) {
  return Math.round(n * 1e12) / 1e12;
}
function simplicity(q, Q, j, lmin, lmax, lstep) {
  const n = size2(Q);
  const i = index_of_default2(Q, q);
  let v = 0;
  const m3 = mod2(lmin, lstep);
  if ((m3 < eps || lstep - m3 < eps) && lmin <= 0 && lmax >= 0) {
    v = 1;
  }
  return 1 - i / (n - 1) - j + v;
}
function simplicityMax(q, Q, j) {
  const n = size2(Q);
  const i = index_of_default2(Q, q);
  const v = 1;
  return 1 - i / (n - 1) - j + v;
}
function density(k2, m3, dMin, dMax, lMin, lMax) {
  const r = (k2 - 1) / (lMax - lMin);
  const rt = (m3 - 1) / (Math.max(lMax, dMax) - Math.min(dMin, lMin));
  return 2 - Math.max(r / rt, rt / r);
}
function densityMax(k2, m3) {
  if (k2 >= m3) {
    return 2 - (k2 - 1) / (m3 - 1);
  }
  return 1;
}
function coverage(dMin, dMax, lMin, lMax) {
  const range4 = dMax - dMin;
  return 1 - 0.5 * ((dMax - lMax) ** 2 + (dMin - lMin) ** 2) / (0.1 * range4) ** 2;
}
function coverageMax(dMin, dMax, span) {
  const range4 = dMax - dMin;
  if (span > range4) {
    const half = (span - range4) / 2;
    return 1 - half ** 2 / (0.1 * range4) ** 2;
  }
  return 1;
}
function legibility() {
  return 1;
}
var wilkinsonExtended = (dMin, dMax, n = 5, onlyLoose = true, Q = DEFAULT_Q, w = [0.25, 0.2, 0.5, 0.05]) => {
  const m3 = n < 0 ? 0 : Math.round(n);
  if (Number.isNaN(dMin) || Number.isNaN(dMax) || typeof dMin !== "number" || typeof dMax !== "number" || !m3) {
    return [];
  }
  if (dMax - dMin < 1e-15 || m3 === 1) {
    return [dMin];
  }
  const best = {
    score: -2,
    lmin: 0,
    lmax: 0,
    lstep: 0
  };
  let j = 1;
  while (j < Infinity) {
    for (let i = 0; i < Q.length; i += 1) {
      const q = Q[i];
      const sm = simplicityMax(q, Q, j);
      if (w[0] * sm + w[1] + w[2] + w[3] < best.score) {
        j = Infinity;
        break;
      }
      let k2 = 2;
      while (k2 < Infinity) {
        const dm = densityMax(k2, m3);
        if (w[0] * sm + w[1] + w[2] * dm + w[3] < best.score) {
          break;
        }
        const delta = (dMax - dMin) / (k2 + 1) / j / q;
        let z = Math.ceil(Math.log10(delta));
        while (z < Infinity) {
          const step2 = j * q * 10 ** z;
          const cm = coverageMax(dMin, dMax, step2 * (k2 - 1));
          if (w[0] * sm + w[1] * cm + w[2] * dm + w[3] < best.score) {
            break;
          }
          const minStart = Math.floor(dMax / step2) * j - (k2 - 1) * j;
          const maxStart = Math.ceil(dMin / step2) * j;
          if (minStart <= maxStart) {
            const count4 = maxStart - minStart;
            for (let i2 = 0; i2 <= count4; i2 += 1) {
              const start = minStart + i2;
              const lMin = start * (step2 / j);
              const lMax = lMin + step2 * (k2 - 1);
              const lStep = step2;
              const s2 = simplicity(q, Q, j, lMin, lMax, lStep);
              const c5 = coverage(dMin, dMax, lMin, lMax);
              const g = density(k2, m3, dMin, dMax, lMin, lMax);
              const l = legibility();
              const score2 = w[0] * s2 + w[1] * c5 + w[2] * g + w[3] * l;
              if (score2 > best.score && (!onlyLoose || lMin <= dMin && lMax >= dMax)) {
                best.lmin = lMin;
                best.lmax = lMax;
                best.lstep = lStep;
                best.score = score2;
              }
            }
          }
          z += 1;
        }
        k2 += 1;
      }
    }
    j += 1;
  }
  const lmax = prettyNumber(best.lmax);
  const lmin = prettyNumber(best.lmin);
  const lstep = prettyNumber(best.lstep);
  const tickCount = Math.floor(round4((lmax - lmin) / lstep)) + 1;
  const ticks2 = new Array(tickCount);
  ticks2[0] = prettyNumber(lmin);
  for (let i = 1; i < tickCount; i += 1) {
    ticks2[i] = prettyNumber(ticks2[i - 1] + lstep);
  }
  return ticks2;
};

// node_modules/@antv/scale/esm/scales/identity.js
var Identity = class _Identity extends Base {
  /**
   * 
   * @returns 
   */
  getDefaultOptions() {
    return {
      domain: [0, 1],
      range: [0, 1],
      tickCount: 5,
      unknown: void 0,
      tickMethod: wilkinsonExtended
    };
  }
  /**
   * y = x
   * @param x 
   * @returns 
   */
  map(x3) {
    return isValid(x3) ? x3 : this.options.unknown;
  }
  /**
   * map x = y map 
   * @param x 
   * @returns 
   */
  invert(x3) {
    return this.map(x3);
  }
  /**
   *  Identity Scale
   * @returns  Identity Scale
   */
  clone() {
    return new _Identity(this.options);
  }
  /**
   *  ticks ticks 
   * @returns  ticks 
   */
  getTicks() {
    const { domain, tickCount, tickMethod } = this.options;
    const [min11, max11] = domain;
    if (!is_number_default2(min11) || !is_number_default2(max11))
      return [];
    return tickMethod(min11, max11, tickCount);
  }
};

// node_modules/@antv/scale/esm/scales/continuous.js
var createBiMap = (domain, range4, createInterpolate) => {
  const [d0, d1] = domain;
  const [r0, r1] = range4;
  let normalize10;
  let interpolate4;
  if (d0 < d1) {
    normalize10 = createNormalize(d0, d1);
    interpolate4 = createInterpolate(r0, r1);
  } else {
    normalize10 = createNormalize(d1, d0);
    interpolate4 = createInterpolate(r1, r0);
  }
  return compose2(interpolate4, normalize10);
};
var createPolyMap = (domain, range4, createInterpolate) => {
  const len5 = Math.min(domain.length, range4.length) - 1;
  const normalizeList = new Array(len5);
  const interpolateList = new Array(len5);
  const reverse3 = domain[0] > domain[len5];
  const ascendingDomain = reverse3 ? [...domain].reverse() : domain;
  const ascendingRange = reverse3 ? [...range4].reverse() : range4;
  for (let i = 0; i < len5; i += 1) {
    normalizeList[i] = createNormalize(ascendingDomain[i], ascendingDomain[i + 1]);
    interpolateList[i] = createInterpolate(ascendingRange[i], ascendingRange[i + 1]);
  }
  return (x3) => {
    const i = bisect(domain, x3, 1, len5) - 1;
    const normalize10 = normalizeList[i];
    const interpolate4 = interpolateList[i];
    return compose2(interpolate4, normalize10)(x3);
  };
};
var choosePiecewise = (domain, range4, interpolate4, shouldRound) => {
  const n = Math.min(domain.length, range4.length);
  const createPiecewise = n > 2 ? createPolyMap : createBiMap;
  const createInterpolate = shouldRound ? createInterpolateRound : interpolate4;
  return createPiecewise(domain, range4, createInterpolate);
};
var Continuous = class extends Base {
  getDefaultOptions() {
    return {
      domain: [0, 1],
      range: [0, 1],
      nice: false,
      clamp: false,
      round: false,
      interpolate: createInterpolateNumber,
      tickCount: 5
    };
  }
  /**
   * y = interpolate(normalize(clamp(transform(x))))
   */
  map(x3) {
    if (!isValid(x3))
      return this.options.unknown;
    return this.output(x3);
  }
  /**
   * x = transform(clamp(interpolate(normalize(y))))
   */
  invert(x3) {
    if (!isValid(x3))
      return this.options.unknown;
    return this.input(x3);
  }
  nice() {
    if (!this.options.nice)
      return;
    const [min11, max11, tickCount, ...rest2] = this.getTickMethodOptions();
    this.options.domain = this.chooseNice()(min11, max11, tickCount, ...rest2);
  }
  getTicks() {
    const { tickMethod } = this.options;
    const [min11, max11, tickCount, ...rest2] = this.getTickMethodOptions();
    return tickMethod(min11, max11, tickCount, ...rest2);
  }
  getTickMethodOptions() {
    const { domain, tickCount } = this.options;
    const min11 = domain[0];
    const max11 = domain[domain.length - 1];
    return [min11, max11, tickCount];
  }
  chooseNice() {
    return d3LinearNice;
  }
  rescale() {
    this.nice();
    const [transform3, untransform] = this.chooseTransforms();
    this.composeOutput(transform3, this.chooseClamp(transform3));
    this.composeInput(transform3, untransform, this.chooseClamp(untransform));
  }
  chooseClamp(transform3) {
    const { clamp: shouldClamp, range: range4 } = this.options;
    const domain = this.options.domain.map(transform3);
    const n = Math.min(domain.length, range4.length);
    return shouldClamp ? createClamp(domain[0], domain[n - 1]) : identity_default2;
  }
  composeOutput(transform3, clamp4) {
    const { domain, range: range4, round: round6, interpolate: interpolate4 } = this.options;
    const piecewise2 = choosePiecewise(domain.map(transform3), range4, interpolate4, round6);
    this.output = compose2(piecewise2, clamp4, transform3);
  }
  composeInput(transform3, untransform, clamp4) {
    const { domain, range: range4 } = this.options;
    const piecewise2 = choosePiecewise(range4, domain.map(transform3), createInterpolateNumber);
    this.input = compose2(untransform, clamp4, piecewise2);
  }
};

// node_modules/@antv/scale/esm/scales/linear.js
var Linear = class _Linear extends Continuous {
  getDefaultOptions() {
    return {
      domain: [0, 1],
      range: [0, 1],
      unknown: void 0,
      nice: false,
      clamp: false,
      round: false,
      interpolate: createInterpolateValue,
      tickMethod: d3Ticks,
      tickCount: 5
    };
  }
  chooseTransforms() {
    return [identity_default2, identity_default2];
  }
  clone() {
    return new _Linear(this.options);
  }
};

// node_modules/@antv/scale/esm/scales/point.js
var Point = class _Point extends Band {
  // 
  getDefaultOptions() {
    return {
      domain: [],
      range: [0, 1],
      align: 0.5,
      round: false,
      padding: 0,
      unknown: defaultUnknown,
      paddingInner: 1,
      paddingOuter: 0
    };
  }
  //  PointOptions paddingInner 
  constructor(options) {
    super(options);
  }
  // Point  paddingInner 1
  getPaddingInner() {
    return 1;
  }
  clone() {
    return new _Point(this.options);
  }
  update(options) {
    super.update(options);
  }
  getPaddingOuter() {
    return this.options.padding;
  }
};

// node_modules/@antv/scale/esm/scales/pow.js
var transformPow = (exponent) => {
  return (x3) => {
    return x3 < 0 ? -((-x3) ** exponent) : x3 ** exponent;
  };
};
var transformPowInvert = (exponent) => {
  return (x3) => {
    return x3 < 0 ? -((-x3) ** (1 / exponent)) : x3 ** (1 / exponent);
  };
};
var transformSqrt = (x3) => {
  return x3 < 0 ? -Math.sqrt(-x3) : Math.sqrt(x3);
};
var Pow = class _Pow extends Continuous {
  getDefaultOptions() {
    return {
      domain: [0, 1],
      range: [0, 1],
      nice: false,
      clamp: false,
      round: false,
      exponent: 2,
      interpolate: createInterpolateValue,
      tickMethod: d3Ticks,
      tickCount: 5
    };
  }
  //  options  PowOptions O 
  constructor(options) {
    super(options);
  }
  chooseTransforms() {
    const { exponent } = this.options;
    if (exponent === 1)
      return [identity_default2, identity_default2];
    const transform3 = exponent === 0.5 ? transformSqrt : transformPow(exponent);
    const untransform = transformPowInvert(exponent);
    return [transform3, untransform];
  }
  clone() {
    return new _Pow(this.options);
  }
};

// node_modules/@antv/scale/esm/scales/sqrt.js
var Sqrt = class _Sqrt extends Pow {
  getDefaultOptions() {
    return {
      domain: [0, 1],
      range: [0, 1],
      nice: false,
      clamp: false,
      round: false,
      interpolate: createInterpolateValue,
      tickMethod: d3Ticks,
      tickCount: 5,
      exponent: 0.5
    };
  }
  constructor(options) {
    super(options);
  }
  update(options) {
    super.update(options);
  }
  clone() {
    return new _Sqrt(this.options);
  }
};

// node_modules/@antv/scale/esm/scales/threshold.js
var Threshold = class _Threshold extends Base {
  getDefaultOptions() {
    return {
      domain: [0.5],
      range: [0, 1]
    };
  }
  constructor(options) {
    super(options);
  }
  /**
   * 
   */
  map(x3) {
    if (!isValid(x3))
      return this.options.unknown;
    const index3 = bisect(this.thresholds, x3, 0, this.n);
    return this.options.range[index3];
  }
  /**
   * 
   */
  invert(y3) {
    const { range: range4 } = this.options;
    const index3 = range4.indexOf(y3);
    const domain = this.thresholds;
    return [domain[index3 - 1], domain[index3]];
  }
  clone() {
    return new _Threshold(this.options);
  }
  rescale() {
    const { domain, range: range4 } = this.options;
    this.n = Math.min(domain.length, range4.length - 1);
    this.thresholds = domain;
  }
};

// node_modules/@antv/scale/esm/tick-methods/d3-log.js
var d3Log = (a4, b, n, base = 10) => {
  const shouldReflect = a4 < 0;
  const pow3 = pows(base, shouldReflect);
  const log2 = logs(base, shouldReflect);
  const r = b < a4;
  const min11 = r ? b : a4;
  const max11 = r ? a4 : b;
  let i = log2(min11);
  let j = log2(max11);
  let ticks2 = [];
  if (!(base % 1) && j - i < n) {
    i = Math.floor(i);
    j = Math.ceil(j);
    if (shouldReflect) {
      for (; i <= j; i += 1) {
        const p2 = pow3(i);
        for (let k2 = base - 1; k2 >= 1; k2 -= 1) {
          const t = p2 * k2;
          if (t > max11)
            break;
          if (t >= min11)
            ticks2.push(t);
        }
      }
    } else {
      for (; i <= j; i += 1) {
        const p2 = pow3(i);
        for (let k2 = 1; k2 < base; k2 += 1) {
          const t = p2 * k2;
          if (t > max11)
            break;
          if (t >= min11)
            ticks2.push(t);
        }
      }
    }
    if (ticks2.length * 2 < n)
      ticks2 = d3Ticks(min11, max11, n);
  } else {
    const count4 = n === -1 ? j - i : Math.min(j - i, n);
    ticks2 = d3Ticks(i, j, count4).map(pow3);
  }
  return r ? ticks2.reverse() : ticks2;
};

// node_modules/@antv/scale/esm/scales/log.js
var Log = class _Log extends Continuous {
  getDefaultOptions() {
    return {
      domain: [1, 10],
      range: [0, 1],
      base: 10,
      interpolate: createInterpolateValue,
      tickMethod: d3Log,
      tickCount: 5
    };
  }
  chooseNice() {
    return d3LogNice;
  }
  getTickMethodOptions() {
    const { domain, tickCount, base } = this.options;
    const min11 = domain[0];
    const max11 = domain[domain.length - 1];
    return [min11, max11, tickCount, base];
  }
  chooseTransforms() {
    const { base, domain } = this.options;
    const shouldReflect = domain[0] < 0;
    return [logs(base, shouldReflect), pows(base, shouldReflect)];
  }
  clone() {
    return new _Log(this.options);
  }
};

// node_modules/@antv/scale/esm/scales/quantize.js
var Quantize = class _Quantize extends Threshold {
  getDefaultOptions() {
    return {
      domain: [0, 1],
      range: [0.5],
      nice: false,
      tickCount: 5,
      tickMethod: wilkinsonExtended
    };
  }
  constructor(options) {
    super(options);
  }
  nice() {
    const { nice: nice2 } = this.options;
    if (nice2) {
      const [min11, max11, tickCount] = this.getTickMethodOptions();
      this.options.domain = d3LinearNice(min11, max11, tickCount);
    }
  }
  getTicks() {
    const { tickMethod } = this.options;
    const [min11, max11, tickCount] = this.getTickMethodOptions();
    return tickMethod(min11, max11, tickCount);
  }
  getTickMethodOptions() {
    const { domain, tickCount } = this.options;
    const min11 = domain[0];
    const max11 = domain[domain.length - 1];
    return [min11, max11, tickCount];
  }
  rescale() {
    this.nice();
    const { range: range4, domain } = this.options;
    const [x05, x12] = domain;
    this.n = range4.length - 1;
    this.thresholds = new Array(this.n);
    for (let i = 0; i < this.n; i += 1) {
      this.thresholds[i] = ((i + 1) * x12 - (i - this.n) * x05) / (this.n + 1);
    }
  }
  /**
   * 
   */
  invert(y3) {
    const [a4, b] = super.invert(y3);
    const [x05, x12] = this.options.domain;
    return a4 === void 0 && b === void 0 ? [a4, b] : [a4 || x05, b || x12];
  }
  getThresholds() {
    return this.thresholds;
  }
  clone() {
    return new _Quantize(this.options);
  }
};

// node_modules/@antv/scale/esm/utils/create-quartile.js
function quantileSorted2(arr, percentage) {
  const len5 = arr.length;
  if (!len5) {
    return void 0;
  }
  if (len5 < 2) {
    return arr[len5 - 1];
  }
  const i = (len5 - 1) * percentage;
  const i0 = Math.floor(i);
  const v0 = arr[i0];
  const v1 = arr[i0 + 1];
  return v0 + (v1 - v0) * (i - i0);
}
function createQuartile(arr, n, isSorted = false) {
  const numberArr = arr;
  if (!isSorted) {
    numberArr.sort((a4, b) => a4 - b);
  }
  const tmp2 = [];
  for (let i = 1; i < n; i += 1) {
    tmp2.push(quantileSorted2(numberArr, i / n));
  }
  return tmp2;
}

// node_modules/@antv/scale/esm/scales/quantile.js
var Quantile = class _Quantile extends Threshold {
  getDefaultOptions() {
    return {
      domain: [],
      range: [],
      tickCount: 5,
      unknown: void 0,
      tickMethod: wilkinsonExtended
    };
  }
  constructor(options) {
    super(options);
  }
  rescale() {
    const { domain, range: range4 } = this.options;
    this.n = range4.length - 1;
    this.thresholds = createQuartile(domain, this.n + 1, false);
  }
  /**
   * 
   */
  invert(y3) {
    const [a4, b] = super.invert(y3);
    const { domain } = this.options;
    const dMin = domain[0];
    const dMax = domain[domain.length - 1];
    return a4 === void 0 && b === void 0 ? [a4, b] : [a4 || dMin, b || dMax];
  }
  getThresholds() {
    return this.thresholds;
  }
  clone() {
    return new _Quantile(this.options);
  }
  getTicks() {
    const { tickCount, domain, tickMethod } = this.options;
    const lastIndex = domain.length - 1;
    const min11 = domain[0];
    const max11 = domain[lastIndex];
    return tickMethod(min11, max11, tickCount);
  }
};

// node_modules/fecha/lib/fecha.js
var token = /d{1,4}|M{1,4}|YY(?:YY)?|S{1,3}|Do|ZZ|Z|([HhMsDm])\1?|[aA]|"[^"]*"|'[^']*'/g;
var twoDigitsOptional = "\\d\\d?";
var twoDigits = "\\d\\d";
var threeDigits = "\\d{3}";
var fourDigits = "\\d{4}";
var word = "[^\\s]+";
var literal = /\[([^]*?)\]/gm;
function shorten(arr, sLen) {
  var newArr = [];
  for (var i = 0, len5 = arr.length; i < len5; i++) {
    newArr.push(arr[i].substr(0, sLen));
  }
  return newArr;
}
var monthUpdate = function(arrName) {
  return function(v, i18n) {
    var lowerCaseArr = i18n[arrName].map(function(v2) {
      return v2.toLowerCase();
    });
    var index3 = lowerCaseArr.indexOf(v.toLowerCase());
    if (index3 > -1) {
      return index3;
    }
    return null;
  };
};
function assign(origObj) {
  var args = [];
  for (var _i = 1; _i < arguments.length; _i++) {
    args[_i - 1] = arguments[_i];
  }
  for (var _a2 = 0, args_1 = args; _a2 < args_1.length; _a2++) {
    var obj = args_1[_a2];
    for (var key in obj) {
      origObj[key] = obj[key];
    }
  }
  return origObj;
}
var dayNames = [
  "Sunday",
  "Monday",
  "Tuesday",
  "Wednesday",
  "Thursday",
  "Friday",
  "Saturday"
];
var monthNames = [
  "January",
  "February",
  "March",
  "April",
  "May",
  "June",
  "July",
  "August",
  "September",
  "October",
  "November",
  "December"
];
var monthNamesShort = shorten(monthNames, 3);
var dayNamesShort = shorten(dayNames, 3);
var defaultI18n = {
  dayNamesShort,
  dayNames,
  monthNamesShort,
  monthNames,
  amPm: ["am", "pm"],
  DoFn: function(dayOfMonth) {
    return dayOfMonth + ["th", "st", "nd", "rd"][dayOfMonth % 10 > 3 ? 0 : (dayOfMonth - dayOfMonth % 10 !== 10 ? 1 : 0) * dayOfMonth % 10];
  }
};
var globalI18n = assign({}, defaultI18n);
var pad = function(val, len5) {
  if (len5 === void 0) {
    len5 = 2;
  }
  val = String(val);
  while (val.length < len5) {
    val = "0" + val;
  }
  return val;
};
var formatFlags = {
  D: function(dateObj) {
    return String(dateObj.getDate());
  },
  DD: function(dateObj) {
    return pad(dateObj.getDate());
  },
  Do: function(dateObj, i18n) {
    return i18n.DoFn(dateObj.getDate());
  },
  d: function(dateObj) {
    return String(dateObj.getDay());
  },
  dd: function(dateObj) {
    return pad(dateObj.getDay());
  },
  ddd: function(dateObj, i18n) {
    return i18n.dayNamesShort[dateObj.getDay()];
  },
  dddd: function(dateObj, i18n) {
    return i18n.dayNames[dateObj.getDay()];
  },
  M: function(dateObj) {
    return String(dateObj.getMonth() + 1);
  },
  MM: function(dateObj) {
    return pad(dateObj.getMonth() + 1);
  },
  MMM: function(dateObj, i18n) {
    return i18n.monthNamesShort[dateObj.getMonth()];
  },
  MMMM: function(dateObj, i18n) {
    return i18n.monthNames[dateObj.getMonth()];
  },
  YY: function(dateObj) {
    return pad(String(dateObj.getFullYear()), 4).substr(2);
  },
  YYYY: function(dateObj) {
    return pad(dateObj.getFullYear(), 4);
  },
  h: function(dateObj) {
    return String(dateObj.getHours() % 12 || 12);
  },
  hh: function(dateObj) {
    return pad(dateObj.getHours() % 12 || 12);
  },
  H: function(dateObj) {
    return String(dateObj.getHours());
  },
  HH: function(dateObj) {
    return pad(dateObj.getHours());
  },
  m: function(dateObj) {
    return String(dateObj.getMinutes());
  },
  mm: function(dateObj) {
    return pad(dateObj.getMinutes());
  },
  s: function(dateObj) {
    return String(dateObj.getSeconds());
  },
  ss: function(dateObj) {
    return pad(dateObj.getSeconds());
  },
  S: function(dateObj) {
    return String(Math.round(dateObj.getMilliseconds() / 100));
  },
  SS: function(dateObj) {
    return pad(Math.round(dateObj.getMilliseconds() / 10), 2);
  },
  SSS: function(dateObj) {
    return pad(dateObj.getMilliseconds(), 3);
  },
  a: function(dateObj, i18n) {
    return dateObj.getHours() < 12 ? i18n.amPm[0] : i18n.amPm[1];
  },
  A: function(dateObj, i18n) {
    return dateObj.getHours() < 12 ? i18n.amPm[0].toUpperCase() : i18n.amPm[1].toUpperCase();
  },
  ZZ: function(dateObj) {
    var offset2 = dateObj.getTimezoneOffset();
    return (offset2 > 0 ? "-" : "+") + pad(Math.floor(Math.abs(offset2) / 60) * 100 + Math.abs(offset2) % 60, 4);
  },
  Z: function(dateObj) {
    var offset2 = dateObj.getTimezoneOffset();
    return (offset2 > 0 ? "-" : "+") + pad(Math.floor(Math.abs(offset2) / 60), 2) + ":" + pad(Math.abs(offset2) % 60, 2);
  }
};
var monthParse = function(v) {
  return +v - 1;
};
var emptyDigits = [null, twoDigitsOptional];
var emptyWord = [null, word];
var amPm = [
  "isPm",
  word,
  function(v, i18n) {
    var val = v.toLowerCase();
    if (val === i18n.amPm[0]) {
      return 0;
    } else if (val === i18n.amPm[1]) {
      return 1;
    }
    return null;
  }
];
var timezoneOffset = [
  "timezoneOffset",
  "[^\\s]*?[\\+\\-]\\d\\d:?\\d\\d|[^\\s]*?Z?",
  function(v) {
    var parts = (v + "").match(/([+-]|\d\d)/gi);
    if (parts) {
      var minutes = +parts[1] * 60 + parseInt(parts[2], 10);
      return parts[0] === "+" ? minutes : -minutes;
    }
    return 0;
  }
];
var parseFlags = {
  D: ["day", twoDigitsOptional],
  DD: ["day", twoDigits],
  Do: ["day", twoDigitsOptional + word, function(v) {
    return parseInt(v, 10);
  }],
  M: ["month", twoDigitsOptional, monthParse],
  MM: ["month", twoDigits, monthParse],
  YY: [
    "year",
    twoDigits,
    function(v) {
      var now3 = /* @__PURE__ */ new Date();
      var cent = +("" + now3.getFullYear()).substr(0, 2);
      return +("" + (+v > 68 ? cent - 1 : cent) + v);
    }
  ],
  h: ["hour", twoDigitsOptional, void 0, "isPm"],
  hh: ["hour", twoDigits, void 0, "isPm"],
  H: ["hour", twoDigitsOptional],
  HH: ["hour", twoDigits],
  m: ["minute", twoDigitsOptional],
  mm: ["minute", twoDigits],
  s: ["second", twoDigitsOptional],
  ss: ["second", twoDigits],
  YYYY: ["year", fourDigits],
  S: ["millisecond", "\\d", function(v) {
    return +v * 100;
  }],
  SS: ["millisecond", twoDigits, function(v) {
    return +v * 10;
  }],
  SSS: ["millisecond", threeDigits],
  d: emptyDigits,
  dd: emptyDigits,
  ddd: emptyWord,
  dddd: emptyWord,
  MMM: ["month", word, monthUpdate("monthNamesShort")],
  MMMM: ["month", word, monthUpdate("monthNames")],
  a: amPm,
  A: amPm,
  ZZ: timezoneOffset,
  Z: timezoneOffset
};
var globalMasks = {
  default: "ddd MMM DD YYYY HH:mm:ss",
  shortDate: "M/D/YY",
  mediumDate: "MMM D, YYYY",
  longDate: "MMMM D, YYYY",
  fullDate: "dddd, MMMM D, YYYY",
  isoDate: "YYYY-MM-DD",
  isoDateTime: "YYYY-MM-DDTHH:mm:ssZ",
  shortTime: "HH:mm",
  mediumTime: "HH:mm:ss",
  longTime: "HH:mm:ss.SSS"
};
var format = function(dateObj, mask, i18n) {
  if (mask === void 0) {
    mask = globalMasks["default"];
  }
  if (i18n === void 0) {
    i18n = {};
  }
  if (typeof dateObj === "number") {
    dateObj = new Date(dateObj);
  }
  if (Object.prototype.toString.call(dateObj) !== "[object Date]" || isNaN(dateObj.getTime())) {
    throw new Error("Invalid Date pass to format");
  }
  mask = globalMasks[mask] || mask;
  var literals = [];
  mask = mask.replace(literal, function($0, $1) {
    literals.push($1);
    return "@@@";
  });
  var combinedI18nSettings = assign(assign({}, globalI18n), i18n);
  mask = mask.replace(token, function($0) {
    return formatFlags[$0](dateObj, combinedI18nSettings);
  });
  return mask.replace(/@@@/g, function() {
    return literals.shift();
  });
};

// node_modules/@antv/scale/esm/tick-methods/d3-time.js
var d3Time = (min11, max11, count4, interval2, utc) => {
  const r = min11 > max11;
  const lo = r ? max11 : min11;
  const hi = r ? min11 : max11;
  const [tickInterval, step2] = findTickInterval(lo, hi, count4, interval2, utc);
  const ticks2 = tickInterval.range(lo, /* @__PURE__ */ new Date(+hi + 1), step2, true);
  return r ? ticks2.reverse() : ticks2;
};

// node_modules/@antv/scale/esm/scales/time.js
function offset(date) {
  const minuteOffset = date.getTimezoneOffset();
  const d2 = new Date(date);
  d2.setMinutes(d2.getMinutes() + minuteOffset, d2.getSeconds(), d2.getMilliseconds());
  return d2;
}
var Time = class _Time extends Continuous {
  getDefaultOptions() {
    return {
      domain: [new Date(2e3, 0, 1), new Date(2e3, 0, 2)],
      range: [0, 1],
      nice: false,
      tickCount: 5,
      tickInterval: void 0,
      unknown: void 0,
      clamp: false,
      tickMethod: d3Time,
      interpolate: createInterpolateNumber,
      mask: void 0,
      utc: false
    };
  }
  chooseTransforms() {
    const transform3 = (x3) => +x3;
    const untransform = (x3) => new Date(x3);
    return [transform3, untransform];
  }
  chooseNice() {
    return d3TimeNice;
  }
  getTickMethodOptions() {
    const { domain, tickCount, tickInterval, utc } = this.options;
    const min11 = domain[0];
    const max11 = domain[domain.length - 1];
    return [min11, max11, tickCount, tickInterval, utc];
  }
  getFormatter() {
    const { mask, utc } = this.options;
    const maskMap = utc ? utcIntervalMap : localIntervalMap;
    const time = utc ? offset : identity_default2;
    return (d2) => format(time(d2), mask || chooseNiceTimeMask(d2, maskMap));
  }
  clone() {
    return new _Time(this.options);
  }
};

// node_modules/@antv/scale/esm/scales/sequential.js
var __decorate = function(decorators, target, key, desc) {
  var c5 = arguments.length, r = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d2 = decorators[i])
        r = (c5 < 3 ? d2(r) : c5 > 3 ? d2(target, key, r) : d2(target, key)) || r;
  return c5 > 3 && r && Object.defineProperty(target, key, r), r;
};
var Sequential_1;
function rangeOf(interpolator) {
  return [interpolator(0), interpolator(1)];
}
var normalizeDomain = (domain) => {
  const [d0, d1] = domain;
  const normalize10 = compose2(createInterpolateNumber(0, 1), createNormalize(d0, d1));
  return normalize10;
};
var Sequential = Sequential_1 = class Sequential2 extends Linear {
  getDefaultOptions() {
    return {
      domain: [0, 1],
      unknown: void 0,
      nice: false,
      clamp: false,
      round: false,
      interpolator: identity_default2,
      tickMethod: d3Ticks,
      tickCount: 5
    };
  }
  constructor(options) {
    super(options);
  }
  clone() {
    return new Sequential_1(this.options);
  }
};
Sequential = Sequential_1 = __decorate([
  interpolatize(rangeOf, normalizeDomain)
], Sequential);

// node_modules/@antv/scale/esm/scales/diverging.js
var __decorate2 = function(decorators, target, key, desc) {
  var c5 = arguments.length, r = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d2 = decorators[i])
        r = (c5 < 3 ? d2(r) : c5 > 3 ? d2(target, key, r) : d2(target, key)) || r;
  return c5 > 3 && r && Object.defineProperty(target, key, r), r;
};
var Diverging_1;
function rangeOf2(interpolator) {
  return [interpolator(0), interpolator(0.5), interpolator(1)];
}
var normalizeDomain2 = (domain) => {
  const [d0, d1, d2] = domain;
  const normalizeLeft = compose2(createInterpolateNumber(0, 0.5), createNormalize(d0, d1));
  const normalizeRight = compose2(createInterpolateNumber(0.5, 1), createNormalize(d1, d2));
  return (x3) => {
    if (d0 > d2) {
      return x3 < d1 ? normalizeRight(x3) : normalizeLeft(x3);
    } else {
      return x3 < d1 ? normalizeLeft(x3) : normalizeRight(x3);
    }
  };
};
var Diverging = Diverging_1 = class Diverging2 extends Linear {
  getDefaultOptions() {
    return {
      domain: [0, 0.5, 1],
      unknown: void 0,
      nice: false,
      clamp: false,
      round: false,
      interpolator: identity_default2,
      tickMethod: d3Ticks,
      tickCount: 5
    };
  }
  constructor(options) {
    super(options);
  }
  clone() {
    return new Diverging_1(this.options);
  }
};
Diverging = Diverging_1 = __decorate2([
  interpolatize(rangeOf2, normalizeDomain2)
], Diverging);

// node_modules/@antv/g2/esm/transform/jitter.js
function rangeOf3(value2, scaleOptions, padding) {
  if (value2 === null)
    return [-0.5, 0.5];
  const domain = domainOf(value2, scaleOptions);
  const scale10 = new Band({ domain, range: [0, 1], padding });
  const step2 = scale10.getBandWidth();
  return [-step2 / 2, step2 / 2];
}
function interpolate(t, a4, b) {
  return a4 * (1 - t) + b * t;
}
var Jitter = (options = {}) => {
  const { padding = 0, paddingX = padding, paddingY = padding, random: random6 = Math.random } = options;
  return (I, mark2) => {
    const { encode, scale: scale10 } = mark2;
    const { x: scaleX, y: scaleY } = scale10;
    const [X] = columnOf(encode, "x");
    const [Y] = columnOf(encode, "y");
    const rangeX = rangeOf3(X, scaleX, paddingX);
    const rangeY = rangeOf3(Y, scaleY, paddingY);
    const DY = I.map(() => interpolate(random6(), ...rangeY));
    const DX = I.map(() => interpolate(random6(), ...rangeX));
    return [
      I,
      deep_mix_default({
        scale: {
          x: { padding: 0.5 },
          y: { padding: 0.5 }
        }
      }, mark2, {
        encode: { dy: column(DY), dx: column(DX) }
      })
    ];
  };
};
Jitter.props = {};

// node_modules/@antv/g2/esm/transform/jitterX.js
var JitterX = (options = {}) => {
  const { padding = 0, random: random6 = Math.random } = options;
  return (I, mark2) => {
    const { encode, scale: scale10 } = mark2;
    const { x: scaleX } = scale10;
    const [X] = columnOf(encode, "x");
    const rangeX = rangeOf3(X, scaleX, padding);
    const DX = I.map(() => interpolate(random6(), ...rangeX));
    return [
      I,
      deep_mix_default({ scale: { x: { padding: 0.5 } } }, mark2, {
        encode: { dx: column(DX) }
      })
    ];
  };
};
JitterX.props = {};

// node_modules/@antv/g2/esm/transform/jitterY.js
var JitterY = (options = {}) => {
  const { padding = 0, random: random6 = Math.random } = options;
  return (I, mark2) => {
    const { encode, scale: scale10 } = mark2;
    const { y: scaleY } = scale10;
    const [Y] = columnOf(encode, "y");
    const rangeY = rangeOf3(Y, scaleY, padding);
    const DY = I.map(() => interpolate(random6(), ...rangeY));
    return [
      I,
      deep_mix_default({ scale: { y: { padding: 0.5 } } }, mark2, {
        encode: { dy: column(DY) }
      })
    ];
  };
};
JitterY.props = {};

// node_modules/@antv/g2/esm/transform/symmetryY.js
var __rest6 = function(s2, e) {
  var t = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
      t[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t[p2[i]] = s2[p2[i]];
    }
  return t;
};
var SymmetryY = (options = {}) => {
  const { groupBy: groupBy3 = "x" } = options;
  return (I, mark2) => {
    const { encode } = mark2;
    const { x: x3 } = encode, rest2 = __rest6(encode, ["x"]);
    const Yn2 = Object.entries(rest2).filter(([k2]) => k2.startsWith("y")).map(([k2]) => [k2, columnOf(encode, k2)[0]]);
    const newYn = Yn2.map(([k2]) => [k2, new Array(I.length)]);
    const groups2 = createGroups(groupBy3, I, mark2);
    const MY = new Array(groups2.length);
    for (let i = 0; i < groups2.length; i++) {
      const I2 = groups2[i];
      const Y = I2.flatMap((i2) => Yn2.map(([, V]) => +V[i2]));
      const [minY, maxY2] = extent(Y);
      MY[i] = (minY + maxY2) / 2;
    }
    const maxMiddleY = Math.max(...MY);
    for (let m3 = 0; m3 < groups2.length; m3++) {
      const offset2 = maxMiddleY - MY[m3];
      const I2 = groups2[m3];
      for (const i of I2) {
        for (let j = 0; j < Yn2.length; j++) {
          const [, V] = Yn2[j];
          const [, newV] = newYn[j];
          newV[i] = +V[i] + offset2;
        }
      }
    }
    return [
      I,
      deep_mix_default({}, mark2, {
        encode: Object.fromEntries(newYn.map(([k2, v]) => [k2, column(v, columnOf(encode, k2)[1])]))
      })
    ];
  };
};
SymmetryY.props = {};

// node_modules/@antv/g2/esm/transform/diffY.js
var DiffY = (options = {}) => {
  const { groupBy: groupBy3 = "x", series = true } = options;
  return (I, mark2) => {
    const { encode } = mark2;
    const [Y] = columnOf(encode, "y");
    const [_2, fy1] = columnOf(encode, "y1");
    const [S] = series ? maybeColumnOf(encode, "series", "color") : columnOf(encode, "color");
    const groups2 = createGroups(groupBy3, I, mark2);
    const newY1 = new Array(I.length);
    for (const G of groups2) {
      const YG = G.map((i) => +Y[i]);
      for (let idx = 0; idx < G.length; idx++) {
        const i = G[idx];
        const max11 = Math.max(...YG.filter((_3, _i) => _i !== idx));
        newY1[i] = Y[i] > max11 ? max11 : Y[i];
      }
    }
    return [
      I,
      deep_mix_default({}, mark2, {
        encode: {
          y1: column(newY1, fy1)
        }
      })
    ];
  };
};
DiffY.props = {};

// node_modules/@antv/g2/esm/transform/select.js
function first(I, V) {
  return [I[0]];
}
function last3(I, V) {
  const i = I.length - 1;
  return [I[i]];
}
function max5(I, V) {
  const i = maxIndex(I, (i2) => V[i2]);
  return [I[i]];
}
function min5(I, V) {
  const i = minIndex(I, (i2) => V[i2]);
  return [I[i]];
}
function normalizeSelector(selector) {
  if (typeof selector === "function")
    return selector;
  const registry = { first, last: last3, max: max5, min: min5 };
  return registry[selector] || first;
}
var Select = (options = {}) => {
  const { groupBy: groupBy3 = "series", channel, selector } = options;
  return (I, mark2) => {
    const { encode } = mark2;
    const groups2 = createGroups(groupBy3, I, mark2);
    const [V] = columnOf(encode, channel);
    const selectFunction = normalizeSelector(selector);
    return [groups2.flatMap((GI) => selectFunction(GI, V)), mark2];
  };
};
Select.props = {};

// node_modules/@antv/g2/esm/transform/selectX.js
var __rest7 = function(s2, e) {
  var t = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
      t[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t[p2[i]] = s2[p2[i]];
    }
  return t;
};
var SelectX = (options = {}) => {
  const { selector } = options, rest2 = __rest7(options, ["selector"]);
  return Select(Object.assign({ channel: "x", selector }, rest2));
};
SelectX.props = {};

// node_modules/@antv/g2/esm/transform/selectY.js
var __rest8 = function(s2, e) {
  var t = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
      t[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t[p2[i]] = s2[p2[i]];
    }
  return t;
};
var SelectY = (options = {}) => {
  const { selector } = options, rest2 = __rest8(options, ["selector"]);
  return Select(Object.assign({ channel: "y", selector }, rest2));
};
SelectY.props = {};

// node_modules/@antv/g2/esm/transform/groupN.js
var __rest9 = function(s2, e) {
  var t = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
      t[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t[p2[i]] = s2[p2[i]];
    }
  return t;
};
function builtinFormatter(summary) {
  return (d2) => d2 === null ? summary : `${summary} of ${d2}`;
}
function normalizeReducer(reducer) {
  if (typeof reducer === "function")
    return [reducer, null];
  const registry = { mean: mean2, max: max6, count: count2, first: first2, last: last4, sum: sum2, min: min6, median: median2 };
  const reducerFunction = registry[reducer];
  if (!reducerFunction)
    throw new Error(`Unknown reducer: ${reducer}.`);
  return reducerFunction();
}
function mean2() {
  const reducer = (I, V) => mean(I, (i) => +V[i]);
  const formatter2 = builtinFormatter("mean");
  return [reducer, formatter2];
}
function median2() {
  const reducer = (I, V) => median(I, (i) => +V[i]);
  const formatter2 = builtinFormatter("median");
  return [reducer, formatter2];
}
function max6() {
  const reducer = (I, V) => max4(I, (i) => +V[i]);
  const formatter2 = builtinFormatter("max");
  return [reducer, formatter2];
}
function min6() {
  const reducer = (I, V) => min4(I, (i) => +V[i]);
  const formatter2 = builtinFormatter("min");
  return [reducer, formatter2];
}
function count2() {
  const reducer = (I, V) => I.length;
  const formatter2 = builtinFormatter("count");
  return [reducer, formatter2];
}
function sum2() {
  const reducer = (I, V) => sum(I, (i) => +V[i]);
  const formatter2 = builtinFormatter("sum");
  return [reducer, formatter2];
}
function first2() {
  const reducer = (I, V) => V[I[0]];
  const formatter2 = builtinFormatter("first");
  return [reducer, formatter2];
}
function last4() {
  const reducer = (I, V) => V[I[I.length - 1]];
  const formatter2 = builtinFormatter("last");
  return [reducer, formatter2];
}
var GroupN = (options = {}) => {
  const { groupBy: groupBy3 } = options, rest2 = __rest9(options, ["groupBy"]);
  return (I, mark2) => {
    const { data: data2, encode } = mark2;
    const groups2 = groupBy3(I, mark2);
    if (!groups2)
      return [I, mark2];
    const maybeFrom = (field3, reducer) => {
      if (field3)
        return field3;
      const { from } = reducer;
      if (!from)
        return field3;
      const [, field1] = columnOf(encode, from);
      return field1;
    };
    const outputs = Object.entries(rest2).map(([channel, reducer]) => {
      const [reducerFunction, formatter2] = normalizeReducer(reducer);
      const [V, field3] = columnOf(encode, channel);
      const field1 = maybeFrom(field3, reducer);
      const RV = groups2.map((I2) => reducerFunction(I2, V !== null && V !== void 0 ? V : data2));
      return [
        channel,
        Object.assign(Object.assign({}, nonConstantColumn(RV, (formatter2 === null || formatter2 === void 0 ? void 0 : formatter2(field1)) || field1)), { aggregate: true })
      ];
    });
    const reducedColumns = Object.keys(encode).map((key) => {
      const [V, fv] = columnOf(encode, key);
      const GV = groups2.map((I2) => V[I2[0]]);
      return [key, column(GV, fv)];
    });
    const GD = groups2.map((I2) => data2[I2[0]]);
    const GI = indexOf2(groups2);
    return [
      GI,
      deep_mix_default({}, mark2, {
        data: GD,
        encode: Object.fromEntries([...reducedColumns, ...outputs])
      })
    ];
  };
};
GroupN.props = {};

// node_modules/@antv/g2/esm/transform/group.js
var __rest10 = function(s2, e) {
  var t = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
      t[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t[p2[i]] = s2[p2[i]];
    }
  return t;
};
var Group = (options = {}) => {
  const { channels = ["x", "y"] } = options, rest2 = __rest10(options, ["channels"]);
  const groupBy3 = (I, mark2) => createGroups(channels, I, mark2);
  return GroupN(Object.assign(Object.assign({}, rest2), { groupBy: groupBy3 }));
};
Group.props = {};

// node_modules/@antv/g2/esm/transform/groupX.js
var GroupX = (options = {}) => {
  return Group(Object.assign(Object.assign({}, options), { channels: ["x", "color", "series"] }));
};
GroupX.props = {};

// node_modules/@antv/g2/esm/transform/groupY.js
var GroupY = (options = {}) => {
  return Group(Object.assign(Object.assign({}, options), { channels: ["y", "color", "series"] }));
};
GroupY.props = {};

// node_modules/@antv/g2/esm/transform/groupColor.js
var GroupColor = (options = {}) => {
  return Group(Object.assign(Object.assign({}, options), { channels: ["color"] }));
};
GroupColor.props = {};

// node_modules/@antv/g2/esm/transform/sort.js
var __rest11 = function(s2, e) {
  var t = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
      t[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t[p2[i]] = s2[p2[i]];
    }
  return t;
};
function createReducer(channel, options, encode) {
  const { by = channel, reducer = "max" } = options;
  const [V] = columnOf(encode, by);
  if (typeof reducer === "function")
    return (GI) => reducer(GI, V);
  if (reducer === "max")
    return (GI) => max4(GI, (i) => +V[i]);
  if (reducer === "min")
    return (GI) => min4(GI, (i) => +V[i]);
  if (reducer === "sum")
    return (GI) => sum(GI, (i) => +V[i]);
  if (reducer === "median")
    return (GI) => median(GI, (i) => +V[i]);
  if (reducer === "mean")
    return (GI) => mean(GI, (i) => +V[i]);
  if (reducer === "first")
    return (GI) => V[GI[0]];
  if (reducer === "last")
    return (GI) => V[GI[GI.length - 1]];
  throw new Error(`Unknown reducer: ${reducer}`);
}
function sortQuantitative(I, mark2, options) {
  const { reverse: reverse3, channel } = options;
  const { encode } = mark2;
  const [V] = columnOf(encode, channel);
  const sortedI = sort(I, (i) => V[i]);
  if (reverse3)
    sortedI.reverse();
  return [sortedI, mark2];
}
function filterIndex(I, values4, specifiedDomain) {
  if (!Array.isArray(specifiedDomain))
    return I;
  const domain = new Set(specifiedDomain);
  return I.filter((i) => domain.has(values4[i]));
}
function sortOrdinal(I, mark2, options) {
  var _a2;
  const { reverse: reverse3, slice: slice4, channel } = options, rest2 = __rest11(options, ["reverse", "slice", "channel"]);
  const { encode, scale: scale10 = {} } = mark2;
  const domain = (_a2 = scale10[channel]) === null || _a2 === void 0 ? void 0 : _a2.domain;
  const [T] = columnOf(encode, channel);
  const normalizeReducer2 = createReducer(channel, rest2, encode);
  const SI = filterIndex(I, T, domain);
  const sortedDomain = groupSort(SI, normalizeReducer2, (i) => T[i]);
  if (reverse3)
    sortedDomain.reverse();
  const s2 = typeof slice4 === "number" ? [0, slice4] : slice4;
  const slicedDomain = slice4 ? sortedDomain.slice(...s2) : sortedDomain;
  return [
    I,
    deep_mix_default(mark2, {
      scale: {
        [channel]: {
          domain: slicedDomain
        }
      }
    })
  ];
}
var Sort = (options = {}) => {
  const { reverse: reverse3 = false, slice: slice4, channel, ordinal = true } = options, rest2 = __rest11(options, ["reverse", "slice", "channel", "ordinal"]);
  return (I, mark2) => {
    if (!ordinal) {
      return sortQuantitative(I, mark2, Object.assign({
        reverse: reverse3,
        slice: slice4,
        channel
      }, rest2));
    }
    return sortOrdinal(I, mark2, Object.assign({ reverse: reverse3, slice: slice4, channel }, rest2));
  };
};
Sort.props = {};

// node_modules/@antv/g2/esm/transform/sortX.js
var SortX = (options = {}) => {
  return Sort(Object.assign(Object.assign({}, options), { channel: "x" }));
};
SortX.props = {};

// node_modules/@antv/g2/esm/transform/sortColor.js
var SortColor = (options = {}) => {
  return Sort(Object.assign(Object.assign({}, options), { channel: "color" }));
};
SortColor.props = {};

// node_modules/@antv/g2/esm/transform/sortY.js
var SortY = (options = {}) => {
  return Sort(Object.assign(Object.assign({}, options), { channel: "y" }));
};
SortY.props = {};

// node_modules/@antv/g2/esm/transform/flexX.js
function valueOf(data2, field3) {
  if (typeof field3 === "string")
    return data2.map((d2) => d2[field3]);
  return data2.map(field3);
}
function createReducer2(reducer, V) {
  if (typeof reducer === "function")
    return (GI) => reducer(GI, V);
  if (reducer === "sum")
    return (GI) => sum(GI, (i) => +V[i]);
  throw new Error(`Unknown reducer: ${reducer}`);
}
var FlexX = (options = {}) => {
  const { field: field3, channel = "y", reducer = "sum" } = options;
  return (I, mark2) => {
    const { data: data2, encode } = mark2;
    const [x3] = columnOf(encode, "x");
    const V = field3 ? valueOf(data2, field3) : columnOf(encode, channel)[0];
    const reducerFunction = createReducer2(reducer, V);
    const flex2 = rollups(I, reducerFunction, (i) => x3[i]).map((d2) => d2[1]);
    return [I, deep_mix_default({}, mark2, { scale: { x: { flex: flex2 } } })];
  };
};
FlexX.props = {};

// node_modules/@antv/g2/esm/utils/vector.js
function sub6([x12, y12], [x22, y22]) {
  return [x12 - x22, y12 - y22];
}
function add7([x12, y12], [x22, y22]) {
  return [x12 + x22, y12 + y22];
}
function dist4([x05, y05], [x12, y12]) {
  return Math.sqrt(Math.pow(x05 - x12, 2) + Math.pow(y05 - y12, 2));
}
function angle3([x3, y3]) {
  return Math.atan2(y3, x3);
}
function angleWithQuadrant([x3, y3]) {
  return angle3([x3, y3]) + Math.PI / 2;
}
function angleBetween2(v0, v1) {
  const a0 = angle3(v0);
  const a1 = angle3(v1);
  if (a0 < a1)
    return a1 - a0;
  return Math.PI * 2 - (a0 - a1);
}
function calcBBox(points) {
  let minX = Infinity;
  let maxX = -Infinity;
  let minY = Infinity;
  let maxY2 = -Infinity;
  for (const [x3, y3] of points) {
    minX = Math.min(x3, minX);
    maxX = Math.max(x3, maxX);
    minY = Math.min(y3, minY);
    maxY2 = Math.max(y3, maxY2);
  }
  const width = maxX - minX;
  const height = maxY2 - minY;
  return [minX, minY, width, height];
}
function mid([x12, y12], [x22, y22]) {
  return [(x12 + x22) / 2, (y12 + y22) / 2];
}

// node_modules/@antv/g2/esm/transform/pack.js
function pack(options) {
  const { padding = 0, direction: direction3 = "col" } = options;
  return (P, count4, layout) => {
    const pcount = P.length;
    if (pcount === 0)
      return [];
    const { innerWidth, innerHeight } = layout;
    const aspect = innerHeight / innerWidth;
    let col = Math.ceil(Math.sqrt(count4 / aspect));
    let size5 = innerWidth / col;
    let row2 = Math.ceil(count4 / col);
    let h0 = row2 * size5;
    while (h0 > innerHeight) {
      col = col + 1;
      size5 = innerWidth / col;
      row2 = Math.ceil(count4 / col);
      h0 = row2 * size5;
    }
    const space = innerHeight - row2 * size5;
    const intervalY = row2 <= 1 ? 0 : space / (row2 - 1);
    const [offsetX, offsetY] = row2 <= 1 ? [
      (innerWidth - pcount * size5) / (pcount - 1),
      (innerHeight - size5) / 2
    ] : [0, 0];
    return P.map((points, m3) => {
      const [x3, y3, width, height] = calcBBox(points);
      const i = direction3 === "col" ? m3 % col : Math.floor(m3 / row2);
      const j = direction3 === "col" ? Math.floor(m3 / col) : m3 % row2;
      const newX = i * size5;
      const newY = (row2 - j - 1) * size5 + space;
      const sx = (size5 - padding) / width;
      const sy = (size5 - padding) / height;
      const tx = newX - x3 + offsetX * i + 1 / 2 * padding;
      const ty = newY - y3 - intervalY * j - offsetY + 1 / 2 * padding;
      return `translate(${tx}, ${ty}) scale(${sx}, ${sy})`;
    });
  };
}
var Pack = (options) => {
  return (I, mark2) => {
    return [I, deep_mix_default({}, mark2, { modifier: pack(options), axis: false })];
  };
};
Pack.props = {};

// node_modules/@antv/g2/esm/transform/bin.js
var __rest12 = function(s2, e) {
  var t = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
      t[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t[p2[i]] = s2[p2[i]];
    }
  return t;
};
var THRESHOLD = "thresholds";
function thresholdAuto(values4) {
  const [min11, max11] = extent(values4);
  return Math.min(200, thresholdScott(values4, min11, max11));
}
var Bin = (options = {}) => {
  const { groupChannels = ["color"], binChannels = ["x", "y"] } = options, rest2 = __rest12(options, ["groupChannels", "binChannels"]);
  const channelIndexKey = {};
  const groupBy3 = (I, mark2) => {
    const { encode } = mark2;
    const binValues = binChannels.map((channel) => {
      const [V] = columnOf(encode, channel);
      return V;
    });
    const thresholds = subObject(rest2, THRESHOLD);
    const DI = I.filter((i) => binValues.every((V) => defined(V[i])));
    const groupKeys = [
      // For discrete channels, use value as group key.
      ...groupChannels.map((d2) => {
        const [V] = columnOf(encode, d2);
        return V;
      }).filter(defined).map((V) => (i) => V[i]),
      // For quantitative channels, use extent of bin as group key.
      ...binChannels.map((d2, i) => {
        const V = binValues[i];
        const t = thresholds[d2] || thresholdAuto(V);
        const bins = bin().thresholds(t).value((i2) => +V[i2])(DI);
        const indexKey = new Map(bins.flatMap((bin2) => {
          const { x0: x05, x1: x12 } = bin2;
          const key2 = `${x05},${x12}`;
          return bin2.map((i2) => [i2, key2]);
        }));
        channelIndexKey[d2] = indexKey;
        return (i2) => indexKey.get(i2);
      })
    ];
    const key = (i) => groupKeys.map((key2) => key2(i)).join("-");
    return Array.from(group(DI, key).values());
  };
  return GroupN(Object.assign(Object.assign(Object.assign({}, Object.fromEntries(Object.entries(rest2).filter(([k2]) => !k2.startsWith(THRESHOLD)))), Object.fromEntries(binChannels.flatMap((channel) => {
    const start = ([i]) => +channelIndexKey[channel].get(i).split(",")[0];
    const end = ([i]) => +channelIndexKey[channel].get(i).split(",")[1];
    end.from = channel;
    return [
      [channel, start],
      [`${channel}1`, end]
    ];
  }))), { groupBy: groupBy3 }));
};
Bin.props = {};

// node_modules/@antv/g2/esm/transform/binX.js
var BinX = (options = {}) => {
  const { thresholds } = options;
  return Bin(Object.assign(Object.assign({}, options), { thresholdsX: thresholds, groupChannels: ["color"], binChannels: ["x"] }));
};
BinX.props = {};

// node_modules/@antv/g2/esm/transform/utils/lttb.js
function lttb(I, X, Y, thresholds) {
  const length5 = I.length;
  if (thresholds >= length5 || thresholds === 0) {
    return I;
  }
  const x3 = (i) => X[I[i]] * 1;
  const y3 = (i) => Y[I[i]] * 1;
  const sampled = [];
  const every3 = (length5 - 2) / (thresholds - 2);
  let a4 = 0;
  let maxArea;
  let area2;
  let nextA;
  sampled.push(a4);
  for (let i = 0; i < thresholds - 2; i++) {
    let avgX = 0;
    let avgY = 0;
    let start = Math.floor((i + 1) * every3) + 1;
    let end = Math.floor((i + 2) * every3) + 1;
    end = Math.min(end, length5);
    const size5 = end - start;
    for (; start < end; start++) {
      avgX += x3(start);
      avgY += y3(start);
    }
    avgX /= size5;
    avgY /= size5;
    let frameStart = Math.floor((i + 0) * every3) + 1;
    const frameEnd = Math.floor((i + 1) * every3) + 1;
    const pointA = [x3(a4), y3(a4)];
    maxArea = area2 = -1;
    for (; frameStart < frameEnd; frameStart++) {
      area2 = Math.abs((pointA[0] - avgX) * (x3(frameStart) - pointA[1]) - (pointA[0] - y3(frameStart)) * (avgY - pointA[0])) * 0.5;
      if (area2 > maxArea) {
        maxArea = area2;
        nextA = frameStart;
      }
    }
    sampled.push(nextA);
    a4 = nextA;
  }
  sampled.push(length5 - 1);
  return sampled.map((a5) => I[a5]);
}

// node_modules/@antv/g2/esm/transform/sample.js
function normalizeSample(strategy) {
  if (typeof strategy === "function")
    return strategy;
  if (strategy === "lttb")
    return lttb;
  const strategies = {
    first: (f) => [f[0]],
    last: (f) => [f[f.length - 1]],
    min: (f, X, Y) => [
      f[minIndex(f, (i) => Y[i])]
    ],
    max: (f, X, Y) => [
      f[maxIndex(f, (i) => Y[i])]
    ],
    median: (f, X, Y) => [
      f[medianIndex(f, (i) => Y[i])]
    ]
  };
  const sampleFunction = strategies[strategy] || strategies.median;
  return (I, X, Y, thresholds) => {
    const frameSize = Math.max(1, Math.floor(I.length / thresholds));
    const frames = getFrames(I, frameSize);
    return frames.flatMap((frame2) => sampleFunction(frame2, X, Y));
  };
}
function getFrames(I, frameSize) {
  const size5 = I.length;
  const frames = [];
  let i = 0;
  while (i < size5) {
    frames.push(I.slice(i, i += frameSize));
  }
  return frames;
}
var Sample = (options = {}) => {
  const { strategy = "median", thresholds = 2e3, groupBy: groupBy3 = ["series", "color"] } = options;
  const sampleFunction = normalizeSample(strategy);
  return (I, mark2) => {
    const { encode } = mark2;
    const groups2 = createGroups(groupBy3, I, mark2);
    const [X] = columnOf(encode, "x");
    const [Y] = columnOf(encode, "y");
    return [
      groups2.flatMap((g) => sampleFunction(g, X, Y, thresholds)),
      mark2
    ];
  };
};
Sample.props = {};

// node_modules/@antv/g2/esm/transform/filter.js
function normalizeValue(value2) {
  if (typeof value2 === "object")
    return [value2.value, value2.ordinal];
  else
    return [value2, true];
}
var Filter = (options = {}) => {
  return (I, mark2) => {
    const { encode, data: data2 } = mark2;
    const filters = Object.entries(options).map(([key, v]) => {
      const [V] = columnOf(encode, key);
      if (!V)
        return null;
      const [value2, ordinal = true] = normalizeValue(v);
      if (typeof value2 === "function")
        return (i) => value2(V[i]);
      if (ordinal) {
        const expectedValues = Array.isArray(value2) ? value2 : [value2];
        if (expectedValues.length === 0)
          return null;
        return (i) => expectedValues.includes(V[i]);
      } else {
        const [start, end] = value2;
        return (i) => V[i] >= start && V[i] <= end;
      }
    }).filter(defined);
    if (filters.length === 0)
      return [I, mark2];
    const totalFilter = (i) => filters.every((f) => f(i));
    const FI = I.filter(totalFilter);
    const newIndex = FI.map((_2, i) => i);
    const newEncodes = Object.entries(encode).map(([key, encode2]) => {
      return [
        key,
        Object.assign(Object.assign({}, encode2), { value: newIndex.map((i) => encode2.value[FI[i]]).filter((v) => v !== void 0) })
      ];
    });
    return [
      newIndex,
      deep_mix_default({}, mark2, {
        encode: Object.fromEntries(newEncodes),
        // Filter data for tooltip item.
        data: FI.map((i) => data2[i])
      })
    ];
  };
};
Filter.props = {};

// node_modules/d3-shape/src/constant.js
function constant_default(x3) {
  return function constant5() {
    return x3;
  };
}

// node_modules/d3-shape/src/math.js
var abs = Math.abs;
var atan2 = Math.atan2;
var cos = Math.cos;
var max7 = Math.max;
var min7 = Math.min;
var sin = Math.sin;
var sqrt = Math.sqrt;
var epsilon = 1e-12;
var pi = Math.PI;
var halfPi = pi / 2;
var tau = 2 * pi;
function acos(x3) {
  return x3 > 1 ? 0 : x3 < -1 ? pi : Math.acos(x3);
}
function asin(x3) {
  return x3 >= 1 ? halfPi : x3 <= -1 ? -halfPi : Math.asin(x3);
}

// node_modules/d3-path/src/path.js
var pi2 = Math.PI;
var tau2 = 2 * pi2;
var epsilon2 = 1e-6;
var tauEpsilon = tau2 - epsilon2;
function append(strings) {
  this._ += strings[0];
  for (let i = 1, n = strings.length; i < n; ++i) {
    this._ += arguments[i] + strings[i];
  }
}
function appendRound(digits) {
  let d2 = Math.floor(digits);
  if (!(d2 >= 0))
    throw new Error(`invalid digits: ${digits}`);
  if (d2 > 15)
    return append;
  const k2 = 10 ** d2;
  return function(strings) {
    this._ += strings[0];
    for (let i = 1, n = strings.length; i < n; ++i) {
      this._ += Math.round(arguments[i] * k2) / k2 + strings[i];
    }
  };
}
var Path = class {
  constructor(digits) {
    this._x0 = this._y0 = // start of current subpath
    this._x1 = this._y1 = null;
    this._ = "";
    this._append = digits == null ? append : appendRound(digits);
  }
  moveTo(x3, y3) {
    this._append`M${this._x0 = this._x1 = +x3},${this._y0 = this._y1 = +y3}`;
  }
  closePath() {
    if (this._x1 !== null) {
      this._x1 = this._x0, this._y1 = this._y0;
      this._append`Z`;
    }
  }
  lineTo(x3, y3) {
    this._append`L${this._x1 = +x3},${this._y1 = +y3}`;
  }
  quadraticCurveTo(x12, y12, x3, y3) {
    this._append`Q${+x12},${+y12},${this._x1 = +x3},${this._y1 = +y3}`;
  }
  bezierCurveTo(x12, y12, x22, y22, x3, y3) {
    this._append`C${+x12},${+y12},${+x22},${+y22},${this._x1 = +x3},${this._y1 = +y3}`;
  }
  arcTo(x12, y12, x22, y22, r) {
    x12 = +x12, y12 = +y12, x22 = +x22, y22 = +y22, r = +r;
    if (r < 0)
      throw new Error(`negative radius: ${r}`);
    let x05 = this._x1, y05 = this._y1, x21 = x22 - x12, y21 = y22 - y12, x01 = x05 - x12, y01 = y05 - y12, l01_2 = x01 * x01 + y01 * y01;
    if (this._x1 === null) {
      this._append`M${this._x1 = x12},${this._y1 = y12}`;
    } else if (!(l01_2 > epsilon2))
      ;
    else if (!(Math.abs(y01 * x21 - y21 * x01) > epsilon2) || !r) {
      this._append`L${this._x1 = x12},${this._y1 = y12}`;
    } else {
      let x20 = x22 - x05, y20 = y22 - y05, l21_2 = x21 * x21 + y21 * y21, l20_2 = x20 * x20 + y20 * y20, l21 = Math.sqrt(l21_2), l01 = Math.sqrt(l01_2), l = r * Math.tan((pi2 - Math.acos((l21_2 + l01_2 - l20_2) / (2 * l21 * l01))) / 2), t01 = l / l01, t21 = l / l21;
      if (Math.abs(t01 - 1) > epsilon2) {
        this._append`L${x12 + t01 * x01},${y12 + t01 * y01}`;
      }
      this._append`A${r},${r},0,0,${+(y01 * x20 > x01 * y20)},${this._x1 = x12 + t21 * x21},${this._y1 = y12 + t21 * y21}`;
    }
  }
  arc(x3, y3, r, a0, a1, ccw) {
    x3 = +x3, y3 = +y3, r = +r, ccw = !!ccw;
    if (r < 0)
      throw new Error(`negative radius: ${r}`);
    let dx = r * Math.cos(a0), dy = r * Math.sin(a0), x05 = x3 + dx, y05 = y3 + dy, cw2 = 1 ^ ccw, da = ccw ? a0 - a1 : a1 - a0;
    if (this._x1 === null) {
      this._append`M${x05},${y05}`;
    } else if (Math.abs(this._x1 - x05) > epsilon2 || Math.abs(this._y1 - y05) > epsilon2) {
      this._append`L${x05},${y05}`;
    }
    if (!r)
      return;
    if (da < 0)
      da = da % tau2 + tau2;
    if (da > tauEpsilon) {
      this._append`A${r},${r},0,1,${cw2},${x3 - dx},${y3 - dy}A${r},${r},0,1,${cw2},${this._x1 = x05},${this._y1 = y05}`;
    } else if (da > epsilon2) {
      this._append`A${r},${r},0,${+(da >= pi2)},${cw2},${this._x1 = x3 + r * Math.cos(a1)},${this._y1 = y3 + r * Math.sin(a1)}`;
    }
  }
  rect(x3, y3, w, h) {
    this._append`M${this._x0 = this._x1 = +x3},${this._y0 = this._y1 = +y3}h${w = +w}v${+h}h${-w}Z`;
  }
  toString() {
    return this._;
  }
};
function path() {
  return new Path();
}
path.prototype = Path.prototype;

// node_modules/d3-shape/src/path.js
function withPath(shape23) {
  let digits = 3;
  shape23.digits = function(_2) {
    if (!arguments.length)
      return digits;
    if (_2 == null) {
      digits = null;
    } else {
      const d2 = Math.floor(_2);
      if (!(d2 >= 0))
        throw new RangeError(`invalid digits: ${_2}`);
      digits = d2;
    }
    return shape23;
  };
  return () => new Path(digits);
}

// node_modules/d3-shape/src/arc.js
function arcInnerRadius(d2) {
  return d2.innerRadius;
}
function arcOuterRadius(d2) {
  return d2.outerRadius;
}
function arcStartAngle(d2) {
  return d2.startAngle;
}
function arcEndAngle(d2) {
  return d2.endAngle;
}
function arcPadAngle(d2) {
  return d2 && d2.padAngle;
}
function intersect(x05, y05, x12, y12, x22, y22, x3, y3) {
  var x10 = x12 - x05, y10 = y12 - y05, x32 = x3 - x22, y32 = y3 - y22, t = y32 * x10 - x32 * y10;
  if (t * t < epsilon)
    return;
  t = (x32 * (y05 - y22) - y32 * (x05 - x22)) / t;
  return [x05 + t * x10, y05 + t * y10];
}
function cornerTangents(x05, y05, x12, y12, r1, rc, cw2) {
  var x01 = x05 - x12, y01 = y05 - y12, lo = (cw2 ? rc : -rc) / sqrt(x01 * x01 + y01 * y01), ox = lo * y01, oy = -lo * x01, x11 = x05 + ox, y11 = y05 + oy, x10 = x12 + ox, y10 = y12 + oy, x004 = (x11 + x10) / 2, y004 = (y11 + y10) / 2, dx = x10 - x11, dy = y10 - y11, d2 = dx * dx + dy * dy, r = r1 - rc, D2 = x11 * y10 - x10 * y11, d3 = (dy < 0 ? -1 : 1) * sqrt(max7(0, r * r * d2 - D2 * D2)), cx0 = (D2 * dy - dx * d3) / d2, cy0 = (-D2 * dx - dy * d3) / d2, cx1 = (D2 * dy + dx * d3) / d2, cy1 = (-D2 * dx + dy * d3) / d2, dx0 = cx0 - x004, dy0 = cy0 - y004, dx1 = cx1 - x004, dy1 = cy1 - y004;
  if (dx0 * dx0 + dy0 * dy0 > dx1 * dx1 + dy1 * dy1)
    cx0 = cx1, cy0 = cy1;
  return {
    cx: cx0,
    cy: cy0,
    x01: -ox,
    y01: -oy,
    x11: cx0 * (r1 / r - 1),
    y11: cy0 * (r1 / r - 1)
  };
}
function arc_default() {
  var innerRadius = arcInnerRadius, outerRadius = arcOuterRadius, cornerRadius = constant_default(0), padRadius = null, startAngle = arcStartAngle, endAngle = arcEndAngle, padAngle = arcPadAngle, context = null, path2 = withPath(arc);
  function arc() {
    var buffer, r, r0 = +innerRadius.apply(this, arguments), r1 = +outerRadius.apply(this, arguments), a0 = startAngle.apply(this, arguments) - halfPi, a1 = endAngle.apply(this, arguments) - halfPi, da = abs(a1 - a0), cw2 = a1 > a0;
    if (!context)
      context = buffer = path2();
    if (r1 < r0)
      r = r1, r1 = r0, r0 = r;
    if (!(r1 > epsilon))
      context.moveTo(0, 0);
    else if (da > tau - epsilon) {
      context.moveTo(r1 * cos(a0), r1 * sin(a0));
      context.arc(0, 0, r1, a0, a1, !cw2);
      if (r0 > epsilon) {
        context.moveTo(r0 * cos(a1), r0 * sin(a1));
        context.arc(0, 0, r0, a1, a0, cw2);
      }
    } else {
      var a01 = a0, a11 = a1, a00 = a0, a10 = a1, da0 = da, da1 = da, ap = padAngle.apply(this, arguments) / 2, rp = ap > epsilon && (padRadius ? +padRadius.apply(this, arguments) : sqrt(r0 * r0 + r1 * r1)), rc = min7(abs(r1 - r0) / 2, +cornerRadius.apply(this, arguments)), rc0 = rc, rc1 = rc, t02, t12;
      if (rp > epsilon) {
        var p0 = asin(rp / r0 * sin(ap)), p1 = asin(rp / r1 * sin(ap));
        if ((da0 -= p0 * 2) > epsilon)
          p0 *= cw2 ? 1 : -1, a00 += p0, a10 -= p0;
        else
          da0 = 0, a00 = a10 = (a0 + a1) / 2;
        if ((da1 -= p1 * 2) > epsilon)
          p1 *= cw2 ? 1 : -1, a01 += p1, a11 -= p1;
        else
          da1 = 0, a01 = a11 = (a0 + a1) / 2;
      }
      var x01 = r1 * cos(a01), y01 = r1 * sin(a01), x10 = r0 * cos(a10), y10 = r0 * sin(a10);
      if (rc > epsilon) {
        var x11 = r1 * cos(a11), y11 = r1 * sin(a11), x004 = r0 * cos(a00), y004 = r0 * sin(a00), oc;
        if (da < pi) {
          if (oc = intersect(x01, y01, x004, y004, x11, y11, x10, y10)) {
            var ax = x01 - oc[0], ay = y01 - oc[1], bx = x11 - oc[0], by = y11 - oc[1], kc = 1 / sin(acos((ax * bx + ay * by) / (sqrt(ax * ax + ay * ay) * sqrt(bx * bx + by * by))) / 2), lc = sqrt(oc[0] * oc[0] + oc[1] * oc[1]);
            rc0 = min7(rc, (r0 - lc) / (kc - 1));
            rc1 = min7(rc, (r1 - lc) / (kc + 1));
          } else {
            rc0 = rc1 = 0;
          }
        }
      }
      if (!(da1 > epsilon))
        context.moveTo(x01, y01);
      else if (rc1 > epsilon) {
        t02 = cornerTangents(x004, y004, x01, y01, r1, rc1, cw2);
        t12 = cornerTangents(x11, y11, x10, y10, r1, rc1, cw2);
        context.moveTo(t02.cx + t02.x01, t02.cy + t02.y01);
        if (rc1 < rc)
          context.arc(t02.cx, t02.cy, rc1, atan2(t02.y01, t02.x01), atan2(t12.y01, t12.x01), !cw2);
        else {
          context.arc(t02.cx, t02.cy, rc1, atan2(t02.y01, t02.x01), atan2(t02.y11, t02.x11), !cw2);
          context.arc(0, 0, r1, atan2(t02.cy + t02.y11, t02.cx + t02.x11), atan2(t12.cy + t12.y11, t12.cx + t12.x11), !cw2);
          context.arc(t12.cx, t12.cy, rc1, atan2(t12.y11, t12.x11), atan2(t12.y01, t12.x01), !cw2);
        }
      } else
        context.moveTo(x01, y01), context.arc(0, 0, r1, a01, a11, !cw2);
      if (!(r0 > epsilon) || !(da0 > epsilon))
        context.lineTo(x10, y10);
      else if (rc0 > epsilon) {
        t02 = cornerTangents(x10, y10, x11, y11, r0, -rc0, cw2);
        t12 = cornerTangents(x01, y01, x004, y004, r0, -rc0, cw2);
        context.lineTo(t02.cx + t02.x01, t02.cy + t02.y01);
        if (rc0 < rc)
          context.arc(t02.cx, t02.cy, rc0, atan2(t02.y01, t02.x01), atan2(t12.y01, t12.x01), !cw2);
        else {
          context.arc(t02.cx, t02.cy, rc0, atan2(t02.y01, t02.x01), atan2(t02.y11, t02.x11), !cw2);
          context.arc(0, 0, r0, atan2(t02.cy + t02.y11, t02.cx + t02.x11), atan2(t12.cy + t12.y11, t12.cx + t12.x11), cw2);
          context.arc(t12.cx, t12.cy, rc0, atan2(t12.y11, t12.x11), atan2(t12.y01, t12.x01), !cw2);
        }
      } else
        context.arc(0, 0, r0, a10, a00, cw2);
    }
    context.closePath();
    if (buffer)
      return context = null, buffer + "" || null;
  }
  arc.centroid = function() {
    var r = (+innerRadius.apply(this, arguments) + +outerRadius.apply(this, arguments)) / 2, a4 = (+startAngle.apply(this, arguments) + +endAngle.apply(this, arguments)) / 2 - pi / 2;
    return [cos(a4) * r, sin(a4) * r];
  };
  arc.innerRadius = function(_2) {
    return arguments.length ? (innerRadius = typeof _2 === "function" ? _2 : constant_default(+_2), arc) : innerRadius;
  };
  arc.outerRadius = function(_2) {
    return arguments.length ? (outerRadius = typeof _2 === "function" ? _2 : constant_default(+_2), arc) : outerRadius;
  };
  arc.cornerRadius = function(_2) {
    return arguments.length ? (cornerRadius = typeof _2 === "function" ? _2 : constant_default(+_2), arc) : cornerRadius;
  };
  arc.padRadius = function(_2) {
    return arguments.length ? (padRadius = _2 == null ? null : typeof _2 === "function" ? _2 : constant_default(+_2), arc) : padRadius;
  };
  arc.startAngle = function(_2) {
    return arguments.length ? (startAngle = typeof _2 === "function" ? _2 : constant_default(+_2), arc) : startAngle;
  };
  arc.endAngle = function(_2) {
    return arguments.length ? (endAngle = typeof _2 === "function" ? _2 : constant_default(+_2), arc) : endAngle;
  };
  arc.padAngle = function(_2) {
    return arguments.length ? (padAngle = typeof _2 === "function" ? _2 : constant_default(+_2), arc) : padAngle;
  };
  arc.context = function(_2) {
    return arguments.length ? (context = _2 == null ? null : _2, arc) : context;
  };
  return arc;
}

// node_modules/d3-shape/src/array.js
var slice2 = Array.prototype.slice;
function array_default(x3) {
  return typeof x3 === "object" && "length" in x3 ? x3 : Array.from(x3);
}

// node_modules/d3-shape/src/curve/linear.js
function Linear2(context) {
  this._context = context;
}
Linear2.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line || this._line !== 0 && this._point === 1)
      this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x3, y3) {
    x3 = +x3, y3 = +y3;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x3, y3) : this._context.moveTo(x3, y3);
        break;
      case 1:
        this._point = 2;
      default:
        this._context.lineTo(x3, y3);
        break;
    }
  }
};
function linear_default(context) {
  return new Linear2(context);
}

// node_modules/d3-shape/src/point.js
function x(p2) {
  return p2[0];
}
function y(p2) {
  return p2[1];
}

// node_modules/d3-shape/src/line.js
function line_default(x3, y3) {
  var defined4 = constant_default(true), context = null, curve = linear_default, output = null, path2 = withPath(line4);
  x3 = typeof x3 === "function" ? x3 : x3 === void 0 ? x : constant_default(x3);
  y3 = typeof y3 === "function" ? y3 : y3 === void 0 ? y : constant_default(y3);
  function line4(data2) {
    var i, n = (data2 = array_default(data2)).length, d2, defined0 = false, buffer;
    if (context == null)
      output = curve(buffer = path2());
    for (i = 0; i <= n; ++i) {
      if (!(i < n && defined4(d2 = data2[i], i, data2)) === defined0) {
        if (defined0 = !defined0)
          output.lineStart();
        else
          output.lineEnd();
      }
      if (defined0)
        output.point(+x3(d2, i, data2), +y3(d2, i, data2));
    }
    if (buffer)
      return output = null, buffer + "" || null;
  }
  line4.x = function(_2) {
    return arguments.length ? (x3 = typeof _2 === "function" ? _2 : constant_default(+_2), line4) : x3;
  };
  line4.y = function(_2) {
    return arguments.length ? (y3 = typeof _2 === "function" ? _2 : constant_default(+_2), line4) : y3;
  };
  line4.defined = function(_2) {
    return arguments.length ? (defined4 = typeof _2 === "function" ? _2 : constant_default(!!_2), line4) : defined4;
  };
  line4.curve = function(_2) {
    return arguments.length ? (curve = _2, context != null && (output = curve(context)), line4) : curve;
  };
  line4.context = function(_2) {
    return arguments.length ? (_2 == null ? context = output = null : output = curve(context = _2), line4) : context;
  };
  return line4;
}

// node_modules/d3-shape/src/area.js
function area_default(x05, y05, y12) {
  var x12 = null, defined4 = constant_default(true), context = null, curve = linear_default, output = null, path2 = withPath(area2);
  x05 = typeof x05 === "function" ? x05 : x05 === void 0 ? x : constant_default(+x05);
  y05 = typeof y05 === "function" ? y05 : y05 === void 0 ? constant_default(0) : constant_default(+y05);
  y12 = typeof y12 === "function" ? y12 : y12 === void 0 ? y : constant_default(+y12);
  function area2(data2) {
    var i, j, k2, n = (data2 = array_default(data2)).length, d2, defined0 = false, buffer, x0z = new Array(n), y0z = new Array(n);
    if (context == null)
      output = curve(buffer = path2());
    for (i = 0; i <= n; ++i) {
      if (!(i < n && defined4(d2 = data2[i], i, data2)) === defined0) {
        if (defined0 = !defined0) {
          j = i;
          output.areaStart();
          output.lineStart();
        } else {
          output.lineEnd();
          output.lineStart();
          for (k2 = i - 1; k2 >= j; --k2) {
            output.point(x0z[k2], y0z[k2]);
          }
          output.lineEnd();
          output.areaEnd();
        }
      }
      if (defined0) {
        x0z[i] = +x05(d2, i, data2), y0z[i] = +y05(d2, i, data2);
        output.point(x12 ? +x12(d2, i, data2) : x0z[i], y12 ? +y12(d2, i, data2) : y0z[i]);
      }
    }
    if (buffer)
      return output = null, buffer + "" || null;
  }
  function arealine() {
    return line_default().defined(defined4).curve(curve).context(context);
  }
  area2.x = function(_2) {
    return arguments.length ? (x05 = typeof _2 === "function" ? _2 : constant_default(+_2), x12 = null, area2) : x05;
  };
  area2.x0 = function(_2) {
    return arguments.length ? (x05 = typeof _2 === "function" ? _2 : constant_default(+_2), area2) : x05;
  };
  area2.x1 = function(_2) {
    return arguments.length ? (x12 = _2 == null ? null : typeof _2 === "function" ? _2 : constant_default(+_2), area2) : x12;
  };
  area2.y = function(_2) {
    return arguments.length ? (y05 = typeof _2 === "function" ? _2 : constant_default(+_2), y12 = null, area2) : y05;
  };
  area2.y0 = function(_2) {
    return arguments.length ? (y05 = typeof _2 === "function" ? _2 : constant_default(+_2), area2) : y05;
  };
  area2.y1 = function(_2) {
    return arguments.length ? (y12 = _2 == null ? null : typeof _2 === "function" ? _2 : constant_default(+_2), area2) : y12;
  };
  area2.lineX0 = area2.lineY0 = function() {
    return arealine().x(x05).y(y05);
  };
  area2.lineY1 = function() {
    return arealine().x(x05).y(y12);
  };
  area2.lineX1 = function() {
    return arealine().x(x12).y(y05);
  };
  area2.defined = function(_2) {
    return arguments.length ? (defined4 = typeof _2 === "function" ? _2 : constant_default(!!_2), area2) : defined4;
  };
  area2.curve = function(_2) {
    return arguments.length ? (curve = _2, context != null && (output = curve(context)), area2) : curve;
  };
  area2.context = function(_2) {
    return arguments.length ? (_2 == null ? context = output = null : output = curve(context = _2), area2) : context;
  };
  return area2;
}

// node_modules/d3-shape/src/curve/radial.js
var curveRadialLinear = curveRadial(linear_default);
function Radial2(curve) {
  this._curve = curve;
}
Radial2.prototype = {
  areaStart: function() {
    this._curve.areaStart();
  },
  areaEnd: function() {
    this._curve.areaEnd();
  },
  lineStart: function() {
    this._curve.lineStart();
  },
  lineEnd: function() {
    this._curve.lineEnd();
  },
  point: function(a4, r) {
    this._curve.point(r * Math.sin(a4), r * -Math.cos(a4));
  }
};
function curveRadial(curve) {
  function radial(context) {
    return new Radial2(curve(context));
  }
  radial._curve = curve;
  return radial;
}

// node_modules/d3-shape/src/lineRadial.js
function lineRadial(l) {
  var c5 = l.curve;
  l.angle = l.x, delete l.x;
  l.radius = l.y, delete l.y;
  l.curve = function(_2) {
    return arguments.length ? c5(curveRadial(_2)) : c5()._curve;
  };
  return l;
}
function lineRadial_default() {
  return lineRadial(line_default().curve(curveRadialLinear));
}

// node_modules/d3-shape/src/areaRadial.js
function areaRadial_default() {
  var a4 = area_default().curve(curveRadialLinear), c5 = a4.curve, x05 = a4.lineX0, x12 = a4.lineX1, y05 = a4.lineY0, y12 = a4.lineY1;
  a4.angle = a4.x, delete a4.x;
  a4.startAngle = a4.x0, delete a4.x0;
  a4.endAngle = a4.x1, delete a4.x1;
  a4.radius = a4.y, delete a4.y;
  a4.innerRadius = a4.y0, delete a4.y0;
  a4.outerRadius = a4.y1, delete a4.y1;
  a4.lineStartAngle = function() {
    return lineRadial(x05());
  }, delete a4.lineX0;
  a4.lineEndAngle = function() {
    return lineRadial(x12());
  }, delete a4.lineX1;
  a4.lineInnerRadius = function() {
    return lineRadial(y05());
  }, delete a4.lineY0;
  a4.lineOuterRadius = function() {
    return lineRadial(y12());
  }, delete a4.lineY1;
  a4.curve = function(_2) {
    return arguments.length ? c5(curveRadial(_2)) : c5()._curve;
  };
  return a4;
}

// node_modules/d3-shape/src/symbol/asterisk.js
var sqrt3 = sqrt(3);

// node_modules/d3-shape/src/symbol/diamond.js
var tan30 = sqrt(1 / 3);
var tan30_2 = tan30 * 2;

// node_modules/d3-shape/src/symbol/star.js
var kr = sin(pi / 10) / sin(7 * pi / 10);
var kx = sin(tau / 10) * kr;
var ky = -cos(tau / 10) * kr;

// node_modules/d3-shape/src/symbol/triangle.js
var sqrt32 = sqrt(3);

// node_modules/d3-shape/src/symbol/triangle2.js
var sqrt33 = sqrt(3);

// node_modules/d3-shape/src/symbol/wye.js
var s = sqrt(3) / 2;
var k = 1 / sqrt(12);
var a = (k / 2 + 1) * 3;

// node_modules/d3-shape/src/noop.js
function noop_default3() {
}

// node_modules/d3-shape/src/curve/basis.js
function point(that, x3, y3) {
  that._context.bezierCurveTo(
    (2 * that._x0 + that._x1) / 3,
    (2 * that._y0 + that._y1) / 3,
    (that._x0 + 2 * that._x1) / 3,
    (that._y0 + 2 * that._y1) / 3,
    (that._x0 + 4 * that._x1 + x3) / 6,
    (that._y0 + 4 * that._y1 + y3) / 6
  );
}
function Basis(context) {
  this._context = context;
}
Basis.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._y0 = this._y1 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 3:
        point(this, this._x1, this._y1);
      case 2:
        this._context.lineTo(this._x1, this._y1);
        break;
    }
    if (this._line || this._line !== 0 && this._point === 1)
      this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x3, y3) {
    x3 = +x3, y3 = +y3;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x3, y3) : this._context.moveTo(x3, y3);
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
        this._context.lineTo((5 * this._x0 + this._x1) / 6, (5 * this._y0 + this._y1) / 6);
      default:
        point(this, x3, y3);
        break;
    }
    this._x0 = this._x1, this._x1 = x3;
    this._y0 = this._y1, this._y1 = y3;
  }
};

// node_modules/d3-shape/src/curve/basisClosed.js
function BasisClosed(context) {
  this._context = context;
}
BasisClosed.prototype = {
  areaStart: noop_default3,
  areaEnd: noop_default3,
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x2, this._y2);
        this._context.closePath();
        break;
      }
      case 2: {
        this._context.moveTo((this._x2 + 2 * this._x3) / 3, (this._y2 + 2 * this._y3) / 3);
        this._context.lineTo((this._x3 + 2 * this._x2) / 3, (this._y3 + 2 * this._y2) / 3);
        this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x2, this._y2);
        this.point(this._x3, this._y3);
        this.point(this._x4, this._y4);
        break;
      }
    }
  },
  point: function(x3, y3) {
    x3 = +x3, y3 = +y3;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._x2 = x3, this._y2 = y3;
        break;
      case 1:
        this._point = 2;
        this._x3 = x3, this._y3 = y3;
        break;
      case 2:
        this._point = 3;
        this._x4 = x3, this._y4 = y3;
        this._context.moveTo((this._x0 + 4 * this._x1 + x3) / 6, (this._y0 + 4 * this._y1 + y3) / 6);
        break;
      default:
        point(this, x3, y3);
        break;
    }
    this._x0 = this._x1, this._x1 = x3;
    this._y0 = this._y1, this._y1 = y3;
  }
};

// node_modules/d3-shape/src/curve/basisOpen.js
function BasisOpen(context) {
  this._context = context;
}
BasisOpen.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._y0 = this._y1 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line || this._line !== 0 && this._point === 3)
      this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x3, y3) {
    x3 = +x3, y3 = +y3;
    switch (this._point) {
      case 0:
        this._point = 1;
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
        var x05 = (this._x0 + 4 * this._x1 + x3) / 6, y05 = (this._y0 + 4 * this._y1 + y3) / 6;
        this._line ? this._context.lineTo(x05, y05) : this._context.moveTo(x05, y05);
        break;
      case 3:
        this._point = 4;
      default:
        point(this, x3, y3);
        break;
    }
    this._x0 = this._x1, this._x1 = x3;
    this._y0 = this._y1, this._y1 = y3;
  }
};

// node_modules/d3-shape/src/curve/bundle.js
function Bundle(context, beta) {
  this._basis = new Basis(context);
  this._beta = beta;
}
Bundle.prototype = {
  lineStart: function() {
    this._x = [];
    this._y = [];
    this._basis.lineStart();
  },
  lineEnd: function() {
    var x3 = this._x, y3 = this._y, j = x3.length - 1;
    if (j > 0) {
      var x05 = x3[0], y05 = y3[0], dx = x3[j] - x05, dy = y3[j] - y05, i = -1, t;
      while (++i <= j) {
        t = i / j;
        this._basis.point(
          this._beta * x3[i] + (1 - this._beta) * (x05 + t * dx),
          this._beta * y3[i] + (1 - this._beta) * (y05 + t * dy)
        );
      }
    }
    this._x = this._y = null;
    this._basis.lineEnd();
  },
  point: function(x3, y3) {
    this._x.push(+x3);
    this._y.push(+y3);
  }
};
var bundle_default = function custom(beta) {
  function bundle(context) {
    return beta === 1 ? new Basis(context) : new Bundle(context, beta);
  }
  bundle.beta = function(beta2) {
    return custom(+beta2);
  };
  return bundle;
}(0.85);

// node_modules/d3-shape/src/curve/cardinal.js
function point2(that, x3, y3) {
  that._context.bezierCurveTo(
    that._x1 + that._k * (that._x2 - that._x0),
    that._y1 + that._k * (that._y2 - that._y0),
    that._x2 + that._k * (that._x1 - x3),
    that._y2 + that._k * (that._y1 - y3),
    that._x2,
    that._y2
  );
}
function Cardinal(context, tension) {
  this._context = context;
  this._k = (1 - tension) / 6;
}
Cardinal.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x2, this._y2);
        break;
      case 3:
        point2(this, this._x1, this._y1);
        break;
    }
    if (this._line || this._line !== 0 && this._point === 1)
      this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x3, y3) {
    x3 = +x3, y3 = +y3;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x3, y3) : this._context.moveTo(x3, y3);
        break;
      case 1:
        this._point = 2;
        this._x1 = x3, this._y1 = y3;
        break;
      case 2:
        this._point = 3;
      default:
        point2(this, x3, y3);
        break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x3;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y3;
  }
};
var cardinal_default = function custom2(tension) {
  function cardinal(context) {
    return new Cardinal(context, tension);
  }
  cardinal.tension = function(tension2) {
    return custom2(+tension2);
  };
  return cardinal;
}(0);

// node_modules/d3-shape/src/curve/cardinalClosed.js
function CardinalClosed(context, tension) {
  this._context = context;
  this._k = (1 - tension) / 6;
}
CardinalClosed.prototype = {
  areaStart: noop_default3,
  areaEnd: noop_default3,
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x3, this._y3);
        this._context.closePath();
        break;
      }
      case 2: {
        this._context.lineTo(this._x3, this._y3);
        this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x3, this._y3);
        this.point(this._x4, this._y4);
        this.point(this._x5, this._y5);
        break;
      }
    }
  },
  point: function(x3, y3) {
    x3 = +x3, y3 = +y3;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._x3 = x3, this._y3 = y3;
        break;
      case 1:
        this._point = 2;
        this._context.moveTo(this._x4 = x3, this._y4 = y3);
        break;
      case 2:
        this._point = 3;
        this._x5 = x3, this._y5 = y3;
        break;
      default:
        point2(this, x3, y3);
        break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x3;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y3;
  }
};
var cardinalClosed_default = function custom3(tension) {
  function cardinal(context) {
    return new CardinalClosed(context, tension);
  }
  cardinal.tension = function(tension2) {
    return custom3(+tension2);
  };
  return cardinal;
}(0);

// node_modules/d3-shape/src/curve/cardinalOpen.js
function CardinalOpen(context, tension) {
  this._context = context;
  this._k = (1 - tension) / 6;
}
CardinalOpen.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line || this._line !== 0 && this._point === 3)
      this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x3, y3) {
    x3 = +x3, y3 = +y3;
    switch (this._point) {
      case 0:
        this._point = 1;
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
        this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2);
        break;
      case 3:
        this._point = 4;
      default:
        point2(this, x3, y3);
        break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x3;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y3;
  }
};
var cardinalOpen_default = function custom4(tension) {
  function cardinal(context) {
    return new CardinalOpen(context, tension);
  }
  cardinal.tension = function(tension2) {
    return custom4(+tension2);
  };
  return cardinal;
}(0);

// node_modules/d3-shape/src/curve/catmullRom.js
function point3(that, x3, y3) {
  var x12 = that._x1, y12 = that._y1, x22 = that._x2, y22 = that._y2;
  if (that._l01_a > epsilon) {
    var a4 = 2 * that._l01_2a + 3 * that._l01_a * that._l12_a + that._l12_2a, n = 3 * that._l01_a * (that._l01_a + that._l12_a);
    x12 = (x12 * a4 - that._x0 * that._l12_2a + that._x2 * that._l01_2a) / n;
    y12 = (y12 * a4 - that._y0 * that._l12_2a + that._y2 * that._l01_2a) / n;
  }
  if (that._l23_a > epsilon) {
    var b = 2 * that._l23_2a + 3 * that._l23_a * that._l12_a + that._l12_2a, m3 = 3 * that._l23_a * (that._l23_a + that._l12_a);
    x22 = (x22 * b + that._x1 * that._l23_2a - x3 * that._l12_2a) / m3;
    y22 = (y22 * b + that._y1 * that._l23_2a - y3 * that._l12_2a) / m3;
  }
  that._context.bezierCurveTo(x12, y12, x22, y22, that._x2, that._y2);
}
function CatmullRom(context, alpha) {
  this._context = context;
  this._alpha = alpha;
}
CatmullRom.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
    this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x2, this._y2);
        break;
      case 3:
        this.point(this._x2, this._y2);
        break;
    }
    if (this._line || this._line !== 0 && this._point === 1)
      this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x3, y3) {
    x3 = +x3, y3 = +y3;
    if (this._point) {
      var x23 = this._x2 - x3, y23 = this._y2 - y3;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
    }
    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x3, y3) : this._context.moveTo(x3, y3);
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
      default:
        point3(this, x3, y3);
        break;
    }
    this._l01_a = this._l12_a, this._l12_a = this._l23_a;
    this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x3;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y3;
  }
};
var catmullRom_default = function custom5(alpha) {
  function catmullRom(context) {
    return alpha ? new CatmullRom(context, alpha) : new Cardinal(context, 0);
  }
  catmullRom.alpha = function(alpha2) {
    return custom5(+alpha2);
  };
  return catmullRom;
}(0.5);

// node_modules/d3-shape/src/curve/catmullRomClosed.js
function CatmullRomClosed(context, alpha) {
  this._context = context;
  this._alpha = alpha;
}
CatmullRomClosed.prototype = {
  areaStart: noop_default3,
  areaEnd: noop_default3,
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN;
    this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x3, this._y3);
        this._context.closePath();
        break;
      }
      case 2: {
        this._context.lineTo(this._x3, this._y3);
        this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x3, this._y3);
        this.point(this._x4, this._y4);
        this.point(this._x5, this._y5);
        break;
      }
    }
  },
  point: function(x3, y3) {
    x3 = +x3, y3 = +y3;
    if (this._point) {
      var x23 = this._x2 - x3, y23 = this._y2 - y3;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
    }
    switch (this._point) {
      case 0:
        this._point = 1;
        this._x3 = x3, this._y3 = y3;
        break;
      case 1:
        this._point = 2;
        this._context.moveTo(this._x4 = x3, this._y4 = y3);
        break;
      case 2:
        this._point = 3;
        this._x5 = x3, this._y5 = y3;
        break;
      default:
        point3(this, x3, y3);
        break;
    }
    this._l01_a = this._l12_a, this._l12_a = this._l23_a;
    this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x3;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y3;
  }
};
var catmullRomClosed_default = function custom6(alpha) {
  function catmullRom(context) {
    return alpha ? new CatmullRomClosed(context, alpha) : new CardinalClosed(context, 0);
  }
  catmullRom.alpha = function(alpha2) {
    return custom6(+alpha2);
  };
  return catmullRom;
}(0.5);

// node_modules/d3-shape/src/curve/catmullRomOpen.js
function CatmullRomOpen(context, alpha) {
  this._context = context;
  this._alpha = alpha;
}
CatmullRomOpen.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
    this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
  },
  lineEnd: function() {
    if (this._line || this._line !== 0 && this._point === 3)
      this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x3, y3) {
    x3 = +x3, y3 = +y3;
    if (this._point) {
      var x23 = this._x2 - x3, y23 = this._y2 - y3;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
    }
    switch (this._point) {
      case 0:
        this._point = 1;
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
        this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2);
        break;
      case 3:
        this._point = 4;
      default:
        point3(this, x3, y3);
        break;
    }
    this._l01_a = this._l12_a, this._l12_a = this._l23_a;
    this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x3;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y3;
  }
};
var catmullRomOpen_default = function custom7(alpha) {
  function catmullRom(context) {
    return alpha ? new CatmullRomOpen(context, alpha) : new CardinalOpen(context, 0);
  }
  catmullRom.alpha = function(alpha2) {
    return custom7(+alpha2);
  };
  return catmullRom;
}(0.5);

// node_modules/d3-shape/src/curve/linearClosed.js
function LinearClosed(context) {
  this._context = context;
}
LinearClosed.prototype = {
  areaStart: noop_default3,
  areaEnd: noop_default3,
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    if (this._point)
      this._context.closePath();
  },
  point: function(x3, y3) {
    x3 = +x3, y3 = +y3;
    if (this._point)
      this._context.lineTo(x3, y3);
    else
      this._point = 1, this._context.moveTo(x3, y3);
  }
};
function linearClosed_default(context) {
  return new LinearClosed(context);
}

// node_modules/d3-shape/src/curve/monotone.js
function sign(x3) {
  return x3 < 0 ? -1 : 1;
}
function slope3(that, x22, y22) {
  var h0 = that._x1 - that._x0, h1 = x22 - that._x1, s0 = (that._y1 - that._y0) / (h0 || h1 < 0 && -0), s1 = (y22 - that._y1) / (h1 || h0 < 0 && -0), p2 = (s0 * h1 + s1 * h0) / (h0 + h1);
  return (sign(s0) + sign(s1)) * Math.min(Math.abs(s0), Math.abs(s1), 0.5 * Math.abs(p2)) || 0;
}
function slope2(that, t) {
  var h = that._x1 - that._x0;
  return h ? (3 * (that._y1 - that._y0) / h - t) / 2 : t;
}
function point4(that, t02, t12) {
  var x05 = that._x0, y05 = that._y0, x12 = that._x1, y12 = that._y1, dx = (x12 - x05) / 3;
  that._context.bezierCurveTo(x05 + dx, y05 + dx * t02, x12 - dx, y12 - dx * t12, x12, y12);
}
function MonotoneX(context) {
  this._context = context;
}
MonotoneX.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._y0 = this._y1 = this._t0 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x1, this._y1);
        break;
      case 3:
        point4(this, this._t0, slope2(this, this._t0));
        break;
    }
    if (this._line || this._line !== 0 && this._point === 1)
      this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x3, y3) {
    var t12 = NaN;
    x3 = +x3, y3 = +y3;
    if (x3 === this._x1 && y3 === this._y1)
      return;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x3, y3) : this._context.moveTo(x3, y3);
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
        point4(this, slope2(this, t12 = slope3(this, x3, y3)), t12);
        break;
      default:
        point4(this, this._t0, t12 = slope3(this, x3, y3));
        break;
    }
    this._x0 = this._x1, this._x1 = x3;
    this._y0 = this._y1, this._y1 = y3;
    this._t0 = t12;
  }
};
function MonotoneY(context) {
  this._context = new ReflectContext(context);
}
(MonotoneY.prototype = Object.create(MonotoneX.prototype)).point = function(x3, y3) {
  MonotoneX.prototype.point.call(this, y3, x3);
};
function ReflectContext(context) {
  this._context = context;
}
ReflectContext.prototype = {
  moveTo: function(x3, y3) {
    this._context.moveTo(y3, x3);
  },
  closePath: function() {
    this._context.closePath();
  },
  lineTo: function(x3, y3) {
    this._context.lineTo(y3, x3);
  },
  bezierCurveTo: function(x12, y12, x22, y22, x3, y3) {
    this._context.bezierCurveTo(y12, x12, y22, x22, y3, x3);
  }
};
function monotoneX(context) {
  return new MonotoneX(context);
}
function monotoneY(context) {
  return new MonotoneY(context);
}

// node_modules/d3-shape/src/curve/natural.js
function Natural(context) {
  this._context = context;
}
Natural.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x = [];
    this._y = [];
  },
  lineEnd: function() {
    var x3 = this._x, y3 = this._y, n = x3.length;
    if (n) {
      this._line ? this._context.lineTo(x3[0], y3[0]) : this._context.moveTo(x3[0], y3[0]);
      if (n === 2) {
        this._context.lineTo(x3[1], y3[1]);
      } else {
        var px = controlPoints(x3), py = controlPoints(y3);
        for (var i0 = 0, i1 = 1; i1 < n; ++i0, ++i1) {
          this._context.bezierCurveTo(px[0][i0], py[0][i0], px[1][i0], py[1][i0], x3[i1], y3[i1]);
        }
      }
    }
    if (this._line || this._line !== 0 && n === 1)
      this._context.closePath();
    this._line = 1 - this._line;
    this._x = this._y = null;
  },
  point: function(x3, y3) {
    this._x.push(+x3);
    this._y.push(+y3);
  }
};
function controlPoints(x3) {
  var i, n = x3.length - 1, m3, a4 = new Array(n), b = new Array(n), r = new Array(n);
  a4[0] = 0, b[0] = 2, r[0] = x3[0] + 2 * x3[1];
  for (i = 1; i < n - 1; ++i)
    a4[i] = 1, b[i] = 4, r[i] = 4 * x3[i] + 2 * x3[i + 1];
  a4[n - 1] = 2, b[n - 1] = 7, r[n - 1] = 8 * x3[n - 1] + x3[n];
  for (i = 1; i < n; ++i)
    m3 = a4[i] / b[i - 1], b[i] -= m3, r[i] -= m3 * r[i - 1];
  a4[n - 1] = r[n - 1] / b[n - 1];
  for (i = n - 2; i >= 0; --i)
    a4[i] = (r[i] - a4[i + 1]) / b[i];
  b[n - 1] = (x3[n] + a4[n - 1]) / 2;
  for (i = 0; i < n - 1; ++i)
    b[i] = 2 * x3[i + 1] - a4[i + 1];
  return [a4, b];
}

// node_modules/d3-shape/src/curve/step.js
function Step(context, t) {
  this._context = context;
  this._t = t;
}
Step.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x = this._y = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    if (0 < this._t && this._t < 1 && this._point === 2)
      this._context.lineTo(this._x, this._y);
    if (this._line || this._line !== 0 && this._point === 1)
      this._context.closePath();
    if (this._line >= 0)
      this._t = 1 - this._t, this._line = 1 - this._line;
  },
  point: function(x3, y3) {
    x3 = +x3, y3 = +y3;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x3, y3) : this._context.moveTo(x3, y3);
        break;
      case 1:
        this._point = 2;
      default: {
        if (this._t <= 0) {
          this._context.lineTo(this._x, y3);
          this._context.lineTo(x3, y3);
        } else {
          var x12 = this._x * (1 - this._t) + x3 * this._t;
          this._context.lineTo(x12, this._y);
          this._context.lineTo(x12, y3);
        }
        break;
      }
    }
    this._x = x3, this._y = y3;
  }
};
function step_default(context) {
  return new Step(context, 0.5);
}
function stepBefore(context) {
  return new Step(context, 0);
}
function stepAfter(context) {
  return new Step(context, 1);
}

// node_modules/@antv/g2/esm/utils/coordinate.js
function isTranspose(coordinate2) {
  const { transformations } = coordinate2.getOptions();
  const transposes = transformations.map(([type]) => type).filter((type) => type === "transpose");
  return transposes.length % 2 !== 0;
}
function isPolar(coordinate2) {
  const { transformations } = coordinate2.getOptions();
  return transformations.some(([type]) => type === "polar");
}
function isRadial(coordinate2) {
  const { transformations } = coordinate2.getOptions();
  return (
    // distinguish radial from theta.
    transformations.some(([type]) => type === "reflect") && transformations.some(([type]) => type.startsWith("transpose"))
  );
}
function isHelix(coordinate2) {
  const { transformations } = coordinate2.getOptions();
  return transformations.some(([type]) => type === "helix");
}
function isParallel(coordinate2) {
  const { transformations } = coordinate2.getOptions();
  return transformations.some(([type]) => type === "parallel");
}
function isFisheye(coordinate2) {
  const { transformations } = coordinate2.getOptions();
  return transformations.some(([type]) => type === "fisheye");
}
function isRadar(coordinate2) {
  return isParallel(coordinate2) && isPolar(coordinate2);
}
function isCircular(coordinate2) {
  return isHelix(coordinate2) || isPolar(coordinate2);
}
function isTheta(coordinate2) {
  return isPolar(coordinate2) && isTranspose(coordinate2);
}
function getRadius(coordinate2) {
  if (isCircular(coordinate2)) {
    const [width, height] = coordinate2.getSize();
    const polar2 = coordinate2.getOptions().transformations.find((t) => t[0] === "polar");
    if (polar2)
      return Math.max(width, height) / 2 * polar2[4];
  }
  return 0;
}
function radiusOf(coordinate2) {
  const { transformations } = coordinate2.getOptions();
  const [, , , innerRadius, outerRadius] = transformations.find((d2) => d2[0] === "polar");
  return [+innerRadius, +outerRadius];
}
function angleOf(coordinate2, isRadius = true) {
  const { transformations } = coordinate2.getOptions();
  const [, startAngle, endAngle] = transformations.find((d2) => d2[0] === "polar");
  return isRadius ? [+startAngle * 180 / Math.PI, +endAngle * 180 / Math.PI] : [startAngle, endAngle];
}
function getTransformOptions(coordinate2, type) {
  const { transformations } = coordinate2.getOptions();
  const [, ...args] = transformations.find((d2) => d2[0] === type);
  return args;
}

// node_modules/eventemitter3/index.mjs
var import_index = __toESM(require_eventemitter3(), 1);
var eventemitter3_default = import_index.default;

// node_modules/d3-color/src/define.js
function define_default(constructor, factory, prototype) {
  constructor.prototype = factory.prototype = prototype;
  prototype.constructor = constructor;
}
function extend(parent2, definition) {
  var prototype = Object.create(parent2.prototype);
  for (var key in definition)
    prototype[key] = definition[key];
  return prototype;
}

// node_modules/d3-color/src/color.js
function Color() {
}
var darker = 0.7;
var brighter = 1 / darker;
var reI = "\\s*([+-]?\\d+)\\s*";
var reN = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)\\s*";
var reP = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)%\\s*";
var reHex = /^#([0-9a-f]{3,8})$/;
var reRgbInteger = new RegExp("^rgb\\(" + [reI, reI, reI] + "\\)$");
var reRgbPercent = new RegExp("^rgb\\(" + [reP, reP, reP] + "\\)$");
var reRgbaInteger = new RegExp("^rgba\\(" + [reI, reI, reI, reN] + "\\)$");
var reRgbaPercent = new RegExp("^rgba\\(" + [reP, reP, reP, reN] + "\\)$");
var reHslPercent = new RegExp("^hsl\\(" + [reN, reP, reP] + "\\)$");
var reHslaPercent = new RegExp("^hsla\\(" + [reN, reP, reP, reN] + "\\)$");
var named = {
  aliceblue: 15792383,
  antiquewhite: 16444375,
  aqua: 65535,
  aquamarine: 8388564,
  azure: 15794175,
  beige: 16119260,
  bisque: 16770244,
  black: 0,
  blanchedalmond: 16772045,
  blue: 255,
  blueviolet: 9055202,
  brown: 10824234,
  burlywood: 14596231,
  cadetblue: 6266528,
  chartreuse: 8388352,
  chocolate: 13789470,
  coral: 16744272,
  cornflowerblue: 6591981,
  cornsilk: 16775388,
  crimson: 14423100,
  cyan: 65535,
  darkblue: 139,
  darkcyan: 35723,
  darkgoldenrod: 12092939,
  darkgray: 11119017,
  darkgreen: 25600,
  darkgrey: 11119017,
  darkkhaki: 12433259,
  darkmagenta: 9109643,
  darkolivegreen: 5597999,
  darkorange: 16747520,
  darkorchid: 10040012,
  darkred: 9109504,
  darksalmon: 15308410,
  darkseagreen: 9419919,
  darkslateblue: 4734347,
  darkslategray: 3100495,
  darkslategrey: 3100495,
  darkturquoise: 52945,
  darkviolet: 9699539,
  deeppink: 16716947,
  deepskyblue: 49151,
  dimgray: 6908265,
  dimgrey: 6908265,
  dodgerblue: 2003199,
  firebrick: 11674146,
  floralwhite: 16775920,
  forestgreen: 2263842,
  fuchsia: 16711935,
  gainsboro: 14474460,
  ghostwhite: 16316671,
  gold: 16766720,
  goldenrod: 14329120,
  gray: 8421504,
  green: 32768,
  greenyellow: 11403055,
  grey: 8421504,
  honeydew: 15794160,
  hotpink: 16738740,
  indianred: 13458524,
  indigo: 4915330,
  ivory: 16777200,
  khaki: 15787660,
  lavender: 15132410,
  lavenderblush: 16773365,
  lawngreen: 8190976,
  lemonchiffon: 16775885,
  lightblue: 11393254,
  lightcoral: 15761536,
  lightcyan: 14745599,
  lightgoldenrodyellow: 16448210,
  lightgray: 13882323,
  lightgreen: 9498256,
  lightgrey: 13882323,
  lightpink: 16758465,
  lightsalmon: 16752762,
  lightseagreen: 2142890,
  lightskyblue: 8900346,
  lightslategray: 7833753,
  lightslategrey: 7833753,
  lightsteelblue: 11584734,
  lightyellow: 16777184,
  lime: 65280,
  limegreen: 3329330,
  linen: 16445670,
  magenta: 16711935,
  maroon: 8388608,
  mediumaquamarine: 6737322,
  mediumblue: 205,
  mediumorchid: 12211667,
  mediumpurple: 9662683,
  mediumseagreen: 3978097,
  mediumslateblue: 8087790,
  mediumspringgreen: 64154,
  mediumturquoise: 4772300,
  mediumvioletred: 13047173,
  midnightblue: 1644912,
  mintcream: 16121850,
  mistyrose: 16770273,
  moccasin: 16770229,
  navajowhite: 16768685,
  navy: 128,
  oldlace: 16643558,
  olive: 8421376,
  olivedrab: 7048739,
  orange: 16753920,
  orangered: 16729344,
  orchid: 14315734,
  palegoldenrod: 15657130,
  palegreen: 10025880,
  paleturquoise: 11529966,
  palevioletred: 14381203,
  papayawhip: 16773077,
  peachpuff: 16767673,
  peru: 13468991,
  pink: 16761035,
  plum: 14524637,
  powderblue: 11591910,
  purple: 8388736,
  rebeccapurple: 6697881,
  red: 16711680,
  rosybrown: 12357519,
  royalblue: 4286945,
  saddlebrown: 9127187,
  salmon: 16416882,
  sandybrown: 16032864,
  seagreen: 3050327,
  seashell: 16774638,
  sienna: 10506797,
  silver: 12632256,
  skyblue: 8900331,
  slateblue: 6970061,
  slategray: 7372944,
  slategrey: 7372944,
  snow: 16775930,
  springgreen: 65407,
  steelblue: 4620980,
  tan: 13808780,
  teal: 32896,
  thistle: 14204888,
  tomato: 16737095,
  turquoise: 4251856,
  violet: 15631086,
  wheat: 16113331,
  white: 16777215,
  whitesmoke: 16119285,
  yellow: 16776960,
  yellowgreen: 10145074
};
define_default(Color, color, {
  copy: function(channels) {
    return Object.assign(new this.constructor(), this, channels);
  },
  displayable: function() {
    return this.rgb().displayable();
  },
  hex: color_formatHex,
  // Deprecated! Use color.formatHex.
  formatHex: color_formatHex,
  formatHsl: color_formatHsl,
  formatRgb: color_formatRgb,
  toString: color_formatRgb
});
function color_formatHex() {
  return this.rgb().formatHex();
}
function color_formatHsl() {
  return hslConvert(this).formatHsl();
}
function color_formatRgb() {
  return this.rgb().formatRgb();
}
function color(format3) {
  var m3, l;
  format3 = (format3 + "").trim().toLowerCase();
  return (m3 = reHex.exec(format3)) ? (l = m3[1].length, m3 = parseInt(m3[1], 16), l === 6 ? rgbn(m3) : l === 3 ? new Rgb(m3 >> 8 & 15 | m3 >> 4 & 240, m3 >> 4 & 15 | m3 & 240, (m3 & 15) << 4 | m3 & 15, 1) : l === 8 ? rgba(m3 >> 24 & 255, m3 >> 16 & 255, m3 >> 8 & 255, (m3 & 255) / 255) : l === 4 ? rgba(m3 >> 12 & 15 | m3 >> 8 & 240, m3 >> 8 & 15 | m3 >> 4 & 240, m3 >> 4 & 15 | m3 & 240, ((m3 & 15) << 4 | m3 & 15) / 255) : null) : (m3 = reRgbInteger.exec(format3)) ? new Rgb(m3[1], m3[2], m3[3], 1) : (m3 = reRgbPercent.exec(format3)) ? new Rgb(m3[1] * 255 / 100, m3[2] * 255 / 100, m3[3] * 255 / 100, 1) : (m3 = reRgbaInteger.exec(format3)) ? rgba(m3[1], m3[2], m3[3], m3[4]) : (m3 = reRgbaPercent.exec(format3)) ? rgba(m3[1] * 255 / 100, m3[2] * 255 / 100, m3[3] * 255 / 100, m3[4]) : (m3 = reHslPercent.exec(format3)) ? hsla(m3[1], m3[2] / 100, m3[3] / 100, 1) : (m3 = reHslaPercent.exec(format3)) ? hsla(m3[1], m3[2] / 100, m3[3] / 100, m3[4]) : named.hasOwnProperty(format3) ? rgbn(named[format3]) : format3 === "transparent" ? new Rgb(NaN, NaN, NaN, 0) : null;
}
function rgbn(n) {
  return new Rgb(n >> 16 & 255, n >> 8 & 255, n & 255, 1);
}
function rgba(r, g, b, a4) {
  if (a4 <= 0)
    r = g = b = NaN;
  return new Rgb(r, g, b, a4);
}
function rgbConvert(o) {
  if (!(o instanceof Color))
    o = color(o);
  if (!o)
    return new Rgb();
  o = o.rgb();
  return new Rgb(o.r, o.g, o.b, o.opacity);
}
function rgb(r, g, b, opacity) {
  return arguments.length === 1 ? rgbConvert(r) : new Rgb(r, g, b, opacity == null ? 1 : opacity);
}
function Rgb(r, g, b, opacity) {
  this.r = +r;
  this.g = +g;
  this.b = +b;
  this.opacity = +opacity;
}
define_default(Rgb, rgb, extend(Color, {
  brighter: function(k2) {
    k2 = k2 == null ? brighter : Math.pow(brighter, k2);
    return new Rgb(this.r * k2, this.g * k2, this.b * k2, this.opacity);
  },
  darker: function(k2) {
    k2 = k2 == null ? darker : Math.pow(darker, k2);
    return new Rgb(this.r * k2, this.g * k2, this.b * k2, this.opacity);
  },
  rgb: function() {
    return this;
  },
  displayable: function() {
    return -0.5 <= this.r && this.r < 255.5 && (-0.5 <= this.g && this.g < 255.5) && (-0.5 <= this.b && this.b < 255.5) && (0 <= this.opacity && this.opacity <= 1);
  },
  hex: rgb_formatHex,
  // Deprecated! Use color.formatHex.
  formatHex: rgb_formatHex,
  formatRgb: rgb_formatRgb,
  toString: rgb_formatRgb
}));
function rgb_formatHex() {
  return "#" + hex(this.r) + hex(this.g) + hex(this.b);
}
function rgb_formatRgb() {
  var a4 = this.opacity;
  a4 = isNaN(a4) ? 1 : Math.max(0, Math.min(1, a4));
  return (a4 === 1 ? "rgb(" : "rgba(") + Math.max(0, Math.min(255, Math.round(this.r) || 0)) + ", " + Math.max(0, Math.min(255, Math.round(this.g) || 0)) + ", " + Math.max(0, Math.min(255, Math.round(this.b) || 0)) + (a4 === 1 ? ")" : ", " + a4 + ")");
}
function hex(value2) {
  value2 = Math.max(0, Math.min(255, Math.round(value2) || 0));
  return (value2 < 16 ? "0" : "") + value2.toString(16);
}
function hsla(h, s2, l, a4) {
  if (a4 <= 0)
    h = s2 = l = NaN;
  else if (l <= 0 || l >= 1)
    h = s2 = NaN;
  else if (s2 <= 0)
    h = NaN;
  return new Hsl(h, s2, l, a4);
}
function hslConvert(o) {
  if (o instanceof Hsl)
    return new Hsl(o.h, o.s, o.l, o.opacity);
  if (!(o instanceof Color))
    o = color(o);
  if (!o)
    return new Hsl();
  if (o instanceof Hsl)
    return o;
  o = o.rgb();
  var r = o.r / 255, g = o.g / 255, b = o.b / 255, min11 = Math.min(r, g, b), max11 = Math.max(r, g, b), h = NaN, s2 = max11 - min11, l = (max11 + min11) / 2;
  if (s2) {
    if (r === max11)
      h = (g - b) / s2 + (g < b) * 6;
    else if (g === max11)
      h = (b - r) / s2 + 2;
    else
      h = (r - g) / s2 + 4;
    s2 /= l < 0.5 ? max11 + min11 : 2 - max11 - min11;
    h *= 60;
  } else {
    s2 = l > 0 && l < 1 ? 0 : h;
  }
  return new Hsl(h, s2, l, o.opacity);
}
function hsl(h, s2, l, opacity) {
  return arguments.length === 1 ? hslConvert(h) : new Hsl(h, s2, l, opacity == null ? 1 : opacity);
}
function Hsl(h, s2, l, opacity) {
  this.h = +h;
  this.s = +s2;
  this.l = +l;
  this.opacity = +opacity;
}
define_default(Hsl, hsl, extend(Color, {
  brighter: function(k2) {
    k2 = k2 == null ? brighter : Math.pow(brighter, k2);
    return new Hsl(this.h, this.s, this.l * k2, this.opacity);
  },
  darker: function(k2) {
    k2 = k2 == null ? darker : Math.pow(darker, k2);
    return new Hsl(this.h, this.s, this.l * k2, this.opacity);
  },
  rgb: function() {
    var h = this.h % 360 + (this.h < 0) * 360, s2 = isNaN(h) || isNaN(this.s) ? 0 : this.s, l = this.l, m22 = l + (l < 0.5 ? l : 1 - l) * s2, m1 = 2 * l - m22;
    return new Rgb(
      hsl2rgb(h >= 240 ? h - 240 : h + 120, m1, m22),
      hsl2rgb(h, m1, m22),
      hsl2rgb(h < 120 ? h + 240 : h - 120, m1, m22),
      this.opacity
    );
  },
  displayable: function() {
    return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && (0 <= this.l && this.l <= 1) && (0 <= this.opacity && this.opacity <= 1);
  },
  formatHsl: function() {
    var a4 = this.opacity;
    a4 = isNaN(a4) ? 1 : Math.max(0, Math.min(1, a4));
    return (a4 === 1 ? "hsl(" : "hsla(") + (this.h || 0) + ", " + (this.s || 0) * 100 + "%, " + (this.l || 0) * 100 + "%" + (a4 === 1 ? ")" : ", " + a4 + ")");
  }
}));
function hsl2rgb(h, m1, m22) {
  return (h < 60 ? m1 + (m22 - m1) * h / 60 : h < 180 ? m22 : h < 240 ? m1 + (m22 - m1) * (240 - h) / 60 : m1) * 255;
}

// node_modules/d3-color/src/math.js
var deg2rad = Math.PI / 180;
var rad2deg = 180 / Math.PI;

// node_modules/d3-color/src/lab.js
var K = 18;
var Xn = 0.96422;
var Yn = 1;
var Zn = 0.82521;
var t0 = 4 / 29;
var t1 = 6 / 29;
var t2 = 3 * t1 * t1;
var t3 = t1 * t1 * t1;
function labConvert(o) {
  if (o instanceof Lab)
    return new Lab(o.l, o.a, o.b, o.opacity);
  if (o instanceof Hcl)
    return hcl2lab(o);
  if (!(o instanceof Rgb))
    o = rgbConvert(o);
  var r = rgb2lrgb(o.r), g = rgb2lrgb(o.g), b = rgb2lrgb(o.b), y3 = xyz2lab((0.2225045 * r + 0.7168786 * g + 0.0606169 * b) / Yn), x3, z;
  if (r === g && g === b)
    x3 = z = y3;
  else {
    x3 = xyz2lab((0.4360747 * r + 0.3850649 * g + 0.1430804 * b) / Xn);
    z = xyz2lab((0.0139322 * r + 0.0971045 * g + 0.7141733 * b) / Zn);
  }
  return new Lab(116 * y3 - 16, 500 * (x3 - y3), 200 * (y3 - z), o.opacity);
}
function lab(l, a4, b, opacity) {
  return arguments.length === 1 ? labConvert(l) : new Lab(l, a4, b, opacity == null ? 1 : opacity);
}
function Lab(l, a4, b, opacity) {
  this.l = +l;
  this.a = +a4;
  this.b = +b;
  this.opacity = +opacity;
}
define_default(Lab, lab, extend(Color, {
  brighter: function(k2) {
    return new Lab(this.l + K * (k2 == null ? 1 : k2), this.a, this.b, this.opacity);
  },
  darker: function(k2) {
    return new Lab(this.l - K * (k2 == null ? 1 : k2), this.a, this.b, this.opacity);
  },
  rgb: function() {
    var y3 = (this.l + 16) / 116, x3 = isNaN(this.a) ? y3 : y3 + this.a / 500, z = isNaN(this.b) ? y3 : y3 - this.b / 200;
    x3 = Xn * lab2xyz(x3);
    y3 = Yn * lab2xyz(y3);
    z = Zn * lab2xyz(z);
    return new Rgb(
      lrgb2rgb(3.1338561 * x3 - 1.6168667 * y3 - 0.4906146 * z),
      lrgb2rgb(-0.9787684 * x3 + 1.9161415 * y3 + 0.033454 * z),
      lrgb2rgb(0.0719453 * x3 - 0.2289914 * y3 + 1.4052427 * z),
      this.opacity
    );
  }
}));
function xyz2lab(t) {
  return t > t3 ? Math.pow(t, 1 / 3) : t / t2 + t0;
}
function lab2xyz(t) {
  return t > t1 ? t * t * t : t2 * (t - t0);
}
function lrgb2rgb(x3) {
  return 255 * (x3 <= 31308e-7 ? 12.92 * x3 : 1.055 * Math.pow(x3, 1 / 2.4) - 0.055);
}
function rgb2lrgb(x3) {
  return (x3 /= 255) <= 0.04045 ? x3 / 12.92 : Math.pow((x3 + 0.055) / 1.055, 2.4);
}
function hclConvert(o) {
  if (o instanceof Hcl)
    return new Hcl(o.h, o.c, o.l, o.opacity);
  if (!(o instanceof Lab))
    o = labConvert(o);
  if (o.a === 0 && o.b === 0)
    return new Hcl(NaN, 0 < o.l && o.l < 100 ? 0 : NaN, o.l, o.opacity);
  var h = Math.atan2(o.b, o.a) * rad2deg;
  return new Hcl(h < 0 ? h + 360 : h, Math.sqrt(o.a * o.a + o.b * o.b), o.l, o.opacity);
}
function hcl(h, c5, l, opacity) {
  return arguments.length === 1 ? hclConvert(h) : new Hcl(h, c5, l, opacity == null ? 1 : opacity);
}
function Hcl(h, c5, l, opacity) {
  this.h = +h;
  this.c = +c5;
  this.l = +l;
  this.opacity = +opacity;
}
function hcl2lab(o) {
  if (isNaN(o.h))
    return new Lab(o.l, 0, 0, o.opacity);
  var h = o.h * deg2rad;
  return new Lab(o.l, Math.cos(h) * o.c, Math.sin(h) * o.c, o.opacity);
}
define_default(Hcl, hcl, extend(Color, {
  brighter: function(k2) {
    return new Hcl(this.h, this.c, this.l + K * (k2 == null ? 1 : k2), this.opacity);
  },
  darker: function(k2) {
    return new Hcl(this.h, this.c, this.l - K * (k2 == null ? 1 : k2), this.opacity);
  },
  rgb: function() {
    return hcl2lab(this).rgb();
  }
}));

// node_modules/d3-color/src/cubehelix.js
var A = -0.14861;
var B = 1.78277;
var C = -0.29227;
var D = -0.90649;
var E = 1.97294;
var ED = E * D;
var EB = E * B;
var BC_DA = B * C - D * A;
function cubehelixConvert(o) {
  if (o instanceof Cubehelix)
    return new Cubehelix(o.h, o.s, o.l, o.opacity);
  if (!(o instanceof Rgb))
    o = rgbConvert(o);
  var r = o.r / 255, g = o.g / 255, b = o.b / 255, l = (BC_DA * b + ED * r - EB * g) / (BC_DA + ED - EB), bl = b - l, k2 = (E * (g - l) - C * bl) / D, s2 = Math.sqrt(k2 * k2 + bl * bl) / (E * l * (1 - l)), h = s2 ? Math.atan2(k2, bl) * rad2deg - 120 : NaN;
  return new Cubehelix(h < 0 ? h + 360 : h, s2, l, o.opacity);
}
function cubehelix(h, s2, l, opacity) {
  return arguments.length === 1 ? cubehelixConvert(h) : new Cubehelix(h, s2, l, opacity == null ? 1 : opacity);
}
function Cubehelix(h, s2, l, opacity) {
  this.h = +h;
  this.s = +s2;
  this.l = +l;
  this.opacity = +opacity;
}
define_default(Cubehelix, cubehelix, extend(Color, {
  brighter: function(k2) {
    k2 = k2 == null ? brighter : Math.pow(brighter, k2);
    return new Cubehelix(this.h, this.s, this.l * k2, this.opacity);
  },
  darker: function(k2) {
    k2 = k2 == null ? darker : Math.pow(darker, k2);
    return new Cubehelix(this.h, this.s, this.l * k2, this.opacity);
  },
  rgb: function() {
    var h = isNaN(this.h) ? 0 : (this.h + 120) * deg2rad, l = +this.l, a4 = isNaN(this.s) ? 0 : this.s * l * (1 - l), cosh2 = Math.cos(h), sinh2 = Math.sin(h);
    return new Rgb(
      255 * (l + a4 * (A * cosh2 + B * sinh2)),
      255 * (l + a4 * (C * cosh2 + D * sinh2)),
      255 * (l + a4 * (E * cosh2)),
      this.opacity
    );
  }
}));

// node_modules/@antv/g-math/dist/index.esm.js
function distance4(x12, y12, x22, y22) {
  var dx = x12 - x22;
  var dy = y12 - y22;
  return Math.sqrt(dx * dx + dy * dy);
}
function getBBoxByArray(xArr, yArr) {
  var minX = Math.min.apply(Math, __spreadArray([], __read(xArr), false));
  var minY = Math.min.apply(Math, __spreadArray([], __read(yArr), false));
  var maxX = Math.max.apply(Math, __spreadArray([], __read(xArr), false));
  var maxY2 = Math.max.apply(Math, __spreadArray([], __read(yArr), false));
  return {
    x: minX,
    y: minY,
    width: maxX - minX,
    height: maxY2 - minY
  };
}
function xExtrema(rx, ry, xRotation) {
  return Math.atan(-ry / rx * Math.tan(xRotation));
}
function yExtrema(rx, ry, xRotation) {
  return Math.atan(ry / (rx * Math.tan(xRotation)));
}
function xAt(cx, cy, rx, ry, xRotation, angle4) {
  return rx * Math.cos(xRotation) * Math.cos(angle4) - ry * Math.sin(xRotation) * Math.sin(angle4) + cx;
}
function yAt(cx, cy, rx, ry, xRotation, angle4) {
  return rx * Math.sin(xRotation) * Math.cos(angle4) + ry * Math.cos(xRotation) * Math.sin(angle4) + cy;
}
function box$5(cx, cy, rx, ry, xRotation, startAngle, endAngle) {
  var xDim = xExtrema(rx, ry, xRotation);
  var minX = Infinity;
  var maxX = -Infinity;
  var xs = [startAngle, endAngle];
  for (var i = -Math.PI * 2; i <= Math.PI * 2; i += Math.PI) {
    var xAngle = xDim + i;
    if (startAngle < endAngle) {
      if (startAngle < xAngle && xAngle < endAngle) {
        xs.push(xAngle);
      }
    } else {
      if (endAngle < xAngle && xAngle < startAngle) {
        xs.push(xAngle);
      }
    }
  }
  for (var i = 0; i < xs.length; i++) {
    var x3 = xAt(cx, cy, rx, ry, xRotation, xs[i]);
    if (x3 < minX) {
      minX = x3;
    }
    if (x3 > maxX) {
      maxX = x3;
    }
  }
  var yDim = yExtrema(rx, ry, xRotation);
  var minY = Infinity;
  var maxY2 = -Infinity;
  var ys = [startAngle, endAngle];
  for (var i = -Math.PI * 2; i <= Math.PI * 2; i += Math.PI) {
    var yAngle = yDim + i;
    if (startAngle < endAngle) {
      if (startAngle < yAngle && yAngle < endAngle) {
        ys.push(yAngle);
      }
    } else {
      if (endAngle < yAngle && yAngle < startAngle) {
        ys.push(yAngle);
      }
    }
  }
  for (var i = 0; i < ys.length; i++) {
    var y3 = yAt(cx, cy, rx, ry, xRotation, ys[i]);
    if (y3 < minY) {
      minY = y3;
    }
    if (y3 > maxY2) {
      maxY2 = y3;
    }
  }
  return {
    x: minX,
    y: minY,
    width: maxX - minX,
    height: maxY2 - minY
  };
}
var EPSILON2 = 1e-4;
function nearestPoint$2(xArr, yArr, x3, y3, tCallback, length5) {
  var t = -1;
  var d2 = Infinity;
  var v0 = [x3, y3];
  var segNum = 20;
  if (length5 && length5 > 200) {
    segNum = length5 / 10;
  }
  var increaseRate = 1 / segNum;
  var interval2 = increaseRate / 10;
  for (var i = 0; i <= segNum; i++) {
    var _t = i * increaseRate;
    var v1 = [
      tCallback.apply(void 0, __spreadArray([], __read(xArr.concat([_t])), false)),
      tCallback.apply(void 0, __spreadArray([], __read(yArr.concat([_t])), false))
    ];
    var d1 = distance4(v0[0], v0[1], v1[0], v1[1]);
    if (d1 < d2) {
      t = _t;
      d2 = d1;
    }
  }
  if (t === 0) {
    return {
      x: xArr[0],
      y: yArr[0]
    };
  }
  if (t === 1) {
    var count4 = xArr.length;
    return {
      x: xArr[count4 - 1],
      y: yArr[count4 - 1]
    };
  }
  d2 = Infinity;
  for (var i = 0; i < 32; i++) {
    if (interval2 < EPSILON2) {
      break;
    }
    var prev = t - interval2;
    var next = t + interval2;
    var v1 = [
      tCallback.apply(void 0, __spreadArray([], __read(xArr.concat([prev])), false)),
      tCallback.apply(void 0, __spreadArray([], __read(yArr.concat([prev])), false))
    ];
    var d1 = distance4(v0[0], v0[1], v1[0], v1[1]);
    if (prev >= 0 && d1 < d2) {
      t = prev;
      d2 = d1;
    } else {
      var v2 = [
        tCallback.apply(void 0, __spreadArray([], __read(xArr.concat([next])), false)),
        tCallback.apply(void 0, __spreadArray([], __read(yArr.concat([next])), false))
      ];
      var d22 = distance4(v0[0], v0[1], v2[0], v2[1]);
      if (next <= 1 && d22 < d2) {
        t = next;
        d2 = d22;
      } else {
        interval2 *= 0.5;
      }
    }
  }
  return {
    x: tCallback.apply(void 0, __spreadArray([], __read(xArr.concat([t])), false)),
    y: tCallback.apply(void 0, __spreadArray([], __read(yArr.concat([t])), false))
  };
}
function length$4(x12, y12, x22, y22) {
  return distance4(x12, y12, x22, y22);
}
function pointAt$3(x12, y12, x22, y22, t) {
  return {
    x: (1 - t) * x12 + t * x22,
    y: (1 - t) * y12 + t * y22
  };
}
function pointToLine(x12, y12, x22, y22, x3, y3) {
  var d2 = [x22 - x12, y22 - y12];
  if (vec2_exports.exactEquals(d2, [0, 0])) {
    return Math.sqrt((x3 - x12) * (x3 - x12) + (y3 - y12) * (y3 - y12));
  }
  var u = [-d2[1], d2[0]];
  vec2_exports.normalize(u, u);
  var a4 = [x3 - x12, y3 - y12];
  return Math.abs(vec2_exports.dot(a4, u));
}
function cubicAt(p0, p1, p2, p3, t) {
  var onet = 1 - t;
  return onet * onet * onet * p0 + 3 * p1 * t * onet * onet + 3 * p2 * t * t * onet + p3 * t * t * t;
}
function extrema$1(p0, p1, p2, p3) {
  var a4 = -3 * p0 + 9 * p1 - 9 * p2 + 3 * p3;
  var b = 6 * p0 - 12 * p1 + 6 * p2;
  var c5 = 3 * p1 - 3 * p0;
  var extremas = [];
  var t12;
  var t22;
  var discSqrt;
  if (isNumberEqual(a4, 0)) {
    if (!isNumberEqual(b, 0)) {
      t12 = -c5 / b;
      if (t12 >= 0 && t12 <= 1) {
        extremas.push(t12);
      }
    }
  } else {
    var disc = b * b - 4 * a4 * c5;
    if (isNumberEqual(disc, 0)) {
      extremas.push(-b / (2 * a4));
    } else if (disc > 0) {
      discSqrt = Math.sqrt(disc);
      t12 = (-b + discSqrt) / (2 * a4);
      t22 = (-b - discSqrt) / (2 * a4);
      if (t12 >= 0 && t12 <= 1) {
        extremas.push(t12);
      }
      if (t22 >= 0 && t22 <= 1) {
        extremas.push(t22);
      }
    }
  }
  return extremas;
}
function box$3(x12, y12, x22, y22, x3, y3, x4, y4) {
  var xArr = [x12, x4];
  var yArr = [y12, y4];
  var xExtrema2 = extrema$1(x12, x22, x3, x4);
  var yExtrema2 = extrema$1(y12, y22, y3, y4);
  for (var i = 0; i < xExtrema2.length; i++) {
    xArr.push(cubicAt(x12, x22, x3, x4, xExtrema2[i]));
  }
  for (var i = 0; i < yExtrema2.length; i++) {
    yArr.push(cubicAt(y12, y22, y3, y4, yExtrema2[i]));
  }
  return getBBoxByArray(xArr, yArr);
}
function nearestPoint$1(x12, y12, x22, y22, x3, y3, x4, y4, x05, y05, length5) {
  return nearestPoint$2([x12, x22, x3, x4], [y12, y22, y3, y4], x05, y05, cubicAt, length5);
}
function pointDistance$3(x12, y12, x22, y22, x3, y3, x4, y4, x05, y05, length5) {
  var point7 = nearestPoint$1(x12, y12, x22, y22, x3, y3, x4, y4, x05, y05, length5);
  return distance4(point7.x, point7.y, x05, y05);
}
function lengthOfSegment(points) {
  if (points.length < 2) {
    return 0;
  }
  var totalLength = 0;
  for (var i = 0; i < points.length - 1; i++) {
    var from = points[i];
    var to = points[i + 1];
    totalLength += distance4(from[0], from[1], to[0], to[1]);
  }
  return totalLength;
}
function length$2(points) {
  return lengthOfSegment(points);
}
function quadraticAt(p0, p1, p2, t) {
  var onet = 1 - t;
  return onet * onet * p0 + 2 * t * onet * p1 + t * t * p2;
}
function extrema(p0, p1, p2) {
  var a4 = p0 + p2 - 2 * p1;
  if (isNumberEqual(a4, 0)) {
    return [0.5];
  }
  var rst = (p0 - p1) / a4;
  if (rst <= 1 && rst >= 0) {
    return [rst];
  }
  return [];
}
function box(x12, y12, x22, y22, x3, y3) {
  var xExtrema2 = extrema(x12, x22, x3)[0];
  var yExtrema2 = extrema(y12, y22, y3)[0];
  var xArr = [x12, x3];
  var yArr = [y12, y3];
  if (xExtrema2 !== void 0) {
    xArr.push(quadraticAt(x12, x22, x3, xExtrema2));
  }
  if (yExtrema2 !== void 0) {
    yArr.push(quadraticAt(y12, y22, y3, yExtrema2));
  }
  return getBBoxByArray(xArr, yArr);
}
function nearestPoint(x12, y12, x22, y22, x3, y3, x05, y05) {
  return nearestPoint$2([x12, x22, x3], [y12, y22, y3], x05, y05, quadraticAt);
}
function pointDistance(x12, y12, x22, y22, x3, y3, x05, y05) {
  var point7 = nearestPoint(x12, y12, x22, y22, x3, y3, x05, y05);
  return distance4(point7.x, point7.y, x05, y05);
}

// node_modules/@antv/g-lite/dist/index.esm.js
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
var rbush = { exports: {} };
(function(module2, exports2) {
  (function(global2, factory) {
    module2.exports = factory();
  })(commonjsGlobal, function() {
    function quickselect2(arr, k2, left2, right2, compare) {
      quickselectStep(arr, k2, left2 || 0, right2 || arr.length - 1, compare || defaultCompare);
    }
    function quickselectStep(arr, k2, left2, right2, compare) {
      while (right2 > left2) {
        if (right2 - left2 > 600) {
          var n = right2 - left2 + 1;
          var m3 = k2 - left2 + 1;
          var z = Math.log(n);
          var s2 = 0.5 * Math.exp(2 * z / 3);
          var sd = 0.5 * Math.sqrt(z * s2 * (n - s2) / n) * (m3 - n / 2 < 0 ? -1 : 1);
          var newLeft = Math.max(left2, Math.floor(k2 - m3 * s2 / n + sd));
          var newRight = Math.min(right2, Math.floor(k2 + (n - m3) * s2 / n + sd));
          quickselectStep(arr, k2, newLeft, newRight, compare);
        }
        var t = arr[k2];
        var i = left2;
        var j = right2;
        swap2(arr, left2, k2);
        if (compare(arr[right2], t) > 0) {
          swap2(arr, left2, right2);
        }
        while (i < j) {
          swap2(arr, i, j);
          i++;
          j--;
          while (compare(arr[i], t) < 0) {
            i++;
          }
          while (compare(arr[j], t) > 0) {
            j--;
          }
        }
        if (compare(arr[left2], t) === 0) {
          swap2(arr, left2, j);
        } else {
          j++;
          swap2(arr, j, right2);
        }
        if (j <= k2) {
          left2 = j + 1;
        }
        if (k2 <= j) {
          right2 = j - 1;
        }
      }
    }
    function swap2(arr, i, j) {
      var tmp2 = arr[i];
      arr[i] = arr[j];
      arr[j] = tmp2;
    }
    function defaultCompare(a4, b) {
      return a4 < b ? -1 : a4 > b ? 1 : 0;
    }
    var RBush2 = function RBush3(maxEntries) {
      if (maxEntries === void 0)
        maxEntries = 9;
      this._maxEntries = Math.max(4, maxEntries);
      this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4));
      this.clear();
    };
    RBush2.prototype.all = function all() {
      return this._all(this.data, []);
    };
    RBush2.prototype.search = function search2(bbox) {
      var node = this.data;
      var result2 = [];
      if (!intersects2(bbox, node)) {
        return result2;
      }
      var toBBox = this.toBBox;
      var nodesToSearch = [];
      while (node) {
        for (var i = 0; i < node.children.length; i++) {
          var child = node.children[i];
          var childBBox = node.leaf ? toBBox(child) : child;
          if (intersects2(bbox, childBBox)) {
            if (node.leaf) {
              result2.push(child);
            } else if (contains(bbox, childBBox)) {
              this._all(child, result2);
            } else {
              nodesToSearch.push(child);
            }
          }
        }
        node = nodesToSearch.pop();
      }
      return result2;
    };
    RBush2.prototype.collides = function collides(bbox) {
      var node = this.data;
      if (!intersects2(bbox, node)) {
        return false;
      }
      var nodesToSearch = [];
      while (node) {
        for (var i = 0; i < node.children.length; i++) {
          var child = node.children[i];
          var childBBox = node.leaf ? this.toBBox(child) : child;
          if (intersects2(bbox, childBBox)) {
            if (node.leaf || contains(bbox, childBBox)) {
              return true;
            }
            nodesToSearch.push(child);
          }
        }
        node = nodesToSearch.pop();
      }
      return false;
    };
    RBush2.prototype.load = function load(data2) {
      if (!(data2 && data2.length)) {
        return this;
      }
      if (data2.length < this._minEntries) {
        for (var i = 0; i < data2.length; i++) {
          this.insert(data2[i]);
        }
        return this;
      }
      var node = this._build(data2.slice(), 0, data2.length - 1, 0);
      if (!this.data.children.length) {
        this.data = node;
      } else if (this.data.height === node.height) {
        this._splitRoot(this.data, node);
      } else {
        if (this.data.height < node.height) {
          var tmpNode = this.data;
          this.data = node;
          node = tmpNode;
        }
        this._insert(node, this.data.height - node.height - 1, true);
      }
      return this;
    };
    RBush2.prototype.insert = function insert(item) {
      if (item) {
        this._insert(item, this.data.height - 1);
      }
      return this;
    };
    RBush2.prototype.clear = function clear() {
      this.data = createNode3([]);
      return this;
    };
    RBush2.prototype.remove = function remove2(item, equalsFn) {
      if (!item) {
        return this;
      }
      var node = this.data;
      var bbox = this.toBBox(item);
      var path2 = [];
      var indexes2 = [];
      var i, parent2, goingUp;
      while (node || path2.length) {
        if (!node) {
          node = path2.pop();
          parent2 = path2[path2.length - 1];
          i = indexes2.pop();
          goingUp = true;
        }
        if (node.leaf) {
          var index3 = findItem(item, node.children, equalsFn);
          if (index3 !== -1) {
            node.children.splice(index3, 1);
            path2.push(node);
            this._condense(path2);
            return this;
          }
        }
        if (!goingUp && !node.leaf && contains(node, bbox)) {
          path2.push(node);
          indexes2.push(i);
          i = 0;
          parent2 = node;
          node = node.children[0];
        } else if (parent2) {
          i++;
          node = parent2.children[i];
          goingUp = false;
        } else {
          node = null;
        }
      }
      return this;
    };
    RBush2.prototype.toBBox = function toBBox(item) {
      return item;
    };
    RBush2.prototype.compareMinX = function compareMinX(a4, b) {
      return a4.minX - b.minX;
    };
    RBush2.prototype.compareMinY = function compareMinY(a4, b) {
      return a4.minY - b.minY;
    };
    RBush2.prototype.toJSON = function toJSON() {
      return this.data;
    };
    RBush2.prototype.fromJSON = function fromJSON(data2) {
      this.data = data2;
      return this;
    };
    RBush2.prototype._all = function _all(node, result2) {
      var nodesToSearch = [];
      while (node) {
        if (node.leaf) {
          result2.push.apply(result2, node.children);
        } else {
          nodesToSearch.push.apply(nodesToSearch, node.children);
        }
        node = nodesToSearch.pop();
      }
      return result2;
    };
    RBush2.prototype._build = function _build(items, left2, right2, height) {
      var N = right2 - left2 + 1;
      var M2 = this._maxEntries;
      var node;
      if (N <= M2) {
        node = createNode3(items.slice(left2, right2 + 1));
        calcBBox2(node, this.toBBox);
        return node;
      }
      if (!height) {
        height = Math.ceil(Math.log(N) / Math.log(M2));
        M2 = Math.ceil(N / Math.pow(M2, height - 1));
      }
      node = createNode3([]);
      node.leaf = false;
      node.height = height;
      var N2 = Math.ceil(N / M2);
      var N1 = N2 * Math.ceil(Math.sqrt(M2));
      multiSelect(items, left2, right2, N1, this.compareMinX);
      for (var i = left2; i <= right2; i += N1) {
        var right22 = Math.min(i + N1 - 1, right2);
        multiSelect(items, i, right22, N2, this.compareMinY);
        for (var j = i; j <= right22; j += N2) {
          var right3 = Math.min(j + N2 - 1, right22);
          node.children.push(this._build(items, j, right3, height - 1));
        }
      }
      calcBBox2(node, this.toBBox);
      return node;
    };
    RBush2.prototype._chooseSubtree = function _chooseSubtree(bbox, node, level, path2) {
      while (true) {
        path2.push(node);
        if (node.leaf || path2.length - 1 === level) {
          break;
        }
        var minArea = Infinity;
        var minEnlargement = Infinity;
        var targetNode = void 0;
        for (var i = 0; i < node.children.length; i++) {
          var child = node.children[i];
          var area2 = bboxArea(child);
          var enlargement = enlargedArea(bbox, child) - area2;
          if (enlargement < minEnlargement) {
            minEnlargement = enlargement;
            minArea = area2 < minArea ? area2 : minArea;
            targetNode = child;
          } else if (enlargement === minEnlargement) {
            if (area2 < minArea) {
              minArea = area2;
              targetNode = child;
            }
          }
        }
        node = targetNode || node.children[0];
      }
      return node;
    };
    RBush2.prototype._insert = function _insert(item, level, isNode) {
      var bbox = isNode ? item : this.toBBox(item);
      var insertPath = [];
      var node = this._chooseSubtree(bbox, this.data, level, insertPath);
      node.children.push(item);
      extend5(node, bbox);
      while (level >= 0) {
        if (insertPath[level].children.length > this._maxEntries) {
          this._split(insertPath, level);
          level--;
        } else {
          break;
        }
      }
      this._adjustParentBBoxes(bbox, insertPath, level);
    };
    RBush2.prototype._split = function _split(insertPath, level) {
      var node = insertPath[level];
      var M2 = node.children.length;
      var m3 = this._minEntries;
      this._chooseSplitAxis(node, m3, M2);
      var splitIndex = this._chooseSplitIndex(node, m3, M2);
      var newNode = createNode3(node.children.splice(splitIndex, node.children.length - splitIndex));
      newNode.height = node.height;
      newNode.leaf = node.leaf;
      calcBBox2(node, this.toBBox);
      calcBBox2(newNode, this.toBBox);
      if (level) {
        insertPath[level - 1].children.push(newNode);
      } else {
        this._splitRoot(node, newNode);
      }
    };
    RBush2.prototype._splitRoot = function _splitRoot(node, newNode) {
      this.data = createNode3([node, newNode]);
      this.data.height = node.height + 1;
      this.data.leaf = false;
      calcBBox2(this.data, this.toBBox);
    };
    RBush2.prototype._chooseSplitIndex = function _chooseSplitIndex(node, m3, M2) {
      var index3;
      var minOverlap = Infinity;
      var minArea = Infinity;
      for (var i = m3; i <= M2 - m3; i++) {
        var bbox1 = distBBox(node, 0, i, this.toBBox);
        var bbox2 = distBBox(node, i, M2, this.toBBox);
        var overlap = intersectionArea2(bbox1, bbox2);
        var area2 = bboxArea(bbox1) + bboxArea(bbox2);
        if (overlap < minOverlap) {
          minOverlap = overlap;
          index3 = i;
          minArea = area2 < minArea ? area2 : minArea;
        } else if (overlap === minOverlap) {
          if (area2 < minArea) {
            minArea = area2;
            index3 = i;
          }
        }
      }
      return index3 || M2 - m3;
    };
    RBush2.prototype._chooseSplitAxis = function _chooseSplitAxis(node, m3, M2) {
      var compareMinX = node.leaf ? this.compareMinX : compareNodeMinX;
      var compareMinY = node.leaf ? this.compareMinY : compareNodeMinY;
      var xMargin = this._allDistMargin(node, m3, M2, compareMinX);
      var yMargin = this._allDistMargin(node, m3, M2, compareMinY);
      if (xMargin < yMargin) {
        node.children.sort(compareMinX);
      }
    };
    RBush2.prototype._allDistMargin = function _allDistMargin(node, m3, M2, compare) {
      node.children.sort(compare);
      var toBBox = this.toBBox;
      var leftBBox = distBBox(node, 0, m3, toBBox);
      var rightBBox = distBBox(node, M2 - m3, M2, toBBox);
      var margin = bboxMargin(leftBBox) + bboxMargin(rightBBox);
      for (var i = m3; i < M2 - m3; i++) {
        var child = node.children[i];
        extend5(leftBBox, node.leaf ? toBBox(child) : child);
        margin += bboxMargin(leftBBox);
      }
      for (var i$1 = M2 - m3 - 1; i$1 >= m3; i$1--) {
        var child$1 = node.children[i$1];
        extend5(rightBBox, node.leaf ? toBBox(child$1) : child$1);
        margin += bboxMargin(rightBBox);
      }
      return margin;
    };
    RBush2.prototype._adjustParentBBoxes = function _adjustParentBBoxes(bbox, path2, level) {
      for (var i = level; i >= 0; i--) {
        extend5(path2[i], bbox);
      }
    };
    RBush2.prototype._condense = function _condense(path2) {
      for (var i = path2.length - 1, siblings = void 0; i >= 0; i--) {
        if (path2[i].children.length === 0) {
          if (i > 0) {
            siblings = path2[i - 1].children;
            siblings.splice(siblings.indexOf(path2[i]), 1);
          } else {
            this.clear();
          }
        } else {
          calcBBox2(path2[i], this.toBBox);
        }
      }
    };
    function findItem(item, items, equalsFn) {
      if (!equalsFn) {
        return items.indexOf(item);
      }
      for (var i = 0; i < items.length; i++) {
        if (equalsFn(item, items[i])) {
          return i;
        }
      }
      return -1;
    }
    function calcBBox2(node, toBBox) {
      distBBox(node, 0, node.children.length, toBBox, node);
    }
    function distBBox(node, k2, p2, toBBox, destNode) {
      if (!destNode) {
        destNode = createNode3(null);
      }
      destNode.minX = Infinity;
      destNode.minY = Infinity;
      destNode.maxX = -Infinity;
      destNode.maxY = -Infinity;
      for (var i = k2; i < p2; i++) {
        var child = node.children[i];
        extend5(destNode, node.leaf ? toBBox(child) : child);
      }
      return destNode;
    }
    function extend5(a4, b) {
      a4.minX = Math.min(a4.minX, b.minX);
      a4.minY = Math.min(a4.minY, b.minY);
      a4.maxX = Math.max(a4.maxX, b.maxX);
      a4.maxY = Math.max(a4.maxY, b.maxY);
      return a4;
    }
    function compareNodeMinX(a4, b) {
      return a4.minX - b.minX;
    }
    function compareNodeMinY(a4, b) {
      return a4.minY - b.minY;
    }
    function bboxArea(a4) {
      return (a4.maxX - a4.minX) * (a4.maxY - a4.minY);
    }
    function bboxMargin(a4) {
      return a4.maxX - a4.minX + (a4.maxY - a4.minY);
    }
    function enlargedArea(a4, b) {
      return (Math.max(b.maxX, a4.maxX) - Math.min(b.minX, a4.minX)) * (Math.max(b.maxY, a4.maxY) - Math.min(b.minY, a4.minY));
    }
    function intersectionArea2(a4, b) {
      var minX = Math.max(a4.minX, b.minX);
      var minY = Math.max(a4.minY, b.minY);
      var maxX = Math.min(a4.maxX, b.maxX);
      var maxY2 = Math.min(a4.maxY, b.maxY);
      return Math.max(0, maxX - minX) * Math.max(0, maxY2 - minY);
    }
    function contains(a4, b) {
      return a4.minX <= b.minX && a4.minY <= b.minY && b.maxX <= a4.maxX && b.maxY <= a4.maxY;
    }
    function intersects2(a4, b) {
      return b.minX <= a4.maxX && b.minY <= a4.maxY && b.maxX >= a4.minX && b.maxY >= a4.minY;
    }
    function createNode3(children) {
      return {
        children,
        height: 1,
        leaf: true,
        minX: Infinity,
        minY: Infinity,
        maxX: -Infinity,
        maxY: -Infinity
      };
    }
    function multiSelect(arr, left2, right2, n, compare) {
      var stack = [left2, right2];
      while (stack.length) {
        right2 = stack.pop();
        left2 = stack.pop();
        if (right2 - left2 <= n) {
          continue;
        }
        var mid2 = left2 + Math.ceil((right2 - left2) / n / 2) * n;
        quickselect2(arr, mid2, left2, right2, compare);
        stack.push(left2, mid2, mid2, right2);
      }
    }
    return RBush2;
  });
})(rbush);
var RBush = rbush.exports;
var Shape;
(function(Shape4) {
  Shape4["GROUP"] = "g";
  Shape4["CIRCLE"] = "circle";
  Shape4["ELLIPSE"] = "ellipse";
  Shape4["IMAGE"] = "image";
  Shape4["RECT"] = "rect";
  Shape4["LINE"] = "line";
  Shape4["POLYLINE"] = "polyline";
  Shape4["POLYGON"] = "polygon";
  Shape4["TEXT"] = "text";
  Shape4["PATH"] = "path";
  Shape4["HTML"] = "html";
  Shape4["MESH"] = "mesh";
})(Shape || (Shape = {}));
var ClipSpaceNearZ;
(function(ClipSpaceNearZ2) {
  ClipSpaceNearZ2[ClipSpaceNearZ2["ZERO"] = 0] = "ZERO";
  ClipSpaceNearZ2[ClipSpaceNearZ2["NEGATIVE_ONE"] = 1] = "NEGATIVE_ONE";
})(ClipSpaceNearZ || (ClipSpaceNearZ = {}));
var AbstractRendererPlugin = (
  /** @class */
  function() {
    function AbstractRendererPlugin2() {
      this.plugins = [];
    }
    AbstractRendererPlugin2.prototype.addRenderingPlugin = function(plugin) {
      this.plugins.push(plugin);
      this.context.renderingPlugins.push(plugin);
    };
    AbstractRendererPlugin2.prototype.removeAllRenderingPlugins = function() {
      var _this2 = this;
      this.plugins.forEach(function(plugin) {
        var index3 = _this2.context.renderingPlugins.indexOf(plugin);
        if (index3 >= 0) {
          _this2.context.renderingPlugins.splice(index3, 1);
        }
      });
    };
    return AbstractRendererPlugin2;
  }()
);
var AbstractRenderer = (
  /** @class */
  function() {
    function AbstractRenderer2(config) {
      this.clipSpaceNearZ = ClipSpaceNearZ.NEGATIVE_ONE;
      this.plugins = [];
      this.config = __assign({
        /**
         * only dirty object will cause re-render
         */
        enableDirtyCheck: true,
        enableCulling: false,
        /**
         * enable auto rendering by default
         */
        enableAutoRendering: true,
        /**
         * enable dirty rectangle rendering by default
         */
        enableDirtyRectangleRendering: true,
        enableDirtyRectangleRenderingDebug: false
      }, config);
    }
    AbstractRenderer2.prototype.registerPlugin = function(plugin) {
      var index3 = this.plugins.findIndex(function(p2) {
        return p2 === plugin;
      });
      if (index3 === -1) {
        this.plugins.push(plugin);
      }
    };
    AbstractRenderer2.prototype.unregisterPlugin = function(plugin) {
      var index3 = this.plugins.findIndex(function(p2) {
        return p2 === plugin;
      });
      if (index3 > -1) {
        this.plugins.splice(index3, 1);
      }
    };
    AbstractRenderer2.prototype.getPlugins = function() {
      return this.plugins;
    };
    AbstractRenderer2.prototype.getPlugin = function(name2) {
      return this.plugins.find(function(plugin) {
        return plugin.name === name2;
      });
    };
    AbstractRenderer2.prototype.getConfig = function() {
      return this.config;
    };
    AbstractRenderer2.prototype.setConfig = function(config) {
      Object.assign(this.config, config);
    };
    return AbstractRenderer2;
  }()
);
function copyVec3(a4, b) {
  a4[0] = b[0];
  a4[1] = b[1];
  a4[2] = b[2];
  return a4;
}
function subVec3(o, a4, b) {
  o[0] = a4[0] - b[0];
  o[1] = a4[1] - b[1];
  o[2] = a4[2] - b[2];
  return o;
}
function addVec3(o, a4, b) {
  o[0] = a4[0] + b[0];
  o[1] = a4[1] + b[1];
  o[2] = a4[2] + b[2];
  return o;
}
function scaleVec3(o, a4, b) {
  o[0] = a4[0] * b;
  o[1] = a4[1] * b;
  o[2] = a4[2] * b;
  return o;
}
function maxVec3(o, a4, b) {
  o[0] = Math.max(a4[0], b[0]);
  o[1] = Math.max(a4[1], b[1]);
  o[2] = Math.max(a4[2], b[2]);
  return o;
}
function minVec3(o, a4, b) {
  o[0] = Math.min(a4[0], b[0]);
  o[1] = Math.min(a4[1], b[1]);
  o[2] = Math.min(a4[2], b[2]);
  return o;
}
function getAngle2(angle4) {
  if (angle4 === void 0) {
    return 0;
  } else if (angle4 > 360 || angle4 < -360) {
    return angle4 % 360;
  }
  return angle4;
}
function createVec3(x3, y3, z) {
  if (y3 === void 0) {
    y3 = 0;
  }
  if (z === void 0) {
    z = 0;
  }
  if (Array.isArray(x3) && x3.length === 3) {
    return vec3_exports.clone(x3);
  }
  if (is_number_default(x3)) {
    return vec3_exports.fromValues(x3, y3, z);
  }
  return vec3_exports.fromValues(x3[0], x3[1] || y3, x3[2] || z);
}
function deg2rad2(deg) {
  return deg * (Math.PI / 180);
}
function rad2deg2(rad) {
  return rad * (180 / Math.PI);
}
function turn2deg(turn) {
  return 360 * turn;
}
function getEulerFromQuat(out, quat2) {
  var x3 = quat2[0];
  var y3 = quat2[1];
  var z = quat2[2];
  var w = quat2[3];
  var x22 = x3 * x3;
  var y22 = y3 * y3;
  var z2 = z * z;
  var w2 = w * w;
  var unit = x22 + y22 + z2 + w2;
  var test = x3 * w - y3 * z;
  if (test > 0.499995 * unit) {
    out[0] = Math.PI / 2;
    out[1] = 2 * Math.atan2(y3, x3);
    out[2] = 0;
  } else if (test < -0.499995 * unit) {
    out[0] = -Math.PI / 2;
    out[1] = 2 * Math.atan2(y3, x3);
    out[2] = 0;
  } else {
    out[0] = Math.asin(2 * (x3 * z - w * y3));
    out[1] = Math.atan2(2 * (x3 * w + y3 * z), 1 - 2 * (z2 + w2));
    out[2] = Math.atan2(2 * (x3 * y3 + z * w), 1 - 2 * (y22 + z2));
  }
  return out;
}
function getEulerFromMat4(out, m3) {
  var x3;
  var z;
  var halfPi3 = Math.PI * 0.5;
  var _a2 = __read(mat4_exports.getScaling(vec3_exports.create(), m3), 3), sx = _a2[0], sy = _a2[1], sz = _a2[2];
  var y3 = Math.asin(-m3[2] / sx);
  if (y3 < halfPi3) {
    if (y3 > -halfPi3) {
      x3 = Math.atan2(m3[6] / sy, m3[10] / sz);
      z = Math.atan2(m3[1] / sx, m3[0] / sx);
    } else {
      z = 0;
      x3 = -Math.atan2(m3[4] / sy, m3[5] / sy);
    }
  } else {
    z = 0;
    x3 = Math.atan2(m3[4] / sy, m3[5] / sy);
  }
  out[0] = x3;
  out[1] = y3;
  out[2] = z;
  return out;
}
function getEuler(out, quat2) {
  if (quat2.length === 16) {
    return getEulerFromMat4(out, quat2);
  } else {
    return getEulerFromQuat(out, quat2);
  }
}
function fromRotationTranslationScale2(rotation, x3, y3, scaleX, scaleY) {
  var cos4 = Math.cos(rotation);
  var sin3 = Math.sin(rotation);
  return mat3_exports.fromValues(scaleX * cos4, scaleY * sin3, 0, -scaleX * sin3, scaleY * cos4, 0, x3, y3, 1);
}
function makePerspective(out, left2, right2, top, bottom, near, far, zero5) {
  if (zero5 === void 0) {
    zero5 = false;
  }
  var x3 = 2 * near / (right2 - left2);
  var y3 = 2 * near / (top - bottom);
  var a4 = (right2 + left2) / (right2 - left2);
  var b = (top + bottom) / (top - bottom);
  var c5;
  var d2;
  if (zero5) {
    c5 = -far / (far - near);
    d2 = -far * near / (far - near);
  } else {
    c5 = -(far + near) / (far - near);
    d2 = -2 * far * near / (far - near);
  }
  out[0] = x3;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = y3;
  out[6] = 0;
  out[7] = 0;
  out[8] = a4;
  out[9] = b;
  out[10] = c5;
  out[11] = -1;
  out[12] = 0;
  out[13] = 0;
  out[14] = d2;
  out[15] = 0;
  return out;
}
function decompose(mat) {
  var row0x = mat[0];
  var row0y = mat[1];
  var row1x = mat[3];
  var row1y = mat[4];
  var scalingX = Math.sqrt(row0x * row0x + row0y * row0y);
  var scalingY = Math.sqrt(row1x * row1x + row1y * row1y);
  var determinant3 = row0x * row1y - row0y * row1x;
  if (determinant3 < 0) {
    if (row0x < row1y) {
      scalingX = -scalingX;
    } else {
      scalingY = -scalingY;
    }
  }
  if (scalingX) {
    row0x *= 1 / scalingX;
    row0y *= 1 / scalingX;
  }
  if (scalingY) {
    row1x *= 1 / scalingY;
    row1y *= 1 / scalingY;
  }
  var rotation = Math.atan2(row0y, row0x);
  var angle4 = rad2deg2(rotation);
  return [mat[6], mat[7], scalingX, scalingY, angle4];
}
var tmp = mat4_exports.create();
var perspectiveMatrix = mat4_exports.create();
var tmpVec4 = vec4_exports.create();
var row = [vec3_exports.create(), vec3_exports.create(), vec3_exports.create()];
var pdum3 = vec3_exports.create();
function decomposeMat4(matrix2, translation, scale10, skew, perspective2, quaternion) {
  if (!normalize6(tmp, matrix2))
    return false;
  mat4_exports.copy(perspectiveMatrix, tmp);
  perspectiveMatrix[3] = 0;
  perspectiveMatrix[7] = 0;
  perspectiveMatrix[11] = 0;
  perspectiveMatrix[15] = 1;
  if (Math.abs(mat4_exports.determinant(perspectiveMatrix)) < 1e-8)
    return false;
  var a03 = tmp[3], a13 = tmp[7], a23 = tmp[11], a30 = tmp[12], a31 = tmp[13], a32 = tmp[14], a33 = tmp[15];
  if (a03 !== 0 || a13 !== 0 || a23 !== 0) {
    tmpVec4[0] = a03;
    tmpVec4[1] = a13;
    tmpVec4[2] = a23;
    tmpVec4[3] = a33;
    var ret = mat4_exports.invert(perspectiveMatrix, perspectiveMatrix);
    if (!ret)
      return false;
    mat4_exports.transpose(perspectiveMatrix, perspectiveMatrix);
    vec4_exports.transformMat4(perspective2, tmpVec4, perspectiveMatrix);
  } else {
    perspective2[0] = perspective2[1] = perspective2[2] = 0;
    perspective2[3] = 1;
  }
  translation[0] = a30;
  translation[1] = a31;
  translation[2] = a32;
  mat3from4(row, tmp);
  scale10[0] = vec3_exports.length(row[0]);
  vec3_exports.normalize(row[0], row[0]);
  skew[0] = vec3_exports.dot(row[0], row[1]);
  combine2(row[1], row[1], row[0], 1, -skew[0]);
  scale10[1] = vec3_exports.length(row[1]);
  vec3_exports.normalize(row[1], row[1]);
  skew[0] /= scale10[1];
  skew[1] = vec3_exports.dot(row[0], row[2]);
  combine2(row[2], row[2], row[0], 1, -skew[1]);
  skew[2] = vec3_exports.dot(row[1], row[2]);
  combine2(row[2], row[2], row[1], 1, -skew[2]);
  scale10[2] = vec3_exports.length(row[2]);
  vec3_exports.normalize(row[2], row[2]);
  skew[1] /= scale10[2];
  skew[2] /= scale10[2];
  vec3_exports.cross(pdum3, row[1], row[2]);
  if (vec3_exports.dot(row[0], pdum3) < 0) {
    for (var i = 0; i < 3; i++) {
      scale10[i] *= -1;
      row[i][0] *= -1;
      row[i][1] *= -1;
      row[i][2] *= -1;
    }
  }
  quaternion[0] = 0.5 * Math.sqrt(Math.max(1 + row[0][0] - row[1][1] - row[2][2], 0));
  quaternion[1] = 0.5 * Math.sqrt(Math.max(1 - row[0][0] + row[1][1] - row[2][2], 0));
  quaternion[2] = 0.5 * Math.sqrt(Math.max(1 - row[0][0] - row[1][1] + row[2][2], 0));
  quaternion[3] = 0.5 * Math.sqrt(Math.max(1 + row[0][0] + row[1][1] + row[2][2], 0));
  if (row[2][1] > row[1][2])
    quaternion[0] = -quaternion[0];
  if (row[0][2] > row[2][0])
    quaternion[1] = -quaternion[1];
  if (row[1][0] > row[0][1])
    quaternion[2] = -quaternion[2];
  return true;
}
function normalize6(out, mat) {
  var m44 = mat[15];
  if (m44 === 0)
    return false;
  var scale10 = 1 / m44;
  for (var i = 0; i < 16; i++)
    out[i] = mat[i] * scale10;
  return true;
}
function mat3from4(out, mat4x4) {
  out[0][0] = mat4x4[0];
  out[0][1] = mat4x4[1];
  out[0][2] = mat4x4[2];
  out[1][0] = mat4x4[4];
  out[1][1] = mat4x4[5];
  out[1][2] = mat4x4[6];
  out[2][0] = mat4x4[8];
  out[2][1] = mat4x4[9];
  out[2][2] = mat4x4[10];
}
function combine2(out, a4, b, scale1, scale22) {
  out[0] = a4[0] * scale1 + b[0] * scale22;
  out[1] = a4[1] * scale1 + b[1] * scale22;
  out[2] = a4[2] * scale1 + b[2] * scale22;
}
var AABB = (
  /** @class */
  function() {
    function AABB2() {
      this.center = [0, 0, 0];
      this.halfExtents = [0, 0, 0];
      this.min = [0, 0, 0];
      this.max = [0, 0, 0];
    }
    AABB2.isEmpty = function(aabb) {
      return !aabb || aabb.halfExtents[0] === 0 && aabb.halfExtents[1] === 0 && aabb.halfExtents[2] === 0;
    };
    AABB2.prototype.update = function(center2, halfExtents) {
      copyVec3(this.center, center2);
      copyVec3(this.halfExtents, halfExtents);
      subVec3(this.min, this.center, this.halfExtents);
      addVec3(this.max, this.center, this.halfExtents);
    };
    AABB2.prototype.setMinMax = function(min11, max11) {
      addVec3(this.center, max11, min11);
      scaleVec3(this.center, this.center, 0.5);
      subVec3(this.halfExtents, max11, min11);
      scaleVec3(this.halfExtents, this.halfExtents, 0.5);
      copyVec3(this.min, min11);
      copyVec3(this.max, max11);
    };
    AABB2.prototype.getMin = function() {
      return this.min;
    };
    AABB2.prototype.getMax = function() {
      return this.max;
    };
    AABB2.prototype.add = function(aabb) {
      if (AABB2.isEmpty(aabb)) {
        return;
      }
      if (AABB2.isEmpty(this)) {
        this.setMinMax(aabb.getMin(), aabb.getMax());
        return;
      }
      var tc = this.center;
      var tcx = tc[0];
      var tcy = tc[1];
      var tcz = tc[2];
      var th = this.halfExtents;
      var thx = th[0];
      var thy = th[1];
      var thz = th[2];
      var tminx = tcx - thx;
      var tmaxx = tcx + thx;
      var tminy = tcy - thy;
      var tmaxy = tcy + thy;
      var tminz = tcz - thz;
      var tmaxz = tcz + thz;
      var oc = aabb.center;
      var ocx = oc[0];
      var ocy = oc[1];
      var ocz = oc[2];
      var oh = aabb.halfExtents;
      var ohx = oh[0];
      var ohy = oh[1];
      var ohz = oh[2];
      var ominx = ocx - ohx;
      var omaxx = ocx + ohx;
      var ominy = ocy - ohy;
      var omaxy = ocy + ohy;
      var ominz = ocz - ohz;
      var omaxz = ocz + ohz;
      if (ominx < tminx) {
        tminx = ominx;
      }
      if (omaxx > tmaxx) {
        tmaxx = omaxx;
      }
      if (ominy < tminy) {
        tminy = ominy;
      }
      if (omaxy > tmaxy) {
        tmaxy = omaxy;
      }
      if (ominz < tminz) {
        tminz = ominz;
      }
      if (omaxz > tmaxz) {
        tmaxz = omaxz;
      }
      tc[0] = (tminx + tmaxx) * 0.5;
      tc[1] = (tminy + tmaxy) * 0.5;
      tc[2] = (tminz + tmaxz) * 0.5;
      th[0] = (tmaxx - tminx) * 0.5;
      th[1] = (tmaxy - tminy) * 0.5;
      th[2] = (tmaxz - tminz) * 0.5;
      this.min[0] = tminx;
      this.min[1] = tminy;
      this.min[2] = tminz;
      this.max[0] = tmaxx;
      this.max[1] = tmaxy;
      this.max[2] = tmaxz;
    };
    AABB2.prototype.setFromTransformedAABB = function(aabb, m3) {
      var bc = this.center;
      var br = this.halfExtents;
      var ac = aabb.center;
      var ar = aabb.halfExtents;
      var mx0 = m3[0];
      var mx1 = m3[4];
      var mx2 = m3[8];
      var my0 = m3[1];
      var my1 = m3[5];
      var my2 = m3[9];
      var mz0 = m3[2];
      var mz1 = m3[6];
      var mz2 = m3[10];
      var mx0a = Math.abs(mx0);
      var mx1a = Math.abs(mx1);
      var mx2a = Math.abs(mx2);
      var my0a = Math.abs(my0);
      var my1a = Math.abs(my1);
      var my2a = Math.abs(my2);
      var mz0a = Math.abs(mz0);
      var mz1a = Math.abs(mz1);
      var mz2a = Math.abs(mz2);
      bc[0] = m3[12] + mx0 * ac[0] + mx1 * ac[1] + mx2 * ac[2];
      bc[1] = m3[13] + my0 * ac[0] + my1 * ac[1] + my2 * ac[2];
      bc[2] = m3[14] + mz0 * ac[0] + mz1 * ac[1] + mz2 * ac[2];
      br[0] = mx0a * ar[0] + mx1a * ar[1] + mx2a * ar[2];
      br[1] = my0a * ar[0] + my1a * ar[1] + my2a * ar[2];
      br[2] = mz0a * ar[0] + mz1a * ar[1] + mz2a * ar[2];
      subVec3(this.min, bc, br);
      addVec3(this.max, bc, br);
    };
    AABB2.prototype.intersects = function(aabb) {
      var aMax = this.getMax();
      var aMin = this.getMin();
      var bMax = aabb.getMax();
      var bMin = aabb.getMin();
      return aMin[0] <= bMax[0] && aMax[0] >= bMin[0] && aMin[1] <= bMax[1] && aMax[1] >= bMin[1] && aMin[2] <= bMax[2] && aMax[2] >= bMin[2];
    };
    AABB2.prototype.intersection = function(aabb) {
      if (!this.intersects(aabb)) {
        return null;
      }
      var intersection4 = new AABB2();
      var min11 = maxVec3([0, 0, 0], this.getMin(), aabb.getMin());
      var max11 = minVec3([0, 0, 0], this.getMax(), aabb.getMax());
      intersection4.setMinMax(min11, max11);
      return intersection4;
    };
    AABB2.prototype.getNegativeFarPoint = function(plane) {
      if (plane.pnVertexFlag === 273) {
        return copyVec3([0, 0, 0], this.min);
      } else if (plane.pnVertexFlag === 272) {
        return [this.min[0], this.min[1], this.max[2]];
      } else if (plane.pnVertexFlag === 257) {
        return [this.min[0], this.max[1], this.min[2]];
      } else if (plane.pnVertexFlag === 256) {
        return [this.min[0], this.max[1], this.max[2]];
      } else if (plane.pnVertexFlag === 17) {
        return [this.max[0], this.min[1], this.min[2]];
      } else if (plane.pnVertexFlag === 16) {
        return [this.max[0], this.min[1], this.max[2]];
      } else if (plane.pnVertexFlag === 1) {
        return [this.max[0], this.max[1], this.min[2]];
      } else {
        return [this.max[0], this.max[1], this.max[2]];
      }
    };
    AABB2.prototype.getPositiveFarPoint = function(plane) {
      if (plane.pnVertexFlag === 273) {
        return copyVec3([0, 0, 0], this.max);
      } else if (plane.pnVertexFlag === 272) {
        return [this.max[0], this.max[1], this.min[2]];
      } else if (plane.pnVertexFlag === 257) {
        return [this.max[0], this.min[1], this.max[2]];
      } else if (plane.pnVertexFlag === 256) {
        return [this.max[0], this.min[1], this.min[2]];
      } else if (plane.pnVertexFlag === 17) {
        return [this.min[0], this.max[1], this.max[2]];
      } else if (plane.pnVertexFlag === 16) {
        return [this.min[0], this.max[1], this.min[2]];
      } else if (plane.pnVertexFlag === 1) {
        return [this.min[0], this.min[1], this.max[2]];
      } else {
        return [this.min[0], this.min[1], this.min[2]];
      }
    };
    return AABB2;
  }()
);
var Plane = (
  /** @class */
  function() {
    function Plane2(distance7, normal) {
      this.distance = distance7 || 0;
      this.normal = normal || vec3_exports.fromValues(0, 1, 0);
      this.updatePNVertexFlag();
    }
    Plane2.prototype.updatePNVertexFlag = function() {
      this.pnVertexFlag = (Number(this.normal[0] >= 0) << 8) + (Number(this.normal[1] >= 0) << 4) + Number(this.normal[2] >= 0);
    };
    Plane2.prototype.distanceToPoint = function(point7) {
      return vec3_exports.dot(point7, this.normal) - this.distance;
    };
    Plane2.prototype.normalize = function() {
      var invLen = 1 / vec3_exports.len(this.normal);
      vec3_exports.scale(this.normal, this.normal, invLen);
      this.distance *= invLen;
    };
    Plane2.prototype.intersectsLine = function(start, end, point7) {
      var d0 = this.distanceToPoint(start);
      var d1 = this.distanceToPoint(end);
      var t = d0 / (d0 - d1);
      var intersects2 = t >= 0 && t <= 1;
      if (intersects2 && point7) {
        vec3_exports.lerp(point7, start, end, t);
      }
      return intersects2;
    };
    return Plane2;
  }()
);
var Mask;
(function(Mask2) {
  Mask2[Mask2["OUTSIDE"] = 4294967295] = "OUTSIDE";
  Mask2[Mask2["INSIDE"] = 0] = "INSIDE";
  Mask2[Mask2["INDETERMINATE"] = 2147483647] = "INDETERMINATE";
})(Mask || (Mask = {}));
var Frustum = (
  /** @class */
  function() {
    function Frustum2(planes) {
      this.planes = [];
      if (planes) {
        this.planes = planes;
      } else {
        for (var i = 0; i < 6; i++) {
          this.planes.push(new Plane());
        }
      }
    }
    Frustum2.prototype.extractFromVPMatrix = function(projectionMatrix) {
      var _a2 = __read(projectionMatrix, 16), m0 = _a2[0], m1 = _a2[1], m22 = _a2[2], m3 = _a2[3], m4 = _a2[4], m5 = _a2[5], m6 = _a2[6], m7 = _a2[7], m8 = _a2[8], m9 = _a2[9], m10 = _a2[10], m11 = _a2[11], m12 = _a2[12], m13 = _a2[13], m14 = _a2[14], m15 = _a2[15];
      vec3_exports.set(this.planes[0].normal, m3 - m0, m7 - m4, m11 - m8);
      this.planes[0].distance = m15 - m12;
      vec3_exports.set(this.planes[1].normal, m3 + m0, m7 + m4, m11 + m8);
      this.planes[1].distance = m15 + m12;
      vec3_exports.set(this.planes[2].normal, m3 + m1, m7 + m5, m11 + m9);
      this.planes[2].distance = m15 + m13;
      vec3_exports.set(this.planes[3].normal, m3 - m1, m7 - m5, m11 - m9);
      this.planes[3].distance = m15 - m13;
      vec3_exports.set(this.planes[4].normal, m3 - m22, m7 - m6, m11 - m10);
      this.planes[4].distance = m15 - m14;
      vec3_exports.set(this.planes[5].normal, m3 + m22, m7 + m6, m11 + m10);
      this.planes[5].distance = m15 + m14;
      this.planes.forEach(function(plane) {
        plane.normalize();
        plane.updatePNVertexFlag();
      });
    };
    return Frustum2;
  }()
);
var Point2 = (
  /** @class */
  function() {
    function Point6(x3, y3) {
      if (x3 === void 0) {
        x3 = 0;
      }
      if (y3 === void 0) {
        y3 = 0;
      }
      this.x = 0;
      this.y = 0;
      this.x = x3;
      this.y = y3;
    }
    Point6.prototype.clone = function() {
      return new Point6(this.x, this.y);
    };
    Point6.prototype.copyFrom = function(p2) {
      this.x = p2.x;
      this.y = p2.y;
    };
    return Point6;
  }()
);
var Rectangle = (
  /** @class */
  function() {
    function Rectangle2(x3, y3, width, height) {
      this.x = x3;
      this.y = y3;
      this.width = width;
      this.height = height;
      this.left = x3;
      this.right = x3 + width;
      this.top = y3;
      this.bottom = y3 + height;
    }
    Rectangle2.prototype.toJSON = function() {
    };
    return Rectangle2;
  }()
);
var ERROR_MSG_METHOD_NOT_IMPLEMENTED = "Method not implemented.";
var ERROR_MSG_USE_DOCUMENT_ELEMENT = "Use document.documentElement instead.";
var ERROR_MSG_APPEND_DESTROYED_ELEMENT = "Cannot append a destroyed element.";
var CameraType;
(function(CameraType2) {
  CameraType2[CameraType2["ORBITING"] = 0] = "ORBITING";
  CameraType2[CameraType2["EXPLORING"] = 1] = "EXPLORING";
  CameraType2[CameraType2["TRACKING"] = 2] = "TRACKING";
})(CameraType || (CameraType = {}));
var CameraTrackingMode;
(function(CameraTrackingMode2) {
  CameraTrackingMode2[CameraTrackingMode2["DEFAULT"] = 0] = "DEFAULT";
  CameraTrackingMode2[CameraTrackingMode2["ROTATIONAL"] = 1] = "ROTATIONAL";
  CameraTrackingMode2[CameraTrackingMode2["TRANSLATIONAL"] = 2] = "TRANSLATIONAL";
  CameraTrackingMode2[CameraTrackingMode2["CINEMATIC"] = 3] = "CINEMATIC";
})(CameraTrackingMode || (CameraTrackingMode = {}));
var CameraProjectionMode;
(function(CameraProjectionMode2) {
  CameraProjectionMode2[CameraProjectionMode2["ORTHOGRAPHIC"] = 0] = "ORTHOGRAPHIC";
  CameraProjectionMode2[CameraProjectionMode2["PERSPECTIVE"] = 1] = "PERSPECTIVE";
})(CameraProjectionMode || (CameraProjectionMode = {}));
var CameraEvent = {
  UPDATED: "updated"
};
var MIN_DISTANCE = 2e-4;
var Camera = (
  /** @class */
  function() {
    function Camera2() {
      this.clipSpaceNearZ = ClipSpaceNearZ.NEGATIVE_ONE;
      this.eventEmitter = new eventemitter3_default();
      this.matrix = mat4_exports.create();
      this.right = vec3_exports.fromValues(1, 0, 0);
      this.up = vec3_exports.fromValues(0, 1, 0);
      this.forward = vec3_exports.fromValues(0, 0, 1);
      this.position = vec3_exports.fromValues(0, 0, 1);
      this.focalPoint = vec3_exports.fromValues(0, 0, 0);
      this.distanceVector = vec3_exports.fromValues(0, 0, -1);
      this.distance = 1;
      this.azimuth = 0;
      this.elevation = 0;
      this.roll = 0;
      this.relAzimuth = 0;
      this.relElevation = 0;
      this.relRoll = 0;
      this.dollyingStep = 0;
      this.maxDistance = Infinity;
      this.minDistance = -Infinity;
      this.zoom = 1;
      this.rotateWorld = false;
      this.fov = 30;
      this.near = 0.1;
      this.far = 1e3;
      this.aspect = 1;
      this.projectionMatrix = mat4_exports.create();
      this.projectionMatrixInverse = mat4_exports.create();
      this.jitteredProjectionMatrix = void 0;
      this.enableUpdate = true;
      this.type = CameraType.EXPLORING;
      this.trackingMode = CameraTrackingMode.DEFAULT;
      this.projectionMode = CameraProjectionMode.PERSPECTIVE;
      this.frustum = new Frustum();
      this.orthoMatrix = mat4_exports.create();
    }
    Camera2.prototype.isOrtho = function() {
      return this.projectionMode === CameraProjectionMode.ORTHOGRAPHIC;
    };
    Camera2.prototype.getProjectionMode = function() {
      return this.projectionMode;
    };
    Camera2.prototype.getPerspective = function() {
      return this.jitteredProjectionMatrix || this.projectionMatrix;
    };
    Camera2.prototype.getPerspectiveInverse = function() {
      return this.projectionMatrixInverse;
    };
    Camera2.prototype.getFrustum = function() {
      return this.frustum;
    };
    Camera2.prototype.getPosition = function() {
      return this.position;
    };
    Camera2.prototype.getFocalPoint = function() {
      return this.focalPoint;
    };
    Camera2.prototype.getDollyingStep = function() {
      return this.dollyingStep;
    };
    Camera2.prototype.getNear = function() {
      return this.near;
    };
    Camera2.prototype.getFar = function() {
      return this.far;
    };
    Camera2.prototype.getZoom = function() {
      return this.zoom;
    };
    Camera2.prototype.getOrthoMatrix = function() {
      return this.orthoMatrix;
    };
    Camera2.prototype.getView = function() {
      return this.view;
    };
    Camera2.prototype.setEnableUpdate = function(enabled) {
      this.enableUpdate = enabled;
    };
    Camera2.prototype.setType = function(type, trackingMode) {
      this.type = type;
      if (this.type === CameraType.EXPLORING) {
        this.setWorldRotation(true);
      } else {
        this.setWorldRotation(false);
      }
      this._getAngles();
      if (this.type === CameraType.TRACKING && trackingMode !== void 0) {
        this.setTrackingMode(trackingMode);
      }
      return this;
    };
    Camera2.prototype.setProjectionMode = function(projectionMode) {
      this.projectionMode = projectionMode;
      return this;
    };
    Camera2.prototype.setTrackingMode = function(trackingMode) {
      if (this.type !== CameraType.TRACKING) {
        throw new Error("Impossible to set a tracking mode if the camera is not of tracking type");
      }
      this.trackingMode = trackingMode;
      return this;
    };
    Camera2.prototype.setWorldRotation = function(flag) {
      this.rotateWorld = flag;
      this._getAngles();
      return this;
    };
    Camera2.prototype.getViewTransform = function() {
      return mat4_exports.invert(mat4_exports.create(), this.matrix);
    };
    Camera2.prototype.getWorldTransform = function() {
      return this.matrix;
    };
    Camera2.prototype.jitterProjectionMatrix = function(x3, y3) {
      var translation = mat4_exports.fromTranslation(mat4_exports.create(), [x3, y3, 0]);
      this.jitteredProjectionMatrix = mat4_exports.multiply(mat4_exports.create(), translation, this.projectionMatrix);
    };
    Camera2.prototype.clearJitterProjectionMatrix = function() {
      this.jitteredProjectionMatrix = void 0;
    };
    Camera2.prototype.setMatrix = function(matrix2) {
      this.matrix = matrix2;
      this._update();
      return this;
    };
    Camera2.prototype.setFov = function(fov) {
      this.setPerspective(this.near, this.far, fov, this.aspect);
      return this;
    };
    Camera2.prototype.setAspect = function(aspect) {
      this.setPerspective(this.near, this.far, this.fov, aspect);
      return this;
    };
    Camera2.prototype.setNear = function(near) {
      if (this.projectionMode === CameraProjectionMode.PERSPECTIVE) {
        this.setPerspective(near, this.far, this.fov, this.aspect);
      } else {
        this.setOrthographic(this.left, this.rright, this.top, this.bottom, near, this.far);
      }
      return this;
    };
    Camera2.prototype.setFar = function(far) {
      if (this.projectionMode === CameraProjectionMode.PERSPECTIVE) {
        this.setPerspective(this.near, far, this.fov, this.aspect);
      } else {
        this.setOrthographic(this.left, this.rright, this.top, this.bottom, this.near, far);
      }
      return this;
    };
    Camera2.prototype.setViewOffset = function(fullWidth, fullHeight, x3, y3, width, height) {
      this.aspect = fullWidth / fullHeight;
      if (this.view === void 0) {
        this.view = {
          enabled: true,
          fullWidth: 1,
          fullHeight: 1,
          offsetX: 0,
          offsetY: 0,
          width: 1,
          height: 1
        };
      }
      this.view.enabled = true;
      this.view.fullWidth = fullWidth;
      this.view.fullHeight = fullHeight;
      this.view.offsetX = x3;
      this.view.offsetY = y3;
      this.view.width = width;
      this.view.height = height;
      if (this.projectionMode === CameraProjectionMode.PERSPECTIVE) {
        this.setPerspective(this.near, this.far, this.fov, this.aspect);
      } else {
        this.setOrthographic(this.left, this.rright, this.top, this.bottom, this.near, this.far);
      }
      return this;
    };
    Camera2.prototype.clearViewOffset = function() {
      if (this.view !== void 0) {
        this.view.enabled = false;
      }
      if (this.projectionMode === CameraProjectionMode.PERSPECTIVE) {
        this.setPerspective(this.near, this.far, this.fov, this.aspect);
      } else {
        this.setOrthographic(this.left, this.rright, this.top, this.bottom, this.near, this.far);
      }
      return this;
    };
    Camera2.prototype.setZoom = function(zoom) {
      this.zoom = zoom;
      if (this.projectionMode === CameraProjectionMode.ORTHOGRAPHIC) {
        this.setOrthographic(this.left, this.rright, this.top, this.bottom, this.near, this.far);
      } else if (this.projectionMode === CameraProjectionMode.PERSPECTIVE) {
        this.setPerspective(this.near, this.far, this.fov, this.aspect);
      }
      return this;
    };
    Camera2.prototype.setZoomByViewportPoint = function(zoom, viewportPoint) {
      var _a2 = this.canvas.viewport2Canvas({
        x: viewportPoint[0],
        y: viewportPoint[1]
      }), ox = _a2.x, oy = _a2.y;
      var roll = this.roll;
      this.rotate(0, 0, -roll);
      this.setPosition(ox, oy);
      this.setFocalPoint(ox, oy);
      this.setZoom(zoom);
      this.rotate(0, 0, roll);
      var _b = this.canvas.viewport2Canvas({
        x: viewportPoint[0],
        y: viewportPoint[1]
      }), cx = _b.x, cy = _b.y;
      var dvec = vec3_exports.fromValues(cx - ox, cy - oy, 0);
      var dx = vec3_exports.dot(dvec, this.right) / vec3_exports.length(this.right);
      var dy = vec3_exports.dot(dvec, this.up) / vec3_exports.length(this.up);
      this.pan(-dx, -dy);
      return this;
    };
    Camera2.prototype.setPerspective = function(near, far, fov, aspect) {
      var _a2;
      this.projectionMode = CameraProjectionMode.PERSPECTIVE;
      this.fov = fov;
      this.near = near;
      this.far = far;
      this.aspect = aspect;
      var top = this.near * Math.tan(deg2rad2(0.5 * this.fov)) / this.zoom;
      var height = 2 * top;
      var width = this.aspect * height;
      var left2 = -0.5 * width;
      if ((_a2 = this.view) === null || _a2 === void 0 ? void 0 : _a2.enabled) {
        var fullWidth = this.view.fullWidth;
        var fullHeight = this.view.fullHeight;
        left2 += this.view.offsetX * width / fullWidth;
        top -= this.view.offsetY * height / fullHeight;
        width *= this.view.width / fullWidth;
        height *= this.view.height / fullHeight;
      }
      makePerspective(this.projectionMatrix, left2, left2 + width, top, top - height, near, this.far, this.clipSpaceNearZ === ClipSpaceNearZ.ZERO);
      mat4_exports.scale(this.projectionMatrix, this.projectionMatrix, vec3_exports.fromValues(1, -1, 1));
      mat4_exports.invert(this.projectionMatrixInverse, this.projectionMatrix);
      this.triggerUpdate();
      return this;
    };
    Camera2.prototype.setOrthographic = function(l, r, t, b, near, far) {
      var _a2;
      this.projectionMode = CameraProjectionMode.ORTHOGRAPHIC;
      this.rright = r;
      this.left = l;
      this.top = t;
      this.bottom = b;
      this.near = near;
      this.far = far;
      var dx = (this.rright - this.left) / (2 * this.zoom);
      var dy = (this.top - this.bottom) / (2 * this.zoom);
      var cx = (this.rright + this.left) / 2;
      var cy = (this.top + this.bottom) / 2;
      var left2 = cx - dx;
      var right2 = cx + dx;
      var top = cy + dy;
      var bottom = cy - dy;
      if ((_a2 = this.view) === null || _a2 === void 0 ? void 0 : _a2.enabled) {
        var scaleW = (this.rright - this.left) / this.view.fullWidth / this.zoom;
        var scaleH = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
        left2 += scaleW * this.view.offsetX;
        right2 = left2 + scaleW * this.view.width;
        top -= scaleH * this.view.offsetY;
        bottom = top - scaleH * this.view.height;
      }
      if (this.clipSpaceNearZ === ClipSpaceNearZ.NEGATIVE_ONE) {
        mat4_exports.ortho(this.projectionMatrix, left2, right2, bottom, top, near, far);
      } else {
        mat4_exports.orthoZO(this.projectionMatrix, left2, right2, bottom, top, near, far);
      }
      mat4_exports.scale(this.projectionMatrix, this.projectionMatrix, vec3_exports.fromValues(1, -1, 1));
      mat4_exports.invert(this.projectionMatrixInverse, this.projectionMatrix);
      this._getOrthoMatrix();
      this.triggerUpdate();
      return this;
    };
    Camera2.prototype.setPosition = function(x3, y3, z) {
      if (y3 === void 0) {
        y3 = this.position[1];
      }
      if (z === void 0) {
        z = this.position[2];
      }
      var position = createVec3(x3, y3, z);
      this._setPosition(position);
      this.setFocalPoint(this.focalPoint);
      this.triggerUpdate();
      return this;
    };
    Camera2.prototype.setFocalPoint = function(x3, y3, z) {
      if (y3 === void 0) {
        y3 = this.focalPoint[1];
      }
      if (z === void 0) {
        z = this.focalPoint[2];
      }
      var up = vec3_exports.fromValues(0, 1, 0);
      this.focalPoint = createVec3(x3, y3, z);
      if (this.trackingMode === CameraTrackingMode.CINEMATIC) {
        var d2 = vec3_exports.subtract(vec3_exports.create(), this.focalPoint, this.position);
        x3 = d2[0];
        y3 = d2[1];
        z = d2[2];
        var r = vec3_exports.length(d2);
        var el = rad2deg2(Math.asin(y3 / r));
        var az = 90 + rad2deg2(Math.atan2(z, x3));
        var m3 = mat4_exports.create();
        mat4_exports.rotateY(m3, m3, deg2rad2(az));
        mat4_exports.rotateX(m3, m3, deg2rad2(el));
        up = vec3_exports.transformMat4(vec3_exports.create(), [0, 1, 0], m3);
      }
      mat4_exports.invert(this.matrix, mat4_exports.lookAt(mat4_exports.create(), this.position, this.focalPoint, up));
      this._getAxes();
      this._getDistance();
      this._getAngles();
      this.triggerUpdate();
      return this;
    };
    Camera2.prototype.getDistance = function() {
      return this.distance;
    };
    Camera2.prototype.getDistanceVector = function() {
      return this.distanceVector;
    };
    Camera2.prototype.setDistance = function(d2) {
      if (this.distance === d2 || d2 < 0) {
        return this;
      }
      this.distance = d2;
      if (this.distance < MIN_DISTANCE) {
        this.distance = MIN_DISTANCE;
      }
      this.dollyingStep = this.distance / 100;
      var pos = vec3_exports.create();
      d2 = this.distance;
      var n = this.forward;
      var f = this.focalPoint;
      pos[0] = d2 * n[0] + f[0];
      pos[1] = d2 * n[1] + f[1];
      pos[2] = d2 * n[2] + f[2];
      this._setPosition(pos);
      this.triggerUpdate();
      return this;
    };
    Camera2.prototype.setMaxDistance = function(d2) {
      this.maxDistance = d2;
      return this;
    };
    Camera2.prototype.setMinDistance = function(d2) {
      this.minDistance = d2;
      return this;
    };
    Camera2.prototype.setAzimuth = function(az) {
      this.azimuth = getAngle2(az);
      this.computeMatrix();
      this._getAxes();
      if (this.type === CameraType.ORBITING || this.type === CameraType.EXPLORING) {
        this._getPosition();
      } else if (this.type === CameraType.TRACKING) {
        this._getFocalPoint();
      }
      this.triggerUpdate();
      return this;
    };
    Camera2.prototype.getAzimuth = function() {
      return this.azimuth;
    };
    Camera2.prototype.setElevation = function(el) {
      this.elevation = getAngle2(el);
      this.computeMatrix();
      this._getAxes();
      if (this.type === CameraType.ORBITING || this.type === CameraType.EXPLORING) {
        this._getPosition();
      } else if (this.type === CameraType.TRACKING) {
        this._getFocalPoint();
      }
      this.triggerUpdate();
      return this;
    };
    Camera2.prototype.getElevation = function() {
      return this.elevation;
    };
    Camera2.prototype.setRoll = function(angle4) {
      this.roll = getAngle2(angle4);
      this.computeMatrix();
      this._getAxes();
      if (this.type === CameraType.ORBITING || this.type === CameraType.EXPLORING) {
        this._getPosition();
      } else if (this.type === CameraType.TRACKING) {
        this._getFocalPoint();
      }
      this.triggerUpdate();
      return this;
    };
    Camera2.prototype.getRoll = function() {
      return this.roll;
    };
    Camera2.prototype._update = function() {
      this._getAxes();
      this._getPosition();
      this._getDistance();
      this._getAngles();
      this._getOrthoMatrix();
      this.triggerUpdate();
    };
    Camera2.prototype.computeMatrix = function() {
      var rotZ = quat_exports.setAxisAngle(quat_exports.create(), [0, 0, 1], deg2rad2(this.roll));
      mat4_exports.identity(this.matrix);
      var rotX = quat_exports.setAxisAngle(quat_exports.create(), [1, 0, 0], deg2rad2((this.rotateWorld && this.type !== CameraType.TRACKING || this.type === CameraType.TRACKING ? 1 : -1) * this.elevation));
      var rotY = quat_exports.setAxisAngle(quat_exports.create(), [0, 1, 0], deg2rad2((this.rotateWorld && this.type !== CameraType.TRACKING || this.type === CameraType.TRACKING ? 1 : -1) * this.azimuth));
      var rotQ = quat_exports.multiply(quat_exports.create(), rotY, rotX);
      rotQ = quat_exports.multiply(quat_exports.create(), rotQ, rotZ);
      var rotMatrix = mat4_exports.fromQuat(mat4_exports.create(), rotQ);
      if (this.type === CameraType.ORBITING || this.type === CameraType.EXPLORING) {
        mat4_exports.translate(this.matrix, this.matrix, this.focalPoint);
        mat4_exports.multiply(this.matrix, this.matrix, rotMatrix);
        mat4_exports.translate(this.matrix, this.matrix, [0, 0, this.distance]);
      } else if (this.type === CameraType.TRACKING) {
        mat4_exports.translate(this.matrix, this.matrix, this.position);
        mat4_exports.multiply(this.matrix, this.matrix, rotMatrix);
      }
    };
    Camera2.prototype._setPosition = function(x3, y3, z) {
      this.position = createVec3(x3, y3, z);
      var m3 = this.matrix;
      m3[12] = this.position[0];
      m3[13] = this.position[1];
      m3[14] = this.position[2];
      m3[15] = 1;
      this._getOrthoMatrix();
    };
    Camera2.prototype._getAxes = function() {
      vec3_exports.copy(this.right, createVec3(vec4_exports.transformMat4(vec4_exports.create(), [1, 0, 0, 0], this.matrix)));
      vec3_exports.copy(this.up, createVec3(vec4_exports.transformMat4(vec4_exports.create(), [0, 1, 0, 0], this.matrix)));
      vec3_exports.copy(this.forward, createVec3(vec4_exports.transformMat4(vec4_exports.create(), [0, 0, 1, 0], this.matrix)));
      vec3_exports.normalize(this.right, this.right);
      vec3_exports.normalize(this.up, this.up);
      vec3_exports.normalize(this.forward, this.forward);
    };
    Camera2.prototype._getAngles = function() {
      var x3 = this.distanceVector[0];
      var y3 = this.distanceVector[1];
      var z = this.distanceVector[2];
      var r = vec3_exports.length(this.distanceVector);
      if (r === 0) {
        this.elevation = 0;
        this.azimuth = 0;
        return;
      }
      if (this.type === CameraType.TRACKING) {
        this.elevation = rad2deg2(Math.asin(y3 / r));
        this.azimuth = rad2deg2(Math.atan2(-x3, -z));
      } else {
        if (this.rotateWorld) {
          this.elevation = rad2deg2(Math.asin(y3 / r));
          this.azimuth = rad2deg2(Math.atan2(-x3, -z));
        } else {
          this.elevation = -rad2deg2(Math.asin(y3 / r));
          this.azimuth = -rad2deg2(Math.atan2(-x3, -z));
        }
      }
    };
    Camera2.prototype._getPosition = function() {
      vec3_exports.copy(this.position, createVec3(vec4_exports.transformMat4(vec4_exports.create(), [0, 0, 0, 1], this.matrix)));
      this._getDistance();
    };
    Camera2.prototype._getFocalPoint = function() {
      vec3_exports.transformMat3(this.distanceVector, [0, 0, -this.distance], mat3_exports.fromMat4(mat3_exports.create(), this.matrix));
      vec3_exports.add(this.focalPoint, this.position, this.distanceVector);
      this._getDistance();
    };
    Camera2.prototype._getDistance = function() {
      this.distanceVector = vec3_exports.subtract(vec3_exports.create(), this.focalPoint, this.position);
      this.distance = vec3_exports.length(this.distanceVector);
      this.dollyingStep = this.distance / 100;
    };
    Camera2.prototype._getOrthoMatrix = function() {
      if (this.projectionMode !== CameraProjectionMode.ORTHOGRAPHIC) {
        return;
      }
      var position = this.position;
      var rotZ = quat_exports.setAxisAngle(quat_exports.create(), [0, 0, 1], -this.roll * Math.PI / 180);
      mat4_exports.fromRotationTranslationScaleOrigin(this.orthoMatrix, rotZ, vec3_exports.fromValues((this.rright - this.left) / 2 - position[0], (this.top - this.bottom) / 2 - position[1], 0), vec3_exports.fromValues(this.zoom, this.zoom, 1), position);
    };
    Camera2.prototype.triggerUpdate = function() {
      if (this.enableUpdate) {
        var viewMatrix = this.getViewTransform();
        var vpMatrix = mat4_exports.multiply(mat4_exports.create(), this.getPerspective(), viewMatrix);
        this.getFrustum().extractFromVPMatrix(vpMatrix);
        this.eventEmitter.emit(CameraEvent.UPDATED);
      }
    };
    Camera2.prototype.rotate = function(azimuth, elevation, roll) {
      throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
    };
    Camera2.prototype.pan = function(tx, ty) {
      throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
    };
    Camera2.prototype.dolly = function(value2) {
      throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
    };
    Camera2.prototype.createLandmark = function(name2, params) {
      throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
    };
    Camera2.prototype.gotoLandmark = function(name2, options) {
      throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
    };
    Camera2.prototype.cancelLandmarkAnimation = function() {
      throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
    };
    return Camera2;
  }()
);
function memoize(func, resolver) {
  if (typeof func !== "function" || resolver != null && typeof resolver !== "function") {
    throw new TypeError("Expected a function");
  }
  var memoized = function() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    var key = resolver ? resolver.apply(this, args) : args[0];
    var cache2 = memoized.cache;
    if (cache2.has(key)) {
      return cache2.get(key);
    }
    var result2 = func.apply(this, args);
    memoized.cache = cache2.set(key, result2) || cache2;
    return result2;
  };
  memoized.cache = new (memoize.Cache || Map)();
  return memoized;
}
memoize.Cache = Map;
var UnitType;
(function(UnitType2) {
  UnitType2[UnitType2["kUnknown"] = 0] = "kUnknown";
  UnitType2[UnitType2["kNumber"] = 1] = "kNumber";
  UnitType2[UnitType2["kPercentage"] = 2] = "kPercentage";
  UnitType2[UnitType2["kEms"] = 3] = "kEms";
  UnitType2[UnitType2["kPixels"] = 4] = "kPixels";
  UnitType2[UnitType2["kRems"] = 5] = "kRems";
  UnitType2[UnitType2["kDegrees"] = 6] = "kDegrees";
  UnitType2[UnitType2["kRadians"] = 7] = "kRadians";
  UnitType2[UnitType2["kGradians"] = 8] = "kGradians";
  UnitType2[UnitType2["kTurns"] = 9] = "kTurns";
  UnitType2[UnitType2["kMilliseconds"] = 10] = "kMilliseconds";
  UnitType2[UnitType2["kSeconds"] = 11] = "kSeconds";
  UnitType2[UnitType2["kInteger"] = 12] = "kInteger";
})(UnitType || (UnitType = {}));
var UnitCategory;
(function(UnitCategory2) {
  UnitCategory2[UnitCategory2["kUNumber"] = 0] = "kUNumber";
  UnitCategory2[UnitCategory2["kUPercent"] = 1] = "kUPercent";
  UnitCategory2[UnitCategory2["kULength"] = 2] = "kULength";
  UnitCategory2[UnitCategory2["kUAngle"] = 3] = "kUAngle";
  UnitCategory2[UnitCategory2["kUTime"] = 4] = "kUTime";
  UnitCategory2[UnitCategory2["kUOther"] = 5] = "kUOther";
})(UnitCategory || (UnitCategory = {}));
var ValueRange;
(function(ValueRange2) {
  ValueRange2[ValueRange2["kAll"] = 0] = "kAll";
  ValueRange2[ValueRange2["kNonNegative"] = 1] = "kNonNegative";
  ValueRange2[ValueRange2["kInteger"] = 2] = "kInteger";
  ValueRange2[ValueRange2["kNonNegativeInteger"] = 3] = "kNonNegativeInteger";
  ValueRange2[ValueRange2["kPositiveInteger"] = 4] = "kPositiveInteger";
})(ValueRange || (ValueRange = {}));
var Nested;
(function(Nested2) {
  Nested2[Nested2["kYes"] = 0] = "kYes";
  Nested2[Nested2["kNo"] = 1] = "kNo";
})(Nested || (Nested = {}));
var ParenLess;
(function(ParenLess2) {
  ParenLess2[ParenLess2["kYes"] = 0] = "kYes";
  ParenLess2[ParenLess2["kNo"] = 1] = "kNo";
})(ParenLess || (ParenLess = {}));
var data = [
  {
    name: "em",
    unit_type: UnitType.kEms
  },
  // {
  //   name: 'ex',
  //   unit_type: UnitType.kExs,
  // },
  {
    name: "px",
    unit_type: UnitType.kPixels
  },
  // {
  //   name: "cm",
  //   unit_type: UnitType.kCentimeters,
  // },
  // {
  //   name: "mm",
  //   unit_type: UnitType.kMillimeters,
  // },
  // {
  //   name: "q",
  //   unit_type: UnitType.kQuarterMillimeters,
  // },
  // {
  //   name: "in",
  //   unit_type: UnitType.kInches,
  // },
  // {
  //   name: "pt",
  //   unit_type: UnitType.kPoints,
  // },
  // {
  //   name: "pc",
  //   unit_type: UnitType.kPicas,
  // },
  {
    name: "deg",
    unit_type: UnitType.kDegrees
  },
  {
    name: "rad",
    unit_type: UnitType.kRadians
  },
  {
    name: "grad",
    unit_type: UnitType.kGradians
  },
  {
    name: "ms",
    unit_type: UnitType.kMilliseconds
  },
  {
    name: "s",
    unit_type: UnitType.kSeconds
  },
  // {
  //   name: "hz",
  //   unit_type: UnitType.kHertz,
  // },
  // {
  //   name: "khz",
  //   unit_type: UnitType.kKilohertz,
  // },
  // {
  //   name: "dpi",
  //   unit_type: "kDotsPerInch",
  // },
  // {
  //   name: "dpcm",
  //   unit_type: "kDotsPerCentimeter",
  // },
  // {
  //   name: "dppx",
  //   unit_type: "kDotsPerPixel",
  // },
  // {
  //   name: "x",
  //   unit_type: "kDotsPerPixel",
  // },
  // {
  //   name: "vw",
  //   unit_type: "kViewportWidth",
  // },
  // {
  //   name: "vh",
  //   unit_type: "kViewportHeight",
  // },
  // {
  //   name: "vi",
  //   unit_type: "kViewportInlineSize",
  // },
  // {
  //   name: "vb",
  //   unit_type: "kViewportBlockSize",
  // },
  // {
  //   name: "vmin",
  //   unit_type: UnitType.kViewportMin,
  // },
  // {
  //   name: "vmax",
  //   unit_type: UnitType.kViewportMax,
  // },
  // {
  //   name: "svw",
  //   unit_type: "kSmallViewportWidth",
  // },
  // {
  //   name: "svh",
  //   unit_type: "kSmallViewportHeight",
  // },
  // {
  //   name: "svi",
  //   unit_type: "kSmallViewportInlineSize",
  // },
  // {
  //   name: "svb",
  //   unit_type: "kSmallViewportBlockSize",
  // },
  // {
  //   name: "svmin",
  //   unit_type: "kSmallViewportMin",
  // },
  // {
  //   name: "svmax",
  //   unit_type: "kSmallViewportMax",
  // },
  // {
  //   name: "lvw",
  //   unit_type: "kLargeViewportWidth",
  // },
  // {
  //   name: "lvh",
  //   unit_type: "kLargeViewportHeight",
  // },
  // {
  //   name: "lvi",
  //   unit_type: "kLargeViewportInlineSize",
  // },
  // {
  //   name: "lvb",
  //   unit_type: "kLargeViewportBlockSize",
  // },
  // {
  //   name: "lvmin",
  //   unit_type: UnitType.kLargeViewportMin,
  // },
  // {
  //   name: "lvmax",
  //   unit_type: UnitType.kLargeViewportMax,
  // },
  // {
  //   name: "dvw",
  //   unit_type: UnitType.kDynamicViewportWidth,
  // },
  // {
  //   name: "dvh",
  //   unit_type: UnitType.kDynamicViewportHeight,
  // },
  // {
  //   name: "dvi",
  //   unit_type: UnitType.kDynamicViewportInlineSize,
  // },
  // {
  //   name: "dvb",
  //   unit_type: UnitType.kDynamicViewportBlockSize,
  // },
  // {
  //   name: "dvmin",
  //   unit_type: UnitType.kDynamicViewportMin,
  // },
  // {
  //   name: "dvmax",
  //   unit_type: UnitType.kDynamicViewportMax,
  // },
  // {
  //   name: "cqw",
  //   unit_type: UnitType.kContainerWidth,
  // },
  // {
  //   name: "cqh",
  //   unit_type: UnitType.kContainerHeight,
  // },
  // {
  //   name: "cqi",
  //   unit_type: UnitType.kContainerInlineSize,
  // },
  // {
  //   name: "cqb",
  //   unit_type: UnitType.kContainerBlockSize,
  // },
  // {
  //   name: "cqmin",
  //   unit_type: UnitType.kContainerMin,
  // },
  // {
  //   name: "cqmax",
  //   unit_type: UnitType.kContainerMax,
  // },
  {
    name: "rem",
    unit_type: UnitType.kRems
  },
  // {
  //   name: 'fr',
  //   unit_type: UnitType.kFraction,
  // },
  {
    name: "turn",
    unit_type: UnitType.kTurns
  }
  // {
  //   name: 'ch',
  //   unit_type: UnitType.kChs,
  // },
  // {
  //   name: '__qem',
  //   unit_type: UnitType.kQuirkyEms,
  // },
];
var CSSStyleValueType;
(function(CSSStyleValueType2) {
  CSSStyleValueType2[CSSStyleValueType2["kUnknownType"] = 0] = "kUnknownType";
  CSSStyleValueType2[CSSStyleValueType2["kUnparsedType"] = 1] = "kUnparsedType";
  CSSStyleValueType2[CSSStyleValueType2["kKeywordType"] = 2] = "kKeywordType";
  CSSStyleValueType2[CSSStyleValueType2["kUnitType"] = 3] = "kUnitType";
  CSSStyleValueType2[CSSStyleValueType2["kSumType"] = 4] = "kSumType";
  CSSStyleValueType2[CSSStyleValueType2["kProductType"] = 5] = "kProductType";
  CSSStyleValueType2[CSSStyleValueType2["kNegateType"] = 6] = "kNegateType";
  CSSStyleValueType2[CSSStyleValueType2["kInvertType"] = 7] = "kInvertType";
  CSSStyleValueType2[CSSStyleValueType2["kMinType"] = 8] = "kMinType";
  CSSStyleValueType2[CSSStyleValueType2["kMaxType"] = 9] = "kMaxType";
  CSSStyleValueType2[CSSStyleValueType2["kClampType"] = 10] = "kClampType";
  CSSStyleValueType2[CSSStyleValueType2["kTransformType"] = 11] = "kTransformType";
  CSSStyleValueType2[CSSStyleValueType2["kPositionType"] = 12] = "kPositionType";
  CSSStyleValueType2[CSSStyleValueType2["kURLImageType"] = 13] = "kURLImageType";
  CSSStyleValueType2[CSSStyleValueType2["kColorType"] = 14] = "kColorType";
  CSSStyleValueType2[CSSStyleValueType2["kUnsupportedColorType"] = 15] = "kUnsupportedColorType";
})(CSSStyleValueType || (CSSStyleValueType = {}));
var stringToUnitType = function(name2) {
  return data.find(function(item) {
    return item.name === name2;
  }).unit_type;
};
var unitFromName = function(name2) {
  if (!name2) {
    return UnitType.kUnknown;
  }
  if (name2 === "number") {
    return UnitType.kNumber;
  }
  if (name2 === "percent" || name2 === "%") {
    return UnitType.kPercentage;
  }
  return stringToUnitType(name2);
};
var unitTypeToUnitCategory = function(type) {
  switch (type) {
    case UnitType.kNumber:
    case UnitType.kInteger:
      return UnitCategory.kUNumber;
    case UnitType.kPercentage:
      return UnitCategory.kUPercent;
    case UnitType.kPixels:
      return UnitCategory.kULength;
    case UnitType.kMilliseconds:
    case UnitType.kSeconds:
      return UnitCategory.kUTime;
    case UnitType.kDegrees:
    case UnitType.kRadians:
    case UnitType.kGradians:
    case UnitType.kTurns:
      return UnitCategory.kUAngle;
    default:
      return UnitCategory.kUOther;
  }
};
var canonicalUnitTypeForCategory = function(category) {
  switch (category) {
    case UnitCategory.kUNumber:
      return UnitType.kNumber;
    case UnitCategory.kULength:
      return UnitType.kPixels;
    case UnitCategory.kUPercent:
      return UnitType.kPercentage;
    case UnitCategory.kUTime:
      return UnitType.kSeconds;
    case UnitCategory.kUAngle:
      return UnitType.kDegrees;
    default:
      return UnitType.kUnknown;
  }
};
var conversionToCanonicalUnitsScaleFactor = function(unit_type) {
  var factor = 1;
  switch (unit_type) {
    case UnitType.kPixels:
    case UnitType.kDegrees:
    case UnitType.kSeconds:
      break;
    case UnitType.kMilliseconds:
      factor = 1e-3;
      break;
    case UnitType.kRadians:
      factor = 180 / Math.PI;
      break;
    case UnitType.kGradians:
      factor = 0.9;
      break;
    case UnitType.kTurns:
      factor = 360;
      break;
  }
  return factor;
};
var unitTypeToString = function(type) {
  switch (type) {
    case UnitType.kNumber:
    case UnitType.kInteger:
      return "";
    case UnitType.kPercentage:
      return "%";
    case UnitType.kEms:
      return "em";
    case UnitType.kRems:
      return "rem";
    case UnitType.kPixels:
      return "px";
    case UnitType.kDegrees:
      return "deg";
    case UnitType.kRadians:
      return "rad";
    case UnitType.kGradians:
      return "grad";
    case UnitType.kMilliseconds:
      return "ms";
    case UnitType.kSeconds:
      return "s";
    case UnitType.kTurns:
      return "turn";
  }
  return "";
};
var CSSStyleValue = (
  /** @class */
  function() {
    function CSSStyleValue2() {
    }
    CSSStyleValue2.isAngle = function(unit) {
      return unit === UnitType.kDegrees || unit === UnitType.kRadians || unit === UnitType.kGradians || unit === UnitType.kTurns;
    };
    CSSStyleValue2.isLength = function(type) {
      return type >= UnitType.kEms && type < UnitType.kDegrees;
    };
    CSSStyleValue2.isRelativeUnit = function(type) {
      return type === UnitType.kPercentage || type === UnitType.kEms || // type === UnitType.kExs ||
      type === UnitType.kRems;
    };
    CSSStyleValue2.isTime = function(unit) {
      return unit === UnitType.kSeconds || unit === UnitType.kMilliseconds;
    };
    CSSStyleValue2.prototype.toString = function() {
      return this.buildCSSText(Nested.kNo, ParenLess.kNo, "");
    };
    CSSStyleValue2.prototype.isNumericValue = function() {
      return this.getType() >= CSSStyleValueType.kUnitType && this.getType() <= CSSStyleValueType.kClampType;
    };
    return CSSStyleValue2;
  }()
);
var CSSColorValue = (
  /** @class */
  function(_super) {
    __extends(CSSColorValue2, _super);
    function CSSColorValue2(colorSpace) {
      var _this2 = _super.call(this) || this;
      _this2.colorSpace = colorSpace;
      return _this2;
    }
    CSSColorValue2.prototype.getType = function() {
      return CSSStyleValueType.kColorType;
    };
    CSSColorValue2.prototype.to = function(colorSpace) {
      return this;
    };
    return CSSColorValue2;
  }(CSSStyleValue)
);
var GradientType;
(function(GradientType2) {
  GradientType2[GradientType2["Constant"] = 0] = "Constant";
  GradientType2[GradientType2["LinearGradient"] = 1] = "LinearGradient";
  GradientType2[GradientType2["RadialGradient"] = 2] = "RadialGradient";
})(GradientType || (GradientType = {}));
var CSSGradientValue = (
  /** @class */
  function(_super) {
    __extends(CSSGradientValue2, _super);
    function CSSGradientValue2(type, value2) {
      var _this2 = _super.call(this) || this;
      _this2.type = type;
      _this2.value = value2;
      return _this2;
    }
    CSSGradientValue2.prototype.clone = function() {
      return new CSSGradientValue2(this.type, this.value);
    };
    CSSGradientValue2.prototype.buildCSSText = function(n, p2, result2) {
      return result2;
    };
    CSSGradientValue2.prototype.getType = function() {
      return CSSStyleValueType.kColorType;
    };
    return CSSGradientValue2;
  }(CSSStyleValue)
);
var CSSKeywordValue = (
  /** @class */
  function(_super) {
    __extends(CSSKeywordValue2, _super);
    function CSSKeywordValue2(value2) {
      var _this2 = _super.call(this) || this;
      _this2.value = value2;
      return _this2;
    }
    CSSKeywordValue2.prototype.clone = function() {
      return new CSSKeywordValue2(this.value);
    };
    CSSKeywordValue2.prototype.getType = function() {
      return CSSStyleValueType.kKeywordType;
    };
    CSSKeywordValue2.prototype.buildCSSText = function(n, p2, result2) {
      return result2 + this.value;
    };
    return CSSKeywordValue2;
  }(CSSStyleValue)
);
var camelCase = memoize(function(str7) {
  if (str7 === void 0) {
    str7 = "";
  }
  return str7.replace(/-([a-z])/g, function(g) {
    return g[1].toUpperCase();
  });
});
var kebabize = function(str7) {
  return str7.split("").map(function(letter, idx) {
    return letter.toUpperCase() === letter ? "".concat(idx !== 0 ? "-" : "").concat(letter.toLowerCase()) : letter;
  }).join("");
};
function DCHECK(bool) {
  if (!bool) {
    throw new Error();
  }
}
function isFunction(func) {
  return typeof func === "function";
}
function isSymbol(value2) {
  return typeof value2 === "symbol";
}
var FORMAT_ATTR_MAP = {
  d: {
    alias: "path"
  },
  strokeDasharray: {
    alias: "lineDash"
  },
  strokeWidth: {
    alias: "lineWidth"
  },
  textAnchor: {
    alias: "textAlign"
  },
  src: {
    alias: "img"
  }
};
var formatAttributeName = memoize(function(name2) {
  var attributeName = camelCase(name2);
  var map5 = FORMAT_ATTR_MAP[attributeName];
  attributeName = (map5 === null || map5 === void 0 ? void 0 : map5.alias) || attributeName;
  return attributeName;
});
var formatInfinityOrNaN = function(number2, suffix) {
  if (suffix === void 0) {
    suffix = "";
  }
  var result2 = "";
  if (!Number.isFinite(number2)) {
    if (number2 > 0)
      result2 = "infinity";
    else
      result2 = "-infinity";
  } else {
    DCHECK(Number.isNaN(number2));
    result2 = "NaN";
  }
  return result2 += suffix;
};
var toCanonicalUnit = function(unit) {
  return canonicalUnitTypeForCategory(unitTypeToUnitCategory(unit));
};
var CSSUnitValue = (
  /** @class */
  function(_super) {
    __extends(CSSUnitValue2, _super);
    function CSSUnitValue2(value2, unitOrName) {
      if (unitOrName === void 0) {
        unitOrName = UnitType.kNumber;
      }
      var _this2 = _super.call(this) || this;
      var unit;
      if (typeof unitOrName === "string") {
        unit = unitFromName(unitOrName);
      } else {
        unit = unitOrName;
      }
      _this2.unit = unit;
      _this2.value = value2;
      return _this2;
    }
    CSSUnitValue2.prototype.clone = function() {
      return new CSSUnitValue2(this.value, this.unit);
    };
    CSSUnitValue2.prototype.equals = function(other) {
      var other_unit_value = other;
      return this.value === other_unit_value.value && this.unit === other_unit_value.unit;
    };
    CSSUnitValue2.prototype.getType = function() {
      return CSSStyleValueType.kUnitType;
    };
    CSSUnitValue2.prototype.convertTo = function(target_unit) {
      if (this.unit === target_unit) {
        return new CSSUnitValue2(this.value, this.unit);
      }
      var canonical_unit = toCanonicalUnit(this.unit);
      if (canonical_unit !== toCanonicalUnit(target_unit) || canonical_unit === UnitType.kUnknown) {
        return null;
      }
      var scale_factor = conversionToCanonicalUnitsScaleFactor(this.unit) / conversionToCanonicalUnitsScaleFactor(target_unit);
      return new CSSUnitValue2(this.value * scale_factor, target_unit);
    };
    CSSUnitValue2.prototype.buildCSSText = function(n, p2, result2) {
      var text;
      switch (this.unit) {
        case UnitType.kUnknown:
          break;
        case UnitType.kInteger:
          text = Number(this.value).toFixed(0);
          break;
        case UnitType.kNumber:
        case UnitType.kPercentage:
        case UnitType.kEms:
        case UnitType.kRems:
        case UnitType.kPixels:
        case UnitType.kDegrees:
        case UnitType.kRadians:
        case UnitType.kGradians:
        case UnitType.kMilliseconds:
        case UnitType.kSeconds:
        case UnitType.kTurns: {
          var kMinInteger = -999999;
          var kMaxInteger = 999999;
          var value2 = this.value;
          var unit = unitTypeToString(this.unit);
          if (value2 < kMinInteger || value2 > kMaxInteger) {
            var unit_1 = unitTypeToString(this.unit);
            if (!Number.isFinite(value2) || Number.isNaN(value2)) {
              text = formatInfinityOrNaN(value2, unit_1);
            } else {
              text = value2 + (unit_1 || "");
            }
          } else {
            text = "".concat(value2).concat(unit);
          }
        }
      }
      result2 += text;
      return result2;
    };
    return CSSUnitValue2;
  }(CSSStyleValue)
);
var Opx = new CSSUnitValue(0, "px");
new CSSUnitValue(1, "px");
var Odeg = new CSSUnitValue(0, "deg");
var CSSRGB = (
  /** @class */
  function(_super) {
    __extends(CSSRGB2, _super);
    function CSSRGB2(r, g, b, alpha, isNone) {
      if (alpha === void 0) {
        alpha = 1;
      }
      if (isNone === void 0) {
        isNone = false;
      }
      var _this2 = _super.call(this, "rgb") || this;
      _this2.r = r;
      _this2.g = g;
      _this2.b = b;
      _this2.alpha = alpha;
      _this2.isNone = isNone;
      return _this2;
    }
    CSSRGB2.prototype.clone = function() {
      return new CSSRGB2(this.r, this.g, this.b, this.alpha);
    };
    CSSRGB2.prototype.buildCSSText = function(n, p2, result2) {
      return result2 + "rgba(".concat(this.r, ",").concat(this.g, ",").concat(this.b, ",").concat(this.alpha, ")");
    };
    return CSSRGB2;
  }(CSSColorValue)
);
var unsetKeywordValue = new CSSKeywordValue("unset");
var initialKeywordValue = new CSSKeywordValue("initial");
var inheritKeywordValue = new CSSKeywordValue("inherit");
var keywordCache = {
  "": unsetKeywordValue,
  unset: unsetKeywordValue,
  initial: initialKeywordValue,
  inherit: inheritKeywordValue
};
var getOrCreateKeyword = function(name2) {
  if (!keywordCache[name2]) {
    keywordCache[name2] = new CSSKeywordValue(name2);
  }
  return keywordCache[name2];
};
var noneColor = new CSSRGB(0, 0, 0, 0, true);
var transparentColor = new CSSRGB(0, 0, 0, 0);
var getOrCreateRGBA = memoize(function(r, g, b, a4) {
  return new CSSRGB(r, g, b, a4);
}, function(r, g, b, a4) {
  return "rgba(".concat(r, ",").concat(g, ",").concat(b, ",").concat(a4, ")");
});
var getOrCreateUnitValue = function(value2, unitOrName) {
  if (unitOrName === void 0) {
    unitOrName = UnitType.kNumber;
  }
  return new CSSUnitValue(value2, unitOrName);
};
var PECENTAGE_50 = new CSSUnitValue(50, "%");
var Strategy;
(function(Strategy2) {
  Strategy2[Strategy2["Standard"] = 0] = "Standard";
})(Strategy || (Strategy = {}));
var SortReason;
(function(SortReason2) {
  SortReason2[SortReason2["ADDED"] = 0] = "ADDED";
  SortReason2[SortReason2["REMOVED"] = 1] = "REMOVED";
  SortReason2[SortReason2["Z_INDEX_CHANGED"] = 2] = "Z_INDEX_CHANGED";
})(SortReason || (SortReason = {}));
var EMPTY_PARSED_PATH = {
  absolutePath: [],
  hasArc: false,
  segments: [],
  polygons: [],
  polylines: [],
  curve: null,
  totalLength: 0,
  rect: new Rectangle(0, 0, 0, 0)
};
var PropertySyntax;
(function(PropertySyntax2) {
  PropertySyntax2["COORDINATE"] = "<coordinate>";
  PropertySyntax2["COLOR"] = "<color>";
  PropertySyntax2["PAINT"] = "<paint>";
  PropertySyntax2["NUMBER"] = "<number>";
  PropertySyntax2["ANGLE"] = "<angle>";
  PropertySyntax2["OPACITY_VALUE"] = "<opacity-value>";
  PropertySyntax2["SHADOW_BLUR"] = "<shadow-blur>";
  PropertySyntax2["LENGTH"] = "<length>";
  PropertySyntax2["PERCENTAGE"] = "<percentage>";
  PropertySyntax2["LENGTH_PERCENTAGE"] = "<length> | <percentage>";
  PropertySyntax2["LENGTH_PERCENTAGE_12"] = "[<length> | <percentage>]{1,2}";
  PropertySyntax2["LENGTH_PERCENTAGE_14"] = "[<length> | <percentage>]{1,4}";
  PropertySyntax2["LIST_OF_POINTS"] = "<list-of-points>";
  PropertySyntax2["PATH"] = "<path>";
  PropertySyntax2["FILTER"] = "<filter>";
  PropertySyntax2["Z_INDEX"] = "<z-index>";
  PropertySyntax2["OFFSET_DISTANCE"] = "<offset-distance>";
  PropertySyntax2["DEFINED_PATH"] = "<defined-path>";
  PropertySyntax2["MARKER"] = "<marker>";
  PropertySyntax2["TRANSFORM"] = "<transform>";
  PropertySyntax2["TRANSFORM_ORIGIN"] = "<transform-origin>";
  PropertySyntax2["TEXT"] = "<text>";
  PropertySyntax2["TEXT_TRANSFORM"] = "<text-transform>";
})(PropertySyntax || (PropertySyntax = {}));
function colorStopToString(colorStop) {
  var type = colorStop.type, value2 = colorStop.value;
  if (type === "hex") {
    return "#".concat(value2);
  } else if (type === "literal") {
    return value2;
  } else if (type === "rgb") {
    return "rgb(".concat(value2.join(","), ")");
  } else {
    return "rgba(".concat(value2.join(","), ")");
  }
}
var parseGradient$1 = function() {
  var tokens4 = {
    linearGradient: /^(linear\-gradient)/i,
    repeatingLinearGradient: /^(repeating\-linear\-gradient)/i,
    radialGradient: /^(radial\-gradient)/i,
    repeatingRadialGradient: /^(repeating\-radial\-gradient)/i,
    /**
     * @see https://projects.verou.me/conic-gradient/
     */
    conicGradient: /^(conic\-gradient)/i,
    sideOrCorner: /^to (left (top|bottom)|right (top|bottom)|top (left|right)|bottom (left|right)|left|right|top|bottom)/i,
    extentKeywords: /^(closest\-side|closest\-corner|farthest\-side|farthest\-corner|contain|cover)/,
    positionKeywords: /^(left|center|right|top|bottom)/i,
    pixelValue: /^(-?(([0-9]*\.[0-9]+)|([0-9]+\.?)))px/,
    percentageValue: /^(-?(([0-9]*\.[0-9]+)|([0-9]+\.?)))\%/,
    emValue: /^(-?(([0-9]*\.[0-9]+)|([0-9]+\.?)))em/,
    angleValue: /^(-?(([0-9]*\.[0-9]+)|([0-9]+\.?)))deg/,
    startCall: /^\(/,
    endCall: /^\)/,
    comma: /^,/,
    hexColor: /^\#([0-9a-fA-F]+)/,
    literalColor: /^([a-zA-Z]+)/,
    rgbColor: /^rgb/i,
    rgbaColor: /^rgba/i,
    number: /^(([0-9]*\.[0-9]+)|([0-9]+\.?))/
  };
  var input = "";
  function error3(msg) {
    throw new Error(input + ": " + msg);
  }
  function getAST() {
    var ast = matchListDefinitions();
    if (input.length > 0) {
      error3("Invalid input not EOF");
    }
    return ast;
  }
  function matchListDefinitions() {
    return matchListing(matchDefinition);
  }
  function matchDefinition() {
    return matchGradient("linear-gradient", tokens4.linearGradient, matchLinearOrientation) || matchGradient("repeating-linear-gradient", tokens4.repeatingLinearGradient, matchLinearOrientation) || matchGradient("radial-gradient", tokens4.radialGradient, matchListRadialOrientations) || matchGradient("repeating-radial-gradient", tokens4.repeatingRadialGradient, matchListRadialOrientations) || matchGradient("conic-gradient", tokens4.conicGradient, matchListRadialOrientations);
  }
  function matchGradient(gradientType, pattern, orientationMatcher) {
    return matchCall(pattern, function(captures) {
      var orientation = orientationMatcher();
      if (orientation) {
        if (!scan2(tokens4.comma)) {
          error3("Missing comma before color stops");
        }
      }
      return {
        type: gradientType,
        orientation,
        colorStops: matchListing(matchColorStop)
      };
    });
  }
  function matchCall(pattern, callback) {
    var captures = scan2(pattern);
    if (captures) {
      if (!scan2(tokens4.startCall)) {
        error3("Missing (");
      }
      var result2 = callback(captures);
      if (!scan2(tokens4.endCall)) {
        error3("Missing )");
      }
      return result2;
    }
  }
  function matchLinearOrientation() {
    return matchSideOrCorner() || matchAngle();
  }
  function matchSideOrCorner() {
    return match("directional", tokens4.sideOrCorner, 1);
  }
  function matchAngle() {
    return match("angular", tokens4.angleValue, 1);
  }
  function matchListRadialOrientations() {
    var radialOrientations, radialOrientation = matchRadialOrientation(), lookaheadCache;
    if (radialOrientation) {
      radialOrientations = [];
      radialOrientations.push(radialOrientation);
      lookaheadCache = input;
      if (scan2(tokens4.comma)) {
        radialOrientation = matchRadialOrientation();
        if (radialOrientation) {
          radialOrientations.push(radialOrientation);
        } else {
          input = lookaheadCache;
        }
      }
    }
    return radialOrientations;
  }
  function matchRadialOrientation() {
    var radialType = matchCircle() || matchEllipse();
    if (radialType) {
      radialType.at = matchAtPosition();
    } else {
      var extent2 = matchExtentKeyword();
      if (extent2) {
        radialType = extent2;
        var positionAt = matchAtPosition();
        if (positionAt) {
          radialType.at = positionAt;
        }
      } else {
        var defaultPosition = matchPositioning();
        if (defaultPosition) {
          radialType = {
            type: "default-radial",
            // @ts-ignore
            at: defaultPosition
          };
        }
      }
    }
    return radialType;
  }
  function matchCircle() {
    var circle3 = match("shape", /^(circle)/i, 0);
    if (circle3) {
      circle3.style = matchLength() || matchExtentKeyword();
    }
    return circle3;
  }
  function matchEllipse() {
    var ellipse = match("shape", /^(ellipse)/i, 0);
    if (ellipse) {
      ellipse.style = matchDistance() || matchExtentKeyword();
    }
    return ellipse;
  }
  function matchExtentKeyword() {
    return match("extent-keyword", tokens4.extentKeywords, 1);
  }
  function matchAtPosition() {
    if (match("position", /^at/, 0)) {
      var positioning = matchPositioning();
      if (!positioning) {
        error3("Missing positioning value");
      }
      return positioning;
    }
  }
  function matchPositioning() {
    var location = matchCoordinates();
    if (location.x || location.y) {
      return {
        type: "position",
        value: location
      };
    }
  }
  function matchCoordinates() {
    return {
      x: matchDistance(),
      y: matchDistance()
    };
  }
  function matchListing(matcher) {
    var captures = matcher();
    var result2 = [];
    if (captures) {
      result2.push(captures);
      while (scan2(tokens4.comma)) {
        captures = matcher();
        if (captures) {
          result2.push(captures);
        } else {
          error3("One extra comma");
        }
      }
    }
    return result2;
  }
  function matchColorStop() {
    var color2 = matchColor();
    if (!color2) {
      error3("Expected color definition");
    }
    color2.length = matchDistance();
    return color2;
  }
  function matchColor() {
    return matchHexColor() || matchRGBAColor() || matchRGBColor() || matchLiteralColor();
  }
  function matchLiteralColor() {
    return match("literal", tokens4.literalColor, 0);
  }
  function matchHexColor() {
    return match("hex", tokens4.hexColor, 1);
  }
  function matchRGBColor() {
    return matchCall(tokens4.rgbColor, function() {
      return {
        type: "rgb",
        value: matchListing(matchNumber)
      };
    });
  }
  function matchRGBAColor() {
    return matchCall(tokens4.rgbaColor, function() {
      return {
        type: "rgba",
        value: matchListing(matchNumber)
      };
    });
  }
  function matchNumber() {
    return scan2(tokens4.number)[1];
  }
  function matchDistance() {
    return match("%", tokens4.percentageValue, 1) || matchPositionKeyword() || matchLength();
  }
  function matchPositionKeyword() {
    return match("position-keyword", tokens4.positionKeywords, 1);
  }
  function matchLength() {
    return match("px", tokens4.pixelValue, 1) || match("em", tokens4.emValue, 1);
  }
  function match(type, pattern, captureIndex) {
    var captures = scan2(pattern);
    if (captures) {
      return {
        type,
        value: captures[captureIndex]
      };
    }
  }
  function scan2(regexp) {
    var blankCaptures = /^[\n\r\t\s]+/.exec(input);
    if (blankCaptures) {
      consume(blankCaptures[0].length);
    }
    var captures = regexp.exec(input);
    if (captures) {
      consume(captures[0].length);
    }
    return captures;
  }
  function consume(size5) {
    input = input.substring(size5);
  }
  return function(code) {
    input = code;
    return getAST();
  };
}();
function computeLinearGradient(width, height, angle4) {
  var rad = deg2rad2(angle4.value);
  var rx = 0;
  var ry = 0;
  var rcx = rx + width / 2;
  var rcy = ry + height / 2;
  var length5 = Math.abs(width * Math.cos(rad)) + Math.abs(height * Math.sin(rad));
  var x12 = rcx - Math.cos(rad) * length5 / 2;
  var y12 = rcy - Math.sin(rad) * length5 / 2;
  var x22 = rcx + Math.cos(rad) * length5 / 2;
  var y22 = rcy + Math.sin(rad) * length5 / 2;
  return { x1: x12, y1: y12, x2: x22, y2: y22 };
}
function computeRadialGradient(width, height, cx, cy, size5) {
  var x3 = cx.value;
  var y3 = cy.value;
  if (cx.unit === UnitType.kPercentage) {
    x3 = cx.value / 100 * width;
  }
  if (cy.unit === UnitType.kPercentage) {
    y3 = cy.value / 100 * height;
  }
  var r = Math.max(distanceSquareRoot([0, 0], [x3, y3]), distanceSquareRoot([0, height], [x3, y3]), distanceSquareRoot([width, height], [x3, y3]), distanceSquareRoot([width, 0], [x3, y3]));
  if (size5) {
    if (size5 instanceof CSSUnitValue) {
      r = size5.value;
    } else if (size5 instanceof CSSKeywordValue) {
      if (size5.value === "closest-side") {
        r = Math.min(x3, width - x3, y3, height - y3);
      } else if (size5.value === "farthest-side") {
        r = Math.max(x3, width - x3, y3, height - y3);
      } else if (size5.value === "closest-corner") {
        r = Math.min(distanceSquareRoot([0, 0], [x3, y3]), distanceSquareRoot([0, height], [x3, y3]), distanceSquareRoot([width, height], [x3, y3]), distanceSquareRoot([width, 0], [x3, y3]));
      }
    }
  }
  return { x: x3, y: y3, r };
}
var regexLG = /^l\s*\(\s*([\d.]+)\s*\)\s*(.*)/i;
var regexRG = /^r\s*\(\s*([\d.]+)\s*,\s*([\d.]+)\s*,\s*([\d.]+)\s*\)\s*(.*)/i;
var regexPR = /^p\s*\(\s*([axyn])\s*\)\s*(.*)/i;
var regexColorStop = /[\d.]+:(#[^\s]+|[^\)]+\))/gi;
function spaceColorStops(colorStops) {
  var _a2, _b, _c;
  var length5 = colorStops.length;
  colorStops[length5 - 1].length = (_a2 = colorStops[length5 - 1].length) !== null && _a2 !== void 0 ? _a2 : {
    type: "%",
    value: "100"
  };
  if (length5 > 1) {
    colorStops[0].length = (_b = colorStops[0].length) !== null && _b !== void 0 ? _b : {
      type: "%",
      value: "0"
    };
  }
  var previousIndex = 0;
  var previousOffset = Number(colorStops[0].length.value);
  for (var i = 1; i < length5; i++) {
    var offset2 = (_c = colorStops[i].length) === null || _c === void 0 ? void 0 : _c.value;
    if (!is_nil_default(offset2) && !is_nil_default(previousOffset)) {
      for (var j = 1; j < i - previousIndex; j++)
        colorStops[previousIndex + j].length = {
          type: "%",
          value: "".concat(previousOffset + (Number(offset2) - previousOffset) * j / (i - previousIndex))
        };
      previousIndex = i;
      previousOffset = Number(offset2);
    }
  }
}
var SideOrCornerToDegMap = {
  left: 270 - 90,
  top: 0 - 90,
  bottom: 180 - 90,
  right: 90 - 90,
  "left top": 315 - 90,
  "top left": 315 - 90,
  "left bottom": 225 - 90,
  "bottom left": 225 - 90,
  "right top": 45 - 90,
  "top right": 45 - 90,
  "right bottom": 135 - 90,
  "bottom right": 135 - 90
};
var angleToDeg = memoize(function(orientation) {
  var angle4;
  if (orientation.type === "angular") {
    angle4 = Number(orientation.value);
  } else {
    angle4 = SideOrCornerToDegMap[orientation.value] || 0;
  }
  return getOrCreateUnitValue(angle4, "deg");
});
var positonToCSSUnitValue = memoize(function(position) {
  var cx = 50;
  var cy = 50;
  var unitX = "%";
  var unitY = "%";
  if ((position === null || position === void 0 ? void 0 : position.type) === "position") {
    var _a2 = position.value, x3 = _a2.x, y3 = _a2.y;
    if ((x3 === null || x3 === void 0 ? void 0 : x3.type) === "position-keyword") {
      if (x3.value === "left") {
        cx = 0;
      } else if (x3.value === "center") {
        cx = 50;
      } else if (x3.value === "right") {
        cx = 100;
      } else if (x3.value === "top") {
        cy = 0;
      } else if (x3.value === "bottom") {
        cy = 100;
      }
    }
    if ((y3 === null || y3 === void 0 ? void 0 : y3.type) === "position-keyword") {
      if (y3.value === "left") {
        cx = 0;
      } else if (y3.value === "center") {
        cy = 50;
      } else if (y3.value === "right") {
        cx = 100;
      } else if (y3.value === "top") {
        cy = 0;
      } else if (y3.value === "bottom") {
        cy = 100;
      }
    }
    if ((x3 === null || x3 === void 0 ? void 0 : x3.type) === "px" || (x3 === null || x3 === void 0 ? void 0 : x3.type) === "%" || (x3 === null || x3 === void 0 ? void 0 : x3.type) === "em") {
      unitX = x3 === null || x3 === void 0 ? void 0 : x3.type;
      cx = Number(x3.value);
    }
    if ((y3 === null || y3 === void 0 ? void 0 : y3.type) === "px" || (y3 === null || y3 === void 0 ? void 0 : y3.type) === "%" || (y3 === null || y3 === void 0 ? void 0 : y3.type) === "em") {
      unitY = y3 === null || y3 === void 0 ? void 0 : y3.type;
      cy = Number(y3.value);
    }
  }
  return {
    cx: getOrCreateUnitValue(cx, unitX),
    cy: getOrCreateUnitValue(cy, unitY)
  };
});
var parseGradient = memoize(function(colorStr) {
  var _a2;
  if (colorStr.indexOf("linear") > -1 || colorStr.indexOf("radial") > -1) {
    var ast = parseGradient$1(colorStr);
    return ast.map(function(_a3) {
      var type2 = _a3.type, orientation = _a3.orientation, colorStops = _a3.colorStops;
      spaceColorStops(colorStops);
      var steps2 = colorStops.map(function(colorStop) {
        return {
          offset: getOrCreateUnitValue(Number(colorStop.length.value), "%"),
          color: colorStopToString(colorStop)
        };
      });
      if (type2 === "linear-gradient") {
        return new CSSGradientValue(GradientType.LinearGradient, {
          angle: orientation ? angleToDeg(orientation) : Odeg,
          steps: steps2
        });
      } else if (type2 === "radial-gradient") {
        if (!orientation) {
          orientation = [
            {
              type: "shape",
              value: "circle"
            }
          ];
        }
        if (orientation[0].type === "shape" && orientation[0].value === "circle") {
          var _b = positonToCSSUnitValue(orientation[0].at), cx = _b.cx, cy = _b.cy;
          var size5 = void 0;
          if (orientation[0].style) {
            var _c = orientation[0].style, type_1 = _c.type, value2 = _c.value;
            if (type_1 === "extent-keyword") {
              size5 = getOrCreateKeyword(value2);
            } else {
              size5 = getOrCreateUnitValue(value2, type_1);
            }
          }
          return new CSSGradientValue(GradientType.RadialGradient, {
            cx,
            cy,
            size: size5,
            steps: steps2
          });
        }
      }
    });
  }
  var type = colorStr[0];
  if (colorStr[1] === "(" || colorStr[2] === "(") {
    if (type === "l") {
      var arr = regexLG.exec(colorStr);
      if (arr) {
        var steps = ((_a2 = arr[2].match(regexColorStop)) === null || _a2 === void 0 ? void 0 : _a2.map(function(stop) {
          return stop.split(":");
        })) || [];
        return [
          new CSSGradientValue(GradientType.LinearGradient, {
            angle: getOrCreateUnitValue(parseFloat(arr[1]), "deg"),
            steps: steps.map(function(_a3) {
              var _b = __read(_a3, 2), offset2 = _b[0], color2 = _b[1];
              return {
                offset: getOrCreateUnitValue(Number(offset2) * 100, "%"),
                color: color2
              };
            })
          })
        ];
      }
    } else if (type === "r") {
      var parsedRadialGradient = parseRadialGradient(colorStr);
      if (parsedRadialGradient) {
        if (is_string_default(parsedRadialGradient)) {
          colorStr = parsedRadialGradient;
        } else {
          return [
            new CSSGradientValue(GradientType.RadialGradient, parsedRadialGradient)
          ];
        }
      }
    } else if (type === "p") {
      return parsePattern(colorStr);
    }
  }
});
function parseRadialGradient(gradientStr) {
  var _a2;
  var arr = regexRG.exec(gradientStr);
  if (arr) {
    var steps = ((_a2 = arr[4].match(regexColorStop)) === null || _a2 === void 0 ? void 0 : _a2.map(function(stop) {
      return stop.split(":");
    })) || [];
    return {
      cx: getOrCreateUnitValue(50, "%"),
      cy: getOrCreateUnitValue(50, "%"),
      steps: steps.map(function(_a3) {
        var _b = __read(_a3, 2), offset2 = _b[0], color2 = _b[1];
        return {
          offset: getOrCreateUnitValue(Number(offset2) * 100, "%"),
          color: color2
        };
      })
    };
  }
  return null;
}
function parsePattern(patternStr) {
  var arr = regexPR.exec(patternStr);
  if (arr) {
    var repetition = arr[1];
    var src = arr[2];
    switch (repetition) {
      case "a":
        repetition = "repeat";
        break;
      case "x":
        repetition = "repeat-x";
        break;
      case "y":
        repetition = "repeat-y";
        break;
      case "n":
        repetition = "no-repeat";
        break;
      default:
        repetition = "no-repeat";
    }
    return {
      image: src,
      // @ts-ignore
      repetition
    };
  }
  return null;
}
function isPattern(object) {
  return object && !!object.image;
}
function isCSSRGB(object) {
  return object && !is_nil_default(object.r) && !is_nil_default(object.g) && !is_nil_default(object.b);
}
var parseColor = memoize(function(colorStr) {
  if (isPattern(colorStr)) {
    return __assign({ repetition: "repeat" }, colorStr);
  }
  if (is_nil_default(colorStr)) {
    colorStr = "";
  }
  if (colorStr === "transparent") {
    return transparentColor;
  } else if (colorStr === "currentColor") {
    colorStr = "black";
  }
  var g = parseGradient(colorStr);
  if (g) {
    return g;
  }
  var color2 = color(colorStr);
  var rgba2 = [0, 0, 0, 0];
  if (color2 !== null) {
    rgba2[0] = color2.r || 0;
    rgba2[1] = color2.g || 0;
    rgba2[2] = color2.b || 0;
    rgba2[3] = color2.opacity;
  }
  return getOrCreateRGBA.apply(void 0, __spreadArray([], __read(rgba2), false));
});
function mergeColors(left2, right2) {
  if (!isCSSRGB(left2) || !isCSSRGB(right2)) {
    return;
  }
  return [
    [Number(left2.r), Number(left2.g), Number(left2.b), Number(left2.alpha)],
    [Number(right2.r), Number(right2.g), Number(right2.b), Number(right2.alpha)],
    function(color2) {
      var rgba2 = color2.slice();
      if (rgba2[3]) {
        for (var i = 0; i < 3; i++)
          rgba2[i] = Math.round(clamp_default(rgba2[i], 0, 255));
      }
      rgba2[3] = clamp_default(rgba2[3], 0, 1);
      return "rgba(".concat(rgba2.join(","), ")");
    }
  ];
}
function parseDimension(unitRegExp, string) {
  if (is_nil_default(string)) {
    return getOrCreateUnitValue(0, "px");
  }
  string = "".concat(string).trim().toLowerCase();
  if (isFinite(Number(string))) {
    if ("px".search(unitRegExp) >= 0) {
      return getOrCreateUnitValue(Number(string), "px");
    } else if ("deg".search(unitRegExp) >= 0) {
      return getOrCreateUnitValue(Number(string), "deg");
    }
  }
  var matchedUnits = [];
  string = string.replace(unitRegExp, function(match) {
    matchedUnits.push(match);
    return "U" + match;
  });
  var taggedUnitRegExp = "U(" + unitRegExp.source + ")";
  return matchedUnits.map(function(unit) {
    return getOrCreateUnitValue(Number(string.replace(new RegExp("U" + unit, "g"), "").replace(new RegExp(taggedUnitRegExp, "g"), "*0")), unit);
  })[0];
}
var parseLength = memoize(function(css) {
  return parseDimension(new RegExp("px", "g"), css);
});
memoize(function(css) {
  return parseDimension(new RegExp("%", "g"), css);
});
var parseLengthOrPercentage = function(css) {
  if (is_number_default(css) || isFinite(Number(css))) {
    return getOrCreateUnitValue(Number(css) || 0, "px");
  }
  return parseDimension(new RegExp("px|%|em|rem", "g"), css);
};
var parseAngle = memoize(function(css) {
  return parseDimension(new RegExp("deg|rad|grad|turn", "g"), css);
});
function mergeDimensions(left2, right2, target, nonNegative, index3) {
  if (index3 === void 0) {
    index3 = 0;
  }
  var unit = "";
  var leftValue = left2.value || 0;
  var rightValue = right2.value || 0;
  var canonicalUnit = toCanonicalUnit(left2.unit);
  var leftCanonicalUnitValue = left2.convertTo(canonicalUnit);
  var rightCanonicalUnitValue = right2.convertTo(canonicalUnit);
  if (leftCanonicalUnitValue && rightCanonicalUnitValue) {
    leftValue = leftCanonicalUnitValue.value;
    rightValue = rightCanonicalUnitValue.value;
    unit = unitTypeToString(left2.unit);
  } else {
    if (CSSUnitValue.isLength(left2.unit) || CSSUnitValue.isLength(right2.unit)) {
      leftValue = convertPercentUnit(left2, index3, target);
      rightValue = convertPercentUnit(right2, index3, target);
      unit = "px";
    }
  }
  return [
    leftValue,
    rightValue,
    function(value2) {
      if (nonNegative) {
        value2 = Math.max(value2, 0);
      }
      return value2 + unit;
    }
  ];
}
function convertAngleUnit(value2) {
  var deg = 0;
  if (value2.unit === UnitType.kDegrees) {
    deg = value2.value;
  } else if (value2.unit === UnitType.kRadians) {
    deg = rad2deg2(Number(value2.value));
  } else if (value2.unit === UnitType.kTurns) {
    deg = turn2deg(Number(value2.value));
  }
  return deg;
}
function parseDimensionArrayFormat(string, size5) {
  var parsed;
  if (Array.isArray(string)) {
    parsed = string.map(function(segment) {
      return Number(segment);
    });
  } else if (is_string_default(string)) {
    parsed = string.split(" ").map(function(segment) {
      return Number(segment);
    });
  } else if (is_number_default(string)) {
    parsed = [string];
  }
  if (size5 === 2) {
    if (parsed.length === 1) {
      return [parsed[0], parsed[0]];
    } else {
      return [parsed[0], parsed[1]];
    }
  } else {
    if (parsed.length === 1) {
      return [parsed[0], parsed[0], parsed[0], parsed[0]];
    } else if (parsed.length === 2) {
      return [parsed[0], parsed[1], parsed[0], parsed[1]];
    } else if (parsed.length === 3) {
      return [parsed[0], parsed[1], parsed[2], parsed[1]];
    } else {
      return [parsed[0], parsed[1], parsed[2], parsed[3]];
    }
  }
}
function parseDimensionArray(string) {
  if (is_string_default(string)) {
    return string.split(" ").map(function(segment) {
      return parseLengthOrPercentage(segment);
    });
  } else {
    return string.map(function(segment) {
      return parseLengthOrPercentage(segment.toString());
    });
  }
}
function convertPercentUnit(valueWithUnit, vec3Index, target) {
  if (valueWithUnit.value === 0) {
    return 0;
  }
  if (valueWithUnit.unit === UnitType.kPixels) {
    return Number(valueWithUnit.value);
  } else if (valueWithUnit.unit === UnitType.kPercentage && target) {
    var bounds = target.nodeName === Shape.GROUP ? target.getLocalBounds() : (
      // : target.getGeometryBounds();
      target.geometry.contentBounds
    );
    return valueWithUnit.value / 100 * bounds.halfExtents[vec3Index] * 2;
  }
  return 0;
}
var parseParam = function(css) {
  return parseDimension(/deg|rad|grad|turn|px|%/g, css);
};
var supportedFilters = [
  "blur",
  "brightness",
  "drop-shadow",
  "contrast",
  "grayscale",
  "sepia",
  "saturate",
  "hue-rotate",
  "invert"
];
function parseFilter(filterStr) {
  if (filterStr === void 0) {
    filterStr = "";
  }
  filterStr = filterStr.toLowerCase().trim();
  if (filterStr === "none") {
    return [];
  }
  var filterRegExp = /\s*([\w-]+)\(([^)]*)\)/g;
  var result2 = [];
  var match;
  var prevLastIndex = 0;
  while (match = filterRegExp.exec(filterStr)) {
    if (match.index !== prevLastIndex) {
      return [];
    }
    prevLastIndex = match.index + match[0].length;
    if (supportedFilters.indexOf(match[1]) > -1) {
      result2.push({
        name: match[1],
        params: match[2].split(" ").map(function(p2) {
          return parseParam(p2) || parseColor(p2);
        })
      });
    }
    if (filterRegExp.lastIndex === filterStr.length) {
      return result2;
    }
  }
  return [];
}
function numberToString(x3) {
  return x3.toString();
}
var parseNumber = memoize(function(string) {
  if (typeof string === "number") {
    return getOrCreateUnitValue(string);
  }
  if (/^\s*[-+]?(\d*\.)?\d+\s*$/.test(string)) {
    return getOrCreateUnitValue(Number(string));
  } else {
    return getOrCreateUnitValue(0);
  }
});
memoize(function(string) {
  if (is_string_default(string)) {
    return string.split(" ").map(parseNumber);
  } else {
    return string.map(parseNumber);
  }
});
function mergeNumbers(left2, right2) {
  return [left2, right2, numberToString];
}
function clampedMergeNumbers(min11, max11) {
  return function(left2, right2) {
    return [
      left2,
      right2,
      function(x3) {
        return numberToString(clamp_default(x3, min11, max11));
      }
    ];
  };
}
function mergeNumberLists(left2, right2) {
  if (left2.length !== right2.length) {
    return;
  }
  return [
    left2,
    right2,
    function(numberList) {
      return numberList;
    }
  ];
}
function getOrCalculatePathTotalLength(path2) {
  if (path2.parsedStyle.path.totalLength === 0) {
    path2.parsedStyle.path.totalLength = getTotalLength(path2.parsedStyle.path.absolutePath);
  }
  return path2.parsedStyle.path.totalLength;
}
function removeRedundantMCommand(path2) {
  for (var i = 0; i < path2.length; i++) {
    var prevSegment = path2[i - 1];
    var segment = path2[i];
    var cmd = segment[0];
    if (cmd === "M") {
      if (prevSegment) {
        var prevCmd = prevSegment[0];
        var srcPoint = [segment[1], segment[2]];
        var destPoint = void 0;
        if (prevCmd === "L" || prevCmd === "M") {
          destPoint = [prevSegment[1], prevSegment[2]];
        } else if (prevCmd === "C" || prevCmd === "A" || prevCmd === "Q") {
          destPoint = [
            prevSegment[prevSegment.length - 2],
            prevSegment[prevSegment.length - 1]
          ];
        }
        if (destPoint && isSamePoint(srcPoint, destPoint)) {
          path2.splice(i, 1);
          i--;
        }
      }
    }
  }
}
function hasArcOrBezier(path2) {
  var hasArc = false;
  var count4 = path2.length;
  for (var i = 0; i < count4; i++) {
    var params = path2[i];
    var cmd = params[0];
    if (cmd === "C" || cmd === "A" || cmd === "Q") {
      hasArc = true;
      break;
    }
  }
  return hasArc;
}
function extractPolygons(pathArray) {
  var polygons = [];
  var polylines = [];
  var points = [];
  for (var i = 0; i < pathArray.length; i++) {
    var params = pathArray[i];
    var cmd = params[0];
    if (cmd === "M") {
      if (points.length) {
        polylines.push(points);
        points = [];
      }
      points.push([params[1], params[2]]);
    } else if (cmd === "Z") {
      if (points.length) {
        polygons.push(points);
        points = [];
      }
    } else {
      points.push([params[1], params[2]]);
    }
  }
  if (points.length > 0) {
    polylines.push(points);
  }
  return {
    polygons,
    polylines
  };
}
function isSamePoint(point1, point22) {
  return point1[0] === point22[0] && point1[1] === point22[1];
}
function getPathBBox2(segments, lineWidth) {
  var xArr = [];
  var yArr = [];
  var segmentsWithAngle = [];
  for (var i = 0; i < segments.length; i++) {
    var segment = segments[i];
    var currentPoint = segment.currentPoint, params = segment.params, prePoint = segment.prePoint;
    var box2 = void 0;
    switch (segment.command) {
      case "Q":
        box2 = box(prePoint[0], prePoint[1], params[1], params[2], params[3], params[4]);
        break;
      case "C":
        box2 = box$3(prePoint[0], prePoint[1], params[1], params[2], params[3], params[4], params[5], params[6]);
        break;
      case "A":
        var arcParams = segment.arcParams;
        box2 = box$5(arcParams.cx, arcParams.cy, arcParams.rx, arcParams.ry, arcParams.xRotation, arcParams.startAngle, arcParams.endAngle);
        break;
      default:
        xArr.push(currentPoint[0]);
        yArr.push(currentPoint[1]);
        break;
    }
    if (box2) {
      segment.box = box2;
      xArr.push(box2.x, box2.x + box2.width);
      yArr.push(box2.y, box2.y + box2.height);
    }
    if (lineWidth && (segment.command === "L" || segment.command === "M") && segment.prePoint && segment.nextPoint) {
      segmentsWithAngle.push(segment);
    }
  }
  xArr = xArr.filter(function(item) {
    return !Number.isNaN(item) && item !== Infinity && item !== -Infinity;
  });
  yArr = yArr.filter(function(item) {
    return !Number.isNaN(item) && item !== Infinity && item !== -Infinity;
  });
  var minX = min_default(xArr);
  var minY = min_default(yArr);
  var maxX = max_default(xArr);
  var maxY2 = max_default(yArr);
  if (segmentsWithAngle.length === 0) {
    return {
      x: minX,
      y: minY,
      width: maxX - minX,
      height: maxY2 - minY
    };
  }
  for (var i = 0; i < segmentsWithAngle.length; i++) {
    var segment = segmentsWithAngle[i];
    var currentPoint = segment.currentPoint;
    var extra = void 0;
    if (currentPoint[0] === minX) {
      extra = getExtraFromSegmentWithAngle(segment, lineWidth);
      minX = minX - extra.xExtra;
    } else if (currentPoint[0] === maxX) {
      extra = getExtraFromSegmentWithAngle(segment, lineWidth);
      maxX = maxX + extra.xExtra;
    }
    if (currentPoint[1] === minY) {
      extra = getExtraFromSegmentWithAngle(segment, lineWidth);
      minY = minY - extra.yExtra;
    } else if (currentPoint[1] === maxY2) {
      extra = getExtraFromSegmentWithAngle(segment, lineWidth);
      maxY2 = maxY2 + extra.yExtra;
    }
  }
  return {
    x: minX,
    y: minY,
    width: maxX - minX,
    height: maxY2 - minY
  };
}
function getExtraFromSegmentWithAngle(segment, lineWidth) {
  var prePoint = segment.prePoint, currentPoint = segment.currentPoint, nextPoint = segment.nextPoint;
  var currentAndPre = Math.pow(currentPoint[0] - prePoint[0], 2) + Math.pow(currentPoint[1] - prePoint[1], 2);
  var currentAndNext = Math.pow(currentPoint[0] - nextPoint[0], 2) + Math.pow(currentPoint[1] - nextPoint[1], 2);
  var preAndNext = Math.pow(prePoint[0] - nextPoint[0], 2) + Math.pow(prePoint[1] - nextPoint[1], 2);
  var currentAngle = Math.acos((currentAndPre + currentAndNext - preAndNext) / (2 * Math.sqrt(currentAndPre) * Math.sqrt(currentAndNext)));
  if (!currentAngle || Math.sin(currentAngle) === 0 || isNumberEqual(currentAngle, 0)) {
    return {
      xExtra: 0,
      yExtra: 0
    };
  }
  var xAngle = Math.abs(Math.atan2(nextPoint[1] - currentPoint[1], nextPoint[0] - currentPoint[0]));
  var yAngle = Math.abs(Math.atan2(nextPoint[0] - currentPoint[0], nextPoint[1] - currentPoint[1]));
  xAngle = xAngle > Math.PI / 2 ? Math.PI - xAngle : xAngle;
  yAngle = yAngle > Math.PI / 2 ? Math.PI - yAngle : yAngle;
  var extra = {
    // 
    xExtra: Math.cos(currentAngle / 2 - xAngle) * (lineWidth / 2 * (1 / Math.sin(currentAngle / 2))) - lineWidth / 2 || 0,
    // 
    yExtra: Math.cos(yAngle - currentAngle / 2) * (lineWidth / 2 * (1 / Math.sin(currentAngle / 2))) - lineWidth / 2 || 0
  };
  return extra;
}
function toSymmetry(point7, center2) {
  return [
    center2[0] + (center2[0] - point7[0]),
    center2[1] + (center2[1] - point7[1])
  ];
}
var angleBetween3 = function(v0, v1) {
  var p2 = v0.x * v1.x + v0.y * v1.y;
  var n = Math.sqrt((Math.pow(v0.x, 2) + Math.pow(v0.y, 2)) * (Math.pow(v1.x, 2) + Math.pow(v1.y, 2)));
  var sign3 = v0.x * v1.y - v0.y * v1.x < 0 ? -1 : 1;
  var angle4 = sign3 * Math.acos(p2 / n);
  return angle4;
};
var pointOnEllipticalArc = function(p0, rx, ry, xAxisRotation, largeArcFlag, sweepFlag, p1, t) {
  rx = Math.abs(rx);
  ry = Math.abs(ry);
  xAxisRotation = mod_default(xAxisRotation, 360);
  var xAxisRotationRadians = deg2rad2(xAxisRotation);
  if (p0.x === p1.x && p0.y === p1.y) {
    return { x: p0.x, y: p0.y, ellipticalArcAngle: 0 };
  }
  if (rx === 0 || ry === 0) {
    return { x: 0, y: 0, ellipticalArcAngle: 0 };
  }
  var dx = (p0.x - p1.x) / 2;
  var dy = (p0.y - p1.y) / 2;
  var transformedPoint = {
    x: Math.cos(xAxisRotationRadians) * dx + Math.sin(xAxisRotationRadians) * dy,
    y: -Math.sin(xAxisRotationRadians) * dx + Math.cos(xAxisRotationRadians) * dy
  };
  var radiiCheck = Math.pow(transformedPoint.x, 2) / Math.pow(rx, 2) + Math.pow(transformedPoint.y, 2) / Math.pow(ry, 2);
  if (radiiCheck > 1) {
    rx = Math.sqrt(radiiCheck) * rx;
    ry = Math.sqrt(radiiCheck) * ry;
  }
  var cSquareNumerator = Math.pow(rx, 2) * Math.pow(ry, 2) - Math.pow(rx, 2) * Math.pow(transformedPoint.y, 2) - Math.pow(ry, 2) * Math.pow(transformedPoint.x, 2);
  var cSquareRootDenom = Math.pow(rx, 2) * Math.pow(transformedPoint.y, 2) + Math.pow(ry, 2) * Math.pow(transformedPoint.x, 2);
  var cRadicand = cSquareNumerator / cSquareRootDenom;
  cRadicand = cRadicand < 0 ? 0 : cRadicand;
  var cCoef = (largeArcFlag !== sweepFlag ? 1 : -1) * Math.sqrt(cRadicand);
  var transformedCenter = {
    x: cCoef * (rx * transformedPoint.y / ry),
    y: cCoef * (-(ry * transformedPoint.x) / rx)
  };
  var center2 = {
    x: Math.cos(xAxisRotationRadians) * transformedCenter.x - Math.sin(xAxisRotationRadians) * transformedCenter.y + (p0.x + p1.x) / 2,
    y: Math.sin(xAxisRotationRadians) * transformedCenter.x + Math.cos(xAxisRotationRadians) * transformedCenter.y + (p0.y + p1.y) / 2
  };
  var startVector = {
    x: (transformedPoint.x - transformedCenter.x) / rx,
    y: (transformedPoint.y - transformedCenter.y) / ry
  };
  var startAngle = angleBetween3({
    x: 1,
    y: 0
  }, startVector);
  var endVector = {
    x: (-transformedPoint.x - transformedCenter.x) / rx,
    y: (-transformedPoint.y - transformedCenter.y) / ry
  };
  var sweepAngle = angleBetween3(startVector, endVector);
  if (!sweepFlag && sweepAngle > 0) {
    sweepAngle -= 2 * Math.PI;
  } else if (sweepFlag && sweepAngle < 0) {
    sweepAngle += 2 * Math.PI;
  }
  sweepAngle %= 2 * Math.PI;
  var angle4 = startAngle + sweepAngle * t;
  var ellipseComponentX = rx * Math.cos(angle4);
  var ellipseComponentY = ry * Math.sin(angle4);
  var point7 = {
    x: Math.cos(xAxisRotationRadians) * ellipseComponentX - Math.sin(xAxisRotationRadians) * ellipseComponentY + center2.x,
    y: Math.sin(xAxisRotationRadians) * ellipseComponentX + Math.cos(xAxisRotationRadians) * ellipseComponentY + center2.y,
    ellipticalArcStartAngle: startAngle,
    ellipticalArcEndAngle: startAngle + sweepAngle,
    ellipticalArcAngle: angle4,
    ellipticalArcCenter: center2,
    resultantRx: rx,
    resultantRy: ry
  };
  return point7;
};
function path2Segments(path2) {
  var segments = [];
  var currentPoint = null;
  var nextParams = null;
  var startMovePoint = null;
  var lastStartMovePointIndex = 0;
  var count4 = path2.length;
  for (var i = 0; i < count4; i++) {
    var params = path2[i];
    nextParams = path2[i + 1];
    var command = params[0];
    var segment = {
      command,
      prePoint: currentPoint,
      params,
      startTangent: null,
      endTangent: null,
      currentPoint: null,
      nextPoint: null,
      arcParams: null,
      box: null,
      cubicParams: null
    };
    switch (command) {
      case "M":
        startMovePoint = [params[1], params[2]];
        lastStartMovePointIndex = i;
        break;
      case "A":
        var arcParams = getArcParams(currentPoint, params);
        segment.arcParams = arcParams;
        break;
    }
    if (command === "Z") {
      currentPoint = startMovePoint;
      nextParams = path2[lastStartMovePointIndex + 1];
    } else {
      var len5 = params.length;
      currentPoint = [params[len5 - 2], params[len5 - 1]];
    }
    if (nextParams && nextParams[0] === "Z") {
      nextParams = path2[lastStartMovePointIndex];
      if (segments[lastStartMovePointIndex]) {
        segments[lastStartMovePointIndex].prePoint = currentPoint;
      }
    }
    segment.currentPoint = currentPoint;
    if (segments[lastStartMovePointIndex] && isSamePoint(currentPoint, segments[lastStartMovePointIndex].currentPoint)) {
      segments[lastStartMovePointIndex].prePoint = segment.prePoint;
    }
    var nextPoint = nextParams ? [nextParams[nextParams.length - 2], nextParams[nextParams.length - 1]] : null;
    segment.nextPoint = nextPoint;
    var prePoint = segment.prePoint;
    if (["L", "H", "V"].includes(command)) {
      segment.startTangent = [
        prePoint[0] - currentPoint[0],
        prePoint[1] - currentPoint[1]
      ];
      segment.endTangent = [
        currentPoint[0] - prePoint[0],
        currentPoint[1] - prePoint[1]
      ];
    } else if (command === "Q") {
      var cp = [params[1], params[2]];
      segment.startTangent = [prePoint[0] - cp[0], prePoint[1] - cp[1]];
      segment.endTangent = [currentPoint[0] - cp[0], currentPoint[1] - cp[1]];
    } else if (command === "T") {
      var preSegment = segments[i - 1];
      var cp = toSymmetry(preSegment.currentPoint, prePoint);
      if (preSegment.command === "Q") {
        segment.command = "Q";
        segment.startTangent = [prePoint[0] - cp[0], prePoint[1] - cp[1]];
        segment.endTangent = [currentPoint[0] - cp[0], currentPoint[1] - cp[1]];
      } else {
        segment.command = "TL";
        segment.startTangent = [
          prePoint[0] - currentPoint[0],
          prePoint[1] - currentPoint[1]
        ];
        segment.endTangent = [
          currentPoint[0] - prePoint[0],
          currentPoint[1] - prePoint[1]
        ];
      }
    } else if (command === "C") {
      var cp1 = [params[1], params[2]];
      var cp2 = [params[3], params[4]];
      segment.startTangent = [prePoint[0] - cp1[0], prePoint[1] - cp1[1]];
      segment.endTangent = [currentPoint[0] - cp2[0], currentPoint[1] - cp2[1]];
      if (segment.startTangent[0] === 0 && segment.startTangent[1] === 0) {
        segment.startTangent = [cp1[0] - cp2[0], cp1[1] - cp2[1]];
      }
      if (segment.endTangent[0] === 0 && segment.endTangent[1] === 0) {
        segment.endTangent = [cp2[0] - cp1[0], cp2[1] - cp1[1]];
      }
    } else if (command === "S") {
      var preSegment = segments[i - 1];
      var cp1 = toSymmetry(preSegment.currentPoint, prePoint);
      var cp2 = [params[1], params[2]];
      if (preSegment.command === "C") {
        segment.command = "C";
        segment.startTangent = [prePoint[0] - cp1[0], prePoint[1] - cp1[1]];
        segment.endTangent = [
          currentPoint[0] - cp2[0],
          currentPoint[1] - cp2[1]
        ];
      } else {
        segment.command = "SQ";
        segment.startTangent = [prePoint[0] - cp2[0], prePoint[1] - cp2[1]];
        segment.endTangent = [
          currentPoint[0] - cp2[0],
          currentPoint[1] - cp2[1]
        ];
      }
    } else if (command === "A") {
      var _a2 = getTangentAtRatio(segment, 0), dx1 = _a2.x, dy1 = _a2.y;
      var _b = getTangentAtRatio(segment, 1, false), dx2 = _b.x, dy2 = _b.y;
      segment.startTangent = [dx1, dy1];
      segment.endTangent = [dx2, dy2];
    }
    segments.push(segment);
  }
  return segments;
}
function getTangentAtRatio(segment, ratio, sign3) {
  if (sign3 === void 0) {
    sign3 = true;
  }
  var _a2 = segment.arcParams, _b = _a2.rx, rx = _b === void 0 ? 0 : _b, _c = _a2.ry, ry = _c === void 0 ? 0 : _c, xRotation = _a2.xRotation, arcFlag = _a2.arcFlag, sweepFlag = _a2.sweepFlag;
  var p1 = pointOnEllipticalArc({ x: segment.prePoint[0], y: segment.prePoint[1] }, rx, ry, xRotation, !!arcFlag, !!sweepFlag, { x: segment.currentPoint[0], y: segment.currentPoint[1] }, ratio);
  var p2 = pointOnEllipticalArc({ x: segment.prePoint[0], y: segment.prePoint[1] }, rx, ry, xRotation, !!arcFlag, !!sweepFlag, { x: segment.currentPoint[0], y: segment.currentPoint[1] }, sign3 ? ratio + 5e-3 : ratio - 5e-3);
  var xDist = p2.x - p1.x;
  var yDist = p2.y - p1.y;
  var dist5 = Math.sqrt(xDist * xDist + yDist * yDist);
  return { x: -xDist / dist5, y: -yDist / dist5 };
}
function vMag(v) {
  return Math.sqrt(v[0] * v[0] + v[1] * v[1]);
}
function vRatio(u, v) {
  return vMag(u) * vMag(v) ? (u[0] * v[0] + u[1] * v[1]) / (vMag(u) * vMag(v)) : 1;
}
function vAngle(u, v) {
  return (u[0] * v[1] < u[1] * v[0] ? -1 : 1) * Math.acos(vRatio(u, v));
}
function getArcParams(startPoint, params) {
  var rx = params[1];
  var ry = params[2];
  var xRotation = mod_default(deg2rad2(params[3]), Math.PI * 2);
  var arcFlag = params[4];
  var sweepFlag = params[5];
  var x12 = startPoint[0];
  var y12 = startPoint[1];
  var x22 = params[6];
  var y22 = params[7];
  var xp = Math.cos(xRotation) * (x12 - x22) / 2 + Math.sin(xRotation) * (y12 - y22) / 2;
  var yp = -1 * Math.sin(xRotation) * (x12 - x22) / 2 + Math.cos(xRotation) * (y12 - y22) / 2;
  var lambda = xp * xp / (rx * rx) + yp * yp / (ry * ry);
  if (lambda > 1) {
    rx *= Math.sqrt(lambda);
    ry *= Math.sqrt(lambda);
  }
  var diff = rx * rx * (yp * yp) + ry * ry * (xp * xp);
  var f = diff ? Math.sqrt((rx * rx * (ry * ry) - diff) / diff) : 1;
  if (arcFlag === sweepFlag) {
    f *= -1;
  }
  if (isNaN(f)) {
    f = 0;
  }
  var cxp = ry ? f * rx * yp / ry : 0;
  var cyp = rx ? f * -ry * xp / rx : 0;
  var cx = (x12 + x22) / 2 + Math.cos(xRotation) * cxp - Math.sin(xRotation) * cyp;
  var cy = (y12 + y22) / 2 + Math.sin(xRotation) * cxp + Math.cos(xRotation) * cyp;
  var u = [(xp - cxp) / rx, (yp - cyp) / ry];
  var v = [(-1 * xp - cxp) / rx, (-1 * yp - cyp) / ry];
  var theta = vAngle([1, 0], u);
  var dTheta = vAngle(u, v);
  if (vRatio(u, v) <= -1) {
    dTheta = Math.PI;
  }
  if (vRatio(u, v) >= 1) {
    dTheta = 0;
  }
  if (sweepFlag === 0 && dTheta > 0) {
    dTheta = dTheta - 2 * Math.PI;
  }
  if (sweepFlag === 1 && dTheta < 0) {
    dTheta = dTheta + 2 * Math.PI;
  }
  return {
    cx,
    cy,
    //  0 
    rx: isSamePoint(startPoint, [x22, y22]) ? 0 : rx,
    ry: isSamePoint(startPoint, [x22, y22]) ? 0 : ry,
    startAngle: theta,
    endAngle: theta + dTheta,
    xRotation,
    arcFlag,
    sweepFlag
  };
}
function commandsToPathString(commands, object, transform3) {
  var _a2 = object.parsedStyle, _b = _a2.defX, defX = _b === void 0 ? 0 : _b, _c = _a2.defY, defY = _c === void 0 ? 0 : _c;
  return commands.reduce(function(prev, cur) {
    var path2 = "";
    if (cur[0] === "M" || cur[0] === "L") {
      var p2 = vec3_exports.fromValues(cur[1] - defX, cur[2] - defY, 0);
      if (transform3) {
        vec3_exports.transformMat4(p2, p2, transform3);
      }
      path2 = "".concat(cur[0]).concat(p2[0], ",").concat(p2[1]);
    } else if (cur[0] === "Z") {
      path2 = cur[0];
    } else if (cur[0] === "C") {
      var p1 = vec3_exports.fromValues(cur[1] - defX, cur[2] - defY, 0);
      var p22 = vec3_exports.fromValues(cur[3] - defX, cur[4] - defY, 0);
      var p3 = vec3_exports.fromValues(cur[5] - defX, cur[6] - defY, 0);
      if (transform3) {
        vec3_exports.transformMat4(p1, p1, transform3);
        vec3_exports.transformMat4(p22, p22, transform3);
        vec3_exports.transformMat4(p3, p3, transform3);
      }
      path2 = "".concat(cur[0]).concat(p1[0], ",").concat(p1[1], ",").concat(p22[0], ",").concat(p22[1], ",").concat(p3[0], ",").concat(p3[1]);
    } else if (cur[0] === "A") {
      var c5 = vec3_exports.fromValues(cur[6] - defX, cur[7] - defY, 0);
      if (transform3) {
        vec3_exports.transformMat4(c5, c5, transform3);
      }
      path2 = "".concat(cur[0]).concat(cur[1], ",").concat(cur[2], ",").concat(cur[3], ",").concat(cur[4], ",").concat(cur[5], ",").concat(c5[0], ",").concat(c5[1]);
    } else if (cur[0] === "Q") {
      var p1 = vec3_exports.fromValues(cur[1] - defX, cur[2] - defY, 0);
      var p22 = vec3_exports.fromValues(cur[3] - defX, cur[4] - defY, 0);
      if (transform3) {
        vec3_exports.transformMat4(p1, p1, transform3);
        vec3_exports.transformMat4(p22, p22, transform3);
      }
      path2 = "".concat(cur[0]).concat(cur[1], ",").concat(cur[2], ",").concat(cur[3], ",").concat(cur[4], "}");
    }
    return prev += path2;
  }, "");
}
function lineToCommands(x12, y12, x22, y22) {
  return [
    ["M", x12, y12],
    ["L", x22, y22]
  ];
}
function ellipseToCommands(rx, ry, cx, cy) {
  var factor = (-1 + Math.sqrt(2)) / 3 * 4;
  var dx = rx * factor;
  var dy = ry * factor;
  var left2 = cx - rx;
  var right2 = cx + rx;
  var top = cy - ry;
  var bottom = cy + ry;
  return [
    ["M", left2, cy],
    ["C", left2, cy - dy, cx - dx, top, cx, top],
    ["C", cx + dx, top, right2, cy - dy, right2, cy],
    ["C", right2, cy + dy, cx + dx, bottom, cx, bottom],
    ["C", cx - dx, bottom, left2, cy + dy, left2, cy],
    ["Z"]
  ];
}
function polygonToCommands(points, closed) {
  var result2 = points.map(function(point7, i) {
    return [i === 0 ? "M" : "L", point7[0], point7[1]];
  });
  if (closed) {
    result2.push(["Z"]);
  }
  return result2;
}
function rectToCommands(width, height, x3, y3, radius) {
  if (radius) {
    var _a2 = __read(radius, 4), tlr = _a2[0], trr = _a2[1], brr = _a2[2], blr = _a2[3];
    var signX = width > 0 ? 1 : -1;
    var signY = height > 0 ? 1 : -1;
    var sweepFlag = signX + signY !== 0 ? 1 : 0;
    return [
      ["M", signX * tlr + x3, y3],
      ["L", width - signX * trr + x3, y3],
      trr ? ["A", trr, trr, 0, 0, sweepFlag, width + x3, signY * trr + y3] : null,
      ["L", width + x3, height - signY * brr + y3],
      brr ? ["A", brr, brr, 0, 0, sweepFlag, width + x3 - signX * brr, height + y3] : null,
      ["L", x3 + signX * blr, height + y3],
      blr ? ["A", blr, blr, 0, 0, sweepFlag, x3, height + y3 - signY * blr] : null,
      ["L", x3, signY * tlr + y3],
      tlr ? ["A", tlr, tlr, 0, 0, sweepFlag, signX * tlr + x3, y3] : null,
      ["Z"]
    ].filter(function(command) {
      return command;
    });
  }
  return [
    ["M", x3, y3],
    ["L", x3 + width, y3],
    ["L", x3 + width, y3 + height],
    ["L", x3, y3 + height],
    ["Z"]
  ];
}
function convertToPath(object, transform3) {
  if (transform3 === void 0) {
    transform3 = object.getLocalTransform();
  }
  var commands = [];
  switch (object.nodeName) {
    case Shape.LINE:
      var _a2 = object.parsedStyle, _b = _a2.x1, x12 = _b === void 0 ? 0 : _b, _c = _a2.y1, y12 = _c === void 0 ? 0 : _c, _d = _a2.x2, x22 = _d === void 0 ? 0 : _d, _e = _a2.y2, y22 = _e === void 0 ? 0 : _e;
      commands = lineToCommands(x12, y12, x22, y22);
      break;
    case Shape.CIRCLE: {
      var _f = object.parsedStyle, _g = _f.r, r = _g === void 0 ? 0 : _g, _h = _f.cx, cx = _h === void 0 ? 0 : _h, _j = _f.cy, cy = _j === void 0 ? 0 : _j;
      commands = ellipseToCommands(r, r, cx, cy);
      break;
    }
    case Shape.ELLIPSE: {
      var _k = object.parsedStyle, _l = _k.rx, rx = _l === void 0 ? 0 : _l, _m = _k.ry, ry = _m === void 0 ? 0 : _m, _o = _k.cx, cx = _o === void 0 ? 0 : _o, _p = _k.cy, cy = _p === void 0 ? 0 : _p;
      commands = ellipseToCommands(rx, ry, cx, cy);
      break;
    }
    case Shape.POLYLINE:
    case Shape.POLYGON:
      var points = object.parsedStyle.points;
      commands = polygonToCommands(points.points, object.nodeName === Shape.POLYGON);
      break;
    case Shape.RECT:
      var _q = object.parsedStyle, _r = _q.width, width_1 = _r === void 0 ? 0 : _r, _s = _q.height, height_1 = _s === void 0 ? 0 : _s, _t = _q.x, x3 = _t === void 0 ? 0 : _t, _u = _q.y, y3 = _u === void 0 ? 0 : _u, radius = _q.radius;
      var hasRadius = radius && radius.some(function(r2) {
        return r2 !== 0;
      });
      commands = rectToCommands(width_1, height_1, x3, y3, hasRadius && radius.map(function(r2) {
        return clamp_default(r2, 0, Math.min(Math.abs(width_1) / 2, Math.abs(height_1) / 2));
      }));
      break;
    case Shape.PATH:
      var absolutePath = object.parsedStyle.path.absolutePath;
      commands = __spreadArray([], __read(absolutePath), false);
      break;
  }
  if (commands.length) {
    return commandsToPathString(commands, object, transform3);
  }
}
var internalParsePath = function(path2) {
  if (path2 === "" || Array.isArray(path2) && path2.length === 0) {
    return {
      absolutePath: [],
      hasArc: false,
      segments: [],
      polygons: [],
      polylines: [],
      curve: null,
      totalLength: 0,
      rect: {
        x: 0,
        y: 0,
        width: 0,
        height: 0
      }
    };
  }
  var absolutePath;
  try {
    absolutePath = normalizePath(path2);
  } catch (e) {
    absolutePath = normalizePath("");
    console.error("[g]: Invalid SVG Path definition: ".concat(path2));
  }
  removeRedundantMCommand(absolutePath);
  var hasArc = hasArcOrBezier(absolutePath);
  var _a2 = extractPolygons(absolutePath), polygons = _a2.polygons, polylines = _a2.polylines;
  var segments = path2Segments(absolutePath);
  var _b = getPathBBox2(segments, 0), x3 = _b.x, y3 = _b.y, width = _b.width, height = _b.height;
  return {
    absolutePath,
    hasArc,
    segments,
    polygons,
    polylines,
    // curve,
    // Delay the calculation of length.
    totalLength: 0,
    rect: {
      x: Number.isFinite(x3) ? x3 : 0,
      y: Number.isFinite(y3) ? y3 : 0,
      width: Number.isFinite(width) ? width : 0,
      height: Number.isFinite(height) ? height : 0
    }
  };
};
var memoizedParsePath = memoize(internalParsePath);
function parsePath(path2) {
  return is_string_default(path2) ? memoizedParsePath(path2) : internalParsePath(path2);
}
function mergePaths(left2, right2, object) {
  var curve1 = left2.curve;
  var curve2 = right2.curve;
  if (!curve1 || curve1.length === 0) {
    curve1 = path2Curve(left2.absolutePath, false);
    left2.curve = curve1;
  }
  if (!curve2 || curve2.length === 0) {
    curve2 = path2Curve(right2.absolutePath, false);
    right2.curve = curve2;
  }
  var curves = [curve1, curve2];
  if (curve1.length !== curve2.length) {
    curves = equalizeSegments(curve1, curve2);
  }
  var curve0 = getDrawDirection(curves[0]) !== getDrawDirection(curves[1]) ? reverseCurve(curves[0]) : clonePath(curves[0]);
  return [
    curve0,
    getRotatedCurve(curves[1], curve0),
    function(pathArray) {
      return pathArray;
    }
  ];
}
function parsePoints(pointsOrStr, object) {
  var points;
  if (is_string_default(pointsOrStr)) {
    points = pointsOrStr.split(" ").map(function(pointStr) {
      var _a2 = __read(pointStr.split(","), 2), x3 = _a2[0], y3 = _a2[1];
      return [Number(x3), Number(y3)];
    });
  } else {
    points = pointsOrStr;
  }
  var segments = [];
  var tempLength = 0;
  var segmentT;
  var segmentL;
  var totalLength = length$2(points);
  points.forEach(function(p2, i) {
    if (points[i + 1]) {
      segmentT = [0, 0];
      segmentT[0] = tempLength / totalLength;
      segmentL = length$4(p2[0], p2[1], points[i + 1][0], points[i + 1][1]);
      tempLength += segmentL;
      segmentT[1] = tempLength / totalLength;
      segments.push(segmentT);
    }
  });
  var minX = Math.min.apply(Math, __spreadArray([], __read(points.map(function(point7) {
    return point7[0];
  })), false));
  var minY = Math.min.apply(Math, __spreadArray([], __read(points.map(function(point7) {
    return point7[1];
  })), false));
  if (object) {
    object.parsedStyle.defX = minX;
    object.parsedStyle.defY = minY;
  }
  return {
    points,
    totalLength,
    segments
  };
}
function mergePoints(left2, right2) {
  return [
    left2.points,
    right2.points,
    function(points) {
      return points;
    }
  ];
}
var _ = null;
function cast(pattern) {
  return function(contents) {
    var i = 0;
    return pattern.map(function(x3) {
      return x3 === _ ? contents[i++] : x3;
    });
  };
}
function id(x3) {
  return x3;
}
var transformFunctions = {
  // @ts-ignore
  matrix: ["NNNNNN", [_, _, 0, 0, _, _, 0, 0, 0, 0, 1, 0, _, _, 0, 1], id],
  matrix3d: ["NNNNNNNNNNNNNNNN", id],
  rotate: ["A"],
  rotatex: ["A"],
  rotatey: ["A"],
  rotatez: ["A"],
  rotate3d: ["NNNA"],
  perspective: ["L"],
  scale: ["Nn", cast([_, _, new CSSUnitValue(1)]), id],
  scalex: [
    "N",
    cast([_, new CSSUnitValue(1), new CSSUnitValue(1)]),
    cast([_, new CSSUnitValue(1)])
  ],
  scaley: [
    "N",
    cast([new CSSUnitValue(1), _, new CSSUnitValue(1)]),
    cast([new CSSUnitValue(1), _])
  ],
  scalez: ["N", cast([new CSSUnitValue(1), new CSSUnitValue(1), _])],
  scale3d: ["NNN", id],
  skew: ["Aa", null, id],
  skewx: ["A", null, cast([_, Odeg])],
  skewy: ["A", null, cast([Odeg, _])],
  translate: ["Tt", cast([_, _, Opx]), id],
  translatex: ["T", cast([_, Opx, Opx]), cast([_, Opx])],
  translatey: ["T", cast([Opx, _, Opx]), cast([Opx, _])],
  translatez: ["L", cast([Opx, Opx, _])],
  translate3d: ["TTL", id]
};
function parseTransform(string) {
  string = (string || "none").toLowerCase().trim();
  if (string === "none") {
    return [];
  }
  var transformRegExp = /\s*(\w+)\(([^)]*)\)/g;
  var result2 = [];
  var match;
  var prevLastIndex = 0;
  while (match = transformRegExp.exec(string)) {
    if (match.index !== prevLastIndex) {
      return [];
    }
    prevLastIndex = match.index + match[0].length;
    var functionName = match[1];
    var functionData = transformFunctions[functionName];
    if (!functionData) {
      return [];
    }
    var args = match[2].split(",");
    var argTypes = functionData[0];
    if (argTypes.length < args.length) {
      return [];
    }
    var parsedArgs = [];
    for (var i = 0; i < argTypes.length; i++) {
      var arg = args[i];
      var type = argTypes[i];
      var parsedArg = void 0;
      if (!arg) {
        parsedArg = {
          a: Odeg,
          n: parsedArgs[0],
          t: Opx
        }[type];
      } else {
        parsedArg = {
          A: function(s2) {
            return s2.trim() === "0" ? Odeg : parseAngle(s2);
          },
          N: parseNumber,
          T: parseLengthOrPercentage,
          L: parseLength
        }[type.toUpperCase()](arg);
      }
      if (parsedArg === void 0) {
        return [];
      }
      parsedArgs.push(parsedArg);
    }
    result2.push({ t: functionName, d: parsedArgs });
    if (transformRegExp.lastIndex === string.length) {
      return result2;
    }
  }
  return [];
}
function convertItemToMatrix(item) {
  var x3;
  var y3;
  var z;
  var angle4;
  switch (item.t) {
    case "rotatex":
      angle4 = deg2rad2(convertAngleUnit(item.d[0]));
      return [
        1,
        0,
        0,
        0,
        0,
        Math.cos(angle4),
        Math.sin(angle4),
        0,
        0,
        -Math.sin(angle4),
        Math.cos(angle4),
        0,
        0,
        0,
        0,
        1
      ];
    case "rotatey":
      angle4 = deg2rad2(convertAngleUnit(item.d[0]));
      return [
        Math.cos(angle4),
        0,
        -Math.sin(angle4),
        0,
        0,
        1,
        0,
        0,
        Math.sin(angle4),
        0,
        Math.cos(angle4),
        0,
        0,
        0,
        0,
        1
      ];
    case "rotate":
    case "rotatez":
      angle4 = deg2rad2(convertAngleUnit(item.d[0]));
      return [
        Math.cos(angle4),
        Math.sin(angle4),
        0,
        0,
        -Math.sin(angle4),
        Math.cos(angle4),
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        1
      ];
    case "rotate3d":
      x3 = item.d[0].value;
      y3 = item.d[1].value;
      z = item.d[2].value;
      angle4 = deg2rad2(convertAngleUnit(item.d[3]));
      var sqrLength = x3 * x3 + y3 * y3 + z * z;
      if (sqrLength === 0) {
        x3 = 1;
        y3 = 0;
        z = 0;
      } else if (sqrLength !== 1) {
        var length_1 = Math.sqrt(sqrLength);
        x3 /= length_1;
        y3 /= length_1;
        z /= length_1;
      }
      var s2 = Math.sin(angle4 / 2);
      var sc = s2 * Math.cos(angle4 / 2);
      var sq = s2 * s2;
      return [
        1 - 2 * (y3 * y3 + z * z) * sq,
        2 * (x3 * y3 * sq + z * sc),
        2 * (x3 * z * sq - y3 * sc),
        0,
        2 * (x3 * y3 * sq - z * sc),
        1 - 2 * (x3 * x3 + z * z) * sq,
        2 * (y3 * z * sq + x3 * sc),
        0,
        2 * (x3 * z * sq + y3 * sc),
        2 * (y3 * z * sq - x3 * sc),
        1 - 2 * (x3 * x3 + y3 * y3) * sq,
        0,
        0,
        0,
        0,
        1
      ];
    case "scale":
      return [
        item.d[0].value,
        0,
        0,
        0,
        0,
        item.d[1].value,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        1
      ];
    case "scalex":
      return [item.d[0].value, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
    case "scaley":
      return [1, 0, 0, 0, 0, item.d[0].value, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
    case "scalez":
      return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, item.d[0].value, 0, 0, 0, 0, 1];
    case "scale3d":
      return [
        item.d[0].value,
        0,
        0,
        0,
        0,
        item.d[1].value,
        0,
        0,
        0,
        0,
        item.d[2].value,
        0,
        0,
        0,
        0,
        1
      ];
    case "skew":
      var xAngle = deg2rad2(convertAngleUnit(item.d[0]));
      var yAngle = deg2rad2(convertAngleUnit(item.d[1]));
      return [
        1,
        Math.tan(yAngle),
        0,
        0,
        Math.tan(xAngle),
        1,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        1
      ];
    case "skewx":
      angle4 = deg2rad2(convertAngleUnit(item.d[0]));
      return [1, 0, 0, 0, Math.tan(angle4), 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
    case "skewy":
      angle4 = deg2rad2(convertAngleUnit(item.d[0]));
      return [1, Math.tan(angle4), 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
    case "translate":
      x3 = convertPercentUnit(item.d[0], 0, null) || 0;
      y3 = convertPercentUnit(item.d[1], 0, null) || 0;
      return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, x3, y3, 0, 1];
    case "translatex":
      x3 = convertPercentUnit(item.d[0], 0, null) || 0;
      return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, x3, 0, 0, 1];
    case "translatey":
      y3 = convertPercentUnit(item.d[0], 0, null) || 0;
      return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, y3, 0, 1];
    case "translatez":
      z = convertPercentUnit(item.d[0], 0, null) || 0;
      return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, z, 1];
    case "translate3d":
      x3 = convertPercentUnit(item.d[0], 0, null) || 0;
      y3 = convertPercentUnit(item.d[1], 0, null) || 0;
      z = convertPercentUnit(item.d[2], 0, null) || 0;
      return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, x3, y3, z, 1];
    case "perspective":
      var t = convertPercentUnit(item.d[0], 0, null) || 0;
      var p2 = t ? -1 / t : 0;
      return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, p2, 0, 0, 0, 1];
    case "matrix":
      return [
        item.d[0].value,
        item.d[1].value,
        0,
        0,
        item.d[2].value,
        item.d[3].value,
        0,
        0,
        0,
        0,
        1,
        0,
        item.d[4].value,
        item.d[5].value,
        0,
        1
      ];
    case "matrix3d":
      return item.d.map(function(d2) {
        return d2.value;
      });
  }
}
function multiplyMatrices(a4, b) {
  return [
    a4[0] * b[0] + a4[4] * b[1] + a4[8] * b[2] + a4[12] * b[3],
    a4[1] * b[0] + a4[5] * b[1] + a4[9] * b[2] + a4[13] * b[3],
    a4[2] * b[0] + a4[6] * b[1] + a4[10] * b[2] + a4[14] * b[3],
    a4[3] * b[0] + a4[7] * b[1] + a4[11] * b[2] + a4[15] * b[3],
    a4[0] * b[4] + a4[4] * b[5] + a4[8] * b[6] + a4[12] * b[7],
    a4[1] * b[4] + a4[5] * b[5] + a4[9] * b[6] + a4[13] * b[7],
    a4[2] * b[4] + a4[6] * b[5] + a4[10] * b[6] + a4[14] * b[7],
    a4[3] * b[4] + a4[7] * b[5] + a4[11] * b[6] + a4[15] * b[7],
    a4[0] * b[8] + a4[4] * b[9] + a4[8] * b[10] + a4[12] * b[11],
    a4[1] * b[8] + a4[5] * b[9] + a4[9] * b[10] + a4[13] * b[11],
    a4[2] * b[8] + a4[6] * b[9] + a4[10] * b[10] + a4[14] * b[11],
    a4[3] * b[8] + a4[7] * b[9] + a4[11] * b[10] + a4[15] * b[11],
    a4[0] * b[12] + a4[4] * b[13] + a4[8] * b[14] + a4[12] * b[15],
    a4[1] * b[12] + a4[5] * b[13] + a4[9] * b[14] + a4[13] * b[15],
    a4[2] * b[12] + a4[6] * b[13] + a4[10] * b[14] + a4[14] * b[15],
    a4[3] * b[12] + a4[7] * b[13] + a4[11] * b[14] + a4[15] * b[15]
  ];
}
function convertToMatrix(transformList) {
  if (transformList.length === 0) {
    return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
  }
  return transformList.map(convertItemToMatrix).reduce(multiplyMatrices);
}
function makeMatrixDecomposition(transformList) {
  var translate4 = [0, 0, 0];
  var scale10 = [1, 1, 1];
  var skew = [0, 0, 0];
  var perspective2 = [0, 0, 0, 1];
  var quaternion = [0, 0, 0, 1];
  decomposeMat4(
    // @ts-ignore
    convertToMatrix(transformList),
    translate4,
    scale10,
    skew,
    perspective2,
    quaternion
  );
  return [[translate4, scale10, skew, quaternion, perspective2]];
}
var composeMatrix = function() {
  function multiply8(a4, b) {
    var result2 = [
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [0, 0, 0, 0]
    ];
    for (var i = 0; i < 4; i++) {
      for (var j = 0; j < 4; j++) {
        for (var k2 = 0; k2 < 4; k2++) {
          result2[i][j] += b[i][k2] * a4[k2][j];
        }
      }
    }
    return result2;
  }
  function is2D(m3) {
    return m3[0][2] == 0 && m3[0][3] == 0 && m3[1][2] == 0 && m3[1][3] == 0 && m3[2][0] == 0 && m3[2][1] == 0 && m3[2][2] == 1 && m3[2][3] == 0 && m3[3][2] == 0 && m3[3][3] == 1;
  }
  function composeMatrix2(translate4, scale10, skew, quat2, perspective2) {
    var matrix2 = [
      [1, 0, 0, 0],
      [0, 1, 0, 0],
      [0, 0, 1, 0],
      [0, 0, 0, 1]
    ];
    for (var i = 0; i < 4; i++) {
      matrix2[i][3] = perspective2[i];
    }
    for (var i = 0; i < 3; i++) {
      for (var j = 0; j < 3; j++) {
        matrix2[3][i] += translate4[j] * matrix2[j][i];
      }
    }
    var x3 = quat2[0], y3 = quat2[1], z = quat2[2], w = quat2[3];
    var rotMatrix = [
      [1, 0, 0, 0],
      [0, 1, 0, 0],
      [0, 0, 1, 0],
      [0, 0, 0, 1]
    ];
    rotMatrix[0][0] = 1 - 2 * (y3 * y3 + z * z);
    rotMatrix[0][1] = 2 * (x3 * y3 - z * w);
    rotMatrix[0][2] = 2 * (x3 * z + y3 * w);
    rotMatrix[1][0] = 2 * (x3 * y3 + z * w);
    rotMatrix[1][1] = 1 - 2 * (x3 * x3 + z * z);
    rotMatrix[1][2] = 2 * (y3 * z - x3 * w);
    rotMatrix[2][0] = 2 * (x3 * z - y3 * w);
    rotMatrix[2][1] = 2 * (y3 * z + x3 * w);
    rotMatrix[2][2] = 1 - 2 * (x3 * x3 + y3 * y3);
    matrix2 = multiply8(matrix2, rotMatrix);
    var temp = [
      [1, 0, 0, 0],
      [0, 1, 0, 0],
      [0, 0, 1, 0],
      [0, 0, 0, 1]
    ];
    if (skew[2]) {
      temp[2][1] = skew[2];
      matrix2 = multiply8(matrix2, temp);
    }
    if (skew[1]) {
      temp[2][1] = 0;
      temp[2][0] = skew[0];
      matrix2 = multiply8(matrix2, temp);
    }
    if (skew[0]) {
      temp[2][0] = 0;
      temp[1][0] = skew[0];
      matrix2 = multiply8(matrix2, temp);
    }
    for (var i = 0; i < 3; i++) {
      for (var j = 0; j < 3; j++) {
        matrix2[i][j] *= scale10[i];
      }
    }
    if (is2D(matrix2)) {
      return [
        matrix2[0][0],
        matrix2[0][1],
        matrix2[1][0],
        matrix2[1][1],
        matrix2[3][0],
        matrix2[3][1]
      ];
    }
    return matrix2[0].concat(matrix2[1], matrix2[2], matrix2[3]);
  }
  return composeMatrix2;
}();
function numberToLongString(x3) {
  return x3.toFixed(6).replace(".000000", "");
}
function mergeMatrices(left2, right2) {
  var leftArgs;
  var rightArgs;
  if (left2.decompositionPair !== right2) {
    left2.decompositionPair = right2;
    leftArgs = makeMatrixDecomposition(left2);
  }
  if (right2.decompositionPair !== left2) {
    right2.decompositionPair = left2;
    rightArgs = makeMatrixDecomposition(right2);
  }
  if (leftArgs[0] === null || rightArgs[0] === null)
    return [
      // @ts-ignore
      [false],
      // @ts-ignore
      [true],
      // @ts-ignore
      function(x3) {
        return x3 ? right2[0].d : left2[0].d;
      }
    ];
  leftArgs[0].push(0);
  rightArgs[0].push(1);
  return [
    leftArgs,
    rightArgs,
    // @ts-ignore
    function(list) {
      var q = quat(leftArgs[0][3], rightArgs[0][3], list[5]);
      var mat = composeMatrix(list[0], list[1], list[2], q, list[4]);
      var stringifiedArgs = mat.map(numberToLongString).join(",");
      return stringifiedArgs;
    }
  ];
}
function dot5(v1, v2) {
  var result2 = 0;
  for (var i = 0; i < v1.length; i++) {
    result2 += v1[i] * v2[i];
  }
  return result2;
}
function quat(fromQ, toQ, f) {
  var product = dot5(fromQ, toQ);
  product = clamp_default(product, -1, 1);
  var quat2 = [];
  if (product === 1) {
    quat2 = fromQ;
  } else {
    var theta = Math.acos(product);
    var w = Math.sin(f * theta) * 1 / Math.sqrt(1 - product * product);
    for (var i = 0; i < 4; i++) {
      quat2.push(fromQ[i] * (Math.cos(f * theta) - product * w) + toQ[i] * w);
    }
  }
  return quat2;
}
function typeTo2D(type) {
  return type.replace(/[xy]/, "");
}
function typeTo3D(type) {
  return type.replace(/(x|y|z|3d)?$/, "3d");
}
var isMatrixOrPerspective = function(lt2, rt) {
  return lt2 === "perspective" && rt === "perspective" || (lt2 === "matrix" || lt2 === "matrix3d") && (rt === "matrix" || rt === "matrix3d");
};
function mergeTransforms(left2, right2, target) {
  var flipResults = false;
  if (!left2.length || !right2.length) {
    if (!left2.length) {
      flipResults = true;
      left2 = right2;
      right2 = [];
    }
    var _loop_1 = function(i2) {
      var _a2 = left2[i2], type2 = _a2.t, args = _a2.d;
      var defaultValue = type2.substring(0, 5) === "scale" ? 1 : 0;
      right2.push({
        t: type2,
        d: args.map(function(arg) {
          if (typeof arg === "number") {
            return getOrCreateUnitValue(defaultValue);
          }
          return getOrCreateUnitValue(defaultValue, arg.unit);
        })
      });
    };
    for (var i = 0; i < left2.length; i++) {
      _loop_1(i);
    }
  }
  var leftResult = [];
  var rightResult = [];
  var types = [];
  if (left2.length !== right2.length) {
    var merged = mergeMatrices(left2, right2);
    leftResult = [merged[0]];
    rightResult = [merged[1]];
    types = [["matrix", [merged[2]]]];
  } else {
    for (var i = 0; i < left2.length; i++) {
      var leftType = left2[i].t;
      var rightType = right2[i].t;
      var leftArgs = left2[i].d;
      var rightArgs = right2[i].d;
      var leftFunctionData = transformFunctions[leftType];
      var rightFunctionData = transformFunctions[rightType];
      var type = void 0;
      if (isMatrixOrPerspective(leftType, rightType)) {
        var merged = mergeMatrices([left2[i]], [right2[i]]);
        leftResult.push(merged[0]);
        rightResult.push(merged[1]);
        types.push(["matrix", [merged[2]]]);
        continue;
      } else if (leftType === rightType) {
        type = leftType;
      } else if (leftFunctionData[2] && rightFunctionData[2] && typeTo2D(leftType) === typeTo2D(rightType)) {
        type = typeTo2D(leftType);
        leftArgs = leftFunctionData[2](leftArgs);
        rightArgs = rightFunctionData[2](rightArgs);
      } else if (leftFunctionData[1] && rightFunctionData[1] && typeTo3D(leftType) === typeTo3D(rightType)) {
        type = typeTo3D(leftType);
        leftArgs = leftFunctionData[1](leftArgs);
        rightArgs = rightFunctionData[1](rightArgs);
      } else {
        var merged = mergeMatrices(left2, right2);
        leftResult = [merged[0]];
        rightResult = [merged[1]];
        types = [["matrix", [merged[2]]]];
        break;
      }
      var leftArgsCopy = [];
      var rightArgsCopy = [];
      var stringConversions = [];
      for (var j = 0; j < leftArgs.length; j++) {
        var merged = mergeDimensions(leftArgs[j], rightArgs[j], target, false, j);
        leftArgsCopy[j] = merged[0];
        rightArgsCopy[j] = merged[1];
        stringConversions.push(merged[2]);
      }
      leftResult.push(leftArgsCopy);
      rightResult.push(rightArgsCopy);
      types.push([type, stringConversions]);
    }
  }
  if (flipResults) {
    var tmp2 = leftResult;
    leftResult = rightResult;
    rightResult = tmp2;
  }
  return [
    leftResult,
    rightResult,
    function(list) {
      return list.map(function(args, i2) {
        var stringifiedArgs = args.map(function(arg, j2) {
          return types[i2][1][j2](arg);
        }).join(",");
        if (types[i2][0] === "matrix" && stringifiedArgs.split(",").length === 16) {
          types[i2][0] = "matrix3d";
        }
        if (types[i2][0] === "matrix3d" && stringifiedArgs.split(",").length === 6) {
          types[i2][0] = "matrix";
        }
        return types[i2][0] + "(" + stringifiedArgs + ")";
      }).join(" ");
    }
  ];
}
var parseTransformOrigin = memoize(function(value2) {
  if (is_string_default(value2)) {
    if (value2 === "text-anchor") {
      return [getOrCreateUnitValue(0, "px"), getOrCreateUnitValue(0, "px")];
    }
    var values4 = value2.split(" ");
    if (values4.length === 1) {
      if (values4[0] === "top" || values4[0] === "bottom") {
        values4[1] = values4[0];
        values4[0] = "center";
      } else {
        values4[1] = "center";
      }
    }
    if (values4.length !== 2) {
      return null;
    }
    return [
      parseLengthOrPercentage(convertKeyword2Percent(values4[0])),
      parseLengthOrPercentage(convertKeyword2Percent(values4[1]))
    ];
  } else {
    return [
      getOrCreateUnitValue(value2[0] || 0, "px"),
      getOrCreateUnitValue(value2[1] || 0, "px")
    ];
  }
});
function convertKeyword2Percent(keyword) {
  if (keyword === "center") {
    return "50%";
  } else if (keyword === "left" || keyword === "top") {
    return "0";
  } else if (keyword === "right" || keyword === "bottom") {
    return "100%";
  }
  return keyword;
}
var BUILT_IN_PROPERTIES = [
  {
    /**
     * used in CSS Layout API
     * eg. `display: 'flex'`
     */
    n: "display",
    k: ["none"]
  },
  {
    /**
     * range [0.0, 1.0]
     * @see https://developer.mozilla.org/en-US/docs/Web/CSS/opacity
     */
    n: "opacity",
    int: true,
    inh: true,
    d: "1",
    syntax: PropertySyntax.OPACITY_VALUE
  },
  {
    /**
     * inheritable, range [0.0, 1.0]
     * @see https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/fill-opacity
     * @see https://svgwg.org/svg2-draft/painting.html#FillOpacity
     */
    n: "fillOpacity",
    int: true,
    inh: true,
    d: "1",
    syntax: PropertySyntax.OPACITY_VALUE
  },
  {
    /**
     * inheritable, range [0.0, 1.0]
     * @see https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/stroke-opacity
     * @see https://svgwg.org/svg2-draft/painting.html#StrokeOpacity
     */
    n: "strokeOpacity",
    int: true,
    inh: true,
    d: "1",
    syntax: PropertySyntax.OPACITY_VALUE
  },
  {
    /**
     * background-color is not inheritable
     * @see https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorial/Fills_and_Strokes
     */
    n: "fill",
    int: true,
    k: ["none"],
    d: "none",
    syntax: PropertySyntax.PAINT
  },
  {
    n: "fillRule",
    k: ["nonzero", "evenodd"],
    d: "nonzero"
  },
  /**
   * default to none
   * @see https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/stroke#usage_notes
   */
  {
    n: "stroke",
    int: true,
    k: ["none"],
    d: "none",
    syntax: PropertySyntax.PAINT,
    /**
     * Stroke 'none' won't affect geometry but others will.
     */
    l: true
  },
  {
    n: "shadowType",
    k: ["inner", "outer", "both"],
    d: "outer",
    l: true
  },
  {
    n: "shadowColor",
    int: true,
    syntax: PropertySyntax.COLOR
  },
  {
    n: "shadowOffsetX",
    int: true,
    l: true,
    d: "0",
    syntax: PropertySyntax.LENGTH_PERCENTAGE
  },
  {
    n: "shadowOffsetY",
    int: true,
    l: true,
    d: "0",
    syntax: PropertySyntax.LENGTH_PERCENTAGE
  },
  {
    n: "shadowBlur",
    int: true,
    l: true,
    d: "0",
    syntax: PropertySyntax.SHADOW_BLUR
  },
  {
    /**
     * @see https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/stroke-width
     */
    n: "lineWidth",
    int: true,
    inh: true,
    d: "1",
    l: true,
    a: ["strokeWidth"],
    syntax: PropertySyntax.LENGTH_PERCENTAGE
  },
  {
    n: "increasedLineWidthForHitTesting",
    inh: true,
    d: "0",
    l: true,
    syntax: PropertySyntax.LENGTH_PERCENTAGE
  },
  {
    n: "lineJoin",
    inh: true,
    l: true,
    a: ["strokeLinejoin"],
    k: ["miter", "bevel", "round"],
    d: "miter"
  },
  {
    n: "lineCap",
    inh: true,
    l: true,
    a: ["strokeLinecap"],
    k: ["butt", "round", "square"],
    d: "butt"
  },
  {
    n: "lineDash",
    int: true,
    inh: true,
    k: ["none"],
    a: ["strokeDasharray"],
    syntax: PropertySyntax.LENGTH_PERCENTAGE_12
  },
  {
    n: "lineDashOffset",
    int: true,
    inh: true,
    d: "0",
    a: ["strokeDashoffset"],
    syntax: PropertySyntax.LENGTH_PERCENTAGE
  },
  {
    n: "offsetPath",
    syntax: PropertySyntax.DEFINED_PATH
  },
  {
    n: "offsetDistance",
    int: true,
    syntax: PropertySyntax.OFFSET_DISTANCE
  },
  {
    n: "dx",
    int: true,
    l: true,
    d: "0",
    syntax: PropertySyntax.LENGTH_PERCENTAGE
  },
  {
    n: "dy",
    int: true,
    l: true,
    d: "0",
    syntax: PropertySyntax.LENGTH_PERCENTAGE
  },
  {
    n: "zIndex",
    ind: true,
    int: true,
    d: "0",
    k: ["auto"],
    syntax: PropertySyntax.Z_INDEX
  },
  {
    n: "visibility",
    k: ["visible", "hidden"],
    ind: true,
    inh: true,
    /**
     * support interpolation
     * @see https://developer.mozilla.org/en-US/docs/Web/CSS/visibility#interpolation
     */
    int: true,
    d: "visible"
  },
  {
    n: "pointerEvents",
    inh: true,
    k: [
      "none",
      "auto",
      "stroke",
      "fill",
      "painted",
      "visible",
      "visiblestroke",
      "visiblefill",
      "visiblepainted",
      // 'bounding-box',
      "all"
    ],
    d: "auto"
  },
  {
    n: "filter",
    ind: true,
    l: true,
    k: ["none"],
    d: "none",
    syntax: PropertySyntax.FILTER
  },
  {
    n: "clipPath",
    syntax: PropertySyntax.DEFINED_PATH
  },
  {
    n: "textPath",
    syntax: PropertySyntax.DEFINED_PATH
  },
  {
    n: "textPathSide",
    k: ["left", "right"],
    d: "left"
  },
  {
    n: "textPathStartOffset",
    l: true,
    d: "0",
    syntax: PropertySyntax.LENGTH_PERCENTAGE
  },
  {
    n: "transform",
    p: 100,
    int: true,
    k: ["none"],
    d: "none",
    syntax: PropertySyntax.TRANSFORM
  },
  {
    n: "transformOrigin",
    p: 100,
    // int: true,
    d: function(nodeName) {
      if (nodeName === Shape.CIRCLE || nodeName === Shape.ELLIPSE) {
        return "center";
      }
      if (nodeName === Shape.TEXT) {
        return "text-anchor";
      }
      return "left top";
    },
    l: true,
    syntax: PropertySyntax.TRANSFORM_ORIGIN
  },
  {
    n: "anchor",
    p: 99,
    d: function(nodeName) {
      if (nodeName === Shape.CIRCLE || nodeName === Shape.ELLIPSE) {
        return "0.5 0.5";
      }
      return "0 0";
    },
    l: true,
    syntax: PropertySyntax.LENGTH_PERCENTAGE_12
  },
  // <circle> & <ellipse>
  {
    n: "cx",
    int: true,
    d: "0",
    syntax: PropertySyntax.COORDINATE
  },
  {
    n: "cy",
    int: true,
    d: "0",
    syntax: PropertySyntax.COORDINATE
  },
  {
    n: "cz",
    int: true,
    d: "0",
    syntax: PropertySyntax.COORDINATE
  },
  {
    n: "r",
    int: true,
    l: true,
    d: "0",
    syntax: PropertySyntax.LENGTH_PERCENTAGE
  },
  {
    n: "rx",
    int: true,
    l: true,
    d: "0",
    syntax: PropertySyntax.LENGTH_PERCENTAGE
  },
  {
    n: "ry",
    int: true,
    l: true,
    d: "0",
    syntax: PropertySyntax.LENGTH_PERCENTAGE
  },
  // Rect Image Group
  {
    // x in local space
    n: "x",
    int: true,
    d: "0",
    syntax: PropertySyntax.COORDINATE
  },
  {
    // y in local space
    n: "y",
    int: true,
    d: "0",
    syntax: PropertySyntax.COORDINATE
  },
  {
    // z in local space
    n: "z",
    int: true,
    d: "0",
    syntax: PropertySyntax.COORDINATE
  },
  {
    n: "width",
    int: true,
    l: true,
    /**
     * @see https://developer.mozilla.org/zh-CN/docs/Web/CSS/width
     */
    k: ["auto", "fit-content", "min-content", "max-content"],
    d: "0",
    syntax: PropertySyntax.LENGTH_PERCENTAGE
  },
  {
    n: "height",
    int: true,
    l: true,
    /**
     * @see https://developer.mozilla.org/zh-CN/docs/Web/CSS/height
     */
    k: ["auto", "fit-content", "min-content", "max-content"],
    d: "0",
    syntax: PropertySyntax.LENGTH_PERCENTAGE
  },
  {
    n: "radius",
    int: true,
    l: true,
    d: "0",
    syntax: PropertySyntax.LENGTH_PERCENTAGE_14
  },
  // Line
  {
    n: "x1",
    int: true,
    l: true,
    syntax: PropertySyntax.COORDINATE
  },
  {
    n: "y1",
    int: true,
    l: true,
    syntax: PropertySyntax.COORDINATE
  },
  {
    n: "z1",
    int: true,
    l: true,
    syntax: PropertySyntax.COORDINATE
  },
  {
    n: "x2",
    int: true,
    l: true,
    syntax: PropertySyntax.COORDINATE
  },
  {
    n: "y2",
    int: true,
    l: true,
    syntax: PropertySyntax.COORDINATE
  },
  {
    n: "z2",
    int: true,
    l: true,
    syntax: PropertySyntax.COORDINATE
  },
  // Path
  {
    n: "path",
    int: true,
    l: true,
    d: "",
    a: ["d"],
    syntax: PropertySyntax.PATH,
    p: 50
  },
  // Polyline & Polygon
  {
    n: "points",
    /**
     * support interpolation
     */
    int: true,
    l: true,
    syntax: PropertySyntax.LIST_OF_POINTS,
    p: 50
  },
  // Text
  {
    n: "text",
    l: true,
    d: "",
    syntax: PropertySyntax.TEXT,
    p: 50
  },
  {
    n: "textTransform",
    l: true,
    inh: true,
    k: ["capitalize", "uppercase", "lowercase", "none"],
    d: "none",
    syntax: PropertySyntax.TEXT_TRANSFORM,
    p: 51
    // it must get parsed after text
  },
  {
    n: "font",
    l: true
  },
  {
    n: "fontSize",
    int: true,
    inh: true,
    /**
     * @see https://www.w3schools.com/css/css_font_size.asp
     */
    d: "16px",
    l: true,
    syntax: PropertySyntax.LENGTH_PERCENTAGE
  },
  {
    n: "fontFamily",
    l: true,
    inh: true,
    d: "sans-serif"
  },
  {
    n: "fontStyle",
    l: true,
    inh: true,
    k: ["normal", "italic", "oblique"],
    d: "normal"
  },
  {
    n: "fontWeight",
    l: true,
    inh: true,
    k: ["normal", "bold", "bolder", "lighter"],
    d: "normal"
  },
  {
    n: "fontVariant",
    l: true,
    inh: true,
    k: ["normal", "small-caps"],
    d: "normal"
  },
  {
    n: "lineHeight",
    l: true,
    syntax: PropertySyntax.LENGTH,
    int: true,
    d: "0"
  },
  {
    n: "letterSpacing",
    l: true,
    syntax: PropertySyntax.LENGTH,
    int: true,
    d: "0"
  },
  {
    n: "miterLimit",
    l: true,
    syntax: PropertySyntax.NUMBER,
    d: function(nodeName) {
      if (nodeName === Shape.PATH || nodeName === Shape.POLYGON || nodeName === Shape.POLYLINE) {
        return "4";
      }
      return "10";
    }
  },
  {
    n: "wordWrap",
    l: true
  },
  {
    n: "wordWrapWidth",
    l: true
  },
  {
    n: "maxLines",
    l: true
  },
  {
    n: "textOverflow",
    l: true,
    d: "clip"
  },
  {
    n: "leading",
    l: true
  },
  {
    n: "textBaseline",
    l: true,
    inh: true,
    k: ["top", "hanging", "middle", "alphabetic", "ideographic", "bottom"],
    d: "alphabetic"
  },
  {
    n: "textAlign",
    l: true,
    inh: true,
    k: ["start", "center", "middle", "end", "left", "right"],
    d: "start"
  },
  // {
  //   n: 'whiteSpace',
  //   l: true,
  // },
  {
    n: "markerStart",
    syntax: PropertySyntax.MARKER
  },
  {
    n: "markerEnd",
    syntax: PropertySyntax.MARKER
  },
  {
    n: "markerMid",
    syntax: PropertySyntax.MARKER
  },
  {
    n: "markerStartOffset",
    syntax: PropertySyntax.LENGTH,
    l: true,
    int: true,
    d: "0"
  },
  {
    n: "markerEndOffset",
    syntax: PropertySyntax.LENGTH,
    l: true,
    int: true,
    d: "0"
  }
];
var GEOMETRY_ATTRIBUTE_NAMES = BUILT_IN_PROPERTIES.filter(function(n) {
  return !!n.l;
}).map(function(n) {
  return n.n;
});
var propertyMetadataCache = {};
var unresolvedProperties = /* @__PURE__ */ new WeakMap();
var isPropertyResolved = function(object, name2) {
  var properties = unresolvedProperties.get(object);
  if (!properties || properties.length === 0) {
    return true;
  }
  return properties.includes(name2);
};
var DefaultStyleValueRegistry = (
  /** @class */
  function() {
    function DefaultStyleValueRegistry2(runtime2) {
      var _this2 = this;
      this.runtime = runtime2;
      BUILT_IN_PROPERTIES.forEach(function(property2) {
        _this2.registerMetadata(property2);
      });
    }
    DefaultStyleValueRegistry2.prototype.registerMetadata = function(metadata) {
      __spreadArray([metadata.n], __read(metadata.a || []), false).forEach(function(name2) {
        propertyMetadataCache[name2] = metadata;
      });
    };
    DefaultStyleValueRegistry2.prototype.unregisterMetadata = function(name2) {
      delete propertyMetadataCache[name2];
    };
    DefaultStyleValueRegistry2.prototype.getPropertySyntax = function(syntax) {
      return this.runtime.CSSPropertySyntaxFactory[syntax];
    };
    DefaultStyleValueRegistry2.prototype.processProperties = function(object, attributes, options) {
      var _this2 = this;
      if (options === void 0) {
        options = {
          skipUpdateAttribute: false,
          skipParse: false,
          forceUpdateGeometry: false,
          usedAttributes: []
        };
      }
      if (!this.runtime.enableCSSParsing) {
        Object.assign(object.attributes, attributes);
        var attributeNames_1 = Object.keys(attributes);
        var oldClipPath = object.parsedStyle.clipPath;
        var oldOffsetPath = object.parsedStyle.offsetPath;
        object.parsedStyle = Object.assign(object.parsedStyle, attributes);
        var needUpdateGeometry_1 = !!options.forceUpdateGeometry;
        if (!needUpdateGeometry_1) {
          for (var i = 0; i < GEOMETRY_ATTRIBUTE_NAMES.length; i++) {
            if (GEOMETRY_ATTRIBUTE_NAMES[i] in attributes) {
              needUpdateGeometry_1 = true;
              break;
            }
          }
        }
        if (attributes.fill) {
          object.parsedStyle.fill = parseColor(attributes.fill);
        }
        if (attributes.stroke) {
          object.parsedStyle.stroke = parseColor(attributes.stroke);
        }
        if (attributes.shadowColor) {
          object.parsedStyle.shadowColor = parseColor(attributes.shadowColor);
        }
        if (attributes.filter) {
          object.parsedStyle.filter = parseFilter(attributes.filter);
        }
        if (!is_nil_default(attributes.radius)) {
          object.parsedStyle.radius = parseDimensionArrayFormat(
            // @ts-ignore
            attributes.radius,
            4
          );
        }
        if (!is_nil_default(attributes.lineDash)) {
          object.parsedStyle.lineDash = parseDimensionArrayFormat(attributes.lineDash, 2);
        }
        if (attributes.points) {
          object.parsedStyle.points = parsePoints(attributes.points, object);
        }
        if (attributes.path === "") {
          object.parsedStyle.path = __assign({}, EMPTY_PARSED_PATH);
        }
        if (attributes.path) {
          object.parsedStyle.path = parsePath(
            // @ts-ignore
            attributes.path
          );
          object.parsedStyle.defX = object.parsedStyle.path.rect.x;
          object.parsedStyle.defY = object.parsedStyle.path.rect.y;
        }
        if (attributes.textTransform) {
          this.runtime.CSSPropertySyntaxFactory["<text-transform>"].calculator(null, null, { value: attributes.textTransform }, object, null);
        }
        if (attributes.clipPath) {
          this.runtime.CSSPropertySyntaxFactory["<defined-path>"].calculator("clipPath", oldClipPath, attributes.clipPath, object, this.runtime);
        }
        if (attributes.offsetPath) {
          this.runtime.CSSPropertySyntaxFactory["<defined-path>"].calculator("offsetPath", oldOffsetPath, attributes.offsetPath, object, this.runtime);
        }
        if (attributes.anchor) {
          object.parsedStyle.anchor = parseDimensionArrayFormat(
            // @ts-ignorex
            attributes.anchor,
            2
          );
        }
        if (attributes.transform) {
          object.parsedStyle.transform = parseTransform(attributes.transform);
        }
        if (attributes.transformOrigin) {
          object.parsedStyle.transformOrigin = parseTransformOrigin(attributes.transformOrigin);
        }
        if (attributes.markerStart) {
          object.parsedStyle.markerStart = this.runtime.CSSPropertySyntaxFactory["<marker>"].calculator(
            null,
            // @ts-ignore
            attributes.markerStart,
            // @ts-ignore
            attributes.markerStart,
            null,
            null
          );
        }
        if (attributes.markerEnd) {
          object.parsedStyle.markerEnd = this.runtime.CSSPropertySyntaxFactory["<marker>"].calculator(
            null,
            // @ts-ignore
            attributes.markerEnd,
            // @ts-ignore
            attributes.markerEnd,
            null,
            null
          );
        }
        if (attributes.markerMid) {
          object.parsedStyle.markerMid = this.runtime.CSSPropertySyntaxFactory["<marker>"].calculator(
            "",
            // @ts-ignore
            attributes.markerMid,
            // @ts-ignore
            attributes.markerMid,
            null,
            null
          );
        }
        if (
          // Circle & Ellipse
          (object.nodeName === Shape.CIRCLE || object.nodeName === Shape.ELLIPSE) && // @ts-ignore
          (!is_nil_default(attributes.cx) || // @ts-ignore
          !is_nil_default(attributes.cy)) || (object.nodeName === Shape.RECT || object.nodeName === Shape.IMAGE || object.nodeName === Shape.GROUP || object.nodeName === Shape.HTML || object.nodeName === Shape.TEXT || object.nodeName === Shape.MESH) && // @ts-ignore
          (!is_nil_default(attributes.x) || // @ts-ignore
          !is_nil_default(attributes.y) || // @ts-ignore
          !is_nil_default(attributes.z)) || // Line
          object.nodeName === Shape.LINE && // @ts-ignore
          (!is_nil_default(attributes.x1) || // @ts-ignore
          !is_nil_default(attributes.y1) || // @ts-ignore
          !is_nil_default(attributes.z1) || // @ts-ignore
          !is_nil_default(attributes.x2) || // @ts-ignore
          !is_nil_default(attributes.y2) || // @ts-ignore
          !is_nil_default(attributes.z2))
        ) {
          this.runtime.CSSPropertySyntaxFactory["<coordinate>"].postProcessor(object, attributeNames_1);
        }
        if (!is_nil_default(attributes.zIndex)) {
          this.runtime.CSSPropertySyntaxFactory["<z-index>"].postProcessor(object, attributeNames_1);
        }
        if (attributes.path) {
          this.runtime.CSSPropertySyntaxFactory["<path>"].postProcessor(object, attributeNames_1);
        }
        if (attributes.points) {
          this.runtime.CSSPropertySyntaxFactory["<list-of-points>"].postProcessor(object, attributeNames_1);
        }
        if (!is_nil_default(attributes.offsetDistance)) {
          this.runtime.CSSPropertySyntaxFactory["<offset-distance>"].postProcessor(object, attributeNames_1);
        }
        if (attributes.transform) {
          this.runtime.CSSPropertySyntaxFactory["<transform>"].postProcessor(object, attributeNames_1);
        }
        if (needUpdateGeometry_1) {
          this.updateGeometry(object);
        }
        return;
      }
      var skipUpdateAttribute = options.skipUpdateAttribute, skipParse = options.skipParse, forceUpdateGeometry = options.forceUpdateGeometry, usedAttributes = options.usedAttributes;
      var needUpdateGeometry = forceUpdateGeometry;
      var attributeNames = Object.keys(attributes);
      attributeNames.forEach(function(attributeName) {
        var _a2;
        if (!skipUpdateAttribute) {
          object.attributes[attributeName] = attributes[attributeName];
        }
        if (!needUpdateGeometry && ((_a2 = propertyMetadataCache[attributeName]) === null || _a2 === void 0 ? void 0 : _a2.l)) {
          needUpdateGeometry = true;
        }
      });
      if (!skipParse) {
        attributeNames.forEach(function(name2) {
          object.computedStyle[name2] = _this2.parseProperty(name2, object.attributes[name2], object);
        });
      }
      if (usedAttributes === null || usedAttributes === void 0 ? void 0 : usedAttributes.length) {
        attributeNames = Array.from(new Set(attributeNames.concat(usedAttributes)));
      }
      attributeNames.forEach(function(name2) {
        if (name2 in object.computedStyle) {
          object.parsedStyle[name2] = _this2.computeProperty(name2, object.computedStyle[name2], object);
        }
      });
      if (needUpdateGeometry) {
        this.updateGeometry(object);
      }
      attributeNames.forEach(function(name2) {
        if (name2 in object.parsedStyle) {
          _this2.postProcessProperty(name2, object, attributeNames);
        }
      });
      if (this.runtime.enableCSSParsing && object.children.length) {
        attributeNames.forEach(function(name2) {
          if (name2 in object.parsedStyle && _this2.isPropertyInheritable(name2)) {
            object.children.forEach(function(child) {
              child.internalSetAttribute(name2, null, {
                skipUpdateAttribute: true,
                skipParse: true
              });
            });
          }
        });
      }
    };
    DefaultStyleValueRegistry2.prototype.parseProperty = function(name2, value2, object) {
      var metadata = propertyMetadataCache[name2];
      var computed = value2;
      if (value2 === "" || is_nil_default(value2)) {
        value2 = "unset";
      }
      if (value2 === "unset" || value2 === "initial" || value2 === "inherit") {
        computed = getOrCreateKeyword(value2);
      } else {
        if (metadata) {
          var keywords = metadata.k, syntax = metadata.syntax;
          var handler = syntax && this.getPropertySyntax(syntax);
          if (keywords && keywords.indexOf(value2) > -1) {
            computed = getOrCreateKeyword(value2);
          } else if (handler && handler.parser) {
            computed = handler.parser(value2, object);
          }
        }
      }
      return computed;
    };
    DefaultStyleValueRegistry2.prototype.computeProperty = function(name2, computed, object) {
      var metadata = propertyMetadataCache[name2];
      var isDocumentElement = object.id === "g-root";
      var used = computed;
      if (metadata) {
        var syntax = metadata.syntax, inherited = metadata.inh, defaultValue = metadata.d;
        if (computed instanceof CSSKeywordValue) {
          var value2 = computed.value;
          if (value2 === "unset") {
            if (inherited && !isDocumentElement) {
              value2 = "inherit";
            } else {
              value2 = "initial";
            }
          }
          if (value2 === "initial") {
            if (!is_nil_default(defaultValue)) {
              computed = this.parseProperty(name2, isFunction(defaultValue) ? defaultValue(object.nodeName) : defaultValue, object);
            }
          } else if (value2 === "inherit") {
            var resolved = this.tryToResolveProperty(object, name2, {
              inherited: true
            });
            if (!is_nil_default(resolved)) {
              return resolved;
            } else {
              this.addUnresolveProperty(object, name2);
              return;
            }
          }
        }
        var handler = syntax && this.getPropertySyntax(syntax);
        if (handler && handler.calculator) {
          var oldParsedValue = object.parsedStyle[name2];
          used = handler.calculator(name2, oldParsedValue, computed, object, this.runtime);
        } else if (computed instanceof CSSKeywordValue) {
          used = computed.value;
        } else {
          used = computed;
        }
      }
      return used;
    };
    DefaultStyleValueRegistry2.prototype.postProcessProperty = function(name2, object, attributes) {
      var metadata = propertyMetadataCache[name2];
      if (metadata && metadata.syntax) {
        var handler = metadata.syntax && this.getPropertySyntax(metadata.syntax);
        var propertyHandler = handler;
        if (propertyHandler && propertyHandler.postProcessor) {
          propertyHandler.postProcessor(object, attributes);
        }
      }
    };
    DefaultStyleValueRegistry2.prototype.addUnresolveProperty = function(object, name2) {
      var properties = unresolvedProperties.get(object);
      if (!properties) {
        unresolvedProperties.set(object, []);
        properties = unresolvedProperties.get(object);
      }
      if (properties.indexOf(name2) === -1) {
        properties.push(name2);
      }
    };
    DefaultStyleValueRegistry2.prototype.tryToResolveProperty = function(object, name2, options) {
      if (options === void 0) {
        options = {};
      }
      var inherited = options.inherited;
      if (inherited) {
        if (object.parentElement && isPropertyResolved(object.parentElement, name2)) {
          var usedValue = object.parentElement.parsedStyle[name2];
          if (
            // usedValue instanceof CSSKeywordValue &&
            usedValue === "unset" || usedValue === "initial" || usedValue === "inherit"
          ) {
            return;
          }
          return usedValue;
        }
      }
      return;
    };
    DefaultStyleValueRegistry2.prototype.recalc = function(object) {
      var properties = unresolvedProperties.get(object);
      if (properties && properties.length) {
        var attributes_1 = {};
        properties.forEach(function(property2) {
          attributes_1[property2] = object.attributes[property2];
        });
        this.processProperties(object, attributes_1);
        unresolvedProperties.delete(object);
      }
    };
    DefaultStyleValueRegistry2.prototype.updateGeometry = function(object) {
      var nodeName = object.nodeName;
      var geometryUpdater = this.runtime.geometryUpdaterFactory[nodeName];
      if (geometryUpdater) {
        var geometry_1 = object.geometry;
        if (!geometry_1.contentBounds) {
          geometry_1.contentBounds = new AABB();
        }
        if (!geometry_1.renderBounds) {
          geometry_1.renderBounds = new AABB();
        }
        var parsedStyle = object.parsedStyle;
        var _a2 = geometryUpdater.update(parsedStyle, object), width = _a2.width, height = _a2.height, _b = _a2.depth, depth = _b === void 0 ? 0 : _b, _c = _a2.offsetX, offsetX = _c === void 0 ? 0 : _c, _d = _a2.offsetY, offsetY = _d === void 0 ? 0 : _d, _e = _a2.offsetZ, offsetZ = _e === void 0 ? 0 : _e;
        var halfExtents = [
          Math.abs(width) / 2,
          Math.abs(height) / 2,
          depth / 2
        ];
        var _f = parsedStyle, stroke2 = _f.stroke, lineWidth = _f.lineWidth, increasedLineWidthForHitTesting = _f.increasedLineWidthForHitTesting, shadowType = _f.shadowType, shadowColor = _f.shadowColor, _g = _f.filter, filter4 = _g === void 0 ? [] : _g, transformOrigin = _f.transformOrigin;
        var anchor = parsedStyle.anchor;
        if (nodeName === Shape.TEXT) {
          delete parsedStyle.anchor;
        } else if (nodeName === Shape.MESH) {
          parsedStyle.anchor[2] = 0.5;
        }
        var center2 = [
          (1 - (anchor && anchor[0] || 0) * 2) * width / 2 + offsetX,
          (1 - (anchor && anchor[1] || 0) * 2) * height / 2 + offsetY,
          (1 - (anchor && anchor[2] || 0) * 2) * halfExtents[2] + offsetZ
        ];
        geometry_1.contentBounds.update(center2, halfExtents);
        var expansion = nodeName === Shape.POLYLINE || nodeName === Shape.POLYGON || nodeName === Shape.PATH ? Math.SQRT2 : 0.5;
        var hasStroke = stroke2 && !stroke2.isNone;
        if (hasStroke) {
          var halfLineWidth = ((lineWidth || 0) + (increasedLineWidthForHitTesting || 0)) * expansion;
          halfExtents[0] += halfLineWidth;
          halfExtents[1] += halfLineWidth;
        }
        geometry_1.renderBounds.update(center2, halfExtents);
        if (shadowColor && shadowType && shadowType !== "inner") {
          var _h = geometry_1.renderBounds, min11 = _h.min, max11 = _h.max;
          var _j = parsedStyle, shadowBlur = _j.shadowBlur, shadowOffsetX = _j.shadowOffsetX, shadowOffsetY = _j.shadowOffsetY;
          var shadowBlurInPixels = shadowBlur || 0;
          var shadowOffsetXInPixels = shadowOffsetX || 0;
          var shadowOffsetYInPixels = shadowOffsetY || 0;
          var shadowLeft = min11[0] - shadowBlurInPixels + shadowOffsetXInPixels;
          var shadowRight = max11[0] + shadowBlurInPixels + shadowOffsetXInPixels;
          var shadowTop = min11[1] - shadowBlurInPixels + shadowOffsetYInPixels;
          var shadowBottom = max11[1] + shadowBlurInPixels + shadowOffsetYInPixels;
          min11[0] = Math.min(min11[0], shadowLeft);
          max11[0] = Math.max(max11[0], shadowRight);
          min11[1] = Math.min(min11[1], shadowTop);
          max11[1] = Math.max(max11[1], shadowBottom);
          geometry_1.renderBounds.setMinMax(min11, max11);
        }
        filter4.forEach(function(_a3) {
          var name2 = _a3.name, params = _a3.params;
          if (name2 === "blur") {
            var blurRadius = params[0].value;
            geometry_1.renderBounds.update(geometry_1.renderBounds.center, addVec3(geometry_1.renderBounds.halfExtents, geometry_1.renderBounds.halfExtents, [blurRadius, blurRadius, 0]));
          } else if (name2 === "drop-shadow") {
            var shadowOffsetX2 = params[0].value;
            var shadowOffsetY2 = params[1].value;
            var shadowBlur2 = params[2].value;
            var _b2 = geometry_1.renderBounds, min12 = _b2.min, max12 = _b2.max;
            var shadowLeft2 = min12[0] - shadowBlur2 + shadowOffsetX2;
            var shadowRight2 = max12[0] + shadowBlur2 + shadowOffsetX2;
            var shadowTop2 = min12[1] - shadowBlur2 + shadowOffsetY2;
            var shadowBottom2 = max12[1] + shadowBlur2 + shadowOffsetY2;
            min12[0] = Math.min(min12[0], shadowLeft2);
            max12[0] = Math.max(max12[0], shadowRight2);
            min12[1] = Math.min(min12[1], shadowTop2);
            max12[1] = Math.max(max12[1], shadowBottom2);
            geometry_1.renderBounds.setMinMax(min12, max12);
          }
        });
        anchor = parsedStyle.anchor;
        var flipY = width < 0;
        var flipX = height < 0;
        var usedOriginXValue = (flipY ? -1 : 1) * (transformOrigin ? convertPercentUnit(transformOrigin[0], 0, object) : 0);
        var usedOriginYValue = (flipX ? -1 : 1) * (transformOrigin ? convertPercentUnit(transformOrigin[1], 1, object) : 0);
        usedOriginXValue = usedOriginXValue - (flipY ? -1 : 1) * (anchor && anchor[0] || 0) * geometry_1.contentBounds.halfExtents[0] * 2;
        usedOriginYValue = usedOriginYValue - (flipX ? -1 : 1) * (anchor && anchor[1] || 0) * geometry_1.contentBounds.halfExtents[1] * 2;
        object.setOrigin(usedOriginXValue, usedOriginYValue);
        this.runtime.sceneGraphService.dirtifyToRoot(object);
      }
    };
    DefaultStyleValueRegistry2.prototype.isPropertyInheritable = function(name2) {
      var metadata = propertyMetadataCache[name2];
      if (!metadata) {
        return false;
      }
      return metadata.inh;
    };
    return DefaultStyleValueRegistry2;
  }()
);
var CSSPropertyAngle = (
  /** @class */
  function() {
    function CSSPropertyAngle2() {
      this.parser = parseAngle;
      this.parserWithCSSDisabled = null;
      this.mixer = mergeNumbers;
    }
    CSSPropertyAngle2.prototype.calculator = function(name2, oldParsed, parsed, object) {
      return convertAngleUnit(parsed);
    };
    return CSSPropertyAngle2;
  }()
);
var CSSPropertyClipPath = (
  /** @class */
  function() {
    function CSSPropertyClipPath2() {
    }
    CSSPropertyClipPath2.prototype.calculator = function(name2, oldPath, newPath, object, runtime2) {
      if (newPath instanceof CSSKeywordValue) {
        newPath = null;
      }
      runtime2.sceneGraphService.updateDisplayObjectDependency(name2, oldPath, newPath, object);
      if (name2 === "clipPath") {
        object.forEach(function(leaf) {
          if (leaf.childNodes.length === 0) {
            runtime2.sceneGraphService.dirtifyToRoot(leaf);
          }
        });
      }
      return newPath;
    };
    return CSSPropertyClipPath2;
  }()
);
var CSSPropertyColor = (
  /** @class */
  function() {
    function CSSPropertyColor2() {
      this.parser = parseColor;
      this.parserWithCSSDisabled = parseColor;
      this.mixer = mergeColors;
    }
    CSSPropertyColor2.prototype.calculator = function(name2, oldParsed, parsed, object) {
      if (parsed instanceof CSSKeywordValue) {
        return parsed.value === "none" ? noneColor : transparentColor;
      }
      return parsed;
    };
    return CSSPropertyColor2;
  }()
);
var CSSPropertyFilter = (
  /** @class */
  function() {
    function CSSPropertyFilter2() {
      this.parser = parseFilter;
    }
    CSSPropertyFilter2.prototype.calculator = function(name2, oldParsed, parsed) {
      if (parsed instanceof CSSKeywordValue) {
        return [];
      }
      return parsed;
    };
    return CSSPropertyFilter2;
  }()
);
function getFontSize(object) {
  var fontSize = object.parsedStyle.fontSize;
  return is_nil_default(fontSize) ? null : fontSize;
}
var CSSPropertyLengthOrPercentage = (
  /** @class */
  function() {
    function CSSPropertyLengthOrPercentage2() {
      this.parser = parseLengthOrPercentage;
      this.parserWithCSSDisabled = null;
      this.mixer = mergeNumbers;
    }
    CSSPropertyLengthOrPercentage2.prototype.calculator = function(name2, oldParsed, computed, object, runtime2) {
      var _a2;
      if (is_number_default(computed)) {
        return computed;
      }
      if (CSSUnitValue.isRelativeUnit(computed.unit)) {
        var registry = runtime2.styleValueRegistry;
        if (computed.unit === UnitType.kPercentage) {
          return 0;
        } else if (computed.unit === UnitType.kEms) {
          if (object.parentNode) {
            var fontSize = getFontSize(object.parentNode);
            if (fontSize) {
              fontSize *= computed.value;
              return fontSize;
            } else {
              registry.addUnresolveProperty(object, name2);
            }
          } else {
            registry.addUnresolveProperty(object, name2);
          }
          return 0;
        } else if (computed.unit === UnitType.kRems) {
          if ((_a2 = object === null || object === void 0 ? void 0 : object.ownerDocument) === null || _a2 === void 0 ? void 0 : _a2.documentElement) {
            var fontSize = getFontSize(object.ownerDocument.documentElement);
            if (fontSize) {
              fontSize *= computed.value;
              return fontSize;
            } else {
              registry.addUnresolveProperty(object, name2);
            }
          } else {
            registry.addUnresolveProperty(object, name2);
          }
          return 0;
        }
      } else {
        return computed.value;
      }
    };
    return CSSPropertyLengthOrPercentage2;
  }()
);
var CSSPropertyLengthOrPercentage12 = (
  /** @class */
  function() {
    function CSSPropertyLengthOrPercentage122() {
      this.mixer = mergeNumberLists;
    }
    CSSPropertyLengthOrPercentage122.prototype.parser = function(radius) {
      var parsed = parseDimensionArray(is_number_default(radius) ? [radius] : radius);
      var formatted;
      if (parsed.length === 1) {
        formatted = [parsed[0], parsed[0]];
      } else {
        formatted = [parsed[0], parsed[1]];
      }
      return formatted;
    };
    CSSPropertyLengthOrPercentage122.prototype.calculator = function(name2, oldParsed, computed) {
      return computed.map(function(c5) {
        return c5.value;
      });
    };
    return CSSPropertyLengthOrPercentage122;
  }()
);
var CSSPropertyLengthOrPercentage14 = (
  /** @class */
  function() {
    function CSSPropertyLengthOrPercentage142() {
      this.mixer = mergeNumberLists;
    }
    CSSPropertyLengthOrPercentage142.prototype.parser = function(radius) {
      var parsed = parseDimensionArray(is_number_default(radius) ? [radius] : radius);
      var formatted;
      if (parsed.length === 1) {
        formatted = [parsed[0], parsed[0], parsed[0], parsed[0]];
      } else if (parsed.length === 2) {
        formatted = [parsed[0], parsed[1], parsed[0], parsed[1]];
      } else if (parsed.length === 3) {
        formatted = [parsed[0], parsed[1], parsed[2], parsed[1]];
      } else {
        formatted = [parsed[0], parsed[1], parsed[2], parsed[3]];
      }
      return formatted;
    };
    CSSPropertyLengthOrPercentage142.prototype.calculator = function(name2, oldParsed, computed) {
      return computed.map(function(c5) {
        return c5.value;
      });
    };
    return CSSPropertyLengthOrPercentage142;
  }()
);
var tmpMat4 = mat4_exports.create();
function parsedTransformToMat4(transform3, object) {
  var defX = object.parsedStyle.defX || 0;
  var defY = object.parsedStyle.defY || 0;
  object.resetLocalTransform();
  object.setLocalPosition(defX, defY);
  transform3.forEach(function(parsed) {
    var t = parsed.t, d2 = parsed.d;
    if (t === "scale") {
      var newScale = (d2 === null || d2 === void 0 ? void 0 : d2.map(function(s2) {
        return s2.value;
      })) || [1, 1];
      object.scaleLocal(newScale[0], newScale[1], 1);
    } else if (t === "scalex") {
      var newScale = (d2 === null || d2 === void 0 ? void 0 : d2.map(function(s2) {
        return s2.value;
      })) || [1];
      object.scaleLocal(newScale[0], 1, 1);
    } else if (t === "scaley") {
      var newScale = (d2 === null || d2 === void 0 ? void 0 : d2.map(function(s2) {
        return s2.value;
      })) || [1];
      object.scaleLocal(1, newScale[0], 1);
    } else if (t === "scalez") {
      var newScale = (d2 === null || d2 === void 0 ? void 0 : d2.map(function(s2) {
        return s2.value;
      })) || [1];
      object.scaleLocal(1, 1, newScale[0]);
    } else if (t === "scale3d") {
      var newScale = (d2 === null || d2 === void 0 ? void 0 : d2.map(function(s2) {
        return s2.value;
      })) || [1, 1, 1];
      object.scaleLocal(newScale[0], newScale[1], newScale[2]);
    } else if (t === "translate") {
      var newTranslation = d2 || [Opx, Opx];
      object.translateLocal(newTranslation[0].value, newTranslation[1].value, 0);
    } else if (t === "translatex") {
      var newTranslation = d2 || [Opx];
      object.translateLocal(newTranslation[0].value, 0, 0);
    } else if (t === "translatey") {
      var newTranslation = d2 || [Opx];
      object.translateLocal(0, newTranslation[0].value, 0);
    } else if (t === "translatez") {
      var newTranslation = d2 || [Opx];
      object.translateLocal(0, 0, newTranslation[0].value);
    } else if (t === "translate3d") {
      var newTranslation = d2 || [Opx, Opx, Opx];
      object.translateLocal(newTranslation[0].value, newTranslation[1].value, newTranslation[2].value);
    } else if (t === "rotate") {
      var newAngles = d2 || [Odeg];
      object.rotateLocal(0, 0, convertAngleUnit(newAngles[0]));
    } else if (t === "rotatex") {
      var newAngles = d2 || [Odeg];
      object.rotateLocal(convertAngleUnit(newAngles[0]), 0, 0);
    } else if (t === "rotatey") {
      var newAngles = d2 || [Odeg];
      object.rotateLocal(0, convertAngleUnit(newAngles[0]), 0);
    } else if (t === "rotatez") {
      var newAngles = d2 || [Odeg];
      object.rotateLocal(0, 0, convertAngleUnit(newAngles[0]));
    } else if (t === "rotate3d")
      ;
    else if (t === "skew") {
      var newSkew = (d2 === null || d2 === void 0 ? void 0 : d2.map(function(s2) {
        return s2.value;
      })) || [0, 0];
      object.setLocalSkew(deg2rad2(newSkew[0]), deg2rad2(newSkew[1]));
    } else if (t === "skewx") {
      var newSkew = (d2 === null || d2 === void 0 ? void 0 : d2.map(function(s2) {
        return s2.value;
      })) || [0];
      object.setLocalSkew(deg2rad2(newSkew[0]), object.getLocalSkew()[1]);
    } else if (t === "skewy") {
      var newSkew = (d2 === null || d2 === void 0 ? void 0 : d2.map(function(s2) {
        return s2.value;
      })) || [0];
      object.setLocalSkew(object.getLocalSkew()[0], deg2rad2(newSkew[0]));
    } else if (t === "matrix") {
      var _a2 = __read(d2.map(function(s2) {
        return s2.value;
      }), 6), a4 = _a2[0], b = _a2[1], c5 = _a2[2], dd = _a2[3], tx = _a2[4], ty = _a2[5];
      object.setLocalTransform(mat4_exports.set(tmpMat4, a4, b, 0, 0, c5, dd, 0, 0, 0, 0, 1, 0, tx + defX, ty + defY, 0, 1));
    } else if (t === "matrix3d") {
      mat4_exports.set.apply(mat4_exports, __spreadArray([tmpMat4], __read(d2.map(function(s2) {
        return s2.value;
      })), false));
      tmpMat4[12] += defX;
      tmpMat4[13] += defY;
      object.setLocalTransform(tmpMat4);
    }
  });
  return object.getLocalTransform();
}
var CSSPropertyLocalPosition = (
  /** @class */
  function(_super) {
    __extends(CSSPropertyLocalPosition2, _super);
    function CSSPropertyLocalPosition2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    CSSPropertyLocalPosition2.prototype.postProcessor = function(object, attributes) {
      var x3;
      var y3;
      var z;
      switch (object.nodeName) {
        case Shape.CIRCLE:
        case Shape.ELLIPSE:
          var _a2 = object.parsedStyle, cx = _a2.cx, cy = _a2.cy, cz = _a2.cz;
          if (!is_nil_default(cx)) {
            x3 = cx;
          }
          if (!is_nil_default(cy)) {
            y3 = cy;
          }
          if (!is_nil_default(cz)) {
            z = cz;
          }
          break;
        case Shape.LINE:
          var _b = object.parsedStyle, x12 = _b.x1, x22 = _b.x2, y12 = _b.y1, y22 = _b.y2;
          var minX = Math.min(x12, x22);
          var minY = Math.min(y12, y22);
          x3 = minX;
          y3 = minY;
          z = 0;
          break;
        case Shape.RECT:
        case Shape.IMAGE:
        case Shape.GROUP:
        case Shape.HTML:
        case Shape.TEXT:
        case Shape.MESH:
          if (!is_nil_default(object.parsedStyle.x)) {
            x3 = object.parsedStyle.x;
          }
          if (!is_nil_default(object.parsedStyle.y)) {
            y3 = object.parsedStyle.y;
          }
          if (!is_nil_default(object.parsedStyle.z)) {
            z = object.parsedStyle.z;
          }
          break;
      }
      if (object.nodeName !== Shape.PATH && object.nodeName !== Shape.POLYLINE && object.nodeName !== Shape.POLYGON) {
        object.parsedStyle.defX = x3 || 0;
        object.parsedStyle.defY = y3 || 0;
      }
      var needResetLocalPosition = !is_nil_default(x3) || !is_nil_default(y3) || !is_nil_default(z);
      if (needResetLocalPosition && attributes.indexOf("transform") === -1) {
        var transform3 = object.parsedStyle.transform;
        if (transform3 && transform3.length) {
          parsedTransformToMat4(transform3, object);
        } else {
          var _c = __read(object.getLocalPosition(), 3), ox = _c[0], oy = _c[1], oz = _c[2];
          object.setLocalPosition(is_nil_default(x3) ? ox : x3, is_nil_default(y3) ? oy : y3, is_nil_default(z) ? oz : z);
        }
      }
    };
    return CSSPropertyLocalPosition2;
  }(CSSPropertyLengthOrPercentage)
);
var CSSPropertyMarker = (
  /** @class */
  function() {
    function CSSPropertyMarker2() {
    }
    CSSPropertyMarker2.prototype.calculator = function(name2, oldMarker, newMarker, object) {
      if (newMarker instanceof CSSKeywordValue) {
        newMarker = null;
      }
      var cloned = newMarker === null || newMarker === void 0 ? void 0 : newMarker.cloneNode(true);
      if (cloned) {
        cloned.style.isMarker = true;
      }
      return cloned;
    };
    return CSSPropertyMarker2;
  }()
);
var CSSPropertyNumber = (
  /** @class */
  function() {
    function CSSPropertyNumber2() {
      this.mixer = mergeNumbers;
      this.parser = parseNumber;
      this.parserWithCSSDisabled = null;
    }
    CSSPropertyNumber2.prototype.calculator = function(name2, oldParsed, computed) {
      return computed.value;
    };
    return CSSPropertyNumber2;
  }()
);
var CSSPropertyOffsetDistance = (
  /** @class */
  function() {
    function CSSPropertyOffsetDistance2() {
      this.parser = parseNumber;
      this.parserWithCSSDisabled = null;
      this.mixer = clampedMergeNumbers(0, 1);
    }
    CSSPropertyOffsetDistance2.prototype.calculator = function(name2, oldParsed, computed) {
      return computed.value;
    };
    CSSPropertyOffsetDistance2.prototype.postProcessor = function(object) {
      var _a2 = object.parsedStyle, offsetPath = _a2.offsetPath, offsetDistance = _a2.offsetDistance;
      if (!offsetPath) {
        return;
      }
      var nodeName = offsetPath.nodeName;
      if (nodeName === Shape.LINE || nodeName === Shape.PATH || nodeName === Shape.POLYLINE) {
        var point7 = offsetPath.getPoint(offsetDistance);
        if (point7) {
          object.parsedStyle.defX = point7.x;
          object.parsedStyle.defY = point7.y;
          object.setLocalPosition(point7.x, point7.y);
        }
      }
    };
    return CSSPropertyOffsetDistance2;
  }()
);
var CSSPropertyOpacity = (
  /** @class */
  function() {
    function CSSPropertyOpacity2() {
      this.parser = parseNumber;
      this.parserWithCSSDisabled = null;
      this.mixer = clampedMergeNumbers(0, 1);
    }
    CSSPropertyOpacity2.prototype.calculator = function(name2, oldParsed, computed) {
      return computed.value;
    };
    return CSSPropertyOpacity2;
  }()
);
var CSSPropertyPath = (
  /** @class */
  function() {
    function CSSPropertyPath2() {
      this.parser = parsePath;
      this.parserWithCSSDisabled = parsePath;
      this.mixer = mergePaths;
    }
    CSSPropertyPath2.prototype.calculator = function(name2, oldParsed, parsed) {
      if (parsed instanceof CSSKeywordValue && parsed.value === "unset") {
        return {
          absolutePath: [],
          hasArc: false,
          segments: [],
          polygons: [],
          polylines: [],
          curve: null,
          totalLength: 0,
          rect: new Rectangle(0, 0, 0, 0)
        };
      }
      return parsed;
    };
    CSSPropertyPath2.prototype.postProcessor = function(object, attributes) {
      object.parsedStyle.defX = object.parsedStyle.path.rect.x;
      object.parsedStyle.defY = object.parsedStyle.path.rect.y;
      if (object.nodeName === Shape.PATH && attributes.indexOf("transform") === -1) {
        var _a2 = object.parsedStyle, _b = _a2.defX, defX = _b === void 0 ? 0 : _b, _c = _a2.defY, defY = _c === void 0 ? 0 : _c;
        object.setLocalPosition(defX, defY);
      }
    };
    return CSSPropertyPath2;
  }()
);
var CSSPropertyPoints = (
  /** @class */
  function() {
    function CSSPropertyPoints2() {
      this.parser = parsePoints;
      this.mixer = mergePoints;
    }
    CSSPropertyPoints2.prototype.postProcessor = function(object, attributes) {
      if ((object.nodeName === Shape.POLYGON || object.nodeName === Shape.POLYLINE) && attributes.indexOf("transform") === -1) {
        var _a2 = object.parsedStyle, defX = _a2.defX, defY = _a2.defY;
        object.setLocalPosition(defX, defY);
      }
    };
    return CSSPropertyPoints2;
  }()
);
var CSSPropertyShadowBlur = (
  /** @class */
  function(_super) {
    __extends(CSSPropertyShadowBlur2, _super);
    function CSSPropertyShadowBlur2() {
      var _this2 = _super.apply(this, __spreadArray([], __read(arguments), false)) || this;
      _this2.mixer = clampedMergeNumbers(0, Infinity);
      return _this2;
    }
    return CSSPropertyShadowBlur2;
  }(CSSPropertyLengthOrPercentage)
);
var CSSPropertyText = (
  /** @class */
  function() {
    function CSSPropertyText2() {
    }
    CSSPropertyText2.prototype.calculator = function(name2, oldParsed, parsed, object) {
      if (parsed instanceof CSSKeywordValue) {
        if (parsed.value === "unset") {
          return "";
        } else {
          return parsed.value;
        }
      }
      return "".concat(parsed);
    };
    CSSPropertyText2.prototype.postProcessor = function(object) {
      object.nodeValue = "".concat(object.parsedStyle.text) || "";
    };
    return CSSPropertyText2;
  }()
);
var CSSPropertyTextTransform = (
  /** @class */
  function() {
    function CSSPropertyTextTransform2() {
    }
    CSSPropertyTextTransform2.prototype.calculator = function(name2, oldParsed, parsed, object) {
      var rawText = object.getAttribute("text");
      if (rawText) {
        var transformedText = rawText;
        if (parsed.value === "capitalize") {
          transformedText = rawText.charAt(0).toUpperCase() + rawText.slice(1);
        } else if (parsed.value === "lowercase") {
          transformedText = rawText.toLowerCase();
        } else if (parsed.value === "uppercase") {
          transformedText = rawText.toUpperCase();
        }
        object.parsedStyle.text = transformedText;
      }
      return parsed.value;
    };
    return CSSPropertyTextTransform2;
  }()
);
var canvasMap = {};
var defaultCanvasIdCounter = 0;
function cleanExistedCanvas(container, canvas) {
  if (container) {
    var id3 = typeof container === "string" ? container : container.id || defaultCanvasIdCounter++;
    if (canvasMap[id3]) {
      canvasMap[id3].destroy();
    }
    canvasMap[id3] = canvas;
  }
}
var isBrowser = typeof window !== "undefined" && typeof window.document !== "undefined";
function isElement2(target) {
  return !!target.getAttribute;
}
function sortedIndex(array2, value2) {
  var low = 0;
  var high = array2.length;
  while (low < high) {
    var mid2 = low + high >>> 1;
    if (sortByZIndex(array2[mid2], value2) < 0) {
      low = mid2 + 1;
    } else {
      high = mid2;
    }
  }
  return low;
}
function sortByZIndex(o1, o2) {
  var zIndex1 = Number(o1.parsedStyle.zIndex);
  var zIndex2 = Number(o2.parsedStyle.zIndex);
  if (zIndex1 === zIndex2) {
    var parent_1 = o1.parentNode;
    if (parent_1) {
      var children = parent_1.childNodes || [];
      return children.indexOf(o1) - children.indexOf(o2);
    }
  }
  return zIndex1 - zIndex2;
}
function findClosestClipPathTarget(object) {
  var _a2;
  var el = object;
  do {
    var clipPath = (_a2 = el.parsedStyle) === null || _a2 === void 0 ? void 0 : _a2.clipPath;
    if (clipPath)
      return el;
    el = el.parentElement;
  } while (el !== null);
  return null;
}
var PX_SUFFIX = "px";
function setDOMSize($el, width, height) {
  if (isBrowser && $el.style) {
    $el.style.width = width + PX_SUFFIX;
    $el.style.height = height + PX_SUFFIX;
  }
}
function getStyle($el, property2) {
  if (isBrowser) {
    return document.defaultView.getComputedStyle($el, null).getPropertyValue(property2);
  }
}
function getWidth($el) {
  var width = getStyle($el, "width");
  if (width === "auto") {
    return $el.offsetWidth;
  }
  return parseFloat(width);
}
function getHeight($el) {
  var height = getStyle($el, "height");
  if (height === "auto") {
    return $el.offsetHeight;
  }
  return parseFloat(height);
}
var MOUSE_POINTER_ID = 1;
var TOUCH_TO_POINTER = {
  touchstart: "pointerdown",
  touchend: "pointerup",
  touchendoutside: "pointerupoutside",
  touchmove: "pointermove",
  touchcancel: "pointercancel"
};
var clock = typeof performance === "object" && performance.now ? performance : Date;
function isFillOrStrokeAffected(pointerEvents, fill2, stroke2) {
  var hasFill = false;
  var hasStroke = false;
  var isFillOtherThanNone = !!fill2 && !fill2.isNone;
  var isStrokeOtherThanNone = !!stroke2 && !stroke2.isNone;
  if (pointerEvents === "visiblepainted" || pointerEvents === "painted" || pointerEvents === "auto") {
    hasFill = isFillOtherThanNone;
    hasStroke = isStrokeOtherThanNone;
  } else if (pointerEvents === "visiblefill" || pointerEvents === "fill") {
    hasFill = true;
  } else if (pointerEvents === "visiblestroke" || pointerEvents === "stroke") {
    hasStroke = true;
  } else if (pointerEvents === "visible" || pointerEvents === "all") {
    hasFill = true;
    hasStroke = true;
  }
  return [hasFill, hasStroke];
}
var uId = 1;
var uniqueId = function() {
  return uId++;
};
var root = typeof self === "object" && self.self == self ? self : (
  // @ts-ignore
  typeof global === "object" && global.global == global ? (
    // @ts-ignore
    global
  ) : {}
);
var nowOffset = Date.now();
var pnow = function() {
  if (root.performance && typeof root.performance.now === "function") {
    return root.performance.now();
  }
  return Date.now() - nowOffset;
};
var reservedCBs = {};
var lastTime = Date.now();
var polyfillRaf = function(callback) {
  if (typeof callback !== "function") {
    throw new TypeError(callback + " is not a function");
  }
  var currentTime = Date.now();
  var gap = currentTime - lastTime;
  var delay2 = gap > 16 ? 0 : 16 - gap;
  var id3 = uniqueId();
  reservedCBs[id3] = callback;
  if (Object.keys(reservedCBs).length > 1)
    return id3;
  setTimeout(function() {
    lastTime = currentTime;
    var copied = reservedCBs;
    reservedCBs = {};
    Object.keys(copied).forEach(function(key) {
      return copied[key](pnow());
    });
  }, delay2);
  return id3;
};
var polyfillCaf = function(id3) {
  delete reservedCBs[id3];
};
var vendorPrefixes = ["", "webkit", "moz", "ms", "o"];
var getRequestAnimationFrame = function(vp2) {
  if (typeof vp2 !== "string")
    return polyfillRaf;
  if (vp2 === "")
    return root["requestAnimationFrame"];
  return root[vp2 + "RequestAnimationFrame"];
};
var getCancelAnimationFrame = function(vp2) {
  if (typeof vp2 !== "string")
    return polyfillCaf;
  if (vp2 === "")
    return root["cancelAnimationFrame"];
  return root[vp2 + "CancelAnimationFrame"] || root[vp2 + "CancelRequestAnimationFrame"];
};
var find = function(arr, predicate) {
  var i = 0;
  while (arr[i] !== void 0) {
    if (predicate(arr[i]))
      return arr[i];
    i = i + 1;
  }
};
var vp = find(vendorPrefixes, function(vp2) {
  return !!getRequestAnimationFrame(vp2);
});
var raf = getRequestAnimationFrame(vp);
var caf = getCancelAnimationFrame(vp);
root.requestAnimationFrame = raf;
root.cancelAnimationFrame = caf;
var AsyncParallelHook = (
  /** @class */
  function() {
    function AsyncParallelHook2() {
      this.callbacks = [];
    }
    AsyncParallelHook2.prototype.getCallbacksNum = function() {
      return this.callbacks.length;
    };
    AsyncParallelHook2.prototype.tapPromise = function(options, fn) {
      this.callbacks.push(fn);
    };
    AsyncParallelHook2.prototype.promise = function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      return Promise.all(this.callbacks.map(function(callback) {
        return callback.apply(void 0, __spreadArray([], __read(args), false));
      }));
    };
    return AsyncParallelHook2;
  }()
);
var AsyncSeriesWaterfallHook = (
  /** @class */
  function() {
    function AsyncSeriesWaterfallHook2() {
      this.callbacks = [];
    }
    AsyncSeriesWaterfallHook2.prototype.tapPromise = function(options, fn) {
      this.callbacks.push(fn);
    };
    AsyncSeriesWaterfallHook2.prototype.promise = function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      return __awaiter(this, void 0, void 0, function() {
        var result2, i, callback;
        var _a2;
        return __generator(this, function(_b) {
          switch (_b.label) {
            case 0:
              if (!this.callbacks.length)
                return [3, 6];
              return [4, (_a2 = this.callbacks)[0].apply(_a2, __spreadArray([], __read(args), false))];
            case 1:
              result2 = _b.sent();
              i = 0;
              _b.label = 2;
            case 2:
              if (!(i < this.callbacks.length - 1))
                return [3, 5];
              callback = this.callbacks[i];
              return [4, callback(result2)];
            case 3:
              result2 = _b.sent();
              _b.label = 4;
            case 4:
              i++;
              return [3, 2];
            case 5:
              return [2, result2];
            case 6:
              return [2, null];
          }
        });
      });
    };
    return AsyncSeriesWaterfallHook2;
  }()
);
var SyncHook = (
  /** @class */
  function() {
    function SyncHook2() {
      this.callbacks = [];
    }
    SyncHook2.prototype.tap = function(options, fn) {
      this.callbacks.push(fn);
    };
    SyncHook2.prototype.call = function() {
      var argsArr = arguments;
      this.callbacks.forEach(function(callback) {
        callback.apply(void 0, argsArr);
      });
    };
    return SyncHook2;
  }()
);
var SyncWaterfallHook = (
  /** @class */
  function() {
    function SyncWaterfallHook2() {
      this.callbacks = [];
    }
    SyncWaterfallHook2.prototype.tap = function(options, fn) {
      this.callbacks.push(fn);
    };
    SyncWaterfallHook2.prototype.call = function() {
      if (this.callbacks.length) {
        var argsArr = arguments;
        var result2 = this.callbacks[0].apply(void 0, argsArr);
        for (var i = 0; i < this.callbacks.length - 1; i++) {
          var callback = this.callbacks[i];
          result2 = callback(result2);
        }
        return result2;
      }
      return null;
    };
    return SyncWaterfallHook2;
  }()
);
var genericFontFamilies = [
  "serif",
  "sans-serif",
  "monospace",
  "cursive",
  "fantasy",
  "system-ui"
];
var stringRegExp = /([\"\'])[^\'\"]+\1/;
function toFontString(attributes) {
  var fontSize = attributes.fontSize, fontFamily = attributes.fontFamily, fontStyle = attributes.fontStyle, fontVariant = attributes.fontVariant, fontWeight = attributes.fontWeight;
  var fontSizeString = is_number_default(fontSize) && "".concat(fontSize, "px") || "16px";
  var fontFamilies = fontFamily.split(",");
  for (var i = fontFamilies.length - 1; i >= 0; i--) {
    var fontFamily_1 = fontFamilies[i].trim();
    if (!stringRegExp.test(fontFamily_1) && genericFontFamilies.indexOf(fontFamily_1) < 0) {
      fontFamily_1 = '"'.concat(fontFamily_1, '"');
    }
    fontFamilies[i] = fontFamily_1;
  }
  return "".concat(fontStyle, " ").concat(fontVariant, " ").concat(fontWeight, " ").concat(fontSizeString, " ").concat(fontFamilies.join(","));
}
var CSSPropertyTransform = (
  /** @class */
  function() {
    function CSSPropertyTransform2() {
      this.parser = parseTransform;
      this.parserWithCSSDisabled = parseTransform;
      this.mixer = mergeTransforms;
    }
    CSSPropertyTransform2.prototype.calculator = function(name2, oldParsed, parsed, object) {
      if (parsed instanceof CSSKeywordValue) {
        return [];
      }
      return parsed;
    };
    CSSPropertyTransform2.prototype.postProcessor = function(object) {
      var transform3 = object.parsedStyle.transform;
      parsedTransformToMat4(transform3, object);
    };
    return CSSPropertyTransform2;
  }()
);
var CSSPropertyTransformOrigin = (
  /** @class */
  function() {
    function CSSPropertyTransformOrigin2() {
      this.parser = parseTransformOrigin;
    }
    return CSSPropertyTransformOrigin2;
  }()
);
var CSSPropertyZIndex = (
  /** @class */
  function() {
    function CSSPropertyZIndex2() {
      this.parser = parseNumber;
    }
    CSSPropertyZIndex2.prototype.calculator = function(name2, oldParsed, computed, object) {
      return computed.value;
    };
    CSSPropertyZIndex2.prototype.postProcessor = function(object) {
      if (object.parentNode) {
        var parentEntity = object.parentNode;
        var parentRenderable = parentEntity.renderable;
        var parentSortable = parentEntity.sortable;
        if (parentRenderable) {
          parentRenderable.dirty = true;
        }
        if (parentSortable) {
          parentSortable.dirty = true;
          parentSortable.dirtyReason = SortReason.Z_INDEX_CHANGED;
        }
      }
    };
    return CSSPropertyZIndex2;
  }()
);
var CircleUpdater = (
  /** @class */
  function() {
    function CircleUpdater2() {
    }
    CircleUpdater2.prototype.update = function(parsedStyle, object) {
      var r = parsedStyle.r;
      var width = r * 2;
      var height = r * 2;
      return {
        width,
        height
      };
    };
    return CircleUpdater2;
  }()
);
var EllipseUpdater = (
  /** @class */
  function() {
    function EllipseUpdater2() {
    }
    EllipseUpdater2.prototype.update = function(parsedStyle, object) {
      var rx = parsedStyle.rx, ry = parsedStyle.ry;
      var width = rx * 2;
      var height = ry * 2;
      return {
        width,
        height
      };
    };
    return EllipseUpdater2;
  }()
);
var LineUpdater = (
  /** @class */
  function() {
    function LineUpdater2() {
    }
    LineUpdater2.prototype.update = function(parsedStyle) {
      var x12 = parsedStyle.x1, y12 = parsedStyle.y1, x22 = parsedStyle.x2, y22 = parsedStyle.y2;
      var minX = Math.min(x12, x22);
      var maxX = Math.max(x12, x22);
      var minY = Math.min(y12, y22);
      var maxY2 = Math.max(y12, y22);
      var width = maxX - minX;
      var height = maxY2 - minY;
      return {
        width,
        height
      };
    };
    return LineUpdater2;
  }()
);
var PathUpdater = (
  /** @class */
  function() {
    function PathUpdater2() {
    }
    PathUpdater2.prototype.update = function(parsedStyle) {
      var path2 = parsedStyle.path;
      var _a2 = path2.rect, width = _a2.width, height = _a2.height;
      return {
        width,
        height
      };
    };
    return PathUpdater2;
  }()
);
var PolylineUpdater = (
  /** @class */
  function() {
    function PolylineUpdater2() {
    }
    PolylineUpdater2.prototype.update = function(parsedStyle) {
      if (parsedStyle.points && is_array_default(parsedStyle.points.points)) {
        var points = parsedStyle.points.points;
        var minX = Math.min.apply(Math, __spreadArray([], __read(points.map(function(point7) {
          return point7[0];
        })), false));
        var maxX = Math.max.apply(Math, __spreadArray([], __read(points.map(function(point7) {
          return point7[0];
        })), false));
        var minY = Math.min.apply(Math, __spreadArray([], __read(points.map(function(point7) {
          return point7[1];
        })), false));
        var maxY2 = Math.max.apply(Math, __spreadArray([], __read(points.map(function(point7) {
          return point7[1];
        })), false));
        var width = maxX - minX;
        var height = maxY2 - minY;
        return {
          width,
          height
        };
      }
      return {
        width: 0,
        height: 0
      };
    };
    return PolylineUpdater2;
  }()
);
var RectUpdater = (
  /** @class */
  function() {
    function RectUpdater2() {
    }
    RectUpdater2.prototype.update = function(parsedStyle, object) {
      var img = parsedStyle.img, _a2 = parsedStyle.width, width = _a2 === void 0 ? 0 : _a2, _b = parsedStyle.height, height = _b === void 0 ? 0 : _b;
      var contentWidth = width;
      var contentHeight = height;
      if (img && !is_string_default(img)) {
        if (!contentWidth) {
          contentWidth = img.width;
          parsedStyle.width = contentWidth;
        }
        if (!contentHeight) {
          contentHeight = img.height;
          parsedStyle.height = contentHeight;
        }
      }
      return {
        width: contentWidth,
        height: contentHeight
      };
    };
    return RectUpdater2;
  }()
);
var TextUpdater = (
  /** @class */
  function() {
    function TextUpdater2(globalRuntime) {
      this.globalRuntime = globalRuntime;
    }
    TextUpdater2.prototype.isReadyToMeasure = function(parsedStyle, object) {
      var text = parsedStyle.text, textAlign = parsedStyle.textAlign, textBaseline = parsedStyle.textBaseline, fontSize = parsedStyle.fontSize, fontStyle = parsedStyle.fontStyle, fontWeight = parsedStyle.fontWeight, fontVariant = parsedStyle.fontVariant, lineWidth = parsedStyle.lineWidth;
      return text && fontSize && fontStyle && fontWeight && fontVariant && textAlign && textBaseline && !is_nil_default(lineWidth);
    };
    TextUpdater2.prototype.update = function(parsedStyle, object) {
      var _a2, _b;
      var text = parsedStyle.text, textAlign = parsedStyle.textAlign, lineWidth = parsedStyle.lineWidth, textBaseline = parsedStyle.textBaseline, dx = parsedStyle.dx, dy = parsedStyle.dy;
      if (!this.isReadyToMeasure(parsedStyle, object)) {
        parsedStyle.metrics = {
          font: "",
          width: 0,
          height: 0,
          lines: [],
          lineWidths: [],
          lineHeight: 0,
          maxLineWidth: 0,
          fontProperties: {
            ascent: 0,
            descent: 0,
            fontSize: 0
          },
          lineMetrics: []
        };
        return {
          width: 0,
          height: 0,
          x: 0,
          y: 0,
          offsetX: 0,
          offsetY: 0
        };
      }
      var offscreenCanvas = (((_b = (_a2 = object === null || object === void 0 ? void 0 : object.ownerDocument) === null || _a2 === void 0 ? void 0 : _a2.defaultView) === null || _b === void 0 ? void 0 : _b.getConfig()) || {}).offscreenCanvas;
      var metrics = this.globalRuntime.textService.measureText(text, parsedStyle, offscreenCanvas);
      parsedStyle.metrics = metrics;
      var width = metrics.width, height = metrics.height, lineHeight = metrics.lineHeight, fontProperties = metrics.fontProperties;
      var halfExtents = [width / 2, height / 2, 0];
      var anchor = [0, 1];
      var lineXOffset = 0;
      if (textAlign === "center" || textAlign === "middle") {
        lineXOffset = lineWidth / 2;
        anchor = [0.5, 1];
      } else if (textAlign === "right" || textAlign === "end") {
        lineXOffset = lineWidth;
        anchor = [1, 1];
      }
      var lineYOffset = 0;
      if (textBaseline === "middle") {
        lineYOffset = halfExtents[1];
      } else if (textBaseline === "top" || textBaseline === "hanging") {
        lineYOffset = halfExtents[1] * 2;
      } else if (textBaseline === "alphabetic") {
        lineYOffset = this.globalRuntime.enableCSSParsing ? lineHeight - fontProperties.ascent : 0;
      } else if (textBaseline === "bottom" || textBaseline === "ideographic") {
        lineYOffset = 0;
      }
      if (dx) {
        lineXOffset += dx;
      }
      if (dy) {
        lineYOffset += dy;
      }
      parsedStyle.anchor = [anchor[0], anchor[1], 0];
      return {
        width: halfExtents[0] * 2,
        height: halfExtents[1] * 2,
        offsetX: lineXOffset,
        offsetY: lineYOffset
      };
    };
    return TextUpdater2;
  }()
);
function isFederatedEvent(value2) {
  return !!value2.type;
}
var FederatedEvent = (
  /** @class */
  function() {
    function FederatedEvent2(manager) {
      this.eventPhase = FederatedEvent2.prototype.NONE;
      this.bubbles = true;
      this.cancelBubble = true;
      this.cancelable = false;
      this.defaultPrevented = false;
      this.propagationStopped = false;
      this.propagationImmediatelyStopped = false;
      this.layer = new Point2();
      this.page = new Point2();
      this.canvas = new Point2();
      this.viewport = new Point2();
      this.composed = false;
      this.NONE = 0;
      this.CAPTURING_PHASE = 1;
      this.AT_TARGET = 2;
      this.BUBBLING_PHASE = 3;
      this.manager = manager;
    }
    Object.defineProperty(FederatedEvent2.prototype, "name", {
      /**
       * @deprecated
       */
      get: function() {
        return this.type;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(FederatedEvent2.prototype, "layerX", {
      get: function() {
        return this.layer.x;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(FederatedEvent2.prototype, "layerY", {
      get: function() {
        return this.layer.y;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(FederatedEvent2.prototype, "pageX", {
      get: function() {
        return this.page.x;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(FederatedEvent2.prototype, "pageY", {
      get: function() {
        return this.page.y;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(FederatedEvent2.prototype, "x", {
      get: function() {
        return this.canvas.x;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(FederatedEvent2.prototype, "y", {
      get: function() {
        return this.canvas.y;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(FederatedEvent2.prototype, "canvasX", {
      get: function() {
        return this.canvas.x;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(FederatedEvent2.prototype, "canvasY", {
      get: function() {
        return this.canvas.y;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(FederatedEvent2.prototype, "viewportX", {
      get: function() {
        return this.viewport.x;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(FederatedEvent2.prototype, "viewportY", {
      get: function() {
        return this.viewport.y;
      },
      enumerable: false,
      configurable: true
    });
    FederatedEvent2.prototype.composedPath = function() {
      if (this.manager && (!this.path || this.path[0] !== this.target)) {
        this.path = this.target ? this.manager.propagationPath(this.target) : [];
      }
      return this.path;
    };
    Object.defineProperty(FederatedEvent2.prototype, "propagationPath", {
      /**
       * @deprecated
       */
      get: function() {
        return this.composedPath();
      },
      enumerable: false,
      configurable: true
    });
    FederatedEvent2.prototype.preventDefault = function() {
      if (this.nativeEvent instanceof Event && this.nativeEvent.cancelable) {
        this.nativeEvent.preventDefault();
      }
      this.defaultPrevented = true;
    };
    FederatedEvent2.prototype.stopImmediatePropagation = function() {
      this.propagationImmediatelyStopped = true;
    };
    FederatedEvent2.prototype.stopPropagation = function() {
      this.propagationStopped = true;
    };
    FederatedEvent2.prototype.initEvent = function() {
    };
    FederatedEvent2.prototype.initUIEvent = function() {
    };
    FederatedEvent2.prototype.clone = function() {
      throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
    };
    return FederatedEvent2;
  }()
);
var FederatedMouseEvent = (
  /** @class */
  function(_super) {
    __extends(FederatedMouseEvent2, _super);
    function FederatedMouseEvent2() {
      var _this2 = _super.apply(this, __spreadArray([], __read(arguments), false)) || this;
      _this2.client = new Point2();
      _this2.movement = new Point2();
      _this2.offset = new Point2();
      _this2.global = new Point2();
      _this2.screen = new Point2();
      return _this2;
    }
    Object.defineProperty(FederatedMouseEvent2.prototype, "clientX", {
      get: function() {
        return this.client.x;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(FederatedMouseEvent2.prototype, "clientY", {
      get: function() {
        return this.client.y;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(FederatedMouseEvent2.prototype, "movementX", {
      get: function() {
        return this.movement.x;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(FederatedMouseEvent2.prototype, "movementY", {
      get: function() {
        return this.movement.y;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(FederatedMouseEvent2.prototype, "offsetX", {
      get: function() {
        return this.offset.x;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(FederatedMouseEvent2.prototype, "offsetY", {
      get: function() {
        return this.offset.y;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(FederatedMouseEvent2.prototype, "globalX", {
      get: function() {
        return this.global.x;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(FederatedMouseEvent2.prototype, "globalY", {
      get: function() {
        return this.global.y;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(FederatedMouseEvent2.prototype, "screenX", {
      get: function() {
        return this.screen.x;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(FederatedMouseEvent2.prototype, "screenY", {
      get: function() {
        return this.screen.y;
      },
      enumerable: false,
      configurable: true
    });
    FederatedMouseEvent2.prototype.getModifierState = function(key) {
      return "getModifierState" in this.nativeEvent && this.nativeEvent.getModifierState(key);
    };
    FederatedMouseEvent2.prototype.initMouseEvent = function() {
      throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
    };
    return FederatedMouseEvent2;
  }(FederatedEvent)
);
var FederatedPointerEvent = (
  /** @class */
  function(_super) {
    __extends(FederatedPointerEvent2, _super);
    function FederatedPointerEvent2() {
      var _this2 = _super.apply(this, __spreadArray([], __read(arguments), false)) || this;
      _this2.width = 0;
      _this2.height = 0;
      _this2.isPrimary = false;
      return _this2;
    }
    FederatedPointerEvent2.prototype.getCoalescedEvents = function() {
      if (this.type === "pointermove" || this.type === "mousemove" || this.type === "touchmove") {
        return [this];
      }
      return [];
    };
    FederatedPointerEvent2.prototype.getPredictedEvents = function() {
      throw new Error("getPredictedEvents is not supported!");
    };
    FederatedPointerEvent2.prototype.clone = function() {
      return this.manager.clonePointerEvent(this);
    };
    return FederatedPointerEvent2;
  }(FederatedMouseEvent)
);
var FederatedWheelEvent = (
  /** @class */
  function(_super) {
    __extends(FederatedWheelEvent2, _super);
    function FederatedWheelEvent2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    FederatedWheelEvent2.prototype.clone = function() {
      return this.manager.cloneWheelEvent(this);
    };
    return FederatedWheelEvent2;
  }(FederatedMouseEvent)
);
var CustomEvent = (
  /** @class */
  function(_super) {
    __extends(CustomEvent2, _super);
    function CustomEvent2(eventName, object) {
      var _this2 = _super.call(this, null) || this;
      _this2.type = eventName;
      _this2.detail = object;
      Object.assign(_this2, object);
      return _this2;
    }
    return CustomEvent2;
  }(FederatedEvent)
);
var DELEGATION_SPLITTER = ":";
var EventTarget = (
  /** @class */
  function() {
    function EventTarget2() {
      this.emitter = new eventemitter3_default();
    }
    EventTarget2.prototype.on = function(type, listener, options) {
      this.addEventListener(type, listener, options);
      return this;
    };
    EventTarget2.prototype.addEventListener = function(type, listener, options) {
      var capture = is_boolean_default(options) && options || is_object_default(options) && options.capture;
      var once2 = is_object_default(options) && options.once;
      var context = isFunction(listener) ? void 0 : listener;
      var useDelegatedName = false;
      var delegatedName = "";
      if (type.indexOf(DELEGATION_SPLITTER) > -1) {
        var _a2 = __read(type.split(DELEGATION_SPLITTER), 2), name_1 = _a2[0], eventType = _a2[1];
        type = eventType;
        delegatedName = name_1;
        useDelegatedName = true;
      }
      type = capture ? "".concat(type, "capture") : type;
      listener = isFunction(listener) ? listener : listener.handleEvent;
      if (useDelegatedName) {
        var originListener_1 = listener;
        listener = function() {
          var _a3;
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
          }
          if (((_a3 = args[0].target) === null || _a3 === void 0 ? void 0 : _a3.name) !== delegatedName) {
            return;
          }
          originListener_1.apply(void 0, __spreadArray([], __read(args), false));
        };
      }
      if (once2) {
        this.emitter.once(type, listener, context);
      } else {
        this.emitter.on(type, listener, context);
      }
      return this;
    };
    EventTarget2.prototype.off = function(type, listener, options) {
      if (type) {
        this.removeEventListener(type, listener, options);
      } else {
        this.removeAllEventListeners();
      }
      return this;
    };
    EventTarget2.prototype.removeAllEventListeners = function() {
      this.emitter.removeAllListeners();
    };
    EventTarget2.prototype.removeEventListener = function(type, listener, options) {
      var capture = is_boolean_default(options) && options || is_object_default(options) && options.capture;
      var context = isFunction(listener) ? void 0 : listener;
      type = capture ? "".concat(type, "capture") : type;
      listener = isFunction(listener) ? listener : listener === null || listener === void 0 ? void 0 : listener.handleEvent;
      this.emitter.off(type, listener, context);
      return this;
    };
    EventTarget2.prototype.emit = function(eventName, object) {
      this.dispatchEvent(new CustomEvent(eventName, object));
    };
    EventTarget2.prototype.dispatchEvent = function(e, skipPropagate) {
      var _a2, _b;
      if (skipPropagate === void 0) {
        skipPropagate = false;
      }
      if (!isFederatedEvent(e)) {
        throw new Error("DisplayObject cannot propagate events outside of the Federated Events API");
      }
      var canvas;
      if (this.document) {
        canvas = this;
      } else if (this.defaultView) {
        canvas = this.defaultView;
      } else {
        canvas = (_a2 = this.ownerDocument) === null || _a2 === void 0 ? void 0 : _a2.defaultView;
      }
      if (canvas) {
        e.manager = canvas.getEventService() || null;
        if (!e.manager) {
          return false;
        }
        e.defaultPrevented = false;
        e.path = [];
        if (!skipPropagate) {
          e.target = this;
        }
        (_b = e.manager) === null || _b === void 0 ? void 0 : _b.dispatchEvent(e, e.type, skipPropagate);
      }
      return !e.defaultPrevented;
    };
    return EventTarget2;
  }()
);
var Node = (
  /** @class */
  function(_super) {
    __extends(Node5, _super);
    function Node5() {
      var _this2 = _super.apply(this, __spreadArray([], __read(arguments), false)) || this;
      _this2.shadow = false;
      _this2.ownerDocument = null;
      _this2.isConnected = false;
      _this2.baseURI = "";
      _this2.childNodes = [];
      _this2.nodeType = 0;
      _this2.nodeName = "";
      _this2.nodeValue = null;
      _this2.parentNode = null;
      return _this2;
    }
    Node5.isNode = function(target) {
      return !!target.childNodes;
    };
    Object.defineProperty(Node5.prototype, "textContent", {
      /**
       * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Node/textContent
       */
      get: function() {
        var e_1, _a2;
        var out = "";
        if (this.nodeName === Shape.TEXT) {
          out += this.style.text;
        }
        try {
          for (var _b = __values(this.childNodes), _c = _b.next(); !_c.done; _c = _b.next()) {
            var child = _c.value;
            if (child.nodeName === Shape.TEXT) {
              out += child.nodeValue;
            } else {
              out += child.textContent;
            }
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (_c && !_c.done && (_a2 = _b.return))
              _a2.call(_b);
          } finally {
            if (e_1)
              throw e_1.error;
          }
        }
        return out;
      },
      set: function(content) {
        var _this2 = this;
        this.childNodes.slice().forEach(function(child) {
          _this2.removeChild(child);
        });
        if (this.nodeName === Shape.TEXT) {
          this.style.text = "".concat(content);
        }
      },
      enumerable: false,
      configurable: true
    });
    Node5.prototype.getRootNode = function(opts) {
      if (opts === void 0) {
        opts = {};
      }
      if (this.parentNode) {
        return this.parentNode.getRootNode(opts);
      }
      if (opts.composed && this.host) {
        return this.host.getRootNode(opts);
      }
      return this;
    };
    Node5.prototype.hasChildNodes = function() {
      return this.childNodes.length > 0;
    };
    Node5.prototype.isDefaultNamespace = function(namespace) {
      throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
    };
    Node5.prototype.lookupNamespaceURI = function(prefix) {
      throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
    };
    Node5.prototype.lookupPrefix = function(namespace) {
      throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
    };
    Node5.prototype.normalize = function() {
      throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
    };
    Node5.prototype.isEqualNode = function(otherNode) {
      return this === otherNode;
    };
    Node5.prototype.isSameNode = function(otherNode) {
      return this.isEqualNode(otherNode);
    };
    Object.defineProperty(Node5.prototype, "parent", {
      /**
       * @deprecated
       * @alias parentNode
       */
      get: function() {
        return this.parentNode;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Node5.prototype, "parentElement", {
      get: function() {
        return null;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Node5.prototype, "nextSibling", {
      get: function() {
        return null;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Node5.prototype, "previousSibling", {
      get: function() {
        return null;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Node5.prototype, "firstChild", {
      get: function() {
        return this.childNodes.length > 0 ? this.childNodes[0] : null;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Node5.prototype, "lastChild", {
      get: function() {
        return this.childNodes.length > 0 ? this.childNodes[this.childNodes.length - 1] : null;
      },
      enumerable: false,
      configurable: true
    });
    Node5.prototype.compareDocumentPosition = function(other) {
      var _a2;
      if (other === this) {
        return 0;
      }
      var node1Root = other;
      var node2Root = this;
      var node1Hierarchy = [node1Root];
      var node2Hierarchy = [node2Root];
      while ((_a2 = node1Root.parentNode) !== null && _a2 !== void 0 ? _a2 : node2Root.parentNode) {
        node1Root = node1Root.parentNode ? (node1Hierarchy.push(node1Root.parentNode), node1Root.parentNode) : node1Root;
        node2Root = node2Root.parentNode ? (node2Hierarchy.push(node2Root.parentNode), node2Root.parentNode) : node2Root;
      }
      if (node1Root !== node2Root) {
        return Node5.DOCUMENT_POSITION_DISCONNECTED | Node5.DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC | Node5.DOCUMENT_POSITION_PRECEDING;
      }
      var longerHierarchy = node1Hierarchy.length > node2Hierarchy.length ? node1Hierarchy : node2Hierarchy;
      var shorterHierarchy = longerHierarchy === node1Hierarchy ? node2Hierarchy : node1Hierarchy;
      if (longerHierarchy[longerHierarchy.length - shorterHierarchy.length] === shorterHierarchy[0]) {
        return longerHierarchy === node1Hierarchy ? (
          // other is a child of this
          Node5.DOCUMENT_POSITION_CONTAINED_BY | Node5.DOCUMENT_POSITION_FOLLOWING
        ) : (
          // this is a child of other
          Node5.DOCUMENT_POSITION_CONTAINS | Node5.DOCUMENT_POSITION_PRECEDING
        );
      }
      var longerStart = longerHierarchy.length - shorterHierarchy.length;
      for (var i = shorterHierarchy.length - 1; i >= 0; i--) {
        var shorterHierarchyNode = shorterHierarchy[i];
        var longerHierarchyNode = longerHierarchy[longerStart + i];
        if (longerHierarchyNode !== shorterHierarchyNode) {
          var siblings = shorterHierarchyNode.parentNode.childNodes;
          if (siblings.indexOf(shorterHierarchyNode) < siblings.indexOf(longerHierarchyNode)) {
            if (shorterHierarchy === node1Hierarchy) {
              return Node5.DOCUMENT_POSITION_PRECEDING;
            } else {
              return Node5.DOCUMENT_POSITION_FOLLOWING;
            }
          } else {
            if (longerHierarchy === node1Hierarchy) {
              return Node5.DOCUMENT_POSITION_PRECEDING;
            } else {
              return Node5.DOCUMENT_POSITION_FOLLOWING;
            }
          }
        }
      }
      return Node5.DOCUMENT_POSITION_FOLLOWING;
    };
    Node5.prototype.contain = function(other) {
      return this.contains(other);
    };
    Node5.prototype.contains = function(other) {
      var tmp2 = other;
      while (tmp2 && this !== tmp2) {
        tmp2 = tmp2.parentNode;
      }
      return !!tmp2;
    };
    Node5.prototype.getAncestor = function(n) {
      var temp = this;
      while (n > 0 && temp) {
        temp = temp.parentNode;
        n--;
      }
      return temp;
    };
    Node5.prototype.forEach = function(callback, assigned) {
      if (assigned === void 0) {
        assigned = false;
      }
      if (!callback(this)) {
        (assigned ? this.childNodes.slice() : this.childNodes).forEach(function(child) {
          child.forEach(callback);
        });
      }
    };
    Node5.DOCUMENT_POSITION_DISCONNECTED = 1;
    Node5.DOCUMENT_POSITION_PRECEDING = 2;
    Node5.DOCUMENT_POSITION_FOLLOWING = 4;
    Node5.DOCUMENT_POSITION_CONTAINS = 8;
    Node5.DOCUMENT_POSITION_CONTAINED_BY = 16;
    Node5.DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC = 32;
    return Node5;
  }(EventTarget)
);
var PROPAGATION_LIMIT = 2048;
var EventService = (
  /** @class */
  function() {
    function EventService2(globalRuntime, context) {
      var _this2 = this;
      this.globalRuntime = globalRuntime;
      this.context = context;
      this.emitter = new eventemitter3_default();
      this.nativeHTMLMap = /* @__PURE__ */ new WeakMap();
      this.cursor = "default";
      this.mappingTable = {};
      this.mappingState = {
        trackingData: {}
      };
      this.eventPool = /* @__PURE__ */ new Map();
      this.tmpMatrix = mat4_exports.create();
      this.tmpVec3 = vec3_exports.create();
      this.onPointerDown = function(from) {
        var e = _this2.createPointerEvent(from);
        _this2.dispatchEvent(e, "pointerdown");
        if (e.pointerType === "touch") {
          _this2.dispatchEvent(e, "touchstart");
        } else if (e.pointerType === "mouse" || e.pointerType === "pen") {
          var isRightButton = e.button === 2;
          _this2.dispatchEvent(e, isRightButton ? "rightdown" : "mousedown");
        }
        var trackingData = _this2.trackingData(from.pointerId);
        trackingData.pressTargetsByButton[from.button] = e.composedPath();
        _this2.freeEvent(e);
      };
      this.onPointerUp = function(from) {
        var _a2;
        var now3 = clock.now();
        var e = _this2.createPointerEvent(from, void 0, void 0, _this2.context.config.alwaysTriggerPointerEventOnCanvas ? _this2.rootTarget : void 0);
        _this2.dispatchEvent(e, "pointerup");
        if (e.pointerType === "touch") {
          _this2.dispatchEvent(e, "touchend");
        } else if (e.pointerType === "mouse" || e.pointerType === "pen") {
          var isRightButton = e.button === 2;
          _this2.dispatchEvent(e, isRightButton ? "rightup" : "mouseup");
        }
        var trackingData = _this2.trackingData(from.pointerId);
        var pressTarget = _this2.findMountedTarget(trackingData.pressTargetsByButton[from.button]);
        var clickTarget = pressTarget;
        if (pressTarget && !e.composedPath().includes(pressTarget)) {
          var currentTarget = pressTarget;
          while (currentTarget && !e.composedPath().includes(currentTarget)) {
            e.currentTarget = currentTarget;
            _this2.notifyTarget(e, "pointerupoutside");
            if (e.pointerType === "touch") {
              _this2.notifyTarget(e, "touchendoutside");
            } else if (e.pointerType === "mouse" || e.pointerType === "pen") {
              var isRightButton = e.button === 2;
              _this2.notifyTarget(e, isRightButton ? "rightupoutside" : "mouseupoutside");
            }
            if (Node.isNode(currentTarget)) {
              currentTarget = currentTarget.parentNode;
            }
          }
          delete trackingData.pressTargetsByButton[from.button];
          clickTarget = currentTarget;
        }
        if (clickTarget) {
          var clickEvent = _this2.clonePointerEvent(e, "click");
          clickEvent.target = clickTarget;
          clickEvent.path = [];
          if (!trackingData.clicksByButton[from.button]) {
            trackingData.clicksByButton[from.button] = {
              clickCount: 0,
              target: clickEvent.target,
              timeStamp: now3
            };
          }
          var clickHistory = trackingData.clicksByButton[from.button];
          if (clickHistory.target === clickEvent.target && now3 - clickHistory.timeStamp < 200) {
            ++clickHistory.clickCount;
          } else {
            clickHistory.clickCount = 1;
          }
          clickHistory.target = clickEvent.target;
          clickHistory.timeStamp = now3;
          clickEvent.detail = clickHistory.clickCount;
          if (!((_a2 = e.detail) === null || _a2 === void 0 ? void 0 : _a2.preventClick)) {
            if (!_this2.context.config.useNativeClickEvent && (clickEvent.pointerType === "mouse" || clickEvent.pointerType === "touch")) {
              _this2.dispatchEvent(clickEvent, "click");
            }
            _this2.dispatchEvent(clickEvent, "pointertap");
          }
          _this2.freeEvent(clickEvent);
        }
        _this2.freeEvent(e);
      };
      this.onPointerMove = function(from) {
        var e = _this2.createPointerEvent(from, void 0, void 0, _this2.context.config.alwaysTriggerPointerEventOnCanvas ? _this2.rootTarget : void 0);
        var isMouse = e.pointerType === "mouse" || e.pointerType === "pen";
        var trackingData = _this2.trackingData(from.pointerId);
        var outTarget = _this2.findMountedTarget(trackingData.overTargets);
        if (trackingData.overTargets && outTarget !== e.target) {
          var outType = from.type === "mousemove" ? "mouseout" : "pointerout";
          var outEvent = _this2.createPointerEvent(from, outType, outTarget || void 0);
          _this2.dispatchEvent(outEvent, "pointerout");
          if (isMouse)
            _this2.dispatchEvent(outEvent, "mouseout");
          if (!e.composedPath().includes(outTarget)) {
            var leaveEvent = _this2.createPointerEvent(from, "pointerleave", outTarget || void 0);
            leaveEvent.eventPhase = leaveEvent.AT_TARGET;
            while (leaveEvent.target && !e.composedPath().includes(leaveEvent.target)) {
              leaveEvent.currentTarget = leaveEvent.target;
              _this2.notifyTarget(leaveEvent);
              if (isMouse) {
                _this2.notifyTarget(leaveEvent, "mouseleave");
              }
              if (Node.isNode(leaveEvent.target)) {
                leaveEvent.target = leaveEvent.target.parentNode;
              }
            }
            _this2.freeEvent(leaveEvent);
          }
          _this2.freeEvent(outEvent);
        }
        if (outTarget !== e.target) {
          var overType = from.type === "mousemove" ? "mouseover" : "pointerover";
          var overEvent = _this2.clonePointerEvent(e, overType);
          _this2.dispatchEvent(overEvent, "pointerover");
          if (isMouse)
            _this2.dispatchEvent(overEvent, "mouseover");
          var overTargetAncestor = outTarget && Node.isNode(outTarget) && outTarget.parentNode;
          while (overTargetAncestor && overTargetAncestor !== (Node.isNode(_this2.rootTarget) && _this2.rootTarget.parentNode)) {
            if (overTargetAncestor === e.target)
              break;
            overTargetAncestor = overTargetAncestor.parentNode;
          }
          var didPointerEnter = !overTargetAncestor || overTargetAncestor === (Node.isNode(_this2.rootTarget) && _this2.rootTarget.parentNode);
          if (didPointerEnter) {
            var enterEvent = _this2.clonePointerEvent(e, "pointerenter");
            enterEvent.eventPhase = enterEvent.AT_TARGET;
            while (enterEvent.target && enterEvent.target !== outTarget && enterEvent.target !== (Node.isNode(_this2.rootTarget) && _this2.rootTarget.parentNode)) {
              enterEvent.currentTarget = enterEvent.target;
              _this2.notifyTarget(enterEvent);
              if (isMouse)
                _this2.notifyTarget(enterEvent, "mouseenter");
              if (Node.isNode(enterEvent.target)) {
                enterEvent.target = enterEvent.target.parentNode;
              }
            }
            _this2.freeEvent(enterEvent);
          }
          _this2.freeEvent(overEvent);
        }
        _this2.dispatchEvent(e, "pointermove");
        if (e.pointerType === "touch")
          _this2.dispatchEvent(e, "touchmove");
        if (isMouse) {
          _this2.dispatchEvent(e, "mousemove");
          _this2.cursor = _this2.getCursor(e.target);
        }
        trackingData.overTargets = e.composedPath();
        _this2.freeEvent(e);
      };
      this.onPointerOut = function(from) {
        var trackingData = _this2.trackingData(from.pointerId);
        if (trackingData.overTargets) {
          var isMouse = from.pointerType === "mouse" || from.pointerType === "pen";
          var outTarget = _this2.findMountedTarget(trackingData.overTargets);
          var outEvent = _this2.createPointerEvent(from, "pointerout", outTarget || void 0);
          _this2.dispatchEvent(outEvent);
          if (isMouse)
            _this2.dispatchEvent(outEvent, "mouseout");
          var leaveEvent = _this2.createPointerEvent(from, "pointerleave", outTarget || void 0);
          leaveEvent.eventPhase = leaveEvent.AT_TARGET;
          while (leaveEvent.target && leaveEvent.target !== (Node.isNode(_this2.rootTarget) && _this2.rootTarget.parentNode)) {
            leaveEvent.currentTarget = leaveEvent.target;
            _this2.notifyTarget(leaveEvent);
            if (isMouse) {
              _this2.notifyTarget(leaveEvent, "mouseleave");
            }
            if (Node.isNode(leaveEvent.target)) {
              leaveEvent.target = leaveEvent.target.parentNode;
            }
          }
          trackingData.overTargets = null;
          _this2.freeEvent(outEvent);
          _this2.freeEvent(leaveEvent);
        }
        _this2.cursor = null;
      };
      this.onPointerOver = function(from) {
        var trackingData = _this2.trackingData(from.pointerId);
        var e = _this2.createPointerEvent(from);
        var isMouse = e.pointerType === "mouse" || e.pointerType === "pen";
        _this2.dispatchEvent(e, "pointerover");
        if (isMouse)
          _this2.dispatchEvent(e, "mouseover");
        if (e.pointerType === "mouse")
          _this2.cursor = _this2.getCursor(e.target);
        var enterEvent = _this2.clonePointerEvent(e, "pointerenter");
        enterEvent.eventPhase = enterEvent.AT_TARGET;
        while (enterEvent.target && enterEvent.target !== (Node.isNode(_this2.rootTarget) && _this2.rootTarget.parentNode)) {
          enterEvent.currentTarget = enterEvent.target;
          _this2.notifyTarget(enterEvent);
          if (isMouse) {
            _this2.notifyTarget(enterEvent, "mouseenter");
          }
          if (Node.isNode(enterEvent.target)) {
            enterEvent.target = enterEvent.target.parentNode;
          }
        }
        trackingData.overTargets = e.composedPath();
        _this2.freeEvent(e);
        _this2.freeEvent(enterEvent);
      };
      this.onPointerUpOutside = function(from) {
        var trackingData = _this2.trackingData(from.pointerId);
        var pressTarget = _this2.findMountedTarget(trackingData.pressTargetsByButton[from.button]);
        var e = _this2.createPointerEvent(from);
        if (pressTarget) {
          var currentTarget = pressTarget;
          while (currentTarget) {
            e.currentTarget = currentTarget;
            _this2.notifyTarget(e, "pointerupoutside");
            if (e.pointerType === "touch")
              ;
            else if (e.pointerType === "mouse" || e.pointerType === "pen") {
              _this2.notifyTarget(e, e.button === 2 ? "rightupoutside" : "mouseupoutside");
            }
            if (Node.isNode(currentTarget)) {
              currentTarget = currentTarget.parentNode;
            }
          }
          delete trackingData.pressTargetsByButton[from.button];
        }
        _this2.freeEvent(e);
      };
      this.onWheel = function(from) {
        var wheelEvent = _this2.createWheelEvent(from);
        _this2.dispatchEvent(wheelEvent);
        _this2.freeEvent(wheelEvent);
      };
      this.onClick = function(from) {
        if (_this2.context.config.useNativeClickEvent) {
          var e = _this2.createPointerEvent(from);
          _this2.dispatchEvent(e);
          _this2.freeEvent(e);
        }
      };
      this.onPointerCancel = function(from) {
        var e = _this2.createPointerEvent(from, void 0, void 0, _this2.context.config.alwaysTriggerPointerEventOnCanvas ? _this2.rootTarget : void 0);
        _this2.dispatchEvent(e);
        _this2.freeEvent(e);
      };
    }
    EventService2.prototype.init = function() {
      this.rootTarget = this.context.renderingContext.root.parentNode;
      this.addEventMapping("pointerdown", this.onPointerDown);
      this.addEventMapping("pointerup", this.onPointerUp);
      this.addEventMapping("pointermove", this.onPointerMove);
      this.addEventMapping("pointerout", this.onPointerOut);
      this.addEventMapping("pointerleave", this.onPointerOut);
      this.addEventMapping("pointercancel", this.onPointerCancel);
      this.addEventMapping("pointerover", this.onPointerOver);
      this.addEventMapping("pointerupoutside", this.onPointerUpOutside);
      this.addEventMapping("wheel", this.onWheel);
      this.addEventMapping("click", this.onClick);
    };
    EventService2.prototype.destroy = function() {
      this.emitter.removeAllListeners();
      this.mappingTable = {};
      this.mappingState = {};
      this.eventPool.clear();
    };
    EventService2.prototype.client2Viewport = function(client) {
      var bbox = this.context.contextService.getBoundingClientRect();
      return new Point2(client.x - ((bbox === null || bbox === void 0 ? void 0 : bbox.left) || 0), client.y - ((bbox === null || bbox === void 0 ? void 0 : bbox.top) || 0));
    };
    EventService2.prototype.viewport2Client = function(canvas) {
      var bbox = this.context.contextService.getBoundingClientRect();
      return new Point2(canvas.x + ((bbox === null || bbox === void 0 ? void 0 : bbox.left) || 0), canvas.y + ((bbox === null || bbox === void 0 ? void 0 : bbox.top) || 0));
    };
    EventService2.prototype.viewport2Canvas = function(_a2) {
      var x3 = _a2.x, y3 = _a2.y;
      var canvas = this.rootTarget.defaultView;
      var camera = canvas.getCamera();
      var _b = this.context.config, width = _b.width, height = _b.height;
      var projectionMatrixInverse = camera.getPerspectiveInverse();
      var worldMatrix = camera.getWorldTransform();
      var vpMatrix = mat4_exports.multiply(this.tmpMatrix, worldMatrix, projectionMatrixInverse);
      var viewport = vec3_exports.set(this.tmpVec3, x3 / width * 2 - 1, (1 - y3 / height) * 2 - 1, 0);
      vec3_exports.transformMat4(viewport, viewport, vpMatrix);
      return new Point2(viewport[0], viewport[1]);
    };
    EventService2.prototype.canvas2Viewport = function(canvasP) {
      var canvas = this.rootTarget.defaultView;
      var camera = canvas.getCamera();
      var projectionMatrix = camera.getPerspective();
      var viewMatrix = camera.getViewTransform();
      var vpMatrix = mat4_exports.multiply(this.tmpMatrix, projectionMatrix, viewMatrix);
      var clip = vec3_exports.set(this.tmpVec3, canvasP.x, canvasP.y, 0);
      vec3_exports.transformMat4(this.tmpVec3, this.tmpVec3, vpMatrix);
      var _a2 = this.context.config, width = _a2.width, height = _a2.height;
      return new Point2((clip[0] + 1) / 2 * width, (1 - (clip[1] + 1) / 2) * height);
    };
    EventService2.prototype.setPickHandler = function(pickHandler) {
      this.pickHandler = pickHandler;
    };
    EventService2.prototype.addEventMapping = function(type, fn) {
      if (!this.mappingTable[type]) {
        this.mappingTable[type] = [];
      }
      this.mappingTable[type].push({
        fn,
        priority: 0
      });
      this.mappingTable[type].sort(function(a4, b) {
        return a4.priority - b.priority;
      });
    };
    EventService2.prototype.mapEvent = function(e) {
      if (!this.rootTarget) {
        return;
      }
      var mappers = this.mappingTable[e.type];
      if (mappers) {
        for (var i = 0, j = mappers.length; i < j; i++) {
          mappers[i].fn(e);
        }
      } else {
        console.warn("[EventService]: Event mapping not defined for ".concat(e.type));
      }
    };
    EventService2.prototype.dispatchEvent = function(e, type, skipPropagate) {
      if (!skipPropagate) {
        e.propagationStopped = false;
        e.propagationImmediatelyStopped = false;
        this.propagate(e, type);
      } else {
        e.eventPhase = e.AT_TARGET;
        var canvas = this.rootTarget.defaultView || null;
        e.currentTarget = canvas;
        this.notifyListeners(e, type);
      }
      this.emitter.emit(type || e.type, e);
    };
    EventService2.prototype.propagate = function(e, type) {
      if (!e.target) {
        return;
      }
      var composedPath = e.composedPath();
      e.eventPhase = e.CAPTURING_PHASE;
      for (var i = composedPath.length - 1; i >= 1; i--) {
        e.currentTarget = composedPath[i];
        this.notifyTarget(e, type);
        if (e.propagationStopped || e.propagationImmediatelyStopped)
          return;
      }
      e.eventPhase = e.AT_TARGET;
      e.currentTarget = e.target;
      this.notifyTarget(e, type);
      if (e.propagationStopped || e.propagationImmediatelyStopped)
        return;
      var index3 = composedPath.indexOf(e.currentTarget);
      e.eventPhase = e.BUBBLING_PHASE;
      for (var i = index3 + 1; i < composedPath.length; i++) {
        e.currentTarget = composedPath[i];
        this.notifyTarget(e, type);
        if (e.propagationStopped || e.propagationImmediatelyStopped)
          return;
      }
    };
    EventService2.prototype.propagationPath = function(target) {
      var propagationPath = [target];
      var canvas = this.rootTarget.defaultView || null;
      if (canvas && canvas === target) {
        propagationPath.unshift(canvas.document);
        return propagationPath;
      }
      for (var i = 0; i < PROPAGATION_LIMIT && target !== this.rootTarget; i++) {
        if (Node.isNode(target) && target.parentNode) {
          propagationPath.push(target.parentNode);
          target = target.parentNode;
        }
      }
      if (canvas) {
        propagationPath.push(canvas);
      }
      return propagationPath;
    };
    EventService2.prototype.hitTest = function(position) {
      var viewportX = position.viewportX, viewportY = position.viewportY;
      var _a2 = this.context.config, width = _a2.width, height = _a2.height, disableHitTesting = _a2.disableHitTesting;
      if (viewportX < 0 || viewportY < 0 || viewportX > width || viewportY > height) {
        return null;
      }
      return !disableHitTesting && this.pickHandler(position) || this.rootTarget || // return Document
      null;
    };
    EventService2.prototype.isNativeEventFromCanvas = function(event) {
      var _a2;
      var $el = this.context.contextService.getDomElement();
      var target = (_a2 = event.nativeEvent) === null || _a2 === void 0 ? void 0 : _a2.target;
      if (target) {
        if (target === $el) {
          return true;
        }
        if ($el && $el.contains) {
          return $el.contains(target);
        }
      }
      if (event.nativeEvent.composedPath) {
        return event.nativeEvent.composedPath().indexOf($el) > -1;
      }
      return false;
    };
    EventService2.prototype.getExistedHTML = function(event) {
      var e_1, _a2;
      if (event.nativeEvent.composedPath) {
        try {
          for (var _b = __values(event.nativeEvent.composedPath()), _c = _b.next(); !_c.done; _c = _b.next()) {
            var eventTarget = _c.value;
            var existed = this.nativeHTMLMap.get(eventTarget);
            if (existed) {
              return existed;
            }
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (_c && !_c.done && (_a2 = _b.return))
              _a2.call(_b);
          } finally {
            if (e_1)
              throw e_1.error;
          }
        }
      }
      return null;
    };
    EventService2.prototype.pickTarget = function(event) {
      return this.hitTest({
        clientX: event.clientX,
        clientY: event.clientY,
        viewportX: event.viewportX,
        viewportY: event.viewportY,
        x: event.canvasX,
        y: event.canvasY
      });
    };
    EventService2.prototype.createPointerEvent = function(from, type, target, fallbackTarget) {
      var event = this.allocateEvent(FederatedPointerEvent);
      this.copyPointerData(from, event);
      this.copyMouseData(from, event);
      this.copyData(from, event);
      event.nativeEvent = from.nativeEvent;
      event.originalEvent = from;
      var existedHTML = this.getExistedHTML(event);
      event.target = target !== null && target !== void 0 ? target : existedHTML || this.isNativeEventFromCanvas(event) && this.pickTarget(event) || fallbackTarget;
      if (typeof type === "string") {
        event.type = type;
      }
      return event;
    };
    EventService2.prototype.createWheelEvent = function(from) {
      var event = this.allocateEvent(FederatedWheelEvent);
      this.copyWheelData(from, event);
      this.copyMouseData(from, event);
      this.copyData(from, event);
      event.nativeEvent = from.nativeEvent;
      event.originalEvent = from;
      var existedHTML = this.getExistedHTML(event);
      event.target = existedHTML || this.isNativeEventFromCanvas(event) && this.pickTarget(event);
      return event;
    };
    EventService2.prototype.trackingData = function(id3) {
      if (!this.mappingState.trackingData[id3]) {
        this.mappingState.trackingData[id3] = {
          pressTargetsByButton: {},
          clicksByButton: {},
          overTarget: null
        };
      }
      return this.mappingState.trackingData[id3];
    };
    EventService2.prototype.cloneWheelEvent = function(from) {
      var event = this.allocateEvent(FederatedWheelEvent);
      event.nativeEvent = from.nativeEvent;
      event.originalEvent = from.originalEvent;
      this.copyWheelData(from, event);
      this.copyMouseData(from, event);
      this.copyData(from, event);
      event.target = from.target;
      event.path = from.composedPath().slice();
      event.type = from.type;
      return event;
    };
    EventService2.prototype.clonePointerEvent = function(from, type) {
      var event = this.allocateEvent(FederatedPointerEvent);
      event.nativeEvent = from.nativeEvent;
      event.originalEvent = from.originalEvent;
      this.copyPointerData(from, event);
      this.copyMouseData(from, event);
      this.copyData(from, event);
      event.target = from.target;
      event.path = from.composedPath().slice();
      event.type = type !== null && type !== void 0 ? type : event.type;
      return event;
    };
    EventService2.prototype.copyPointerData = function(from, to) {
      to.pointerId = from.pointerId;
      to.width = from.width;
      to.height = from.height;
      to.isPrimary = from.isPrimary;
      to.pointerType = from.pointerType;
      to.pressure = from.pressure;
      to.tangentialPressure = from.tangentialPressure;
      to.tiltX = from.tiltX;
      to.tiltY = from.tiltY;
      to.twist = from.twist;
    };
    EventService2.prototype.copyMouseData = function(from, to) {
      to.altKey = from.altKey;
      to.button = from.button;
      to.buttons = from.buttons;
      to.ctrlKey = from.ctrlKey;
      to.metaKey = from.metaKey;
      to.shiftKey = from.shiftKey;
      to.client.copyFrom(from.client);
      to.movement.copyFrom(from.movement);
      to.canvas.copyFrom(from.canvas);
      to.screen.copyFrom(from.screen);
      to.global.copyFrom(from.global);
      to.offset.copyFrom(from.offset);
    };
    EventService2.prototype.copyWheelData = function(from, to) {
      to.deltaMode = from.deltaMode;
      to.deltaX = from.deltaX;
      to.deltaY = from.deltaY;
      to.deltaZ = from.deltaZ;
    };
    EventService2.prototype.copyData = function(from, to) {
      to.isTrusted = from.isTrusted;
      to.timeStamp = clock.now();
      to.type = from.type;
      to.detail = from.detail;
      to.view = from.view;
      to.page.copyFrom(from.page);
      to.viewport.copyFrom(from.viewport);
    };
    EventService2.prototype.allocateEvent = function(constructor) {
      if (!this.eventPool.has(constructor)) {
        this.eventPool.set(constructor, []);
      }
      var event = this.eventPool.get(constructor).pop() || new constructor(this);
      event.eventPhase = event.NONE;
      event.currentTarget = null;
      event.path = [];
      event.target = null;
      return event;
    };
    EventService2.prototype.freeEvent = function(event) {
      if (event.manager !== this)
        throw new Error("It is illegal to free an event not managed by this EventBoundary!");
      var constructor = event.constructor;
      if (!this.eventPool.has(constructor)) {
        this.eventPool.set(constructor, []);
      }
      this.eventPool.get(constructor).push(event);
    };
    EventService2.prototype.notifyTarget = function(e, type) {
      type = type !== null && type !== void 0 ? type : e.type;
      var key = e.eventPhase === e.CAPTURING_PHASE || e.eventPhase === e.AT_TARGET ? "".concat(type, "capture") : type;
      this.notifyListeners(e, key);
      if (e.eventPhase === e.AT_TARGET) {
        this.notifyListeners(e, type);
      }
    };
    EventService2.prototype.notifyListeners = function(e, type) {
      var emitter = e.currentTarget.emitter;
      var listeners = emitter._events[type];
      if (!listeners)
        return;
      if ("fn" in listeners) {
        if (listeners.once) {
          emitter.removeListener(type, listeners.fn, void 0, true);
        }
        listeners.fn.call(e.currentTarget || listeners.context, e);
      } else {
        for (var i = 0; i < listeners.length && !e.propagationImmediatelyStopped; i++) {
          if (listeners[i].once) {
            emitter.removeListener(type, listeners[i].fn, void 0, true);
          }
          listeners[i].fn.call(e.currentTarget || listeners[i].context, e);
        }
      }
    };
    EventService2.prototype.findMountedTarget = function(propagationPath) {
      if (!propagationPath) {
        return null;
      }
      var currentTarget = propagationPath[propagationPath.length - 1];
      for (var i = propagationPath.length - 2; i >= 0; i--) {
        var target = propagationPath[i];
        if (target === this.rootTarget || Node.isNode(target) && target.parentNode === currentTarget) {
          currentTarget = propagationPath[i];
        } else {
          break;
        }
      }
      return currentTarget;
    };
    EventService2.prototype.getCursor = function(target) {
      var tmp2 = target;
      while (tmp2) {
        var cursor = isElement2(tmp2) && tmp2.getAttribute("cursor");
        if (cursor) {
          return cursor;
        }
        tmp2 = Node.isNode(tmp2) && tmp2.parentNode;
      }
    };
    return EventService2;
  }()
);
var OffscreenCanvasCreator = (
  /** @class */
  function() {
    function OffscreenCanvasCreator2() {
    }
    OffscreenCanvasCreator2.prototype.getOrCreateCanvas = function(offscreenCanvas, contextAttributes) {
      if (this.canvas) {
        return this.canvas;
      }
      if (offscreenCanvas || runtime.offscreenCanvas) {
        this.canvas = offscreenCanvas || runtime.offscreenCanvas;
        this.context = this.canvas.getContext("2d", __assign({ willReadFrequently: true }, contextAttributes));
      } else {
        try {
          this.canvas = new window.OffscreenCanvas(0, 0);
          this.context = this.canvas.getContext("2d", __assign({ willReadFrequently: true }, contextAttributes));
          if (!this.context || !this.context.measureText) {
            this.canvas = document.createElement("canvas");
            this.context = this.canvas.getContext("2d");
          }
        } catch (ex) {
          this.canvas = document.createElement("canvas");
          this.context = this.canvas.getContext("2d", __assign({ willReadFrequently: true }, contextAttributes));
        }
      }
      this.canvas.width = 10;
      this.canvas.height = 10;
      return this.canvas;
    };
    OffscreenCanvasCreator2.prototype.getOrCreateContext = function(offscreenCanvas, contextAttributes) {
      if (this.context) {
        return this.context;
      }
      this.getOrCreateCanvas(offscreenCanvas, contextAttributes);
      return this.context;
    };
    return OffscreenCanvasCreator2;
  }()
);
var RenderReason;
(function(RenderReason2) {
  RenderReason2[RenderReason2["CAMERA_CHANGED"] = 0] = "CAMERA_CHANGED";
  RenderReason2[RenderReason2["DISPLAY_OBJECT_CHANGED"] = 1] = "DISPLAY_OBJECT_CHANGED";
  RenderReason2[RenderReason2["NONE"] = 2] = "NONE";
})(RenderReason || (RenderReason = {}));
var RenderingService = (
  /** @class */
  function() {
    function RenderingService2(globalRuntime, context) {
      this.globalRuntime = globalRuntime;
      this.context = context;
      this.inited = false;
      this.stats = {
        /**
         * total display objects in scenegraph
         */
        total: 0,
        /**
         * number of display objects need to render in current frame
         */
        rendered: 0
      };
      this.zIndexCounter = 0;
      this.hooks = {
        /**
         * called before any frame rendered
         */
        init: new SyncHook(),
        initAsync: new AsyncParallelHook(),
        /**
         * only dirty object which has sth changed will be rendered
         */
        dirtycheck: new SyncWaterfallHook(),
        /**
         * do culling
         */
        cull: new SyncWaterfallHook(),
        /**
         * called at beginning of each frame, won't get called if nothing to re-render
         */
        beginFrame: new SyncHook(),
        /**
         * called before every dirty object get rendered
         */
        beforeRender: new SyncHook(),
        /**
         * called when every dirty object rendering even it's culled
         */
        render: new SyncHook(),
        /**
         * called after every dirty object get rendered
         */
        afterRender: new SyncHook(),
        endFrame: new SyncHook(),
        destroy: new SyncHook(),
        /**
         * use async but faster method such as GPU-based picking in `g-plugin-device-renderer`
         */
        pick: new AsyncSeriesWaterfallHook(),
        /**
         * Unsafe but sync version of pick.
         */
        pickSync: new SyncWaterfallHook(),
        /**
         * used in event system
         */
        pointerDown: new SyncHook(),
        pointerUp: new SyncHook(),
        pointerMove: new SyncHook(),
        pointerOut: new SyncHook(),
        pointerOver: new SyncHook(),
        pointerWheel: new SyncHook(),
        pointerCancel: new SyncHook(),
        click: new SyncHook()
      };
    }
    RenderingService2.prototype.init = function(callback) {
      var _this2 = this;
      var context = __assign(__assign({}, this.globalRuntime), this.context);
      this.context.renderingPlugins.forEach(function(plugin) {
        plugin.apply(context, _this2.globalRuntime);
      });
      this.hooks.init.call();
      if (this.hooks.initAsync.getCallbacksNum() === 0) {
        this.inited = true;
        callback();
      } else {
        this.hooks.initAsync.promise().then(function() {
          _this2.inited = true;
          callback();
        });
      }
    };
    RenderingService2.prototype.getStats = function() {
      return this.stats;
    };
    RenderingService2.prototype.disableDirtyRectangleRendering = function() {
      var renderer = this.context.config.renderer;
      var enableDirtyRectangleRendering = renderer.getConfig().enableDirtyRectangleRendering;
      return !enableDirtyRectangleRendering || this.context.renderingContext.renderReasons.has(RenderReason.CAMERA_CHANGED);
    };
    RenderingService2.prototype.render = function(canvasConfig, rerenderCallback) {
      var _this2 = this;
      this.stats.total = 0;
      this.stats.rendered = 0;
      this.zIndexCounter = 0;
      var renderingContext = this.context.renderingContext;
      this.globalRuntime.sceneGraphService.syncHierarchy(renderingContext.root);
      this.globalRuntime.sceneGraphService.triggerPendingEvents();
      if (renderingContext.renderReasons.size && this.inited) {
        renderingContext.dirtyRectangleRenderingDisabled = this.disableDirtyRectangleRendering();
        var onlyCameraChanged = renderingContext.renderReasons.size === 1 && renderingContext.renderReasons.has(RenderReason.CAMERA_CHANGED);
        var shouldTriggerRenderHooks = !canvasConfig.disableRenderHooks || !(canvasConfig.disableRenderHooks && onlyCameraChanged);
        if (shouldTriggerRenderHooks) {
          this.renderDisplayObject(renderingContext.root, canvasConfig, renderingContext);
        }
        this.hooks.beginFrame.call();
        if (shouldTriggerRenderHooks) {
          renderingContext.renderListCurrentFrame.forEach(function(object) {
            _this2.hooks.beforeRender.call(object);
            _this2.hooks.render.call(object);
            _this2.hooks.afterRender.call(object);
          });
        }
        this.hooks.endFrame.call();
        renderingContext.renderListCurrentFrame = [];
        renderingContext.renderReasons.clear();
        rerenderCallback();
      }
    };
    RenderingService2.prototype.renderDisplayObject = function(displayObject, canvasConfig, renderingContext) {
      var _this2 = this;
      var _a2 = canvasConfig.renderer.getConfig(), enableDirtyCheck = _a2.enableDirtyCheck, enableCulling = _a2.enableCulling;
      if (this.globalRuntime.enableCSSParsing) {
        this.globalRuntime.styleValueRegistry.recalc(displayObject);
      }
      var renderable = displayObject.renderable;
      var objectChanged = enableDirtyCheck ? (
        // @ts-ignore
        renderable.dirty || renderingContext.dirtyRectangleRenderingDisabled ? displayObject : null
      ) : displayObject;
      if (objectChanged) {
        var objectToRender = enableCulling ? this.hooks.cull.call(objectChanged, this.context.camera) : objectChanged;
        if (objectToRender) {
          this.stats.rendered++;
          renderingContext.renderListCurrentFrame.push(objectToRender);
        }
      }
      displayObject.renderable.dirty = false;
      displayObject.sortable.renderOrder = this.zIndexCounter++;
      this.stats.total++;
      var sortable = displayObject.sortable;
      if (sortable.dirty) {
        this.sort(displayObject, sortable);
        sortable.dirty = false;
        sortable.dirtyChildren = [];
        sortable.dirtyReason = void 0;
      }
      (sortable.sorted || displayObject.childNodes).forEach(function(child) {
        _this2.renderDisplayObject(child, canvasConfig, renderingContext);
      });
    };
    RenderingService2.prototype.sort = function(displayObject, sortable) {
      if (sortable.sorted && sortable.dirtyReason !== SortReason.Z_INDEX_CHANGED) {
        sortable.dirtyChildren.forEach(function(child) {
          var index3 = displayObject.childNodes.indexOf(child);
          if (index3 === -1) {
            var index_1 = sortable.sorted.indexOf(child);
            if (index_1 >= 0) {
              sortable.sorted.splice(index_1, 1);
            }
          } else {
            if (sortable.sorted.length === 0) {
              sortable.sorted.push(child);
            } else {
              var index_2 = sortedIndex(sortable.sorted, child);
              sortable.sorted.splice(index_2, 0, child);
            }
          }
        });
      } else {
        sortable.sorted = displayObject.childNodes.slice().sort(sortByZIndex);
      }
    };
    RenderingService2.prototype.destroy = function() {
      this.inited = false;
      this.hooks.destroy.call();
      this.globalRuntime.sceneGraphService.clearPendingEvents();
    };
    RenderingService2.prototype.dirtify = function() {
      this.context.renderingContext.renderReasons.add(RenderReason.DISPLAY_OBJECT_CHANGED);
    };
    return RenderingService2;
  }()
);
var ATTRIBUTE_REGEXP = /\[\s*(.*)=(.*)\s*\]/;
var DefaultSceneGraphSelector = (
  /** @class */
  function() {
    function DefaultSceneGraphSelector2() {
    }
    DefaultSceneGraphSelector2.prototype.selectOne = function(query, root3) {
      var _this2 = this;
      if (query.startsWith(".")) {
        return root3.find(function(node) {
          return ((node === null || node === void 0 ? void 0 : node.classList) || []).indexOf(_this2.getIdOrClassname(query)) > -1;
        });
      } else if (query.startsWith("#")) {
        return root3.find(function(node) {
          return node.id === _this2.getIdOrClassname(query);
        });
      } else if (query.startsWith("[")) {
        var _a2 = this.getAttribute(query), name_1 = _a2.name, value_1 = _a2.value;
        if (name_1) {
          return root3.find(function(node) {
            return root3 !== node && (name_1 === "name" ? node.name === value_1 : _this2.attributeToString(node, name_1) === value_1);
          });
        } else {
          return null;
        }
      } else {
        return root3.find(function(node) {
          return root3 !== node && node.nodeName === query;
        });
      }
    };
    DefaultSceneGraphSelector2.prototype.selectAll = function(query, root3) {
      var _this2 = this;
      if (query.startsWith(".")) {
        return root3.findAll(function(node) {
          return root3 !== node && ((node === null || node === void 0 ? void 0 : node.classList) || []).indexOf(_this2.getIdOrClassname(query)) > -1;
        });
      } else if (query.startsWith("#")) {
        return root3.findAll(function(node) {
          return root3 !== node && node.id === _this2.getIdOrClassname(query);
        });
      } else if (query.startsWith("[")) {
        var _a2 = this.getAttribute(query), name_2 = _a2.name, value_2 = _a2.value;
        if (name_2) {
          return root3.findAll(function(node) {
            return root3 !== node && (name_2 === "name" ? node.name === value_2 : _this2.attributeToString(node, name_2) === value_2);
          });
        } else {
          return [];
        }
      } else {
        return root3.findAll(function(node) {
          return root3 !== node && node.nodeName === query;
        });
      }
    };
    DefaultSceneGraphSelector2.prototype.is = function(query, node) {
      if (query.startsWith(".")) {
        return node.className === this.getIdOrClassname(query);
      } else if (query.startsWith("#")) {
        return node.id === this.getIdOrClassname(query);
      } else if (query.startsWith("[")) {
        var _a2 = this.getAttribute(query), name_3 = _a2.name, value2 = _a2.value;
        return name_3 === "name" ? node.name === value2 : this.attributeToString(node, name_3) === value2;
      } else {
        return node.nodeName === query;
      }
    };
    DefaultSceneGraphSelector2.prototype.getIdOrClassname = function(query) {
      return query.substring(1);
    };
    DefaultSceneGraphSelector2.prototype.getAttribute = function(query) {
      var matches2 = query.match(ATTRIBUTE_REGEXP);
      var name2 = "";
      var value2 = "";
      if (matches2 && matches2.length > 2) {
        name2 = matches2[1].replace(/"/g, "");
        value2 = matches2[2].replace(/"/g, "");
      }
      return { name: name2, value: value2 };
    };
    DefaultSceneGraphSelector2.prototype.attributeToString = function(node, name2) {
      if (!node.getAttribute) {
        return "";
      }
      var value2 = node.getAttribute(name2);
      if (is_nil_default(value2)) {
        return "";
      }
      if (value2.toString) {
        return value2.toString();
      }
      return "";
    };
    return DefaultSceneGraphSelector2;
  }()
);
var MutationEvent = (
  /** @class */
  function(_super) {
    __extends(MutationEvent2, _super);
    function MutationEvent2(typeArg, relatedNode, prevValue, newValue, attrName, attrChange, prevParsedValue, newParsedValue) {
      var _this2 = _super.call(this, null) || this;
      _this2.relatedNode = relatedNode;
      _this2.prevValue = prevValue;
      _this2.newValue = newValue;
      _this2.attrName = attrName;
      _this2.attrChange = attrChange;
      _this2.prevParsedValue = prevParsedValue;
      _this2.newParsedValue = newParsedValue;
      _this2.type = typeArg;
      return _this2;
    }
    MutationEvent2.ADDITION = 2;
    MutationEvent2.MODIFICATION = 1;
    MutationEvent2.REMOVAL = 3;
    return MutationEvent2;
  }(FederatedEvent)
);
var ElementEvent;
(function(ElementEvent2) {
  ElementEvent2["REPARENT"] = "reparent";
  ElementEvent2["DESTROY"] = "destroy";
  ElementEvent2["ATTR_MODIFIED"] = "DOMAttrModified";
  ElementEvent2["INSERTED"] = "DOMNodeInserted";
  ElementEvent2["REMOVED"] = "removed";
  ElementEvent2["MOUNTED"] = "DOMNodeInsertedIntoDocument";
  ElementEvent2["UNMOUNTED"] = "DOMNodeRemovedFromDocument";
  ElementEvent2["BOUNDS_CHANGED"] = "bounds-changed";
  ElementEvent2["CULLED"] = "culled";
})(ElementEvent || (ElementEvent = {}));
function markRenderableDirty(e) {
  var renderable = e.renderable;
  if (renderable) {
    renderable.renderBoundsDirty = true;
    renderable.boundsDirty = true;
  }
}
var reparentEvent = new MutationEvent(ElementEvent.REPARENT, null, "", "", "", 0, "", "");
var DefaultSceneGraphService = (
  /** @class */
  function() {
    function DefaultSceneGraphService2(runtime2) {
      var _this2 = this;
      this.runtime = runtime2;
      this.pendingEvents = [];
      this.boundsChangedEvent = new CustomEvent(ElementEvent.BOUNDS_CHANGED);
      this.rotate = function() {
        var parentInvertRotation = quat_exports.create();
        return function(element, degrees3, y3, z) {
          if (y3 === void 0) {
            y3 = 0;
          }
          if (z === void 0) {
            z = 0;
          }
          if (typeof degrees3 === "number") {
            degrees3 = vec3_exports.fromValues(degrees3, y3, z);
          }
          var transform3 = element.transformable;
          if (element.parentNode === null || !element.parentNode.transformable) {
            _this2.rotateLocal(element, degrees3);
          } else {
            var rotation = quat_exports.create();
            quat_exports.fromEuler(rotation, degrees3[0], degrees3[1], degrees3[2]);
            var rot = _this2.getRotation(element);
            var parentRot = _this2.getRotation(element.parentNode);
            quat_exports.copy(parentInvertRotation, parentRot);
            quat_exports.invert(parentInvertRotation, parentInvertRotation);
            quat_exports.multiply(rotation, parentInvertRotation, rotation);
            quat_exports.multiply(transform3.localRotation, rotation, rot);
            quat_exports.normalize(transform3.localRotation, transform3.localRotation);
            _this2.dirtifyLocal(element, transform3);
          }
        };
      }();
      this.rotateLocal = function() {
        var rotation = quat_exports.create();
        return function(element, degrees3, y3, z) {
          if (y3 === void 0) {
            y3 = 0;
          }
          if (z === void 0) {
            z = 0;
          }
          if (typeof degrees3 === "number") {
            degrees3 = vec3_exports.fromValues(degrees3, y3, z);
          }
          var transform3 = element.transformable;
          quat_exports.fromEuler(rotation, degrees3[0], degrees3[1], degrees3[2]);
          quat_exports.mul(transform3.localRotation, transform3.localRotation, rotation);
          _this2.dirtifyLocal(element, transform3);
        };
      }();
      this.setEulerAngles = function() {
        var invParentRot = quat_exports.create();
        return function(element, degrees3, y3, z) {
          if (y3 === void 0) {
            y3 = 0;
          }
          if (z === void 0) {
            z = 0;
          }
          if (typeof degrees3 === "number") {
            degrees3 = vec3_exports.fromValues(degrees3, y3, z);
          }
          var transform3 = element.transformable;
          if (element.parentNode === null || !element.parentNode.transformable) {
            _this2.setLocalEulerAngles(element, degrees3);
          } else {
            quat_exports.fromEuler(transform3.localRotation, degrees3[0], degrees3[1], degrees3[2]);
            var parentRotation = _this2.getRotation(element.parentNode);
            quat_exports.copy(invParentRot, quat_exports.invert(quat_exports.create(), parentRotation));
            quat_exports.mul(transform3.localRotation, transform3.localRotation, invParentRot);
            _this2.dirtifyLocal(element, transform3);
          }
        };
      }();
      this.translateLocal = function() {
        return function(element, translation, y3, z) {
          if (y3 === void 0) {
            y3 = 0;
          }
          if (z === void 0) {
            z = 0;
          }
          if (typeof translation === "number") {
            translation = vec3_exports.fromValues(translation, y3, z);
          }
          var transform3 = element.transformable;
          if (vec3_exports.equals(translation, vec3_exports.create())) {
            return;
          }
          vec3_exports.transformQuat(translation, translation, transform3.localRotation);
          vec3_exports.add(transform3.localPosition, transform3.localPosition, translation);
          _this2.dirtifyLocal(element, transform3);
        };
      }();
      this.setPosition = function() {
        var parentInvertMatrix = mat4_exports.create();
        var tmpPosition = vec3_exports.create();
        return function(element, position) {
          var transform3 = element.transformable;
          tmpPosition[0] = position[0];
          tmpPosition[1] = position[1];
          tmpPosition[2] = position[2] || 0;
          if (vec3_exports.equals(_this2.getPosition(element), tmpPosition)) {
            return;
          }
          vec3_exports.copy(transform3.position, tmpPosition);
          if (element.parentNode === null || !element.parentNode.transformable) {
            vec3_exports.copy(transform3.localPosition, tmpPosition);
          } else {
            var parentTransform = element.parentNode.transformable;
            mat4_exports.copy(parentInvertMatrix, parentTransform.worldTransform);
            mat4_exports.invert(parentInvertMatrix, parentInvertMatrix);
            vec3_exports.transformMat4(transform3.localPosition, tmpPosition, parentInvertMatrix);
          }
          _this2.dirtifyLocal(element, transform3);
        };
      }();
      this.setLocalPosition = function() {
        var tmpPosition = vec3_exports.create();
        return function(element, position) {
          var transform3 = element.transformable;
          tmpPosition[0] = position[0];
          tmpPosition[1] = position[1];
          tmpPosition[2] = position[2] || 0;
          if (vec3_exports.equals(transform3.localPosition, tmpPosition)) {
            return;
          }
          vec3_exports.copy(transform3.localPosition, tmpPosition);
          _this2.dirtifyLocal(element, transform3);
        };
      }();
      this.translate = function() {
        var zeroVec3 = vec3_exports.create();
        var tmpVec3 = vec3_exports.create();
        var tr = vec3_exports.create();
        return function(element, translation, y3, z) {
          if (y3 === void 0) {
            y3 = 0;
          }
          if (z === void 0) {
            z = 0;
          }
          if (typeof translation === "number") {
            translation = vec3_exports.set(tmpVec3, translation, y3, z);
          }
          if (vec3_exports.equals(translation, zeroVec3)) {
            return;
          }
          vec3_exports.add(tr, _this2.getPosition(element), translation);
          _this2.setPosition(element, tr);
        };
      }();
      this.setRotation = function() {
        var parentInvertRotation = quat_exports.create();
        return function(element, rotation, y3, z, w) {
          var transform3 = element.transformable;
          if (typeof rotation === "number") {
            rotation = quat_exports.fromValues(rotation, y3, z, w);
          }
          if (element.parentNode === null || !element.parentNode.transformable) {
            _this2.setLocalRotation(element, rotation);
          } else {
            var parentRot = _this2.getRotation(element.parentNode);
            quat_exports.copy(parentInvertRotation, parentRot);
            quat_exports.invert(parentInvertRotation, parentInvertRotation);
            quat_exports.multiply(transform3.localRotation, parentInvertRotation, rotation);
            quat_exports.normalize(transform3.localRotation, transform3.localRotation);
            _this2.dirtifyLocal(element, transform3);
          }
        };
      };
      this.displayObjectDependencyMap = /* @__PURE__ */ new WeakMap();
      this.calcLocalTransform = function() {
        var tmpMat = mat4_exports.create();
        var tmpPosition = vec3_exports.create();
        var tmpQuat = quat_exports.fromValues(0, 0, 0, 1);
        return function(transform3) {
          var hasSkew = transform3.localSkew[0] !== 0 || transform3.localSkew[1] !== 0;
          if (hasSkew) {
            mat4_exports.fromRotationTranslationScaleOrigin(transform3.localTransform, transform3.localRotation, transform3.localPosition, vec3_exports.fromValues(1, 1, 1), transform3.origin);
            if (transform3.localSkew[0] !== 0 || transform3.localSkew[1] !== 0) {
              var tmpMat43 = mat4_exports.identity(tmpMat);
              tmpMat43[4] = Math.tan(transform3.localSkew[0]);
              tmpMat43[1] = Math.tan(transform3.localSkew[1]);
              mat4_exports.multiply(transform3.localTransform, transform3.localTransform, tmpMat43);
            }
            var scaling = mat4_exports.fromRotationTranslationScaleOrigin(tmpMat, tmpQuat, tmpPosition, transform3.localScale, transform3.origin);
            mat4_exports.multiply(transform3.localTransform, transform3.localTransform, scaling);
          } else {
            mat4_exports.fromRotationTranslationScaleOrigin(transform3.localTransform, transform3.localRotation, transform3.localPosition, transform3.localScale, transform3.origin);
          }
        };
      }();
    }
    DefaultSceneGraphService2.prototype.matches = function(query, root3) {
      return this.runtime.sceneGraphSelector.is(query, root3);
    };
    DefaultSceneGraphService2.prototype.querySelector = function(query, root3) {
      return this.runtime.sceneGraphSelector.selectOne(query, root3);
    };
    DefaultSceneGraphService2.prototype.querySelectorAll = function(query, root3) {
      return this.runtime.sceneGraphSelector.selectAll(query, root3);
    };
    DefaultSceneGraphService2.prototype.attach = function(child, parent2, index3) {
      var _a2, _b;
      var detached = false;
      if (child.parentNode) {
        detached = child.parentNode !== parent2;
        this.detach(child);
      }
      child.parentNode = parent2;
      if (!is_nil_default(index3)) {
        child.parentNode.childNodes.splice(index3, 0, child);
      } else {
        child.parentNode.childNodes.push(child);
      }
      var sortable = parent2.sortable;
      if (((_a2 = sortable === null || sortable === void 0 ? void 0 : sortable.sorted) === null || _a2 === void 0 ? void 0 : _a2.length) || ((_b = child.style) === null || _b === void 0 ? void 0 : _b.zIndex)) {
        if (sortable.dirtyChildren.indexOf(child) === -1) {
          sortable.dirtyChildren.push(child);
        }
        sortable.dirty = true;
        sortable.dirtyReason = SortReason.ADDED;
      }
      var transform3 = child.transformable;
      if (transform3) {
        this.dirtifyWorld(child, transform3);
      }
      if (transform3.frozen) {
        this.unfreezeParentToRoot(child);
      }
      if (detached) {
        child.dispatchEvent(reparentEvent);
      }
    };
    DefaultSceneGraphService2.prototype.detach = function(child) {
      var _a2, _b;
      if (child.parentNode) {
        var transform3 = child.transformable;
        var sortable = child.parentNode.sortable;
        if (((_a2 = sortable === null || sortable === void 0 ? void 0 : sortable.sorted) === null || _a2 === void 0 ? void 0 : _a2.length) || ((_b = child.style) === null || _b === void 0 ? void 0 : _b.zIndex)) {
          if (sortable.dirtyChildren.indexOf(child) === -1) {
            sortable.dirtyChildren.push(child);
          }
          sortable.dirty = true;
          sortable.dirtyReason = SortReason.REMOVED;
        }
        var index3 = child.parentNode.childNodes.indexOf(child);
        if (index3 > -1) {
          child.parentNode.childNodes.splice(index3, 1);
        }
        if (transform3) {
          this.dirtifyWorld(child, transform3);
        }
        child.parentNode = null;
      }
    };
    DefaultSceneGraphService2.prototype.getOrigin = function(element) {
      return element.transformable.origin;
    };
    DefaultSceneGraphService2.prototype.setOrigin = function(element, origin, y3, z) {
      if (y3 === void 0) {
        y3 = 0;
      }
      if (z === void 0) {
        z = 0;
      }
      if (typeof origin === "number") {
        origin = [origin, y3, z];
      }
      var transform3 = element.transformable;
      if (origin[0] === transform3.origin[0] && origin[1] === transform3.origin[1] && origin[2] === transform3.origin[2]) {
        return;
      }
      var originVec = transform3.origin;
      originVec[0] = origin[0];
      originVec[1] = origin[1];
      originVec[2] = origin[2] || 0;
      this.dirtifyLocal(element, transform3);
    };
    DefaultSceneGraphService2.prototype.setLocalEulerAngles = function(element, degrees3, y3, z) {
      if (y3 === void 0) {
        y3 = 0;
      }
      if (z === void 0) {
        z = 0;
      }
      if (typeof degrees3 === "number") {
        degrees3 = vec3_exports.fromValues(degrees3, y3, z);
      }
      var transform3 = element.transformable;
      quat_exports.fromEuler(transform3.localRotation, degrees3[0], degrees3[1], degrees3[2]);
      this.dirtifyLocal(element, transform3);
    };
    DefaultSceneGraphService2.prototype.scaleLocal = function(element, scaling) {
      var transform3 = element.transformable;
      vec3_exports.multiply(transform3.localScale, transform3.localScale, vec3_exports.fromValues(scaling[0], scaling[1], scaling[2] || 1));
      this.dirtifyLocal(element, transform3);
    };
    DefaultSceneGraphService2.prototype.setLocalScale = function(element, scaling) {
      var transform3 = element.transformable;
      var updatedScaling = vec3_exports.fromValues(scaling[0], scaling[1], scaling[2] || transform3.localScale[2]);
      if (vec3_exports.equals(updatedScaling, transform3.localScale)) {
        return;
      }
      vec3_exports.copy(transform3.localScale, updatedScaling);
      this.dirtifyLocal(element, transform3);
    };
    DefaultSceneGraphService2.prototype.setLocalRotation = function(element, rotation, y3, z, w) {
      if (typeof rotation === "number") {
        rotation = quat_exports.fromValues(rotation, y3, z, w);
      }
      var transform3 = element.transformable;
      quat_exports.copy(transform3.localRotation, rotation);
      this.dirtifyLocal(element, transform3);
    };
    DefaultSceneGraphService2.prototype.setLocalSkew = function(element, skew, y3) {
      if (typeof skew === "number") {
        skew = vec2_exports.fromValues(skew, y3);
      }
      var transform3 = element.transformable;
      vec2_exports.copy(transform3.localSkew, skew);
      this.dirtifyLocal(element, transform3);
    };
    DefaultSceneGraphService2.prototype.dirtifyLocal = function(element, transform3) {
      if (!transform3.localDirtyFlag) {
        transform3.localDirtyFlag = true;
        if (!transform3.dirtyFlag) {
          this.dirtifyWorld(element, transform3);
        }
      }
    };
    DefaultSceneGraphService2.prototype.dirtifyWorld = function(element, transform3) {
      if (!transform3.dirtyFlag) {
        this.unfreezeParentToRoot(element);
      }
      this.dirtifyWorldInternal(element, transform3);
      this.dirtifyToRoot(element, true);
    };
    DefaultSceneGraphService2.prototype.triggerPendingEvents = function() {
      var _this2 = this;
      var set9 = /* @__PURE__ */ new Set();
      var trigger = function(element, detail) {
        if (element.isConnected && !set9.has(element.entity)) {
          _this2.boundsChangedEvent.detail = detail;
          _this2.boundsChangedEvent.target = element;
          if (element.isMutationObserved) {
            element.dispatchEvent(_this2.boundsChangedEvent);
          } else {
            element.ownerDocument.defaultView.dispatchEvent(_this2.boundsChangedEvent, true);
          }
          set9.add(element.entity);
        }
      };
      this.pendingEvents.forEach(function(_a2) {
        var _b = __read(_a2, 2), element = _b[0], detail = _b[1];
        if (detail.affectChildren) {
          element.forEach(function(e) {
            trigger(e, detail);
          });
        } else {
          trigger(element, detail);
        }
      });
      this.clearPendingEvents();
      set9.clear();
    };
    DefaultSceneGraphService2.prototype.clearPendingEvents = function() {
      this.pendingEvents = [];
    };
    DefaultSceneGraphService2.prototype.dirtifyToRoot = function(element, affectChildren) {
      if (affectChildren === void 0) {
        affectChildren = false;
      }
      var p2 = element;
      if (p2.renderable) {
        p2.renderable.dirty = true;
      }
      while (p2) {
        markRenderableDirty(p2);
        p2 = p2.parentNode;
      }
      if (affectChildren) {
        element.forEach(function(e) {
          markRenderableDirty(e);
        });
      }
      this.informDependentDisplayObjects(element);
      this.pendingEvents.push([element, { affectChildren }]);
    };
    DefaultSceneGraphService2.prototype.updateDisplayObjectDependency = function(name2, oldPath, newPath, object) {
      if (oldPath && oldPath !== newPath) {
        var oldDependencyMap = this.displayObjectDependencyMap.get(oldPath);
        if (oldDependencyMap && oldDependencyMap[name2]) {
          var index3 = oldDependencyMap[name2].indexOf(object);
          oldDependencyMap[name2].splice(index3, 1);
        }
      }
      if (newPath) {
        var newDependencyMap = this.displayObjectDependencyMap.get(newPath);
        if (!newDependencyMap) {
          this.displayObjectDependencyMap.set(newPath, {});
          newDependencyMap = this.displayObjectDependencyMap.get(newPath);
        }
        if (!newDependencyMap[name2]) {
          newDependencyMap[name2] = [];
        }
        newDependencyMap[name2].push(object);
      }
    };
    DefaultSceneGraphService2.prototype.informDependentDisplayObjects = function(object) {
      var _this2 = this;
      var dependencyMap = this.displayObjectDependencyMap.get(object);
      if (dependencyMap) {
        Object.keys(dependencyMap).forEach(function(name2) {
          dependencyMap[name2].forEach(function(target) {
            _this2.dirtifyToRoot(target, true);
            target.dispatchEvent(new MutationEvent(ElementEvent.ATTR_MODIFIED, target, _this2, _this2, name2, MutationEvent.MODIFICATION, _this2, _this2));
            if (target.isCustomElement && target.isConnected) {
              if (target.attributeChangedCallback) {
                target.attributeChangedCallback(name2, _this2, _this2);
              }
            }
          });
        });
      }
    };
    DefaultSceneGraphService2.prototype.getPosition = function(element) {
      var transform3 = element.transformable;
      return mat4_exports.getTranslation(transform3.position, this.getWorldTransform(element, transform3));
    };
    DefaultSceneGraphService2.prototype.getRotation = function(element) {
      var transform3 = element.transformable;
      return mat4_exports.getRotation(transform3.rotation, this.getWorldTransform(element, transform3));
    };
    DefaultSceneGraphService2.prototype.getScale = function(element) {
      var transform3 = element.transformable;
      return mat4_exports.getScaling(transform3.scaling, this.getWorldTransform(element, transform3));
    };
    DefaultSceneGraphService2.prototype.getWorldTransform = function(element, transform3) {
      if (transform3 === void 0) {
        transform3 = element.transformable;
      }
      if (!transform3.localDirtyFlag && !transform3.dirtyFlag) {
        return transform3.worldTransform;
      }
      if (element.parentNode && element.parentNode.transformable) {
        this.getWorldTransform(element.parentNode);
      }
      this.sync(element, transform3);
      return transform3.worldTransform;
    };
    DefaultSceneGraphService2.prototype.getLocalPosition = function(element) {
      return element.transformable.localPosition;
    };
    DefaultSceneGraphService2.prototype.getLocalRotation = function(element) {
      return element.transformable.localRotation;
    };
    DefaultSceneGraphService2.prototype.getLocalScale = function(element) {
      return element.transformable.localScale;
    };
    DefaultSceneGraphService2.prototype.getLocalSkew = function(element) {
      return element.transformable.localSkew;
    };
    DefaultSceneGraphService2.prototype.getLocalTransform = function(element) {
      var transform3 = element.transformable;
      if (transform3.localDirtyFlag) {
        this.calcLocalTransform(transform3);
        transform3.localDirtyFlag = false;
      }
      return transform3.localTransform;
    };
    DefaultSceneGraphService2.prototype.setLocalTransform = function(element, transform3) {
      var t = mat4_exports.getTranslation(vec3_exports.create(), transform3);
      var r = mat4_exports.getRotation(quat_exports.create(), transform3);
      var s2 = mat4_exports.getScaling(vec3_exports.create(), transform3);
      this.setLocalScale(element, s2);
      this.setLocalPosition(element, t);
      this.setLocalRotation(element, r);
    };
    DefaultSceneGraphService2.prototype.resetLocalTransform = function(element) {
      this.setLocalScale(element, [1, 1, 1]);
      this.setLocalPosition(element, [0, 0, 0]);
      this.setLocalEulerAngles(element, [0, 0, 0]);
      this.setLocalSkew(element, [0, 0]);
    };
    DefaultSceneGraphService2.prototype.getTransformedGeometryBounds = function(element, render3, existedAABB) {
      if (render3 === void 0) {
        render3 = false;
      }
      var bounds = this.getGeometryBounds(element, render3);
      if (!AABB.isEmpty(bounds)) {
        var aabb = existedAABB || new AABB();
        aabb.setFromTransformedAABB(bounds, this.getWorldTransform(element));
        return aabb;
      } else {
        return null;
      }
    };
    DefaultSceneGraphService2.prototype.getGeometryBounds = function(element, render3) {
      if (render3 === void 0) {
        render3 = false;
      }
      var geometry = element.geometry;
      var bounds = render3 ? geometry.renderBounds : geometry.contentBounds || null;
      return bounds || new AABB();
    };
    DefaultSceneGraphService2.prototype.getBounds = function(element, render3) {
      var _this2 = this;
      if (render3 === void 0) {
        render3 = false;
      }
      var renderable = element.renderable;
      if (!renderable.boundsDirty && !render3 && renderable.bounds) {
        return renderable.bounds;
      }
      if (!renderable.renderBoundsDirty && render3 && renderable.renderBounds) {
        return renderable.renderBounds;
      }
      var existedAABB = render3 ? renderable.renderBounds : renderable.bounds;
      var aabb = this.getTransformedGeometryBounds(element, render3, existedAABB);
      var children = element.childNodes;
      children.forEach(function(child) {
        var childBounds = _this2.getBounds(child, render3);
        if (childBounds) {
          if (!aabb) {
            aabb = existedAABB || new AABB();
            aabb.update(childBounds.center, childBounds.halfExtents);
          } else {
            aabb.add(childBounds);
          }
        }
      });
      if (render3) {
        var clipped = findClosestClipPathTarget(element);
        if (clipped) {
          var clipPathBounds = clipped.parsedStyle.clipPath.getBounds(render3);
          if (!aabb) {
            aabb = clipPathBounds;
          } else if (clipPathBounds) {
            aabb = clipPathBounds.intersection(aabb);
          }
        }
      }
      if (!aabb) {
        aabb = new AABB();
      }
      if (aabb) {
        if (render3) {
          renderable.renderBounds = aabb;
        } else {
          renderable.bounds = aabb;
        }
      }
      if (render3) {
        renderable.renderBoundsDirty = false;
      } else {
        renderable.boundsDirty = false;
      }
      return aabb;
    };
    DefaultSceneGraphService2.prototype.getLocalBounds = function(element) {
      if (element.parentNode) {
        var parentInvert = mat4_exports.create();
        if (element.parentNode.transformable) {
          parentInvert = mat4_exports.invert(mat4_exports.create(), this.getWorldTransform(element.parentNode));
        }
        var bounds = this.getBounds(element);
        if (!AABB.isEmpty(bounds)) {
          var localBounds = new AABB();
          localBounds.setFromTransformedAABB(bounds, parentInvert);
          return localBounds;
        }
      }
      return this.getBounds(element);
    };
    DefaultSceneGraphService2.prototype.getBoundingClientRect = function(element) {
      var _a2, _b;
      var aabb;
      var bounds = this.getGeometryBounds(element);
      if (!AABB.isEmpty(bounds)) {
        aabb = new AABB();
        aabb.setFromTransformedAABB(bounds, this.getWorldTransform(element));
      }
      var bbox = (_b = (_a2 = element.ownerDocument) === null || _a2 === void 0 ? void 0 : _a2.defaultView) === null || _b === void 0 ? void 0 : _b.getContextService().getBoundingClientRect();
      if (aabb) {
        var _c = __read(aabb.getMin(), 2), left2 = _c[0], top_1 = _c[1];
        var _d = __read(aabb.getMax(), 2), right2 = _d[0], bottom = _d[1];
        return new Rectangle(left2 + ((bbox === null || bbox === void 0 ? void 0 : bbox.left) || 0), top_1 + ((bbox === null || bbox === void 0 ? void 0 : bbox.top) || 0), right2 - left2, bottom - top_1);
      }
      return new Rectangle((bbox === null || bbox === void 0 ? void 0 : bbox.left) || 0, (bbox === null || bbox === void 0 ? void 0 : bbox.top) || 0, 0, 0);
    };
    DefaultSceneGraphService2.prototype.dirtifyWorldInternal = function(element, transform3) {
      var _this2 = this;
      if (!transform3.dirtyFlag) {
        transform3.dirtyFlag = true;
        transform3.frozen = false;
        element.childNodes.forEach(function(child) {
          var childTransform = child.transformable;
          if (!childTransform.dirtyFlag) {
            _this2.dirtifyWorldInternal(child, childTransform);
          }
        });
        var renderable = element.renderable;
        if (renderable) {
          renderable.renderBoundsDirty = true;
          renderable.boundsDirty = true;
          renderable.dirty = true;
        }
      }
    };
    DefaultSceneGraphService2.prototype.syncHierarchy = function(element) {
      var transform3 = element.transformable;
      if (transform3.frozen) {
        return;
      }
      transform3.frozen = true;
      if (transform3.localDirtyFlag || transform3.dirtyFlag) {
        this.sync(element, transform3);
      }
      var children = element.childNodes;
      for (var i = 0; i < children.length; i++) {
        this.syncHierarchy(children[i]);
      }
    };
    DefaultSceneGraphService2.prototype.sync = function(element, transform3) {
      if (transform3.localDirtyFlag) {
        this.calcLocalTransform(transform3);
        transform3.localDirtyFlag = false;
      }
      if (transform3.dirtyFlag) {
        var parent_1 = element.parentNode;
        var parentTransform = parent_1 && parent_1.transformable;
        if (parent_1 === null || !parentTransform) {
          mat4_exports.copy(transform3.worldTransform, transform3.localTransform);
        } else {
          mat4_exports.multiply(transform3.worldTransform, parentTransform.worldTransform, transform3.localTransform);
        }
        transform3.dirtyFlag = false;
      }
    };
    DefaultSceneGraphService2.prototype.unfreezeParentToRoot = function(child) {
      var p2 = child.parentNode;
      while (p2) {
        var transform3 = p2.transformable;
        if (transform3) {
          transform3.frozen = false;
        }
        p2 = p2.parentNode;
      }
    };
    return DefaultSceneGraphService2;
  }()
);
var TEXT_METRICS = {
  MetricsString: "|q",
  BaselineSymbol: "M",
  BaselineMultiplier: 1.4,
  HeightMultiplier: 2,
  Newlines: [
    10,
    // line feed
    13
    // carriage return
  ],
  BreakingSpaces: [
    9,
    // character tabulation
    32,
    // space
    8192,
    // en quad
    8193,
    // em quad
    8194,
    // en space
    8195,
    // em space
    8196,
    // three-per-em space
    8197,
    // four-per-em space
    8198,
    // six-per-em space
    8200,
    // punctuation space
    8201,
    // thin space
    8202,
    // hair space
    8287,
    // medium mathematical space
    12288
    // ideographic space
  ]
};
var LATIN_REGEX = /[a-zA-Z0-9\u00C0-\u00D6\u00D8-\u00f6\u00f8-\u00ff!"#$%&'()*+,-./:;]/;
var regexCannotStartZhCn = /[!%),.:;?\]}'""]/;
var regexCannotEndZhCn = /[$('"]/;
var regexCannotStartZhTw = /[!),.:;?\]}'""]/;
var regexCannotEndZhTw = /[([{'"]/;
var regexCannotStartJaJp = /[)\]'"?!:;,.]/;
var regexCannotEndJaJp = /[(['"...]/;
var regexCannotStartKoKr = /[!%),.:;?\]}'"]/;
var regexCannotEndKoKr = /[$([{'"#]/;
var regexCannotStart = new RegExp("".concat(regexCannotStartZhCn.source, "|").concat(regexCannotStartZhTw.source, "|").concat(regexCannotStartJaJp.source, "|").concat(regexCannotStartKoKr.source));
var regexCannotEnd = new RegExp("".concat(regexCannotEndZhCn.source, "|").concat(regexCannotEndZhTw.source, "|").concat(regexCannotEndJaJp.source, "|").concat(regexCannotEndKoKr.source));
var TextService = (
  /** @class */
  function() {
    function TextService2(runtime2) {
      var _this2 = this;
      this.runtime = runtime2;
      this.fontMetricsCache = {};
      this.shouldBreakByKinsokuShorui = function(char, nextChar) {
        if (_this2.isBreakingSpace(nextChar))
          return false;
        if (char) {
          if (regexCannotEnd.exec(nextChar) || regexCannotStart.exec(char)) {
            return true;
          }
        }
        return false;
      };
      this.trimByKinsokuShorui = function(prev) {
        var next = __spreadArray([], __read(prev), false);
        var prevLine = next[next.length - 2];
        if (!prevLine) {
          return prev;
        }
        var lastChar = prevLine[prevLine.length - 1];
        next[next.length - 2] = prevLine.slice(0, -1);
        next[next.length - 1] = lastChar + next[next.length - 1];
        return next;
      };
    }
    TextService2.prototype.measureFont = function(font, offscreenCanvas) {
      if (this.fontMetricsCache[font]) {
        return this.fontMetricsCache[font];
      }
      var properties = {
        ascent: 0,
        descent: 0,
        fontSize: 0
      };
      var canvas = this.runtime.offscreenCanvasCreator.getOrCreateCanvas(offscreenCanvas);
      var context = this.runtime.offscreenCanvasCreator.getOrCreateContext(offscreenCanvas, {
        willReadFrequently: true
      });
      context.font = font;
      var metricsString = TEXT_METRICS.MetricsString + TEXT_METRICS.BaselineSymbol;
      var width = Math.ceil(context.measureText(metricsString).width);
      var baseline = Math.ceil(context.measureText(TEXT_METRICS.BaselineSymbol).width);
      var height = TEXT_METRICS.HeightMultiplier * baseline;
      baseline = baseline * TEXT_METRICS.BaselineMultiplier | 0;
      canvas.width = width;
      canvas.height = height;
      context.fillStyle = "#f00";
      context.fillRect(0, 0, width, height);
      context.font = font;
      context.textBaseline = "alphabetic";
      context.fillStyle = "#000";
      context.fillText(metricsString, 0, baseline);
      var imagedata = context.getImageData(0, 0, width || 1, height || 1).data;
      var pixels = imagedata.length;
      var line4 = width * 4;
      var i = 0;
      var idx = 0;
      var stop = false;
      for (i = 0; i < baseline; ++i) {
        for (var j = 0; j < line4; j += 4) {
          if (imagedata[idx + j] !== 255) {
            stop = true;
            break;
          }
        }
        if (!stop) {
          idx += line4;
        } else {
          break;
        }
      }
      properties.ascent = baseline - i;
      idx = pixels - line4;
      stop = false;
      for (i = height; i > baseline; --i) {
        for (var j = 0; j < line4; j += 4) {
          if (imagedata[idx + j] !== 255) {
            stop = true;
            break;
          }
        }
        if (!stop) {
          idx -= line4;
        } else {
          break;
        }
      }
      properties.descent = i - baseline;
      properties.fontSize = properties.ascent + properties.descent;
      this.fontMetricsCache[font] = properties;
      return properties;
    };
    TextService2.prototype.measureText = function(text, parsedStyle, offscreenCanvas) {
      var fontSize = parsedStyle.fontSize, wordWrap = parsedStyle.wordWrap, strokeHeight = parsedStyle.lineHeight, lineWidth = parsedStyle.lineWidth, textBaseline = parsedStyle.textBaseline, textAlign = parsedStyle.textAlign, letterSpacing = parsedStyle.letterSpacing, textPath = parsedStyle.textPath;
      parsedStyle.textPathSide;
      parsedStyle.textPathStartOffset;
      var _a2 = parsedStyle.leading, leading = _a2 === void 0 ? 0 : _a2;
      var font = toFontString(parsedStyle);
      var fontProperties = this.measureFont(font, offscreenCanvas);
      if (fontProperties.fontSize === 0) {
        fontProperties.fontSize = fontSize;
        fontProperties.ascent = fontSize;
      }
      var context = this.runtime.offscreenCanvasCreator.getOrCreateContext(offscreenCanvas);
      context.font = font;
      parsedStyle.isOverflowing = false;
      var outputText = wordWrap ? this.wordWrap(text, parsedStyle, offscreenCanvas) : text;
      var lines = outputText.split(/(?:\r\n|\r|\n)/);
      var lineWidths = new Array(lines.length);
      var maxLineWidth = 0;
      if (textPath) {
        textPath.getTotalLength();
        for (var i = 0; i < lines.length; i++) {
          var width = context.measureText(lines[i]).width + (lines[i].length - 1) * letterSpacing;
        }
      } else {
        for (var i = 0; i < lines.length; i++) {
          var lineWidth_1 = context.measureText(lines[i]).width + (lines[i].length - 1) * letterSpacing;
          lineWidths[i] = lineWidth_1;
          maxLineWidth = Math.max(maxLineWidth, lineWidth_1);
        }
        var width = maxLineWidth + lineWidth;
        var lineHeight_1 = strokeHeight || fontProperties.fontSize + lineWidth;
        var height = Math.max(lineHeight_1, fontProperties.fontSize + lineWidth) + (lines.length - 1) * (lineHeight_1 + leading);
        lineHeight_1 += leading;
        var offsetY_1 = 0;
        if (textBaseline === "middle") {
          offsetY_1 = -height / 2;
        } else if (textBaseline === "bottom" || textBaseline === "alphabetic" || textBaseline === "ideographic") {
          offsetY_1 = -height;
        } else if (textBaseline === "top" || textBaseline === "hanging") {
          offsetY_1 = 0;
        }
        return {
          font,
          width,
          height,
          lines,
          lineWidths,
          lineHeight: lineHeight_1,
          maxLineWidth,
          fontProperties,
          lineMetrics: lineWidths.map(function(width2, i2) {
            var offsetX = 0;
            if (textAlign === "center" || textAlign === "middle") {
              offsetX -= width2 / 2;
            } else if (textAlign === "right" || textAlign === "end") {
              offsetX -= width2;
            }
            return new Rectangle(offsetX - lineWidth / 2, offsetY_1 + i2 * lineHeight_1, width2 + lineWidth, lineHeight_1);
          })
        };
      }
    };
    TextService2.prototype.setGraphemeOnPath = function() {
    };
    TextService2.prototype.wordWrap = function(text, parsedStyle, offscreenCanvas) {
      var _this2 = this;
      var _a2 = parsedStyle.wordWrapWidth, wordWrapWidth = _a2 === void 0 ? 0 : _a2, letterSpacing = parsedStyle.letterSpacing, _b = parsedStyle.maxLines, maxLines = _b === void 0 ? Infinity : _b, textOverflow = parsedStyle.textOverflow;
      var context = this.runtime.offscreenCanvasCreator.getOrCreateContext(offscreenCanvas);
      var maxWidth = wordWrapWidth + letterSpacing;
      var ellipsis = "";
      if (textOverflow === "ellipsis") {
        ellipsis = "...";
      } else if (textOverflow && textOverflow !== "clip") {
        ellipsis = textOverflow;
      }
      var lines = [];
      var currentIndex = 0;
      var currentWidth = 0;
      var cache2 = {};
      var calcWidth = function(char2) {
        return _this2.getFromCache(char2, letterSpacing, cache2, context);
      };
      var ellipsisWidth = Array.from(ellipsis).reduce(function(prev, cur) {
        return prev + calcWidth(cur);
      }, 0);
      var chars = Array.from(text);
      for (var i = 0; i < chars.length; i++) {
        var char = chars[i];
        var prevChar = text[i - 1];
        var nextChar = text[i + 1];
        var charWidth = calcWidth(char);
        if (this.isNewline(char)) {
          currentIndex++;
          if (currentIndex >= maxLines) {
            parsedStyle.isOverflowing = true;
            break;
          }
          currentWidth = 0;
          lines[currentIndex] = "";
          continue;
        }
        if (currentWidth > 0 && currentWidth + charWidth > maxWidth) {
          if (currentIndex + 1 >= maxLines) {
            parsedStyle.isOverflowing = true;
            if (ellipsisWidth > 0 && ellipsisWidth <= maxWidth) {
              var currentLineLength = lines[currentIndex].length;
              var lastLineWidth = 0;
              var lastLineIndex = currentLineLength;
              for (var i_1 = 0; i_1 < currentLineLength; i_1++) {
                var width = calcWidth(lines[currentIndex][i_1]);
                if (lastLineWidth + width + ellipsisWidth > maxWidth) {
                  lastLineIndex = i_1;
                  break;
                }
                lastLineWidth += width;
              }
              lines[currentIndex] = (lines[currentIndex] || "").slice(0, lastLineIndex) + ellipsis;
            }
            break;
          }
          currentIndex++;
          currentWidth = 0;
          lines[currentIndex] = "";
          if (this.isBreakingSpace(char)) {
            continue;
          }
          if (!this.canBreakInLastChar(char)) {
            lines = this.trimToBreakable(lines);
            currentWidth = this.sumTextWidthByCache(lines[currentIndex] || "", cache2);
          }
          if (this.shouldBreakByKinsokuShorui(char, nextChar)) {
            lines = this.trimByKinsokuShorui(lines);
            currentWidth += calcWidth(prevChar || "");
          }
        }
        currentWidth += charWidth;
        lines[currentIndex] = (lines[currentIndex] || "") + char;
      }
      return lines.join("\n");
    };
    TextService2.prototype.isBreakingSpace = function(char) {
      if (typeof char !== "string") {
        return false;
      }
      return TEXT_METRICS.BreakingSpaces.indexOf(char.charCodeAt(0)) >= 0;
    };
    TextService2.prototype.isNewline = function(char) {
      if (typeof char !== "string") {
        return false;
      }
      return TEXT_METRICS.Newlines.indexOf(char.charCodeAt(0)) >= 0;
    };
    TextService2.prototype.trimToBreakable = function(prev) {
      var next = __spreadArray([], __read(prev), false);
      var prevLine = next[next.length - 2];
      var index3 = this.findBreakableIndex(prevLine);
      if (index3 === -1 || !prevLine)
        return next;
      var trimmedChar = prevLine.slice(index3, index3 + 1);
      var isTrimmedWithSpace = this.isBreakingSpace(trimmedChar);
      var trimFrom = index3 + 1;
      var trimTo = index3 + (isTrimmedWithSpace ? 0 : 1);
      next[next.length - 1] += prevLine.slice(trimFrom, prevLine.length);
      next[next.length - 2] = prevLine.slice(0, trimTo);
      return next;
    };
    TextService2.prototype.canBreakInLastChar = function(char) {
      if (char && LATIN_REGEX.test(char))
        return false;
      return true;
    };
    TextService2.prototype.sumTextWidthByCache = function(text, cache2) {
      return text.split("").reduce(function(sum5, c5) {
        if (!cache2[c5])
          throw Error("cannot count the word without cache");
        return sum5 + cache2[c5];
      }, 0);
    };
    TextService2.prototype.findBreakableIndex = function(line4) {
      for (var i = line4.length - 1; i >= 0; i--) {
        if (!LATIN_REGEX.test(line4[i]))
          return i;
      }
      return -1;
    };
    TextService2.prototype.getFromCache = function(key, letterSpacing, cache2, context) {
      var width = cache2[key];
      if (typeof width !== "number") {
        var spacing = key.length * letterSpacing;
        width = context.measureText(key).width + spacing;
        cache2[key] = width;
      }
      return width;
    };
    return TextService2;
  }()
);
var runtime = {};
var geometryUpdaterFactory = function() {
  var _a2;
  var rectUpdater = new RectUpdater();
  var polylineUpdater = new PolylineUpdater();
  return _a2 = {}, _a2[Shape.CIRCLE] = new CircleUpdater(), _a2[Shape.ELLIPSE] = new EllipseUpdater(), _a2[Shape.RECT] = rectUpdater, _a2[Shape.IMAGE] = rectUpdater, _a2[Shape.GROUP] = rectUpdater, _a2[Shape.LINE] = new LineUpdater(), _a2[Shape.TEXT] = new TextUpdater(runtime), _a2[Shape.POLYLINE] = polylineUpdater, _a2[Shape.POLYGON] = polylineUpdater, _a2[Shape.PATH] = new PathUpdater(), _a2[Shape.HTML] = null, _a2[Shape.MESH] = null, _a2;
}();
var CSSPropertySyntaxFactory = function() {
  var _a2;
  var color2 = new CSSPropertyColor();
  var length5 = new CSSPropertyLengthOrPercentage();
  return _a2 = {}, _a2[PropertySyntax.PERCENTAGE] = null, _a2[PropertySyntax.NUMBER] = new CSSPropertyNumber(), _a2[PropertySyntax.ANGLE] = new CSSPropertyAngle(), _a2[PropertySyntax.DEFINED_PATH] = new CSSPropertyClipPath(), _a2[PropertySyntax.PAINT] = color2, _a2[PropertySyntax.COLOR] = color2, _a2[PropertySyntax.FILTER] = new CSSPropertyFilter(), _a2[PropertySyntax.LENGTH] = length5, _a2[PropertySyntax.LENGTH_PERCENTAGE] = length5, _a2[PropertySyntax.LENGTH_PERCENTAGE_12] = new CSSPropertyLengthOrPercentage12(), _a2[PropertySyntax.LENGTH_PERCENTAGE_14] = new CSSPropertyLengthOrPercentage14(), _a2[PropertySyntax.COORDINATE] = new CSSPropertyLocalPosition(), _a2[PropertySyntax.OFFSET_DISTANCE] = new CSSPropertyOffsetDistance(), _a2[PropertySyntax.OPACITY_VALUE] = new CSSPropertyOpacity(), _a2[PropertySyntax.PATH] = new CSSPropertyPath(), _a2[PropertySyntax.LIST_OF_POINTS] = new CSSPropertyPoints(), _a2[PropertySyntax.SHADOW_BLUR] = new CSSPropertyShadowBlur(), _a2[PropertySyntax.TEXT] = new CSSPropertyText(), _a2[PropertySyntax.TEXT_TRANSFORM] = new CSSPropertyTextTransform(), _a2[PropertySyntax.TRANSFORM] = new CSSPropertyTransform(), _a2[PropertySyntax.TRANSFORM_ORIGIN] = new CSSPropertyTransformOrigin(), _a2[PropertySyntax.Z_INDEX] = new CSSPropertyZIndex(), _a2[PropertySyntax.MARKER] = new CSSPropertyMarker(), _a2;
}();
var getGlobalThis = function() {
  if (typeof globalThis !== "undefined")
    return globalThis;
  if (typeof self !== "undefined")
    return self;
  if (typeof window !== "undefined")
    return window;
  if (typeof global !== "undefined")
    return global;
  return {};
};
runtime.CameraContribution = Camera;
runtime.AnimationTimeline = null;
runtime.EasingFunction = null;
runtime.offscreenCanvasCreator = new OffscreenCanvasCreator();
runtime.sceneGraphSelector = new DefaultSceneGraphSelector();
runtime.sceneGraphService = new DefaultSceneGraphService(runtime);
runtime.textService = new TextService(runtime);
runtime.geometryUpdaterFactory = geometryUpdaterFactory;
runtime.CSSPropertySyntaxFactory = CSSPropertySyntaxFactory;
runtime.styleValueRegistry = new DefaultStyleValueRegistry(runtime);
runtime.layoutRegistry = null;
runtime.globalThis = getGlobalThis();
runtime.enableCSSParsing = true;
runtime.enableDataset = false;
runtime.enableStyleSyntax = true;
var entityCounter = 0;
var insertedEvent = new MutationEvent(ElementEvent.INSERTED, null, "", "", "", 0, "", "");
var removedEvent = new MutationEvent(ElementEvent.REMOVED, null, "", "", "", 0, "", "");
var destroyEvent = new CustomEvent(ElementEvent.DESTROY);
var Element2 = (
  /** @class */
  function(_super) {
    __extends(Element3, _super);
    function Element3() {
      var _this2 = _super.apply(this, __spreadArray([], __read(arguments), false)) || this;
      _this2.entity = entityCounter++;
      _this2.renderable = {
        bounds: void 0,
        boundsDirty: true,
        renderBounds: void 0,
        renderBoundsDirty: true,
        dirtyRenderBounds: void 0,
        dirty: false
      };
      _this2.cullable = {
        strategy: Strategy.Standard,
        visibilityPlaneMask: -1,
        visible: true,
        enable: true
      };
      _this2.transformable = {
        dirtyFlag: false,
        localDirtyFlag: false,
        frozen: false,
        localPosition: [0, 0, 0],
        localRotation: [0, 0, 0, 1],
        localScale: [1, 1, 1],
        localTransform: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1],
        localSkew: [0, 0],
        position: [0, 0, 0],
        rotation: [0, 0, 0, 1],
        scaling: [1, 1, 1],
        worldTransform: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1],
        origin: [0, 0, 0]
      };
      _this2.sortable = {
        dirty: false,
        sorted: void 0,
        renderOrder: 0,
        dirtyChildren: [],
        dirtyReason: void 0
      };
      _this2.geometry = {
        contentBounds: void 0,
        renderBounds: void 0
      };
      _this2.rBushNode = {
        aabb: void 0
      };
      _this2.namespaceURI = "g";
      _this2.scrollLeft = 0;
      _this2.scrollTop = 0;
      _this2.clientTop = 0;
      _this2.clientLeft = 0;
      _this2.destroyed = false;
      _this2.style = {};
      _this2.computedStyle = runtime.enableCSSParsing ? {
        anchor: unsetKeywordValue,
        opacity: unsetKeywordValue,
        fillOpacity: unsetKeywordValue,
        strokeOpacity: unsetKeywordValue,
        fill: unsetKeywordValue,
        stroke: unsetKeywordValue,
        transform: unsetKeywordValue,
        transformOrigin: unsetKeywordValue,
        visibility: unsetKeywordValue,
        pointerEvents: unsetKeywordValue,
        lineWidth: unsetKeywordValue,
        lineCap: unsetKeywordValue,
        lineJoin: unsetKeywordValue,
        increasedLineWidthForHitTesting: unsetKeywordValue,
        fontSize: unsetKeywordValue,
        fontFamily: unsetKeywordValue,
        fontStyle: unsetKeywordValue,
        fontWeight: unsetKeywordValue,
        fontVariant: unsetKeywordValue,
        textAlign: unsetKeywordValue,
        textBaseline: unsetKeywordValue,
        textTransform: unsetKeywordValue,
        zIndex: unsetKeywordValue,
        filter: unsetKeywordValue,
        shadowType: unsetKeywordValue
      } : null;
      _this2.parsedStyle = {
        // opacity: '',
        // fillOpacity: '',
        // strokeOpacity: '',
        // transformOrigin: '',
        // visibility: '',
        // pointerEvents: '',
        // lineWidth: '',
        // lineCap: '',
        // lineJoin: '',
        // increasedLineWidthForHitTesting: '',
        // fontSize: '',
        // fontFamily: '',
        // fontStyle: '',
        // fontWeight: '',
        // fontVariant: '',
        // textAlign: '',
        // textBaseline: '',
        // textTransform: '',
      };
      _this2.attributes = {};
      return _this2;
    }
    Object.defineProperty(Element3.prototype, "className", {
      /**
       * used in `getElementsByClassName`
       * @see https://developer.mozilla.org/en-US/docs/Web/API/Document/getElementsByClassName
       */
      get: function() {
        return this.getAttribute("class") || "";
      },
      set: function(className2) {
        this.setAttribute("class", className2);
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Element3.prototype, "classList", {
      /**
       * @see https://developer.mozilla.org/en-US/docs/Web/API/Element/classList
       */
      get: function() {
        return this.className.split(" ").filter(function(c5) {
          return c5 !== "";
        });
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Element3.prototype, "tagName", {
      get: function() {
        return this.nodeName;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Element3.prototype, "children", {
      get: function() {
        return this.childNodes;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Element3.prototype, "childElementCount", {
      get: function() {
        return this.childNodes.length;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Element3.prototype, "firstElementChild", {
      get: function() {
        return this.firstChild;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Element3.prototype, "lastElementChild", {
      get: function() {
        return this.lastChild;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Element3.prototype, "parentElement", {
      get: function() {
        return this.parentNode;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Element3.prototype, "nextSibling", {
      get: function() {
        if (this.parentNode) {
          var index3 = this.parentNode.childNodes.indexOf(this);
          return this.parentNode.childNodes[index3 + 1] || null;
        }
        return null;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Element3.prototype, "previousSibling", {
      get: function() {
        if (this.parentNode) {
          var index3 = this.parentNode.childNodes.indexOf(this);
          return this.parentNode.childNodes[index3 - 1] || null;
        }
        return null;
      },
      enumerable: false,
      configurable: true
    });
    Element3.prototype.cloneNode = function(deep2) {
      throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
    };
    Element3.prototype.appendChild = function(child, index3) {
      var _a2;
      if (child.destroyed) {
        throw new Error(ERROR_MSG_APPEND_DESTROYED_ELEMENT);
      }
      runtime.sceneGraphService.attach(child, this, index3);
      if ((_a2 = this.ownerDocument) === null || _a2 === void 0 ? void 0 : _a2.defaultView) {
        this.ownerDocument.defaultView.mountChildren(child);
      }
      insertedEvent.relatedNode = this;
      child.dispatchEvent(insertedEvent);
      return child;
    };
    Element3.prototype.insertBefore = function(newChild, refChild) {
      if (!refChild) {
        this.appendChild(newChild);
      } else {
        if (newChild.parentElement) {
          newChild.parentElement.removeChild(newChild);
        }
        var index3 = this.childNodes.indexOf(refChild);
        if (index3 === -1) {
          this.appendChild(newChild);
        } else {
          this.appendChild(newChild, index3);
        }
      }
      return newChild;
    };
    Element3.prototype.replaceChild = function(newChild, oldChild) {
      var index3 = this.childNodes.indexOf(oldChild);
      this.removeChild(oldChild);
      this.appendChild(newChild, index3);
      return oldChild;
    };
    Element3.prototype.removeChild = function(child) {
      var _a2;
      removedEvent.relatedNode = this;
      child.dispatchEvent(removedEvent);
      if ((_a2 = child.ownerDocument) === null || _a2 === void 0 ? void 0 : _a2.defaultView) {
        child.ownerDocument.defaultView.unmountChildren(child);
      }
      runtime.sceneGraphService.detach(child);
      return child;
    };
    Element3.prototype.removeChildren = function() {
      for (var i = this.childNodes.length - 1; i >= 0; i--) {
        var child = this.childNodes[i];
        this.removeChild(child);
      }
    };
    Element3.prototype.destroyChildren = function() {
      for (var i = this.childNodes.length - 1; i >= 0; i--) {
        var child = this.childNodes[i];
        if (child.childNodes.length) {
          child.destroyChildren();
        }
        child.destroy();
      }
    };
    Element3.prototype.matches = function(selector) {
      return runtime.sceneGraphService.matches(selector, this);
    };
    Element3.prototype.getElementById = function(id3) {
      return runtime.sceneGraphService.querySelector("#".concat(id3), this);
    };
    Element3.prototype.getElementsByName = function(name2) {
      return runtime.sceneGraphService.querySelectorAll('[name="'.concat(name2, '"]'), this);
    };
    Element3.prototype.getElementsByClassName = function(className2) {
      return runtime.sceneGraphService.querySelectorAll(".".concat(className2), this);
    };
    Element3.prototype.getElementsByTagName = function(tagName) {
      return runtime.sceneGraphService.querySelectorAll(tagName, this);
    };
    Element3.prototype.querySelector = function(selectors) {
      return runtime.sceneGraphService.querySelector(selectors, this);
    };
    Element3.prototype.querySelectorAll = function(selectors) {
      return runtime.sceneGraphService.querySelectorAll(selectors, this);
    };
    Element3.prototype.closest = function(selectors) {
      var el = this;
      do {
        if (runtime.sceneGraphService.matches(selectors, el))
          return el;
        el = el.parentElement;
      } while (el !== null);
      return null;
    };
    Element3.prototype.find = function(filter4) {
      var _this2 = this;
      var target = null;
      this.forEach(function(object) {
        if (object !== _this2 && filter4(object)) {
          target = object;
          return true;
        }
        return false;
      });
      return target;
    };
    Element3.prototype.findAll = function(filter4) {
      var _this2 = this;
      var objects = [];
      this.forEach(function(object) {
        if (object !== _this2 && filter4(object)) {
          objects.push(object);
        }
      });
      return objects;
    };
    Element3.prototype.after = function() {
      var _this2 = this;
      var nodes = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        nodes[_i] = arguments[_i];
      }
      if (this.parentNode) {
        var index_1 = this.parentNode.childNodes.indexOf(this);
        nodes.forEach(function(node, i) {
          var _a2;
          return (_a2 = _this2.parentNode) === null || _a2 === void 0 ? void 0 : _a2.appendChild(node, index_1 + i + 1);
        });
      }
    };
    Element3.prototype.before = function() {
      var _a2;
      var nodes = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        nodes[_i] = arguments[_i];
      }
      if (this.parentNode) {
        var index3 = this.parentNode.childNodes.indexOf(this);
        var _b = __read(nodes), first3 = _b[0], rest2 = _b.slice(1);
        this.parentNode.appendChild(first3, index3);
        (_a2 = first3).after.apply(_a2, __spreadArray([], __read(rest2), false));
      }
    };
    Element3.prototype.replaceWith = function() {
      var nodes = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        nodes[_i] = arguments[_i];
      }
      this.after.apply(this, __spreadArray([], __read(nodes), false));
      this.remove();
    };
    Element3.prototype.append = function() {
      var _this2 = this;
      var nodes = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        nodes[_i] = arguments[_i];
      }
      nodes.forEach(function(node) {
        return _this2.appendChild(node);
      });
    };
    Element3.prototype.prepend = function() {
      var _this2 = this;
      var nodes = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        nodes[_i] = arguments[_i];
      }
      nodes.forEach(function(node, i) {
        return _this2.appendChild(node, i);
      });
    };
    Element3.prototype.replaceChildren = function() {
      var nodes = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        nodes[_i] = arguments[_i];
      }
      while (this.childNodes.length && this.firstChild) {
        this.removeChild(this.firstChild);
      }
      this.append.apply(this, __spreadArray([], __read(nodes), false));
    };
    Element3.prototype.remove = function() {
      if (this.parentNode) {
        return this.parentNode.removeChild(this);
      }
      return this;
    };
    Element3.prototype.destroy = function() {
      this.dispatchEvent(destroyEvent);
      this.remove();
      this.emitter.removeAllListeners();
      this.destroyed = true;
    };
    Element3.prototype.getGeometryBounds = function() {
      return runtime.sceneGraphService.getGeometryBounds(this);
    };
    Element3.prototype.getRenderBounds = function() {
      return runtime.sceneGraphService.getBounds(this, true);
    };
    Element3.prototype.getBounds = function() {
      return runtime.sceneGraphService.getBounds(this);
    };
    Element3.prototype.getLocalBounds = function() {
      return runtime.sceneGraphService.getLocalBounds(this);
    };
    Element3.prototype.getBoundingClientRect = function() {
      return runtime.sceneGraphService.getBoundingClientRect(this);
    };
    Element3.prototype.getClientRects = function() {
      return [this.getBoundingClientRect()];
    };
    Element3.prototype.computedStyleMap = function() {
      return new Map(Object.entries(this.computedStyle));
    };
    Element3.prototype.getAttributeNames = function() {
      return Object.keys(this.attributes);
    };
    Element3.prototype.getAttribute = function(name2) {
      if (isSymbol(name2)) {
        return runtime.enableCSSParsing ? null : void 0;
      }
      var value2 = this.attributes[name2];
      if (value2 === void 0) {
        var attributeName = formatAttributeName(name2);
        value2 = this.attributes[attributeName];
        return runtime.enableCSSParsing ? is_nil_default(value2) ? null : value2 : value2;
      } else {
        return value2;
      }
    };
    Element3.prototype.hasAttribute = function(qualifiedName) {
      return this.getAttributeNames().includes(qualifiedName);
    };
    Element3.prototype.hasAttributes = function() {
      return !!this.getAttributeNames().length;
    };
    Element3.prototype.removeAttribute = function(attributeName) {
      this.setAttribute(attributeName, null);
      delete this.attributes[attributeName];
    };
    Element3.prototype.setAttribute = function(attributeName, value2, force) {
      this.attributes[attributeName] = value2;
    };
    Element3.prototype.getAttributeNS = function(namespace, localName) {
      throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
    };
    Element3.prototype.getAttributeNode = function(qualifiedName) {
      throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
    };
    Element3.prototype.getAttributeNodeNS = function(namespace, localName) {
      throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
    };
    Element3.prototype.hasAttributeNS = function(namespace, localName) {
      throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
    };
    Element3.prototype.removeAttributeNS = function(namespace, localName) {
      throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
    };
    Element3.prototype.removeAttributeNode = function(attr2) {
      throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
    };
    Element3.prototype.setAttributeNS = function(namespace, qualifiedName, value2) {
      throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
    };
    Element3.prototype.setAttributeNode = function(attr2) {
      throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
    };
    Element3.prototype.setAttributeNodeNS = function(attr2) {
      throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
    };
    Element3.prototype.toggleAttribute = function(qualifiedName, force) {
      throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
    };
    return Element3;
  }(Node)
);
function isDisplayObject(value2) {
  return !!(value2 === null || value2 === void 0 ? void 0 : value2.nodeName);
}
var mutationEvent = new MutationEvent(ElementEvent.ATTR_MODIFIED, null, null, null, null, MutationEvent.MODIFICATION, null, null);
var DEFAULT_STYLE_PROPS = {
  anchor: "",
  opacity: "",
  fillOpacity: "",
  strokeOpacity: "",
  fill: "",
  stroke: "",
  transform: "",
  transformOrigin: "",
  visibility: "",
  pointerEvents: "",
  lineWidth: "",
  lineCap: "",
  lineJoin: "",
  increasedLineWidthForHitTesting: "",
  fontSize: "",
  fontFamily: "",
  fontStyle: "",
  fontWeight: "",
  fontVariant: "",
  textAlign: "",
  textBaseline: "",
  textTransform: "",
  zIndex: "",
  filter: "",
  shadowType: ""
};
var DEFAULT_PARSED_STYLE_PROPS = {
  anchor: [0, 0],
  fill: noneColor,
  stroke: noneColor,
  transform: [],
  zIndex: 0,
  filter: [],
  shadowType: "outer",
  miterLimit: 10
};
var DEFAULT_PARSED_STYLE_PROPS_CSS_DISABLED = __assign(__assign({}, DEFAULT_PARSED_STYLE_PROPS), { opacity: 1, fillOpacity: 1, strokeOpacity: 1, visibility: "visible", pointerEvents: "auto", lineWidth: 1, lineCap: "butt", lineJoin: "miter", increasedLineWidthForHitTesting: 0, fillRule: "nonzero" });
var INHERITABLE_BASE_STYLE_PROPS = [
  "opacity",
  "fillOpacity",
  "strokeOpacity",
  "transformOrigin",
  "visibility",
  "pointerEvents",
  "lineWidth",
  "lineCap",
  "lineJoin",
  "increasedLineWidthForHitTesting"
];
var INHERITABLE_STYLE_PROPS = __spreadArray(__spreadArray([], __read(INHERITABLE_BASE_STYLE_PROPS), false), [
  "fontSize",
  "fontFamily",
  "fontStyle",
  "fontWeight",
  "fontVariant",
  "textAlign",
  "textBaseline",
  "textTransform"
], false);
var DATASET_PREFIX = "data-";
var DisplayObject = (
  /** @class */
  function(_super) {
    __extends(DisplayObject2, _super);
    function DisplayObject2(config) {
      var _a2;
      var _this2 = _super.call(this) || this;
      _this2.isCustomElement = false;
      _this2.isMutationObserved = false;
      _this2.activeAnimations = [];
      _this2.getClip = function() {
        return this.style.clipPath || null;
      };
      _this2.config = config;
      _this2.config.interactive = (_a2 = _this2.config.capture) !== null && _a2 !== void 0 ? _a2 : _this2.config.interactive;
      _this2.id = _this2.config.id || "";
      _this2.name = _this2.config.name || "";
      if (_this2.config.className || _this2.config.class) {
        _this2.className = _this2.config.className || _this2.config.class;
      }
      _this2.nodeName = _this2.config.type || Shape.GROUP;
      _this2.config.style = _this2.config.style || _this2.config.attrs || {};
      Object.assign(_this2.config.style, _this2.config.attrs);
      if (_this2.config.visible != null) {
        _this2.config.style.visibility = _this2.config.visible === false ? "hidden" : "visible";
      }
      if (_this2.config.interactive != null) {
        _this2.config.style.pointerEvents = _this2.config.interactive === false ? "none" : "auto";
      }
      Object.assign(_this2.parsedStyle, runtime.enableCSSParsing ? DEFAULT_PARSED_STYLE_PROPS : DEFAULT_PARSED_STYLE_PROPS_CSS_DISABLED, _this2.config.initialParsedStyle);
      if (runtime.enableCSSParsing) {
        Object.assign(_this2.attributes, DEFAULT_STYLE_PROPS);
      }
      _this2.initAttributes(_this2.config.style);
      var Proxy = runtime.globalThis.Proxy ? runtime.globalThis.Proxy : function() {
      };
      if (runtime.enableDataset) {
        _this2.dataset = new Proxy({}, {
          get: function(target, name2) {
            var formattedName = "".concat(DATASET_PREFIX).concat(kebabize(name2));
            if (target[formattedName] !== void 0) {
              return target[formattedName];
            }
            return _this2.getAttribute(formattedName);
          },
          set: function(_2, prop, value2) {
            _this2.setAttribute("".concat(DATASET_PREFIX).concat(kebabize(prop)), value2);
            return true;
          }
        });
      }
      if (runtime.enableStyleSyntax) {
        _this2.style = new Proxy(
          // @ts-ignore
          {
            // ...this.attributes,
            setProperty: function(propertyName, value2) {
              _this2.setAttribute(propertyName, value2);
            },
            getPropertyValue: function(propertyName) {
              return _this2.getAttribute(propertyName);
            },
            removeProperty: function(propertyName) {
              _this2.removeAttribute(propertyName);
            },
            item: function() {
              return "";
            }
          },
          {
            get: function(target, name2) {
              if (target[name2] !== void 0) {
                return target[name2];
              }
              return _this2.getAttribute(name2);
            },
            set: function(_2, prop, value2) {
              _this2.setAttribute(prop, value2);
              return true;
            }
          }
        );
      }
      return _this2;
    }
    DisplayObject2.prototype.destroy = function() {
      _super.prototype.destroy.call(this);
      this.getAnimations().forEach(function(animation) {
        animation.cancel();
      });
    };
    DisplayObject2.prototype.cloneNode = function(deep2, customCloneFunc) {
      var clonedStyle = __assign({}, this.attributes);
      for (var attributeName in clonedStyle) {
        var attribute = clonedStyle[attributeName];
        if (isDisplayObject(attribute) && // share the same clipPath if possible
        attributeName !== "clipPath" && attributeName !== "offsetPath" && attributeName !== "textPath") {
          clonedStyle[attributeName] = attribute.cloneNode(deep2);
        }
        if (customCloneFunc) {
          clonedStyle[attributeName] = customCloneFunc(attributeName, attribute);
        }
      }
      var cloned = new this.constructor({
        // copy id & name
        // @see https://developer.mozilla.org/en-US/docs/Web/API/Node/cloneNode#notes
        id: this.id,
        name: this.name,
        className: this.name,
        interactive: this.interactive,
        style: clonedStyle
      });
      cloned.setLocalTransform(this.getLocalTransform());
      if (deep2) {
        this.children.forEach(function(child) {
          if (!child.style.isMarker) {
            var clonedChild = child.cloneNode(deep2);
            cloned.appendChild(clonedChild);
          }
        });
      }
      return cloned;
    };
    DisplayObject2.prototype.initAttributes = function(attributes) {
      if (attributes === void 0) {
        attributes = {};
      }
      var renderable = this.renderable;
      var options = {
        forceUpdateGeometry: true
        // usedAttributes:
        //   // only Group / Text should account for text relative props
        //   this.tagName === Shape.GROUP || this.tagName === Shape.TEXT
        //     ? INHERITABLE_STYLE_PROPS
        //     : INHERITABLE_BASE_STYLE_PROPS,
      };
      if (runtime.enableCSSParsing) {
        options.usedAttributes = INHERITABLE_STYLE_PROPS;
      }
      var formattedAttributes = {};
      for (var name_1 in attributes) {
        var attributeName = formatAttributeName(name_1);
        formattedAttributes[attributeName] = attributes[name_1];
      }
      runtime.styleValueRegistry.processProperties(this, formattedAttributes, options);
      renderable.dirty = true;
    };
    DisplayObject2.prototype.setAttribute = function(name2, value2, force) {
      if (force === void 0) {
        force = false;
      }
      var attributeName = formatAttributeName(name2);
      if (is_undefined_default(value2)) {
        return;
      }
      if (force || value2 !== this.attributes[attributeName]) {
        this.internalSetAttribute(attributeName, value2);
        _super.prototype.setAttribute.call(this, attributeName, value2);
      }
    };
    DisplayObject2.prototype.internalSetAttribute = function(name2, value2, parseOptions) {
      var _a2;
      if (parseOptions === void 0) {
        parseOptions = {};
      }
      var renderable = this.renderable;
      var oldValue = this.attributes[name2];
      var oldParsedValue = this.parsedStyle[name2];
      runtime.styleValueRegistry.processProperties(this, (_a2 = {}, _a2[name2] = value2, _a2), parseOptions);
      renderable.dirty = true;
      var newParsedValue = this.parsedStyle[name2];
      if (this.isConnected) {
        mutationEvent.relatedNode = this;
        mutationEvent.prevValue = oldValue;
        mutationEvent.newValue = value2;
        mutationEvent.attrName = name2;
        mutationEvent.prevParsedValue = oldParsedValue;
        mutationEvent.newParsedValue = newParsedValue;
        if (this.isMutationObserved) {
          this.dispatchEvent(mutationEvent);
        } else {
          mutationEvent.target = this;
          this.ownerDocument.defaultView.dispatchEvent(mutationEvent, true);
        }
      }
      if ((this.isCustomElement && this.isConnected || !this.isCustomElement) && this.attributeChangedCallback) {
        this.attributeChangedCallback(name2, oldValue, value2, oldParsedValue, newParsedValue);
      }
    };
    DisplayObject2.prototype.getBBox = function() {
      var aabb = this.getBounds();
      var _a2 = __read(aabb.getMin(), 2), left2 = _a2[0], top = _a2[1];
      var _b = __read(aabb.getMax(), 2), right2 = _b[0], bottom = _b[1];
      return new Rectangle(left2, top, right2 - left2, bottom - top);
    };
    DisplayObject2.prototype.setOrigin = function(position, y3, z) {
      if (y3 === void 0) {
        y3 = 0;
      }
      if (z === void 0) {
        z = 0;
      }
      runtime.sceneGraphService.setOrigin(this, createVec3(position, y3, z));
      return this;
    };
    DisplayObject2.prototype.getOrigin = function() {
      return runtime.sceneGraphService.getOrigin(this);
    };
    DisplayObject2.prototype.setPosition = function(position, y3, z) {
      if (y3 === void 0) {
        y3 = 0;
      }
      if (z === void 0) {
        z = 0;
      }
      runtime.sceneGraphService.setPosition(this, createVec3(position, y3, z));
      return this;
    };
    DisplayObject2.prototype.setLocalPosition = function(position, y3, z) {
      if (y3 === void 0) {
        y3 = 0;
      }
      if (z === void 0) {
        z = 0;
      }
      runtime.sceneGraphService.setLocalPosition(this, createVec3(position, y3, z));
      return this;
    };
    DisplayObject2.prototype.translate = function(position, y3, z) {
      if (y3 === void 0) {
        y3 = 0;
      }
      if (z === void 0) {
        z = 0;
      }
      runtime.sceneGraphService.translate(this, createVec3(position, y3, z));
      return this;
    };
    DisplayObject2.prototype.translateLocal = function(position, y3, z) {
      if (y3 === void 0) {
        y3 = 0;
      }
      if (z === void 0) {
        z = 0;
      }
      runtime.sceneGraphService.translateLocal(this, createVec3(position, y3, z));
      return this;
    };
    DisplayObject2.prototype.getPosition = function() {
      return runtime.sceneGraphService.getPosition(this);
    };
    DisplayObject2.prototype.getLocalPosition = function() {
      return runtime.sceneGraphService.getLocalPosition(this);
    };
    DisplayObject2.prototype.scale = function(scaling, y3, z) {
      return this.scaleLocal(scaling, y3, z);
    };
    DisplayObject2.prototype.scaleLocal = function(scaling, y3, z) {
      if (typeof scaling === "number") {
        y3 = y3 || scaling;
        z = z || scaling;
        scaling = createVec3(scaling, y3, z);
      }
      runtime.sceneGraphService.scaleLocal(this, scaling);
      return this;
    };
    DisplayObject2.prototype.setLocalScale = function(scaling, y3, z) {
      if (typeof scaling === "number") {
        y3 = y3 || scaling;
        z = z || scaling;
        scaling = createVec3(scaling, y3, z);
      }
      runtime.sceneGraphService.setLocalScale(this, scaling);
      return this;
    };
    DisplayObject2.prototype.getLocalScale = function() {
      return runtime.sceneGraphService.getLocalScale(this);
    };
    DisplayObject2.prototype.getScale = function() {
      return runtime.sceneGraphService.getScale(this);
    };
    DisplayObject2.prototype.getEulerAngles = function() {
      var _a2 = __read(getEuler(vec3_exports.create(), runtime.sceneGraphService.getWorldTransform(this)), 3), ez = _a2[2];
      return rad2deg2(ez);
    };
    DisplayObject2.prototype.getLocalEulerAngles = function() {
      var _a2 = __read(getEuler(vec3_exports.create(), runtime.sceneGraphService.getLocalRotation(this)), 3), ez = _a2[2];
      return rad2deg2(ez);
    };
    DisplayObject2.prototype.setEulerAngles = function(z) {
      runtime.sceneGraphService.setEulerAngles(this, 0, 0, z);
      return this;
    };
    DisplayObject2.prototype.setLocalEulerAngles = function(z) {
      runtime.sceneGraphService.setLocalEulerAngles(this, 0, 0, z);
      return this;
    };
    DisplayObject2.prototype.rotateLocal = function(x3, y3, z) {
      if (is_nil_default(y3) && is_nil_default(z)) {
        runtime.sceneGraphService.rotateLocal(this, 0, 0, x3);
      } else {
        runtime.sceneGraphService.rotateLocal(this, x3, y3, z);
      }
      return this;
    };
    DisplayObject2.prototype.rotate = function(x3, y3, z) {
      if (is_nil_default(y3) && is_nil_default(z)) {
        runtime.sceneGraphService.rotate(this, 0, 0, x3);
      } else {
        runtime.sceneGraphService.rotate(this, x3, y3, z);
      }
      return this;
    };
    DisplayObject2.prototype.setRotation = function(rotation, y3, z, w) {
      runtime.sceneGraphService.setRotation(this, rotation, y3, z, w);
      return this;
    };
    DisplayObject2.prototype.setLocalRotation = function(rotation, y3, z, w) {
      runtime.sceneGraphService.setLocalRotation(this, rotation, y3, z, w);
      return this;
    };
    DisplayObject2.prototype.setLocalSkew = function(skew, y3) {
      runtime.sceneGraphService.setLocalSkew(this, skew, y3);
      return this;
    };
    DisplayObject2.prototype.getRotation = function() {
      return runtime.sceneGraphService.getRotation(this);
    };
    DisplayObject2.prototype.getLocalRotation = function() {
      return runtime.sceneGraphService.getLocalRotation(this);
    };
    DisplayObject2.prototype.getLocalSkew = function() {
      return runtime.sceneGraphService.getLocalSkew(this);
    };
    DisplayObject2.prototype.getLocalTransform = function() {
      return runtime.sceneGraphService.getLocalTransform(this);
    };
    DisplayObject2.prototype.getWorldTransform = function() {
      return runtime.sceneGraphService.getWorldTransform(this);
    };
    DisplayObject2.prototype.setLocalTransform = function(transform3) {
      runtime.sceneGraphService.setLocalTransform(this, transform3);
      return this;
    };
    DisplayObject2.prototype.resetLocalTransform = function() {
      runtime.sceneGraphService.resetLocalTransform(this);
    };
    DisplayObject2.prototype.getAnimations = function() {
      return this.activeAnimations;
    };
    DisplayObject2.prototype.animate = function(keyframes, options) {
      var _a2;
      var timeline = (_a2 = this.ownerDocument) === null || _a2 === void 0 ? void 0 : _a2.timeline;
      if (timeline) {
        return timeline.play(this, keyframes, options);
      }
      return null;
    };
    DisplayObject2.prototype.isVisible = function() {
      var _a2;
      return ((_a2 = this.parsedStyle) === null || _a2 === void 0 ? void 0 : _a2.visibility) === "visible";
    };
    Object.defineProperty(DisplayObject2.prototype, "interactive", {
      get: function() {
        return this.isInteractive();
      },
      set: function(b) {
        this.style.pointerEvents = b ? "auto" : "none";
      },
      enumerable: false,
      configurable: true
    });
    DisplayObject2.prototype.isInteractive = function() {
      var _a2;
      return ((_a2 = this.parsedStyle) === null || _a2 === void 0 ? void 0 : _a2.pointerEvents) !== "none";
    };
    DisplayObject2.prototype.isCulled = function() {
      return !!(this.cullable && this.cullable.enable && !this.cullable.visible);
    };
    DisplayObject2.prototype.toFront = function() {
      if (this.parentNode) {
        this.style.zIndex = Math.max.apply(Math, __spreadArray([], __read(this.parentNode.children.map(function(child) {
          return Number(child.style.zIndex);
        })), false)) + 1;
      }
      return this;
    };
    DisplayObject2.prototype.toBack = function() {
      if (this.parentNode) {
        this.style.zIndex = Math.min.apply(Math, __spreadArray([], __read(this.parentNode.children.map(function(child) {
          return Number(child.style.zIndex);
        })), false)) - 1;
      }
      return this;
    };
    DisplayObject2.prototype.getConfig = function() {
      return this.config;
    };
    DisplayObject2.prototype.attr = function() {
      var _this2 = this;
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      var _a2 = __read(args, 2), name2 = _a2[0], value2 = _a2[1];
      if (!name2) {
        return this.attributes;
      }
      if (is_object_default(name2)) {
        Object.keys(name2).forEach(function(key) {
          _this2.setAttribute(key, name2[key]);
        });
        return this;
      }
      if (args.length === 2) {
        this.setAttribute(name2, value2);
        return this;
      }
      return this.attributes[name2];
    };
    DisplayObject2.prototype.getMatrix = function(transformMat44) {
      var transform3 = transformMat44 || this.getWorldTransform();
      var _a2 = __read(mat4_exports.getTranslation(vec3_exports.create(), transform3), 2), tx = _a2[0], ty = _a2[1];
      var _b = __read(mat4_exports.getScaling(vec3_exports.create(), transform3), 2), sx = _b[0], sy = _b[1];
      var rotation = mat4_exports.getRotation(quat_exports.create(), transform3);
      var _c = __read(getEuler(vec3_exports.create(), rotation), 3), eux = _c[0], euz = _c[2];
      return fromRotationTranslationScale2(eux || euz, tx, ty, sx, sy);
    };
    DisplayObject2.prototype.getLocalMatrix = function() {
      return this.getMatrix(this.getLocalTransform());
    };
    DisplayObject2.prototype.setMatrix = function(mat) {
      var _a2 = __read(decompose(mat), 5), tx = _a2[0], ty = _a2[1], scalingX = _a2[2], scalingY = _a2[3], angle4 = _a2[4];
      this.setEulerAngles(angle4).setPosition(tx, ty).setLocalScale(scalingX, scalingY);
    };
    DisplayObject2.prototype.setLocalMatrix = function(mat) {
      var _a2 = __read(decompose(mat), 5), tx = _a2[0], ty = _a2[1], scalingX = _a2[2], scalingY = _a2[3], angle4 = _a2[4];
      this.setLocalEulerAngles(angle4).setLocalPosition(tx, ty).setLocalScale(scalingX, scalingY);
    };
    DisplayObject2.prototype.show = function() {
      if (runtime.enableCSSParsing) {
        this.style.visibility = "visible";
      } else {
        this.forEach(function(object) {
          object.style.visibility = "visible";
        });
      }
    };
    DisplayObject2.prototype.hide = function() {
      if (runtime.enableCSSParsing) {
        this.style.visibility = "hidden";
      } else {
        this.forEach(function(object) {
          object.style.visibility = "hidden";
        });
      }
    };
    DisplayObject2.prototype.getCount = function() {
      return this.childElementCount;
    };
    DisplayObject2.prototype.getParent = function() {
      return this.parentElement;
    };
    DisplayObject2.prototype.getChildren = function() {
      return this.children;
    };
    DisplayObject2.prototype.getFirst = function() {
      return this.firstElementChild;
    };
    DisplayObject2.prototype.getLast = function() {
      return this.lastElementChild;
    };
    DisplayObject2.prototype.getChildByIndex = function(index3) {
      return this.children[index3] || null;
    };
    DisplayObject2.prototype.add = function(child, index3) {
      return this.appendChild(child, index3);
    };
    DisplayObject2.prototype.setClip = function(clipPath) {
      this.style.clipPath = clipPath;
    };
    DisplayObject2.prototype.set = function(name2, value2) {
      this.config[name2] = value2;
    };
    DisplayObject2.prototype.get = function(name2) {
      return this.config[name2];
    };
    DisplayObject2.prototype.moveTo = function(position, y3, z) {
      if (y3 === void 0) {
        y3 = 0;
      }
      if (z === void 0) {
        z = 0;
      }
      this.setPosition(position, y3, z);
      return this;
    };
    DisplayObject2.prototype.move = function(position, y3, z) {
      if (y3 === void 0) {
        y3 = 0;
      }
      if (z === void 0) {
        z = 0;
      }
      this.setPosition(position, y3, z);
      return this;
    };
    DisplayObject2.prototype.setZIndex = function(zIndex) {
      this.style.zIndex = zIndex;
      return this;
    };
    return DisplayObject2;
  }(Element2)
);
var CSS = {
  /**
   * <number>
   * @see https://drafts.csswg.org/css-values-4/#number-value
   */
  number: function(n) {
    return new CSSUnitValue(n);
  },
  /**
   * <percentage>
   * @see https://drafts.csswg.org/css-values-4/#percentage-value
   */
  percent: function(n) {
    return new CSSUnitValue(n, "%");
  },
  /**
   * <length>
   */
  px: function(n) {
    return new CSSUnitValue(n, "px");
  },
  /**
   * <length>
   */
  em: function(n) {
    return new CSSUnitValue(n, "em");
  },
  rem: function(n) {
    return new CSSUnitValue(n, "rem");
  },
  /**
   * <angle>
   */
  deg: function(n) {
    return new CSSUnitValue(n, "deg");
  },
  /**
   * <angle>
   */
  grad: function(n) {
    return new CSSUnitValue(n, "grad");
  },
  /**
   * <angle>
   */
  rad: function(n) {
    return new CSSUnitValue(n, "rad");
  },
  /**
   * <angle>
   */
  turn: function(n) {
    return new CSSUnitValue(n, "turn");
  },
  /**
   * <time>
   */
  s: function(n) {
    return new CSSUnitValue(n, "s");
  },
  /**
   * <time>
   */
  ms: function(n) {
    return new CSSUnitValue(n, "ms");
  },
  /**
   * CSS Properties & Values API
   *
   * @see https://developer.mozilla.org/en-US/docs/Web/API/CSS_Properties_and_Values_API
   * @see https://drafts.css-houdini.org/css-properties-values-api/#registering-custom-properties
   * @see https://developer.mozilla.org/en-US/docs/Web/API/CSS/RegisterProperty
   */
  registerProperty: function(definition) {
    var name2 = definition.name, inherits = definition.inherits, interpolable = definition.interpolable, initialValue = definition.initialValue, syntax = definition.syntax;
    runtime.styleValueRegistry.registerMetadata({
      n: name2,
      inh: inherits,
      int: interpolable,
      d: initialValue,
      syntax
    });
  },
  /**
   * CSS Layout API
   * register layout
   *
   * @see https://github.com/w3c/css-houdini-drafts/blob/main/css-layout-api/EXPLAINER.md
   * @see https://developer.mozilla.org/en-US/docs/Web/Guide/Houdini#css_layout_api
   */
  registerLayout: function(name2, clazz) {
    runtime.layoutRegistry.registerLayout(name2, clazz);
  }
};
var Circle = (
  /** @class */
  function(_super) {
    __extends(Circle2, _super);
    function Circle2(_a2) {
      if (_a2 === void 0) {
        _a2 = {};
      }
      var style = _a2.style, rest2 = __rest(_a2, ["style"]);
      return _super.call(this, __assign({ type: Shape.CIRCLE, style: runtime.enableCSSParsing ? __assign({ cx: "", cy: "", r: "" }, style) : __assign({}, style), initialParsedStyle: {
        anchor: [0.5, 0.5],
        transformOrigin: runtime.enableCSSParsing ? null : [PECENTAGE_50, PECENTAGE_50]
      } }, rest2)) || this;
    }
    return Circle2;
  }(DisplayObject)
);
var CustomElement = (
  /** @class */
  function(_super) {
    __extends(CustomElement2, _super);
    function CustomElement2(_a2) {
      if (_a2 === void 0) {
        _a2 = {};
      }
      var _this2 = this;
      var style = _a2.style, rest2 = __rest(_a2, ["style"]);
      _this2 = _super.call(this, __assign({ style: runtime.enableCSSParsing ? __assign({ x: "", y: "" }, style) : __assign({}, style) }, rest2)) || this;
      _this2.isCustomElement = true;
      return _this2;
    }
    return CustomElement2;
  }(DisplayObject)
);
var Ellipse = (
  /** @class */
  function(_super) {
    __extends(Ellipse2, _super);
    function Ellipse2(_a2) {
      if (_a2 === void 0) {
        _a2 = {};
      }
      var style = _a2.style, rest2 = __rest(_a2, ["style"]);
      return _super.call(this, __assign({ type: Shape.ELLIPSE, style: runtime.enableCSSParsing ? __assign({ cx: "", cy: "", rx: "", ry: "" }, style) : __assign({}, style), initialParsedStyle: {
        anchor: [0.5, 0.5],
        transformOrigin: runtime.enableCSSParsing ? null : [PECENTAGE_50, PECENTAGE_50]
      } }, rest2)) || this;
    }
    return Ellipse2;
  }(DisplayObject)
);
var Group2 = (
  /** @class */
  function(_super) {
    __extends(Group3, _super);
    function Group3(_a2) {
      if (_a2 === void 0) {
        _a2 = {};
      }
      var style = _a2.style, rest2 = __rest(_a2, ["style"]);
      return _super.call(this, __assign({ type: Shape.GROUP, style: runtime.enableCSSParsing ? __assign({ x: "", y: "", width: "", height: "" }, style) : __assign({}, style) }, rest2)) || this;
    }
    return Group3;
  }(DisplayObject)
);
var HTML = (
  /** @class */
  function(_super) {
    __extends(HTML2, _super);
    function HTML2(_a2) {
      if (_a2 === void 0) {
        _a2 = {};
      }
      var _this2 = this;
      var style = _a2.style, rest2 = __rest(_a2, ["style"]);
      _this2 = _super.call(this, __assign({ type: Shape.HTML, style: runtime.enableCSSParsing ? __assign({ x: "", y: "", width: "auto", height: "auto", innerHTML: "" }, style) : __assign({}, style) }, rest2)) || this;
      _this2.cullable.enable = false;
      return _this2;
    }
    HTML2.prototype.getDomElement = function() {
      return this.parsedStyle.$el;
    };
    HTML2.prototype.getBoundingClientRect = function() {
      if (this.parsedStyle.$el) {
        return this.parsedStyle.$el.getBoundingClientRect();
      } else {
        var _a2 = this.parsedStyle, x3 = _a2.x, y3 = _a2.y, width = _a2.width, height = _a2.height;
        return new Rectangle(x3, y3, width, height);
      }
    };
    HTML2.prototype.getClientRects = function() {
      return [this.getBoundingClientRect()];
    };
    HTML2.prototype.getBounds = function() {
      var _a2, _b;
      var clientRect = this.getBoundingClientRect();
      var canvasRect = (_b = (_a2 = this.ownerDocument) === null || _a2 === void 0 ? void 0 : _a2.defaultView) === null || _b === void 0 ? void 0 : _b.getContextService().getBoundingClientRect();
      var aabb = new AABB();
      var minX = clientRect.left - ((canvasRect === null || canvasRect === void 0 ? void 0 : canvasRect.left) || 0);
      var minY = clientRect.top - ((canvasRect === null || canvasRect === void 0 ? void 0 : canvasRect.top) || 0);
      aabb.setMinMax([minX, minY, 0], [minX + clientRect.width, minY + clientRect.height, 0]);
      return aabb;
    };
    HTML2.prototype.getLocalBounds = function() {
      if (this.parentNode) {
        var parentInvert = mat4_exports.invert(mat4_exports.create(), this.parentNode.getWorldTransform());
        var bounds = this.getBounds();
        if (!AABB.isEmpty(bounds)) {
          var localBounds = new AABB();
          localBounds.setFromTransformedAABB(bounds, parentInvert);
          return localBounds;
        }
      }
      return this.getBounds();
    };
    return HTML2;
  }(DisplayObject)
);
var Image2 = (
  /** @class */
  function(_super) {
    __extends(Image5, _super);
    function Image5(_a2) {
      if (_a2 === void 0) {
        _a2 = {};
      }
      var style = _a2.style, rest2 = __rest(_a2, ["style"]);
      return _super.call(this, __assign({ type: Shape.IMAGE, style: runtime.enableCSSParsing ? __assign({ x: "", y: "", img: "", width: "", height: "" }, style) : __assign({}, style) }, rest2)) || this;
    }
    return Image5;
  }(DisplayObject)
);
var Line = (
  /** @class */
  function(_super) {
    __extends(Line7, _super);
    function Line7(_a2) {
      if (_a2 === void 0) {
        _a2 = {};
      }
      var _this2 = this;
      var style = _a2.style, rest2 = __rest(_a2, ["style"]);
      _this2 = _super.call(this, __assign({ type: Shape.LINE, style: __assign({ x1: 0, y1: 0, x2: 0, y2: 0, z1: 0, z2: 0 }, style) }, rest2)) || this;
      _this2.markerStartAngle = 0;
      _this2.markerEndAngle = 0;
      var _b = _this2.parsedStyle, markerStart = _b.markerStart, markerEnd = _b.markerEnd;
      if (markerStart && isDisplayObject(markerStart)) {
        _this2.markerStartAngle = markerStart.getLocalEulerAngles();
        _this2.appendChild(markerStart);
      }
      if (markerEnd && isDisplayObject(markerEnd)) {
        _this2.markerEndAngle = markerEnd.getLocalEulerAngles();
        _this2.appendChild(markerEnd);
      }
      _this2.transformMarker(true);
      _this2.transformMarker(false);
      return _this2;
    }
    Line7.prototype.attributeChangedCallback = function(attrName, oldValue, newValue, prevParsedValue, newParsedValue) {
      if (attrName === "x1" || attrName === "y1" || attrName === "x2" || attrName === "y2" || attrName === "markerStartOffset" || attrName === "markerEndOffset") {
        this.transformMarker(true);
        this.transformMarker(false);
      } else if (attrName === "markerStart") {
        if (prevParsedValue && isDisplayObject(prevParsedValue)) {
          this.markerStartAngle = 0;
          prevParsedValue.remove();
        }
        if (newParsedValue && isDisplayObject(newParsedValue)) {
          this.markerStartAngle = newParsedValue.getLocalEulerAngles();
          this.appendChild(newParsedValue);
          this.transformMarker(true);
        }
      } else if (attrName === "markerEnd") {
        if (prevParsedValue && isDisplayObject(prevParsedValue)) {
          this.markerEndAngle = 0;
          prevParsedValue.remove();
        }
        if (newParsedValue && isDisplayObject(newParsedValue)) {
          this.markerEndAngle = newParsedValue.getLocalEulerAngles();
          this.appendChild(newParsedValue);
          this.transformMarker(false);
        }
      }
    };
    Line7.prototype.transformMarker = function(isStart) {
      var _a2 = this.parsedStyle, markerStart = _a2.markerStart, markerEnd = _a2.markerEnd, markerStartOffset = _a2.markerStartOffset, markerEndOffset = _a2.markerEndOffset, x12 = _a2.x1, x22 = _a2.x2, y12 = _a2.y1, y22 = _a2.y2, defX = _a2.defX, defY = _a2.defY;
      var marker = isStart ? markerStart : markerEnd;
      if (!marker || !isDisplayObject(marker)) {
        return;
      }
      var rad = 0;
      var x3;
      var y3;
      var ox;
      var oy;
      var offset2;
      var originalAngle;
      if (isStart) {
        ox = x12 - defX;
        oy = y12 - defY;
        x3 = x22 - x12;
        y3 = y22 - y12;
        offset2 = markerStartOffset || 0;
        originalAngle = this.markerStartAngle;
      } else {
        ox = x22 - defX;
        oy = y22 - defY;
        x3 = x12 - x22;
        y3 = y12 - y22;
        offset2 = markerEndOffset || 0;
        originalAngle = this.markerEndAngle;
      }
      rad = Math.atan2(y3, x3);
      marker.setLocalEulerAngles(rad * 180 / Math.PI + originalAngle);
      marker.setLocalPosition(ox + Math.cos(rad) * offset2, oy + Math.sin(rad) * offset2);
    };
    Line7.prototype.getPoint = function(ratio, inWorldSpace) {
      if (inWorldSpace === void 0) {
        inWorldSpace = false;
      }
      var _a2 = this.parsedStyle, x12 = _a2.x1, y12 = _a2.y1, x22 = _a2.x2, y22 = _a2.y2, defX = _a2.defX, defY = _a2.defY;
      var _b = pointAt$3(x12, y12, x22, y22, ratio), x3 = _b.x, y3 = _b.y;
      var transformed = vec3_exports.transformMat4(vec3_exports.create(), vec3_exports.fromValues(x3 - defX, y3 - defY, 0), inWorldSpace ? this.getWorldTransform() : this.getLocalTransform());
      return new Point2(transformed[0], transformed[1]);
    };
    Line7.prototype.getPointAtLength = function(distance7, inWorldSpace) {
      if (inWorldSpace === void 0) {
        inWorldSpace = false;
      }
      return this.getPoint(distance7 / this.getTotalLength(), inWorldSpace);
    };
    Line7.prototype.getTotalLength = function() {
      var _a2 = this.parsedStyle, x12 = _a2.x1, y12 = _a2.y1, x22 = _a2.x2, y22 = _a2.y2;
      return length$4(x12, y12, x22, y22);
    };
    return Line7;
  }(DisplayObject)
);
var Path2 = (
  /** @class */
  function(_super) {
    __extends(Path5, _super);
    function Path5(_a2) {
      if (_a2 === void 0) {
        _a2 = {};
      }
      var _this2 = this;
      var style = _a2.style, rest2 = __rest(_a2, ["style"]);
      _this2 = _super.call(this, __assign({ type: Shape.PATH, style: runtime.enableCSSParsing ? __assign({ path: "", miterLimit: "" }, style) : __assign({}, style), initialParsedStyle: runtime.enableCSSParsing ? null : {
        miterLimit: 4,
        path: __assign({}, EMPTY_PARSED_PATH)
      } }, rest2)) || this;
      _this2.markerStartAngle = 0;
      _this2.markerEndAngle = 0;
      _this2.markerMidList = [];
      var _b = _this2.parsedStyle, markerStart = _b.markerStart, markerEnd = _b.markerEnd, markerMid = _b.markerMid;
      if (markerStart && isDisplayObject(markerStart)) {
        _this2.markerStartAngle = markerStart.getLocalEulerAngles();
        _this2.appendChild(markerStart);
      }
      if (markerMid && isDisplayObject(markerMid)) {
        _this2.placeMarkerMid(markerMid);
      }
      if (markerEnd && isDisplayObject(markerEnd)) {
        _this2.markerEndAngle = markerEnd.getLocalEulerAngles();
        _this2.appendChild(markerEnd);
      }
      _this2.transformMarker(true);
      _this2.transformMarker(false);
      return _this2;
    }
    Path5.prototype.attributeChangedCallback = function(attrName, oldValue, newValue, prevParsedValue, newParsedValue) {
      if (attrName === "path") {
        this.transformMarker(true);
        this.transformMarker(false);
        this.placeMarkerMid(this.parsedStyle.markerMid);
      } else if (attrName === "markerStartOffset" || attrName === "markerEndOffset") {
        this.transformMarker(true);
        this.transformMarker(false);
      } else if (attrName === "markerStart") {
        if (prevParsedValue && isDisplayObject(prevParsedValue)) {
          this.markerStartAngle = 0;
          prevParsedValue.remove();
        }
        if (newParsedValue && isDisplayObject(newParsedValue)) {
          this.markerStartAngle = newParsedValue.getLocalEulerAngles();
          this.appendChild(newParsedValue);
          this.transformMarker(true);
        }
      } else if (attrName === "markerEnd") {
        if (prevParsedValue && isDisplayObject(prevParsedValue)) {
          this.markerEndAngle = 0;
          prevParsedValue.remove();
        }
        if (newParsedValue && isDisplayObject(newParsedValue)) {
          this.markerEndAngle = newParsedValue.getLocalEulerAngles();
          this.appendChild(newParsedValue);
          this.transformMarker(false);
        }
      } else if (attrName === "markerMid") {
        this.placeMarkerMid(newParsedValue);
      }
    };
    Path5.prototype.transformMarker = function(isStart) {
      var _a2 = this.parsedStyle, markerStart = _a2.markerStart, markerEnd = _a2.markerEnd, markerStartOffset = _a2.markerStartOffset, markerEndOffset = _a2.markerEndOffset, defX = _a2.defX, defY = _a2.defY;
      var marker = isStart ? markerStart : markerEnd;
      if (!marker || !isDisplayObject(marker)) {
        return;
      }
      var rad = 0;
      var x3;
      var y3;
      var ox;
      var oy;
      var offset2;
      var originalAngle;
      if (isStart) {
        var _b = __read(this.getStartTangent(), 2), p1 = _b[0], p2 = _b[1];
        ox = p2[0] - defX;
        oy = p2[1] - defY;
        x3 = p1[0] - p2[0];
        y3 = p1[1] - p2[1];
        offset2 = markerStartOffset || 0;
        originalAngle = this.markerStartAngle;
      } else {
        var _c = __read(this.getEndTangent(), 2), p1 = _c[0], p2 = _c[1];
        ox = p2[0] - defX;
        oy = p2[1] - defY;
        x3 = p1[0] - p2[0];
        y3 = p1[1] - p2[1];
        offset2 = markerEndOffset || 0;
        originalAngle = this.markerEndAngle;
      }
      rad = Math.atan2(y3, x3);
      marker.setLocalEulerAngles(rad * 180 / Math.PI + originalAngle);
      marker.setLocalPosition(ox + Math.cos(rad) * offset2, oy + Math.sin(rad) * offset2);
    };
    Path5.prototype.placeMarkerMid = function(marker) {
      var _a2 = this.parsedStyle, segments = _a2.path.segments, defX = _a2.defX, defY = _a2.defY;
      this.markerMidList.forEach(function(marker2) {
        marker2.remove();
      });
      if (marker && isDisplayObject(marker)) {
        for (var i = 1; i < segments.length - 1; i++) {
          var _b = __read(segments[i].currentPoint, 2), ox = _b[0], oy = _b[1];
          var cloned = i === 1 ? marker : marker.cloneNode(true);
          this.markerMidList.push(cloned);
          this.appendChild(cloned);
          cloned.setLocalPosition(ox - defX, oy - defY);
        }
      }
    };
    Path5.prototype.getTotalLength = function() {
      return getOrCalculatePathTotalLength(this);
    };
    Path5.prototype.getPointAtLength = function(distance7, inWorldSpace) {
      if (inWorldSpace === void 0) {
        inWorldSpace = false;
      }
      var _a2 = this.parsedStyle, defX = _a2.defX, defY = _a2.defY, absolutePath = _a2.path.absolutePath;
      var _b = getPointAtLength(absolutePath, distance7), x3 = _b.x, y3 = _b.y;
      var transformed = vec3_exports.transformMat4(vec3_exports.create(), vec3_exports.fromValues(x3 - defX, y3 - defY, 0), inWorldSpace ? this.getWorldTransform() : this.getLocalTransform());
      return new Point2(transformed[0], transformed[1]);
    };
    Path5.prototype.getPoint = function(ratio, inWorldSpace) {
      if (inWorldSpace === void 0) {
        inWorldSpace = false;
      }
      return this.getPointAtLength(ratio * getOrCalculatePathTotalLength(this), inWorldSpace);
    };
    Path5.prototype.getStartTangent = function() {
      var segments = this.parsedStyle.path.segments;
      var result2 = [];
      if (segments.length > 1) {
        var startPoint = segments[0].currentPoint;
        var endPoint = segments[1].currentPoint;
        var tangent = segments[1].startTangent;
        result2 = [];
        if (tangent) {
          result2.push([startPoint[0] - tangent[0], startPoint[1] - tangent[1]]);
          result2.push([startPoint[0], startPoint[1]]);
        } else {
          result2.push([endPoint[0], endPoint[1]]);
          result2.push([startPoint[0], startPoint[1]]);
        }
      }
      return result2;
    };
    Path5.prototype.getEndTangent = function() {
      var segments = this.parsedStyle.path.segments;
      var length5 = segments.length;
      var result2 = [];
      if (length5 > 1) {
        var startPoint = segments[length5 - 2].currentPoint;
        var endPoint = segments[length5 - 1].currentPoint;
        var tangent = segments[length5 - 1].endTangent;
        result2 = [];
        if (tangent) {
          result2.push([endPoint[0] - tangent[0], endPoint[1] - tangent[1]]);
          result2.push([endPoint[0], endPoint[1]]);
        } else {
          result2.push([startPoint[0], startPoint[1]]);
          result2.push([endPoint[0], endPoint[1]]);
        }
      }
      return result2;
    };
    return Path5;
  }(DisplayObject)
);
var Polygon = (
  /** @class */
  function(_super) {
    __extends(Polygon5, _super);
    function Polygon5(_a2) {
      if (_a2 === void 0) {
        _a2 = {};
      }
      var _this2 = this;
      var style = _a2.style, rest2 = __rest(_a2, ["style"]);
      _this2 = _super.call(this, __assign({ type: Shape.POLYGON, style: runtime.enableCSSParsing ? __assign({ points: "", miterLimit: "", isClosed: true }, style) : __assign({}, style), initialParsedStyle: runtime.enableCSSParsing ? null : {
        points: {
          points: [],
          totalLength: 0,
          segments: []
        },
        miterLimit: 4,
        isClosed: true
      } }, rest2)) || this;
      _this2.markerStartAngle = 0;
      _this2.markerEndAngle = 0;
      _this2.markerMidList = [];
      var _b = _this2.parsedStyle, markerStart = _b.markerStart, markerEnd = _b.markerEnd, markerMid = _b.markerMid;
      if (markerStart && isDisplayObject(markerStart)) {
        _this2.markerStartAngle = markerStart.getLocalEulerAngles();
        _this2.appendChild(markerStart);
      }
      if (markerMid && isDisplayObject(markerMid)) {
        _this2.placeMarkerMid(markerMid);
      }
      if (markerEnd && isDisplayObject(markerEnd)) {
        _this2.markerEndAngle = markerEnd.getLocalEulerAngles();
        _this2.appendChild(markerEnd);
      }
      _this2.transformMarker(true);
      _this2.transformMarker(false);
      return _this2;
    }
    Polygon5.prototype.attributeChangedCallback = function(attrName, oldValue, newValue, prevParsedValue, newParsedValue) {
      if (attrName === "points") {
        this.transformMarker(true);
        this.transformMarker(false);
        this.placeMarkerMid(this.parsedStyle.markerMid);
      } else if (attrName === "markerStartOffset" || attrName === "markerEndOffset") {
        this.transformMarker(true);
        this.transformMarker(false);
      } else if (attrName === "markerStart") {
        if (prevParsedValue && isDisplayObject(prevParsedValue)) {
          this.markerStartAngle = 0;
          prevParsedValue.remove();
        }
        if (newParsedValue && isDisplayObject(newParsedValue)) {
          this.markerStartAngle = newParsedValue.getLocalEulerAngles();
          this.appendChild(newParsedValue);
          this.transformMarker(true);
        }
      } else if (attrName === "markerEnd") {
        if (prevParsedValue && isDisplayObject(prevParsedValue)) {
          this.markerEndAngle = 0;
          prevParsedValue.remove();
        }
        if (newParsedValue && isDisplayObject(newParsedValue)) {
          this.markerEndAngle = newParsedValue.getLocalEulerAngles();
          this.appendChild(newParsedValue);
          this.transformMarker(false);
        }
      } else if (attrName === "markerMid") {
        this.placeMarkerMid(newParsedValue);
      }
    };
    Polygon5.prototype.transformMarker = function(isStart) {
      var _a2 = this.parsedStyle, markerStart = _a2.markerStart, markerEnd = _a2.markerEnd, markerStartOffset = _a2.markerStartOffset, markerEndOffset = _a2.markerEndOffset, P = _a2.points, defX = _a2.defX, defY = _a2.defY;
      var points = (P || {}).points;
      var marker = isStart ? markerStart : markerEnd;
      if (!marker || !isDisplayObject(marker) || !points) {
        return;
      }
      var rad = 0;
      var x3;
      var y3;
      var ox;
      var oy;
      var offset2;
      var originalAngle;
      ox = points[0][0] - defX;
      oy = points[0][1] - defY;
      if (isStart) {
        x3 = points[1][0] - points[0][0];
        y3 = points[1][1] - points[0][1];
        offset2 = markerStartOffset || 0;
        originalAngle = this.markerStartAngle;
      } else {
        var length_1 = points.length;
        if (!this.parsedStyle.isClosed) {
          ox = points[length_1 - 1][0] - defX;
          oy = points[length_1 - 1][1] - defY;
          x3 = points[length_1 - 2][0] - points[length_1 - 1][0];
          y3 = points[length_1 - 2][1] - points[length_1 - 1][1];
        } else {
          x3 = points[length_1 - 1][0] - points[0][0];
          y3 = points[length_1 - 1][1] - points[0][1];
        }
        offset2 = markerEndOffset || 0;
        originalAngle = this.markerEndAngle;
      }
      rad = Math.atan2(y3, x3);
      marker.setLocalEulerAngles(rad * 180 / Math.PI + originalAngle);
      marker.setLocalPosition(ox + Math.cos(rad) * offset2, oy + Math.sin(rad) * offset2);
    };
    Polygon5.prototype.placeMarkerMid = function(marker) {
      var _a2 = this.parsedStyle, P = _a2.points, defX = _a2.defX, defY = _a2.defY;
      var points = (P || {}).points;
      this.markerMidList.forEach(function(marker2) {
        marker2.remove();
      });
      this.markerMidList = [];
      if (marker && isDisplayObject(marker) && points) {
        for (var i = 1; i < (this.parsedStyle.isClosed ? points.length : points.length - 1); i++) {
          var ox = points[i][0] - defX;
          var oy = points[i][1] - defY;
          var cloned = i === 1 ? marker : marker.cloneNode(true);
          this.markerMidList.push(cloned);
          this.appendChild(cloned);
          cloned.setLocalPosition(ox, oy);
        }
      }
    };
    return Polygon5;
  }(DisplayObject)
);
var Polyline = (
  /** @class */
  function(_super) {
    __extends(Polyline2, _super);
    function Polyline2(_a2) {
      if (_a2 === void 0) {
        _a2 = {};
      }
      var style = _a2.style, rest2 = __rest(_a2, ["style"]);
      return _super.call(this, __assign({ type: Shape.POLYLINE, style: runtime.enableCSSParsing ? __assign({ points: "", miterLimit: "", isClosed: false }, style) : __assign({}, style), initialParsedStyle: runtime.enableCSSParsing ? null : {
        points: {
          points: [],
          totalLength: 0,
          segments: []
        },
        miterLimit: 4,
        isClosed: false
      } }, rest2)) || this;
    }
    Polyline2.prototype.getTotalLength = function() {
      return this.parsedStyle.points.totalLength;
    };
    Polyline2.prototype.getPointAtLength = function(distance7, inWorldSpace) {
      if (inWorldSpace === void 0) {
        inWorldSpace = false;
      }
      return this.getPoint(distance7 / this.getTotalLength(), inWorldSpace);
    };
    Polyline2.prototype.getPoint = function(ratio, inWorldSpace) {
      if (inWorldSpace === void 0) {
        inWorldSpace = false;
      }
      var _a2 = this.parsedStyle, defX = _a2.defX, defY = _a2.defY, _b = _a2.points, points = _b.points, segments = _b.segments;
      var subt = 0;
      var index3 = 0;
      segments.forEach(function(v, i) {
        if (ratio >= v[0] && ratio <= v[1]) {
          subt = (ratio - v[0]) / (v[1] - v[0]);
          index3 = i;
        }
      });
      var _c = pointAt$3(points[index3][0], points[index3][1], points[index3 + 1][0], points[index3 + 1][1], subt), x3 = _c.x, y3 = _c.y;
      var transformed = vec3_exports.transformMat4(vec3_exports.create(), vec3_exports.fromValues(x3 - defX, y3 - defY, 0), inWorldSpace ? this.getWorldTransform() : this.getLocalTransform());
      return new Point2(transformed[0], transformed[1]);
    };
    Polyline2.prototype.getStartTangent = function() {
      var points = this.parsedStyle.points.points;
      var result2 = [];
      result2.push([points[1][0], points[1][1]]);
      result2.push([points[0][0], points[0][1]]);
      return result2;
    };
    Polyline2.prototype.getEndTangent = function() {
      var points = this.parsedStyle.points.points;
      var l = points.length - 1;
      var result2 = [];
      result2.push([points[l - 1][0], points[l - 1][1]]);
      result2.push([points[l][0], points[l][1]]);
      return result2;
    };
    return Polyline2;
  }(Polygon)
);
var Rect = (
  /** @class */
  function(_super) {
    __extends(Rect4, _super);
    function Rect4(_a2) {
      if (_a2 === void 0) {
        _a2 = {};
      }
      var style = _a2.style, rest2 = __rest(_a2, ["style"]);
      return _super.call(this, __assign({ type: Shape.RECT, style: runtime.enableCSSParsing ? __assign({ x: "", y: "", width: "", height: "", radius: "" }, style) : __assign({}, style) }, rest2)) || this;
    }
    return Rect4;
  }(DisplayObject)
);
var Text = (
  /** @class */
  function(_super) {
    __extends(Text6, _super);
    function Text6(_a2) {
      if (_a2 === void 0) {
        _a2 = {};
      }
      var style = _a2.style, rest2 = __rest(_a2, ["style"]);
      return _super.call(this, __assign({ type: Shape.TEXT, style: runtime.enableCSSParsing ? __assign({
        x: "",
        y: "",
        text: "",
        fontSize: "",
        fontFamily: "",
        fontStyle: "",
        fontWeight: "",
        fontVariant: "",
        textAlign: "",
        textBaseline: "",
        textTransform: "",
        fill: "black",
        letterSpacing: "",
        lineHeight: "",
        miterLimit: "",
        // whiteSpace: 'pre',
        wordWrap: false,
        wordWrapWidth: 0,
        leading: 0,
        dx: "",
        dy: ""
      }, style) : __assign({ fill: "black" }, style), initialParsedStyle: runtime.enableCSSParsing ? {} : {
        x: 0,
        y: 0,
        fontSize: 16,
        fontFamily: "sans-serif",
        fontStyle: "normal",
        fontWeight: "normal",
        fontVariant: "normal",
        lineHeight: 0,
        letterSpacing: 0,
        textBaseline: "alphabetic",
        textAlign: "start",
        wordWrap: false,
        wordWrapWidth: 0,
        leading: 0,
        dx: 0,
        dy: 0
      } }, rest2)) || this;
    }
    Text6.prototype.getComputedTextLength = function() {
      var _a2;
      return ((_a2 = this.parsedStyle.metrics) === null || _a2 === void 0 ? void 0 : _a2.maxLineWidth) || 0;
    };
    Text6.prototype.getLineBoundingRects = function() {
      var _a2;
      return ((_a2 = this.parsedStyle.metrics) === null || _a2 === void 0 ? void 0 : _a2.lineMetrics) || [];
    };
    Text6.prototype.isOverflowing = function() {
      return !!this.parsedStyle.isOverflowing;
    };
    return Text6;
  }(DisplayObject)
);
var CustomElementRegistry = (
  /** @class */
  function() {
    function CustomElementRegistry2() {
      this.registry = {};
      this.define(Shape.CIRCLE, Circle);
      this.define(Shape.ELLIPSE, Ellipse);
      this.define(Shape.RECT, Rect);
      this.define(Shape.IMAGE, Image2);
      this.define(Shape.LINE, Line);
      this.define(Shape.GROUP, Group2);
      this.define(Shape.PATH, Path2);
      this.define(Shape.POLYGON, Polygon);
      this.define(Shape.POLYLINE, Polyline);
      this.define(Shape.TEXT, Text);
      this.define(Shape.HTML, HTML);
    }
    CustomElementRegistry2.prototype.define = function(name2, constructor) {
      this.registry[name2] = constructor;
    };
    CustomElementRegistry2.prototype.get = function(name2) {
      return this.registry[name2];
    };
    return CustomElementRegistry2;
  }()
);
var Document2 = (
  /** @class */
  function(_super) {
    __extends(Document3, _super);
    function Document3() {
      var _this2 = _super.call(this) || this;
      _this2.defaultView = null;
      _this2.ownerDocument = null;
      _this2.nodeName = "document";
      try {
        _this2.timeline = new runtime.AnimationTimeline(_this2);
      } catch (e) {
      }
      var initialStyle = {};
      BUILT_IN_PROPERTIES.forEach(function(_a2) {
        var n = _a2.n, inh = _a2.inh, d2 = _a2.d;
        if (inh && d2) {
          initialStyle[n] = isFunction(d2) ? d2(Shape.GROUP) : d2;
        }
      });
      _this2.documentElement = new Group2({
        id: "g-root",
        style: initialStyle
      });
      _this2.documentElement.ownerDocument = _this2;
      _this2.documentElement.parentNode = _this2;
      _this2.childNodes = [_this2.documentElement];
      return _this2;
    }
    Object.defineProperty(Document3.prototype, "children", {
      get: function() {
        return this.childNodes;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Document3.prototype, "childElementCount", {
      get: function() {
        return this.childNodes.length;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Document3.prototype, "firstElementChild", {
      get: function() {
        return this.firstChild;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Document3.prototype, "lastElementChild", {
      get: function() {
        return this.lastChild;
      },
      enumerable: false,
      configurable: true
    });
    Document3.prototype.createElement = function(tagName, options) {
      if (tagName === "svg") {
        return this.documentElement;
      }
      var clazz = this.defaultView.customElements.get(tagName);
      if (!clazz) {
        console.warn("Unsupported tagName: ", tagName);
        clazz = tagName === "tspan" ? Text : Group2;
      }
      var shape23 = new clazz(options);
      shape23.ownerDocument = this;
      return shape23;
    };
    Document3.prototype.createElementNS = function(namespaceURI, tagName, options) {
      return this.createElement(tagName, options);
    };
    Document3.prototype.cloneNode = function(deep2) {
      throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
    };
    Document3.prototype.destroy = function() {
      try {
        this.documentElement.destroyChildren();
        this.timeline.destroy();
      } catch (e) {
      }
    };
    Document3.prototype.elementsFromBBox = function(minX, minY, maxX, maxY2) {
      var rBush = this.defaultView.context.rBushRoot;
      var rBushNodes = rBush.search({ minX, minY, maxX, maxY: maxY2 });
      var hitTestList = [];
      rBushNodes.forEach(function(_a2) {
        var displayObject = _a2.displayObject;
        var pointerEvents = displayObject.parsedStyle.pointerEvents;
        var isVisibilityAffected = [
          "auto",
          "visiblepainted",
          "visiblefill",
          "visiblestroke",
          "visible"
        ].includes(pointerEvents);
        if ((!isVisibilityAffected || isVisibilityAffected && displayObject.isVisible()) && !displayObject.isCulled() && displayObject.isInteractive()) {
          hitTestList.push(displayObject);
        }
      });
      hitTestList.sort(function(a4, b) {
        return b.sortable.renderOrder - a4.sortable.renderOrder;
      });
      return hitTestList;
    };
    Document3.prototype.elementFromPointSync = function(x3, y3) {
      var _a2 = this.defaultView.canvas2Viewport({
        x: x3,
        y: y3
      }), viewportX = _a2.x, viewportY = _a2.y;
      var _b = this.defaultView.getConfig(), width = _b.width, height = _b.height;
      if (viewportX < 0 || viewportY < 0 || viewportX > width || viewportY > height) {
        return null;
      }
      var _c = this.defaultView.viewport2Client({
        x: viewportX,
        y: viewportY
      }), clientX = _c.x, clientY = _c.y;
      var picked = this.defaultView.getRenderingService().hooks.pickSync.call({
        topmost: true,
        position: {
          x: x3,
          y: y3,
          viewportX,
          viewportY,
          clientX,
          clientY
        },
        picked: []
      }).picked;
      return picked && picked[0] || this.documentElement;
    };
    Document3.prototype.elementFromPoint = function(x3, y3) {
      return __awaiter(this, void 0, void 0, function() {
        var _a2, viewportX, viewportY, _b, width, height, _c, clientX, clientY, picked;
        return __generator(this, function(_d) {
          switch (_d.label) {
            case 0:
              _a2 = this.defaultView.canvas2Viewport({
                x: x3,
                y: y3
              }), viewportX = _a2.x, viewportY = _a2.y;
              _b = this.defaultView.getConfig(), width = _b.width, height = _b.height;
              if (viewportX < 0 || viewportY < 0 || viewportX > width || viewportY > height) {
                return [2, null];
              }
              _c = this.defaultView.viewport2Client({
                x: viewportX,
                y: viewportY
              }), clientX = _c.x, clientY = _c.y;
              return [4, this.defaultView.getRenderingService().hooks.pick.promise({
                topmost: true,
                position: {
                  x: x3,
                  y: y3,
                  viewportX,
                  viewportY,
                  clientX,
                  clientY
                },
                picked: []
              })];
            case 1:
              picked = _d.sent().picked;
              return [2, picked && picked[0] || this.documentElement];
          }
        });
      });
    };
    Document3.prototype.elementsFromPointSync = function(x3, y3) {
      var _a2 = this.defaultView.canvas2Viewport({
        x: x3,
        y: y3
      }), viewportX = _a2.x, viewportY = _a2.y;
      var _b = this.defaultView.getConfig(), width = _b.width, height = _b.height;
      if (viewportX < 0 || viewportY < 0 || viewportX > width || viewportY > height) {
        return [];
      }
      var _c = this.defaultView.viewport2Client({
        x: viewportX,
        y: viewportY
      }), clientX = _c.x, clientY = _c.y;
      var picked = this.defaultView.getRenderingService().hooks.pickSync.call({
        topmost: false,
        position: {
          x: x3,
          y: y3,
          viewportX,
          viewportY,
          clientX,
          clientY
        },
        picked: []
      }).picked;
      if (picked[picked.length - 1] !== this.documentElement) {
        picked.push(this.documentElement);
      }
      return picked;
    };
    Document3.prototype.elementsFromPoint = function(x3, y3) {
      return __awaiter(this, void 0, void 0, function() {
        var _a2, viewportX, viewportY, _b, width, height, _c, clientX, clientY, picked;
        return __generator(this, function(_d) {
          switch (_d.label) {
            case 0:
              _a2 = this.defaultView.canvas2Viewport({
                x: x3,
                y: y3
              }), viewportX = _a2.x, viewportY = _a2.y;
              _b = this.defaultView.getConfig(), width = _b.width, height = _b.height;
              if (viewportX < 0 || viewportY < 0 || viewportX > width || viewportY > height) {
                return [2, []];
              }
              _c = this.defaultView.viewport2Client({
                x: viewportX,
                y: viewportY
              }), clientX = _c.x, clientY = _c.y;
              return [4, this.defaultView.getRenderingService().hooks.pick.promise({
                topmost: false,
                position: {
                  x: x3,
                  y: y3,
                  viewportX,
                  viewportY,
                  clientX,
                  clientY
                },
                picked: []
              })];
            case 1:
              picked = _d.sent().picked;
              if (picked[picked.length - 1] !== this.documentElement) {
                picked.push(this.documentElement);
              }
              return [2, picked];
          }
        });
      });
    };
    Document3.prototype.appendChild = function(newChild, index3) {
      throw new Error(ERROR_MSG_USE_DOCUMENT_ELEMENT);
    };
    Document3.prototype.insertBefore = function(newChild, refChild) {
      throw new Error(ERROR_MSG_USE_DOCUMENT_ELEMENT);
    };
    Document3.prototype.removeChild = function(oldChild, destroy2) {
      throw new Error(ERROR_MSG_USE_DOCUMENT_ELEMENT);
    };
    Document3.prototype.replaceChild = function(newChild, oldChild, destroy2) {
      throw new Error(ERROR_MSG_USE_DOCUMENT_ELEMENT);
    };
    Document3.prototype.append = function() {
      throw new Error(ERROR_MSG_USE_DOCUMENT_ELEMENT);
    };
    Document3.prototype.prepend = function() {
      throw new Error(ERROR_MSG_USE_DOCUMENT_ELEMENT);
    };
    Document3.prototype.getElementById = function(id3) {
      return this.documentElement.getElementById(id3);
    };
    Document3.prototype.getElementsByName = function(name2) {
      return this.documentElement.getElementsByName(name2);
    };
    Document3.prototype.getElementsByTagName = function(tagName) {
      return this.documentElement.getElementsByTagName(tagName);
    };
    Document3.prototype.getElementsByClassName = function(className2) {
      return this.documentElement.getElementsByClassName(className2);
    };
    Document3.prototype.querySelector = function(selectors) {
      return this.documentElement.querySelector(selectors);
    };
    Document3.prototype.querySelectorAll = function(selectors) {
      return this.documentElement.querySelectorAll(selectors);
    };
    Document3.prototype.find = function(filter4) {
      return this.documentElement.find(filter4);
    };
    Document3.prototype.findAll = function(filter4) {
      return this.documentElement.findAll(filter4);
    };
    return Document3;
  }(Node)
);
var CullingPlugin = (
  /** @class */
  function() {
    function CullingPlugin2(strategies) {
      this.strategies = strategies;
    }
    CullingPlugin2.prototype.apply = function(context) {
      var camera = context.camera, renderingService = context.renderingService, renderingContext = context.renderingContext;
      var strategies = this.strategies;
      renderingService.hooks.cull.tap(CullingPlugin2.tag, function(object) {
        if (object) {
          var cullable = object.cullable;
          if (strategies.length === 0) {
            cullable.visible = renderingContext.unculledEntities.indexOf(object.entity) > -1;
          } else {
            cullable.visible = strategies.every(function(strategy) {
              return strategy.isVisible(camera, object);
            });
          }
          if (!object.isCulled() && object.isVisible()) {
            return object;
          } else {
            object.dispatchEvent(new CustomEvent(ElementEvent.CULLED));
          }
          return null;
        }
        return object;
      });
      renderingService.hooks.afterRender.tap(CullingPlugin2.tag, function(object) {
        object.cullable.visibilityPlaneMask = -1;
      });
    };
    CullingPlugin2.tag = "Culling";
    return CullingPlugin2;
  }()
);
var EventPlugin = (
  /** @class */
  function() {
    function EventPlugin2() {
      var _this2 = this;
      this.autoPreventDefault = false;
      this.rootPointerEvent = new FederatedPointerEvent(null);
      this.rootWheelEvent = new FederatedWheelEvent(null);
      this.onPointerMove = function(nativeEvent) {
        var e_1, _a2;
        var _b, _c;
        var canvas = (_c = (_b = _this2.context.renderingContext.root) === null || _b === void 0 ? void 0 : _b.ownerDocument) === null || _c === void 0 ? void 0 : _c.defaultView;
        if (canvas.supportsTouchEvents && nativeEvent.pointerType === "touch")
          return;
        var normalizedEvents = _this2.normalizeToPointerEvent(nativeEvent, canvas);
        try {
          for (var normalizedEvents_1 = __values(normalizedEvents), normalizedEvents_1_1 = normalizedEvents_1.next(); !normalizedEvents_1_1.done; normalizedEvents_1_1 = normalizedEvents_1.next()) {
            var normalizedEvent = normalizedEvents_1_1.value;
            var event_1 = _this2.bootstrapEvent(_this2.rootPointerEvent, normalizedEvent, canvas, nativeEvent);
            _this2.context.eventService.mapEvent(event_1);
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (normalizedEvents_1_1 && !normalizedEvents_1_1.done && (_a2 = normalizedEvents_1.return))
              _a2.call(normalizedEvents_1);
          } finally {
            if (e_1)
              throw e_1.error;
          }
        }
        _this2.setCursor(_this2.context.eventService.cursor);
      };
      this.onClick = function(nativeEvent) {
        var e_2, _a2;
        var _b, _c;
        var canvas = (_c = (_b = _this2.context.renderingContext.root) === null || _b === void 0 ? void 0 : _b.ownerDocument) === null || _c === void 0 ? void 0 : _c.defaultView;
        var normalizedEvents = _this2.normalizeToPointerEvent(nativeEvent, canvas);
        try {
          for (var normalizedEvents_2 = __values(normalizedEvents), normalizedEvents_2_1 = normalizedEvents_2.next(); !normalizedEvents_2_1.done; normalizedEvents_2_1 = normalizedEvents_2.next()) {
            var normalizedEvent = normalizedEvents_2_1.value;
            var event_2 = _this2.bootstrapEvent(_this2.rootPointerEvent, normalizedEvent, canvas, nativeEvent);
            _this2.context.eventService.mapEvent(event_2);
          }
        } catch (e_2_1) {
          e_2 = { error: e_2_1 };
        } finally {
          try {
            if (normalizedEvents_2_1 && !normalizedEvents_2_1.done && (_a2 = normalizedEvents_2.return))
              _a2.call(normalizedEvents_2);
          } finally {
            if (e_2)
              throw e_2.error;
          }
        }
        _this2.setCursor(_this2.context.eventService.cursor);
      };
    }
    EventPlugin2.prototype.apply = function(context) {
      var _this2 = this;
      this.context = context;
      var renderingService = context.renderingService;
      var canvas = this.context.renderingContext.root.ownerDocument.defaultView;
      this.context.eventService.setPickHandler(function(position) {
        var picked = _this2.context.renderingService.hooks.pickSync.call({
          position,
          picked: [],
          topmost: true
          // we only concern the topmost element
        }).picked;
        return picked[0] || null;
      });
      renderingService.hooks.pointerWheel.tap(EventPlugin2.tag, function(nativeEvent) {
        var wheelEvent = _this2.normalizeWheelEvent(nativeEvent);
        _this2.context.eventService.mapEvent(wheelEvent);
      });
      renderingService.hooks.pointerDown.tap(EventPlugin2.tag, function(nativeEvent) {
        var e_3, _a2;
        if (canvas.supportsTouchEvents && nativeEvent.pointerType === "touch")
          return;
        var events = _this2.normalizeToPointerEvent(nativeEvent, canvas);
        if (_this2.autoPreventDefault && events[0].isNormalized) {
          var cancelable = nativeEvent.cancelable || !("cancelable" in nativeEvent);
          if (cancelable) {
            nativeEvent.preventDefault();
          }
        }
        try {
          for (var events_1 = __values(events), events_1_1 = events_1.next(); !events_1_1.done; events_1_1 = events_1.next()) {
            var event_3 = events_1_1.value;
            var federatedEvent = _this2.bootstrapEvent(_this2.rootPointerEvent, event_3, canvas, nativeEvent);
            _this2.context.eventService.mapEvent(federatedEvent);
          }
        } catch (e_3_1) {
          e_3 = { error: e_3_1 };
        } finally {
          try {
            if (events_1_1 && !events_1_1.done && (_a2 = events_1.return))
              _a2.call(events_1);
          } finally {
            if (e_3)
              throw e_3.error;
          }
        }
        _this2.setCursor(_this2.context.eventService.cursor);
      });
      renderingService.hooks.pointerUp.tap(EventPlugin2.tag, function(nativeEvent) {
        var e_4, _a2;
        if (canvas.supportsTouchEvents && nativeEvent.pointerType === "touch")
          return;
        var $element = _this2.context.contextService.getDomElement();
        var outside2 = "outside";
        try {
          outside2 = $element && nativeEvent.target && nativeEvent.target !== $element && $element.contains && !$element.contains(nativeEvent.target) ? "outside" : "";
        } catch (e) {
        }
        var normalizedEvents = _this2.normalizeToPointerEvent(nativeEvent, canvas);
        try {
          for (var normalizedEvents_3 = __values(normalizedEvents), normalizedEvents_3_1 = normalizedEvents_3.next(); !normalizedEvents_3_1.done; normalizedEvents_3_1 = normalizedEvents_3.next()) {
            var normalizedEvent = normalizedEvents_3_1.value;
            var event_4 = _this2.bootstrapEvent(_this2.rootPointerEvent, normalizedEvent, canvas, nativeEvent);
            event_4.type += outside2;
            _this2.context.eventService.mapEvent(event_4);
          }
        } catch (e_4_1) {
          e_4 = { error: e_4_1 };
        } finally {
          try {
            if (normalizedEvents_3_1 && !normalizedEvents_3_1.done && (_a2 = normalizedEvents_3.return))
              _a2.call(normalizedEvents_3);
          } finally {
            if (e_4)
              throw e_4.error;
          }
        }
        _this2.setCursor(_this2.context.eventService.cursor);
      });
      renderingService.hooks.pointerMove.tap(EventPlugin2.tag, this.onPointerMove);
      renderingService.hooks.pointerOver.tap(EventPlugin2.tag, this.onPointerMove);
      renderingService.hooks.pointerOut.tap(EventPlugin2.tag, this.onPointerMove);
      renderingService.hooks.click.tap(EventPlugin2.tag, this.onClick);
      renderingService.hooks.pointerCancel.tap(EventPlugin2.tag, function(nativeEvent) {
        var e_5, _a2;
        var normalizedEvents = _this2.normalizeToPointerEvent(nativeEvent, canvas);
        try {
          for (var normalizedEvents_4 = __values(normalizedEvents), normalizedEvents_4_1 = normalizedEvents_4.next(); !normalizedEvents_4_1.done; normalizedEvents_4_1 = normalizedEvents_4.next()) {
            var normalizedEvent = normalizedEvents_4_1.value;
            var event_5 = _this2.bootstrapEvent(_this2.rootPointerEvent, normalizedEvent, canvas, nativeEvent);
            _this2.context.eventService.mapEvent(event_5);
          }
        } catch (e_5_1) {
          e_5 = { error: e_5_1 };
        } finally {
          try {
            if (normalizedEvents_4_1 && !normalizedEvents_4_1.done && (_a2 = normalizedEvents_4.return))
              _a2.call(normalizedEvents_4);
          } finally {
            if (e_5)
              throw e_5.error;
          }
        }
        _this2.setCursor(_this2.context.eventService.cursor);
      });
    };
    EventPlugin2.prototype.getViewportXY = function(nativeEvent) {
      var x3;
      var y3;
      var offsetX = nativeEvent.offsetX, offsetY = nativeEvent.offsetY, clientX = nativeEvent.clientX, clientY = nativeEvent.clientY;
      if (this.context.config.supportsCSSTransform && !is_nil_default(offsetX) && !is_nil_default(offsetY)) {
        x3 = offsetX;
        y3 = offsetY;
      } else {
        var point7 = this.context.eventService.client2Viewport(new Point2(clientX, clientY));
        x3 = point7.x;
        y3 = point7.y;
      }
      return { x: x3, y: y3 };
    };
    EventPlugin2.prototype.bootstrapEvent = function(event, normalizedEvent, view, nativeEvent) {
      event.view = view;
      event.originalEvent = null;
      event.nativeEvent = nativeEvent;
      event.pointerId = normalizedEvent.pointerId;
      event.width = normalizedEvent.width;
      event.height = normalizedEvent.height;
      event.isPrimary = normalizedEvent.isPrimary;
      event.pointerType = normalizedEvent.pointerType;
      event.pressure = normalizedEvent.pressure;
      event.tangentialPressure = normalizedEvent.tangentialPressure;
      event.tiltX = normalizedEvent.tiltX;
      event.tiltY = normalizedEvent.tiltY;
      event.twist = normalizedEvent.twist;
      this.transferMouseData(event, normalizedEvent);
      var _a2 = this.getViewportXY(normalizedEvent), x3 = _a2.x, y3 = _a2.y;
      event.viewport.x = x3;
      event.viewport.y = y3;
      var _b = this.context.eventService.viewport2Canvas(event.viewport), canvasX = _b.x, canvasY = _b.y;
      event.canvas.x = canvasX;
      event.canvas.y = canvasY;
      event.global.copyFrom(event.canvas);
      event.offset.copyFrom(event.canvas);
      event.isTrusted = nativeEvent.isTrusted;
      if (event.type === "pointerleave") {
        event.type = "pointerout";
      }
      if (event.type.startsWith("mouse")) {
        event.type = event.type.replace("mouse", "pointer");
      }
      if (event.type.startsWith("touch")) {
        event.type = TOUCH_TO_POINTER[event.type] || event.type;
      }
      return event;
    };
    EventPlugin2.prototype.normalizeWheelEvent = function(nativeEvent) {
      var event = this.rootWheelEvent;
      this.transferMouseData(event, nativeEvent);
      event.deltaMode = nativeEvent.deltaMode;
      event.deltaX = nativeEvent.deltaX;
      event.deltaY = nativeEvent.deltaY;
      event.deltaZ = nativeEvent.deltaZ;
      var _a2 = this.getViewportXY(nativeEvent), x3 = _a2.x, y3 = _a2.y;
      event.viewport.x = x3;
      event.viewport.y = y3;
      var _b = this.context.eventService.viewport2Canvas(event.viewport), canvasX = _b.x, canvasY = _b.y;
      event.canvas.x = canvasX;
      event.canvas.y = canvasY;
      event.global.copyFrom(event.canvas);
      event.offset.copyFrom(event.canvas);
      event.nativeEvent = nativeEvent;
      event.type = nativeEvent.type;
      return event;
    };
    EventPlugin2.prototype.transferMouseData = function(event, nativeEvent) {
      event.isTrusted = nativeEvent.isTrusted;
      event.srcElement = nativeEvent.srcElement;
      event.timeStamp = clock.now();
      event.type = nativeEvent.type;
      event.altKey = nativeEvent.altKey;
      event.metaKey = nativeEvent.metaKey;
      event.shiftKey = nativeEvent.shiftKey;
      event.ctrlKey = nativeEvent.ctrlKey;
      event.button = nativeEvent.button;
      event.buttons = nativeEvent.buttons;
      event.client.x = nativeEvent.clientX;
      event.client.y = nativeEvent.clientY;
      event.movement.x = nativeEvent.movementX;
      event.movement.y = nativeEvent.movementY;
      event.page.x = nativeEvent.pageX;
      event.page.y = nativeEvent.pageY;
      event.screen.x = nativeEvent.screenX;
      event.screen.y = nativeEvent.screenY;
      event.relatedTarget = null;
    };
    EventPlugin2.prototype.setCursor = function(cursor) {
      this.context.contextService.applyCursorStyle(cursor || this.context.config.cursor || "default");
    };
    EventPlugin2.prototype.normalizeToPointerEvent = function(event, canvas) {
      var normalizedEvents = [];
      if (canvas.isTouchEvent(event)) {
        for (var i = 0; i < event.changedTouches.length; i++) {
          var touch = event.changedTouches[i];
          if (is_undefined_default(touch.button))
            touch.button = 0;
          if (is_undefined_default(touch.buttons))
            touch.buttons = 1;
          if (is_undefined_default(touch.isPrimary)) {
            touch.isPrimary = event.touches.length === 1 && event.type === "touchstart";
          }
          if (is_undefined_default(touch.width))
            touch.width = touch.radiusX || 1;
          if (is_undefined_default(touch.height))
            touch.height = touch.radiusY || 1;
          if (is_undefined_default(touch.tiltX))
            touch.tiltX = 0;
          if (is_undefined_default(touch.tiltY))
            touch.tiltY = 0;
          if (is_undefined_default(touch.pointerType))
            touch.pointerType = "touch";
          if (is_undefined_default(touch.pointerId))
            touch.pointerId = touch.identifier || 0;
          if (is_undefined_default(touch.pressure))
            touch.pressure = touch.force || 0.5;
          if (is_undefined_default(touch.twist))
            touch.twist = 0;
          if (is_undefined_default(touch.tangentialPressure))
            touch.tangentialPressure = 0;
          touch.isNormalized = true;
          touch.type = event.type;
          normalizedEvents.push(touch);
        }
      } else if (canvas.isMouseEvent(event)) {
        var tempEvent = event;
        if (is_undefined_default(tempEvent.isPrimary))
          tempEvent.isPrimary = true;
        if (is_undefined_default(tempEvent.width))
          tempEvent.width = 1;
        if (is_undefined_default(tempEvent.height))
          tempEvent.height = 1;
        if (is_undefined_default(tempEvent.tiltX))
          tempEvent.tiltX = 0;
        if (is_undefined_default(tempEvent.tiltY))
          tempEvent.tiltY = 0;
        if (is_undefined_default(tempEvent.pointerType))
          tempEvent.pointerType = "mouse";
        if (is_undefined_default(tempEvent.pointerId))
          tempEvent.pointerId = MOUSE_POINTER_ID;
        if (is_undefined_default(tempEvent.pressure))
          tempEvent.pressure = 0.5;
        if (is_undefined_default(tempEvent.twist))
          tempEvent.twist = 0;
        if (is_undefined_default(tempEvent.tangentialPressure))
          tempEvent.tangentialPressure = 0;
        tempEvent.isNormalized = true;
        normalizedEvents.push(tempEvent);
      } else {
        normalizedEvents.push(event);
      }
      return normalizedEvents;
    };
    EventPlugin2.tag = "Event";
    return EventPlugin2;
  }()
);
var shape2D = [
  Shape.CIRCLE,
  Shape.ELLIPSE,
  Shape.IMAGE,
  Shape.RECT,
  Shape.LINE,
  Shape.POLYLINE,
  Shape.POLYGON,
  Shape.TEXT,
  Shape.PATH,
  Shape.HTML
];
var FrustumCullingStrategy = (
  /** @class */
  function() {
    function FrustumCullingStrategy2() {
    }
    FrustumCullingStrategy2.prototype.isVisible = function(camera, object) {
      var _a2, _b;
      var cullable = object.cullable;
      if (!cullable.enable) {
        return true;
      }
      var renderBounds = object.getRenderBounds();
      if (AABB.isEmpty(renderBounds)) {
        return false;
      }
      var frustum2 = camera.getFrustum();
      var parentVisibilityPlaneMask = (_b = (_a2 = object.parentNode) === null || _a2 === void 0 ? void 0 : _a2.cullable) === null || _b === void 0 ? void 0 : _b.visibilityPlaneMask;
      cullable.visibilityPlaneMask = this.computeVisibilityWithPlaneMask(object, renderBounds, parentVisibilityPlaneMask || Mask.INDETERMINATE, frustum2.planes);
      cullable.visible = cullable.visibilityPlaneMask !== Mask.OUTSIDE;
      return cullable.visible;
    };
    FrustumCullingStrategy2.prototype.computeVisibilityWithPlaneMask = function(object, aabb, parentPlaneMask, planes) {
      if (parentPlaneMask === Mask.OUTSIDE || parentPlaneMask === Mask.INSIDE) {
        return parentPlaneMask;
      }
      var mask = Mask.INSIDE;
      var isShape2D = shape2D.indexOf(object.nodeName) > -1;
      for (var k2 = 0, len5 = planes.length; k2 < len5; ++k2) {
        var flag = 1 << k2;
        if ((parentPlaneMask & flag) === 0) {
          continue;
        }
        if (isShape2D && (k2 === 4 || k2 === 5)) {
          continue;
        }
        var _a2 = planes[k2], normal = _a2.normal, distance7 = _a2.distance;
        if (vec3_exports.dot(normal, aabb.getPositiveFarPoint(planes[k2])) + distance7 < 0) {
          return Mask.OUTSIDE;
        }
        if (vec3_exports.dot(normal, aabb.getNegativeFarPoint(planes[k2])) + distance7 < 0) {
          mask |= flag;
        }
      }
      return mask;
    };
    return FrustumCullingStrategy2;
  }()
);
var PrepareRendererPlugin = (
  /** @class */
  function() {
    function PrepareRendererPlugin2() {
      this.toSync = /* @__PURE__ */ new Set();
    }
    PrepareRendererPlugin2.prototype.apply = function(context) {
      var _this2 = this;
      var renderingService = context.renderingService, renderingContext = context.renderingContext, rBushRoot = context.rBushRoot;
      var canvas = renderingContext.root.ownerDocument.defaultView;
      this.rBush = rBushRoot;
      var handleAttributeChanged = function(e) {
        var object = e.target;
        object.renderable.dirty = true;
        renderingService.dirtify();
      };
      var handleBoundsChanged = function(e) {
        var affectChildren = e.detail.affectChildren;
        var object = e.target;
        if (affectChildren) {
          object.forEach(function(node) {
            _this2.toSync.add(node);
          });
        }
        var p2 = object;
        while (p2) {
          if (p2.renderable) {
            _this2.toSync.add(p2);
          }
          p2 = p2.parentElement;
        }
        renderingService.dirtify();
      };
      var handleMounted = function(e) {
        var object = e.target;
        if (runtime.enableCSSParsing) {
          runtime.styleValueRegistry.recalc(object);
        }
        runtime.sceneGraphService.dirtifyToRoot(object);
        renderingService.dirtify();
      };
      var handleUnmounted = function(e) {
        var object = e.target;
        var rBushNode = object.rBushNode;
        if (rBushNode.aabb) {
          _this2.rBush.remove(rBushNode.aabb);
        }
        _this2.toSync.delete(object);
        runtime.sceneGraphService.dirtifyToRoot(object);
        renderingService.dirtify();
      };
      renderingService.hooks.init.tap(PrepareRendererPlugin2.tag, function() {
        canvas.addEventListener(ElementEvent.MOUNTED, handleMounted);
        canvas.addEventListener(ElementEvent.UNMOUNTED, handleUnmounted);
        canvas.addEventListener(ElementEvent.ATTR_MODIFIED, handleAttributeChanged);
        canvas.addEventListener(ElementEvent.BOUNDS_CHANGED, handleBoundsChanged);
      });
      renderingService.hooks.destroy.tap(PrepareRendererPlugin2.tag, function() {
        canvas.removeEventListener(ElementEvent.MOUNTED, handleMounted);
        canvas.removeEventListener(ElementEvent.UNMOUNTED, handleUnmounted);
        canvas.removeEventListener(ElementEvent.ATTR_MODIFIED, handleAttributeChanged);
        canvas.removeEventListener(ElementEvent.BOUNDS_CHANGED, handleBoundsChanged);
        _this2.toSync.clear();
      });
      renderingService.hooks.endFrame.tap(PrepareRendererPlugin2.tag, function() {
        _this2.syncRTree();
      });
    };
    PrepareRendererPlugin2.prototype.syncRTree = function() {
      var _this2 = this;
      var bulk = [];
      Array.from(this.toSync).filter(function(object) {
        return object.isConnected;
      }).forEach(function(node) {
        var rBushNode = node.rBushNode;
        if (rBushNode && rBushNode.aabb) {
          _this2.rBush.remove(rBushNode.aabb);
        }
        var renderBounds = node.getRenderBounds();
        if (renderBounds) {
          var _a2 = __read(renderBounds.getMin(), 2), minX = _a2[0], minY = _a2[1];
          var _b = __read(renderBounds.getMax(), 2), maxX = _b[0], maxY2 = _b[1];
          if (!rBushNode.aabb) {
            rBushNode.aabb = {};
          }
          rBushNode.aabb.displayObject = node;
          rBushNode.aabb.minX = minX;
          rBushNode.aabb.minY = minY;
          rBushNode.aabb.maxX = maxX;
          rBushNode.aabb.maxY = maxY2;
        }
        if (rBushNode.aabb) {
          if (!isNaN(rBushNode.aabb.maxX) && !isNaN(rBushNode.aabb.maxX) && !isNaN(rBushNode.aabb.minX) && !isNaN(rBushNode.aabb.minY)) {
            bulk.push(rBushNode.aabb);
          }
        }
      });
      this.rBush.load(bulk);
      bulk.length = 0;
      this.toSync.clear();
    };
    PrepareRendererPlugin2.tag = "Prepare";
    return PrepareRendererPlugin2;
  }()
);
var CanvasEvent;
(function(CanvasEvent2) {
  CanvasEvent2["READY"] = "ready";
  CanvasEvent2["BEFORE_RENDER"] = "beforerender";
  CanvasEvent2["RERENDER"] = "rerender";
  CanvasEvent2["AFTER_RENDER"] = "afterrender";
  CanvasEvent2["BEFORE_DESTROY"] = "beforedestroy";
  CanvasEvent2["AFTER_DESTROY"] = "afterdestroy";
  CanvasEvent2["RESIZE"] = "resize";
  CanvasEvent2["DIRTY_RECTANGLE"] = "dirtyrectangle";
  CanvasEvent2["RENDERER_CHANGED"] = "rendererchanged";
})(CanvasEvent || (CanvasEvent = {}));
var DEFAULT_CAMERA_Z = 500;
var DEFAULT_CAMERA_NEAR = 0.1;
var DEFAULT_CAMERA_FAR = 1e3;
var mountedEvent = new CustomEvent(ElementEvent.MOUNTED);
var unmountedEvent = new CustomEvent(ElementEvent.UNMOUNTED);
var beforeRenderEvent = new CustomEvent(CanvasEvent.BEFORE_RENDER);
var rerenderEvent = new CustomEvent(CanvasEvent.RERENDER);
var afterRenderEvent = new CustomEvent(CanvasEvent.AFTER_RENDER);
var Canvas = (
  /** @class */
  function(_super) {
    __extends(Canvas3, _super);
    function Canvas3(config) {
      var _this2 = _super.call(this) || this;
      _this2.Element = DisplayObject;
      _this2.inited = false;
      _this2.context = {};
      _this2.document = new Document2();
      _this2.document.defaultView = _this2;
      _this2.customElements = new CustomElementRegistry();
      var container = config.container, canvas = config.canvas, offscreenCanvas = config.offscreenCanvas, width = config.width, height = config.height, devicePixelRatio = config.devicePixelRatio, renderer = config.renderer, background = config.background, cursor = config.cursor, document2 = config.document, requestAnimationFrame4 = config.requestAnimationFrame, cancelAnimationFrame5 = config.cancelAnimationFrame, createImage = config.createImage, supportsPointerEvents = config.supportsPointerEvents, supportsTouchEvents = config.supportsTouchEvents, supportsCSSTransform = config.supportsCSSTransform, supportsMutipleCanvasesInOneContainer = config.supportsMutipleCanvasesInOneContainer, useNativeClickEvent = config.useNativeClickEvent, alwaysTriggerPointerEventOnCanvas = config.alwaysTriggerPointerEventOnCanvas, isTouchEvent = config.isTouchEvent, isMouseEvent = config.isMouseEvent;
      if (!supportsMutipleCanvasesInOneContainer) {
        cleanExistedCanvas(container, _this2);
      }
      var canvasWidth = width;
      var canvasHeight = height;
      var dpr = devicePixelRatio;
      if (canvas) {
        dpr = devicePixelRatio || isBrowser && window.devicePixelRatio || 1;
        dpr = dpr >= 1 ? Math.ceil(dpr) : 1;
        canvasWidth = width || getWidth(canvas) || canvas.width / dpr;
        canvasHeight = height || getHeight(canvas) || canvas.height / dpr;
      }
      if (offscreenCanvas) {
        runtime.offscreenCanvas = offscreenCanvas;
      }
      _this2.devicePixelRatio = dpr;
      _this2.requestAnimationFrame = requestAnimationFrame4 !== null && requestAnimationFrame4 !== void 0 ? requestAnimationFrame4 : raf.bind(runtime.globalThis);
      _this2.cancelAnimationFrame = cancelAnimationFrame5 !== null && cancelAnimationFrame5 !== void 0 ? cancelAnimationFrame5 : caf.bind(runtime.globalThis);
      _this2.supportsTouchEvents = supportsTouchEvents !== null && supportsTouchEvents !== void 0 ? supportsTouchEvents : "ontouchstart" in runtime.globalThis;
      _this2.supportsPointerEvents = supportsPointerEvents !== null && supportsPointerEvents !== void 0 ? supportsPointerEvents : !!runtime.globalThis.PointerEvent;
      _this2.isTouchEvent = isTouchEvent !== null && isTouchEvent !== void 0 ? isTouchEvent : function(event) {
        return _this2.supportsTouchEvents && event instanceof runtime.globalThis.TouchEvent;
      };
      _this2.isMouseEvent = isMouseEvent !== null && isMouseEvent !== void 0 ? isMouseEvent : function(event) {
        return !runtime.globalThis.MouseEvent || event instanceof runtime.globalThis.MouseEvent && (!_this2.supportsPointerEvents || !(event instanceof runtime.globalThis.PointerEvent));
      };
      _this2.initRenderingContext({
        container,
        canvas,
        width: canvasWidth,
        height: canvasHeight,
        renderer,
        offscreenCanvas,
        devicePixelRatio: dpr,
        cursor: cursor || "default",
        background: background || "transparent",
        createImage,
        document: document2,
        supportsCSSTransform,
        useNativeClickEvent,
        alwaysTriggerPointerEventOnCanvas
      });
      _this2.initDefaultCamera(canvasWidth, canvasHeight, renderer.clipSpaceNearZ);
      _this2.initRenderer(renderer, true);
      return _this2;
    }
    Canvas3.prototype.initRenderingContext = function(mergedConfig) {
      this.context.config = mergedConfig;
      this.context.renderingContext = {
        /**
         * the root node in scene graph
         */
        root: this.document.documentElement,
        renderListCurrentFrame: [],
        unculledEntities: [],
        renderReasons: /* @__PURE__ */ new Set(),
        force: false,
        dirty: false
      };
    };
    Canvas3.prototype.initDefaultCamera = function(width, height, clipSpaceNearZ) {
      var _this2 = this;
      var camera = new runtime.CameraContribution();
      camera.clipSpaceNearZ = clipSpaceNearZ;
      camera.setType(CameraType.EXPLORING, CameraTrackingMode.DEFAULT).setPosition(width / 2, height / 2, DEFAULT_CAMERA_Z).setFocalPoint(width / 2, height / 2, 0).setOrthographic(width / -2, width / 2, height / 2, height / -2, DEFAULT_CAMERA_NEAR, DEFAULT_CAMERA_FAR);
      camera.canvas = this;
      camera.eventEmitter.on(CameraEvent.UPDATED, function() {
        _this2.context.renderingContext.renderReasons.add(RenderReason.CAMERA_CHANGED);
      });
      this.context.camera = camera;
    };
    Canvas3.prototype.getConfig = function() {
      return this.context.config;
    };
    Canvas3.prototype.getRoot = function() {
      return this.document.documentElement;
    };
    Canvas3.prototype.getCamera = function() {
      return this.context.camera;
    };
    Canvas3.prototype.getContextService = function() {
      return this.context.contextService;
    };
    Canvas3.prototype.getEventService = function() {
      return this.context.eventService;
    };
    Canvas3.prototype.getRenderingService = function() {
      return this.context.renderingService;
    };
    Canvas3.prototype.getRenderingContext = function() {
      return this.context.renderingContext;
    };
    Canvas3.prototype.getStats = function() {
      return this.getRenderingService().getStats();
    };
    Object.defineProperty(Canvas3.prototype, "ready", {
      // /**
      //  * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Window/getComputedStyle
      //  */
      // getComputedStyle(node: DisplayObject) {
      //   return node.computedStyle;
      // }
      get: function() {
        var _this2 = this;
        if (!this.readyPromise) {
          this.readyPromise = new Promise(function(resolve) {
            _this2.resolveReadyPromise = function() {
              resolve(_this2);
            };
          });
          if (this.inited) {
            this.resolveReadyPromise();
          }
        }
        return this.readyPromise;
      },
      enumerable: false,
      configurable: true
    });
    Canvas3.prototype.destroy = function(cleanUp, skipTriggerEvent) {
      if (cleanUp === void 0) {
        cleanUp = true;
      }
      if (skipTriggerEvent === void 0) {
        skipTriggerEvent = false;
      }
      if (!skipTriggerEvent) {
        this.dispatchEvent(new CustomEvent(CanvasEvent.BEFORE_DESTROY));
      }
      if (this.frameId) {
        var cancelRAF = this.getConfig().cancelAnimationFrame || cancelAnimationFrame;
        cancelRAF(this.frameId);
      }
      var root3 = this.getRoot();
      this.unmountChildren(root3);
      if (cleanUp) {
        this.document.destroy();
        this.getEventService().destroy();
      }
      this.getRenderingService().destroy();
      this.getContextService().destroy();
      if (cleanUp && this.context.rBushRoot) {
        this.context.rBushRoot.clear();
        this.context.rBushRoot = null;
        this.context.renderingContext.root = null;
      }
      if (!skipTriggerEvent) {
        this.dispatchEvent(new CustomEvent(CanvasEvent.AFTER_DESTROY));
      }
    };
    Canvas3.prototype.changeSize = function(width, height) {
      this.resize(width, height);
    };
    Canvas3.prototype.resize = function(width, height) {
      var canvasConfig = this.context.config;
      canvasConfig.width = width;
      canvasConfig.height = height;
      this.getContextService().resize(width, height);
      var camera = this.context.camera;
      var projectionMode = camera.getProjectionMode();
      camera.setPosition(width / 2, height / 2, DEFAULT_CAMERA_Z).setFocalPoint(width / 2, height / 2, 0);
      if (projectionMode === CameraProjectionMode.ORTHOGRAPHIC) {
        camera.setOrthographic(width / -2, width / 2, height / 2, height / -2, camera.getNear(), camera.getFar());
      } else {
        camera.setAspect(width / height);
      }
      this.dispatchEvent(new CustomEvent(CanvasEvent.RESIZE, { width, height }));
    };
    Canvas3.prototype.appendChild = function(child, index3) {
      return this.document.documentElement.appendChild(child, index3);
    };
    Canvas3.prototype.insertBefore = function(newChild, refChild) {
      return this.document.documentElement.insertBefore(newChild, refChild);
    };
    Canvas3.prototype.removeChild = function(child) {
      return this.document.documentElement.removeChild(child);
    };
    Canvas3.prototype.removeChildren = function() {
      this.document.documentElement.removeChildren();
    };
    Canvas3.prototype.destroyChildren = function() {
      this.document.documentElement.destroyChildren();
    };
    Canvas3.prototype.render = function() {
      var _this2 = this;
      this.dispatchEvent(beforeRenderEvent);
      var renderingService = this.getRenderingService();
      renderingService.render(this.getConfig(), function() {
        _this2.dispatchEvent(rerenderEvent);
      });
      this.dispatchEvent(afterRenderEvent);
    };
    Canvas3.prototype.run = function() {
      var _this2 = this;
      var tick3 = function() {
        _this2.render();
        _this2.frameId = _this2.requestAnimationFrame(tick3);
      };
      tick3();
    };
    Canvas3.prototype.initRenderer = function(renderer, firstContentfullPaint) {
      var _this2 = this;
      if (firstContentfullPaint === void 0) {
        firstContentfullPaint = false;
      }
      if (!renderer) {
        throw new Error("Renderer is required.");
      }
      this.inited = false;
      this.readyPromise = void 0;
      this.context.rBushRoot = new RBush();
      this.context.renderingPlugins = [];
      this.context.renderingPlugins.push(
        new EventPlugin(),
        new PrepareRendererPlugin(),
        // new DirtyCheckPlugin(),
        new CullingPlugin([new FrustumCullingStrategy()])
      );
      this.loadRendererContainerModule(renderer);
      this.context.contextService = new this.context.ContextService(__assign(__assign({}, runtime), this.context));
      this.context.renderingService = new RenderingService(runtime, this.context);
      this.context.eventService = new EventService(runtime, this.context);
      this.context.eventService.init();
      if (this.context.contextService.init) {
        this.context.contextService.init();
        this.initRenderingService(renderer, firstContentfullPaint, true);
      } else {
        this.context.contextService.initAsync().then(function() {
          _this2.initRenderingService(renderer, firstContentfullPaint);
        });
      }
    };
    Canvas3.prototype.initRenderingService = function(renderer, firstContentfullPaint, async) {
      var _this2 = this;
      if (firstContentfullPaint === void 0) {
        firstContentfullPaint = false;
      }
      if (async === void 0) {
        async = false;
      }
      this.context.renderingService.init(function() {
        _this2.inited = true;
        if (firstContentfullPaint) {
          if (async) {
            _this2.requestAnimationFrame(function() {
              _this2.dispatchEvent(new CustomEvent(CanvasEvent.READY));
            });
          } else {
            _this2.dispatchEvent(new CustomEvent(CanvasEvent.READY));
          }
          if (_this2.readyPromise) {
            _this2.resolveReadyPromise();
          }
        } else {
          _this2.dispatchEvent(new CustomEvent(CanvasEvent.RENDERER_CHANGED));
        }
        if (!firstContentfullPaint) {
          _this2.getRoot().forEach(function(node) {
            var renderable = node.renderable;
            if (renderable) {
              renderable.renderBoundsDirty = true;
              renderable.boundsDirty = true;
              renderable.dirty = true;
            }
          });
        }
        _this2.mountChildren(_this2.getRoot());
        if (renderer.getConfig().enableAutoRendering) {
          _this2.run();
        }
      });
    };
    Canvas3.prototype.loadRendererContainerModule = function(renderer) {
      var _this2 = this;
      var plugins = renderer.getPlugins();
      plugins.forEach(function(plugin) {
        plugin.context = _this2.context;
        plugin.init(runtime);
      });
    };
    Canvas3.prototype.setRenderer = function(renderer) {
      var canvasConfig = this.getConfig();
      if (canvasConfig.renderer === renderer) {
        return;
      }
      var oldRenderer = canvasConfig.renderer;
      canvasConfig.renderer = renderer;
      this.destroy(false, true);
      __spreadArray([], __read(oldRenderer === null || oldRenderer === void 0 ? void 0 : oldRenderer.getPlugins()), false).reverse().forEach(function(plugin) {
        plugin.destroy(runtime);
      });
      this.initRenderer(renderer);
    };
    Canvas3.prototype.setCursor = function(cursor) {
      var canvasConfig = this.getConfig();
      canvasConfig.cursor = cursor;
      this.getContextService().applyCursorStyle(cursor);
    };
    Canvas3.prototype.unmountChildren = function(parent2) {
      var _this2 = this;
      parent2.childNodes.forEach(function(child) {
        _this2.unmountChildren(child);
      });
      if (this.inited) {
        if (parent2.isMutationObserved) {
          parent2.dispatchEvent(unmountedEvent);
        } else {
          unmountedEvent.target = parent2;
          this.dispatchEvent(unmountedEvent, true);
        }
        if (parent2 !== this.document.documentElement) {
          parent2.ownerDocument = null;
        }
        parent2.isConnected = false;
      }
      if (parent2.isCustomElement) {
        if (parent2.disconnectedCallback) {
          parent2.disconnectedCallback();
        }
      }
    };
    Canvas3.prototype.mountChildren = function(parent2) {
      var _this2 = this;
      if (this.inited) {
        if (!parent2.isConnected) {
          parent2.ownerDocument = this.document;
          parent2.isConnected = true;
          if (parent2.isMutationObserved) {
            parent2.dispatchEvent(mountedEvent);
          } else {
            mountedEvent.target = parent2;
            this.dispatchEvent(mountedEvent, true);
          }
        }
      } else {
        console.warn("[g]: You are trying to call `canvas.appendChild` before canvas' initialization finished. You can either await `canvas.ready` or listen to `CanvasEvent.READY` manually.", "appended child: ", parent2.nodeName);
      }
      parent2.childNodes.forEach(function(child) {
        _this2.mountChildren(child);
      });
      if (parent2.isCustomElement) {
        if (parent2.connectedCallback) {
          parent2.connectedCallback();
        }
      }
    };
    Canvas3.prototype.client2Viewport = function(client) {
      return this.getEventService().client2Viewport(client);
    };
    Canvas3.prototype.viewport2Client = function(canvas) {
      return this.getEventService().viewport2Client(canvas);
    };
    Canvas3.prototype.viewport2Canvas = function(viewport) {
      return this.getEventService().viewport2Canvas(viewport);
    };
    Canvas3.prototype.canvas2Viewport = function(canvas) {
      return this.getEventService().canvas2Viewport(canvas);
    };
    Canvas3.prototype.getPointByClient = function(clientX, clientY) {
      return this.client2Viewport({ x: clientX, y: clientY });
    };
    Canvas3.prototype.getClientByPoint = function(x3, y3) {
      return this.viewport2Client({ x: x3, y: y3 });
    };
    return Canvas3;
  }(EventTarget)
);

// node_modules/@antv/g-camera-api/dist/index.esm.js
var AdvancedCamera = (
  /** @class */
  function(_super) {
    __extends(AdvancedCamera2, _super);
    function AdvancedCamera2() {
      var _this2 = _super.apply(this, __spreadArray([], __read(arguments), false)) || this;
      _this2.landmarks = [];
      return _this2;
    }
    AdvancedCamera2.prototype.rotate = function(azimuth, elevation, roll) {
      this.relElevation = getAngle2(elevation);
      this.relAzimuth = getAngle2(azimuth);
      this.relRoll = getAngle2(roll);
      this.elevation += this.relElevation;
      this.azimuth += this.relAzimuth;
      this.roll += this.relRoll;
      if (this.type === CameraType.EXPLORING) {
        var rotX = quat_exports.setAxisAngle(quat_exports.create(), [1, 0, 0], deg2rad2((this.rotateWorld ? 1 : -1) * this.relElevation));
        var rotY = quat_exports.setAxisAngle(quat_exports.create(), [0, 1, 0], deg2rad2((this.rotateWorld ? 1 : -1) * this.relAzimuth));
        var rotZ = quat_exports.setAxisAngle(quat_exports.create(), [0, 0, 1], deg2rad2(this.relRoll));
        var rotQ = quat_exports.multiply(quat_exports.create(), rotY, rotX);
        rotQ = quat_exports.multiply(quat_exports.create(), rotQ, rotZ);
        var rotMatrix = mat4_exports.fromQuat(mat4_exports.create(), rotQ);
        mat4_exports.translate(this.matrix, this.matrix, [0, 0, -this.distance]);
        mat4_exports.multiply(this.matrix, this.matrix, rotMatrix);
        mat4_exports.translate(this.matrix, this.matrix, [0, 0, this.distance]);
      } else {
        if (Math.abs(this.elevation) > 90) {
          return this;
        }
        this.computeMatrix();
      }
      this._getAxes();
      if (this.type === CameraType.ORBITING || this.type === CameraType.EXPLORING) {
        this._getPosition();
      } else if (this.type === CameraType.TRACKING) {
        this._getFocalPoint();
      }
      this._update();
      return this;
    };
    AdvancedCamera2.prototype.pan = function(tx, ty) {
      var coords = createVec3(tx, ty, 0);
      var pos = vec3_exports.clone(this.position);
      vec3_exports.add(pos, pos, vec3_exports.scale(vec3_exports.create(), this.right, coords[0]));
      vec3_exports.add(pos, pos, vec3_exports.scale(vec3_exports.create(), this.up, coords[1]));
      this._setPosition(pos);
      this.triggerUpdate();
      return this;
    };
    AdvancedCamera2.prototype.dolly = function(value2) {
      var n = this.forward;
      var pos = vec3_exports.clone(this.position);
      var step2 = value2 * this.dollyingStep;
      var updatedDistance = this.distance + value2 * this.dollyingStep;
      step2 = Math.max(Math.min(updatedDistance, this.maxDistance), this.minDistance) - this.distance;
      pos[0] += step2 * n[0];
      pos[1] += step2 * n[1];
      pos[2] += step2 * n[2];
      this._setPosition(pos);
      if (this.type === CameraType.ORBITING || this.type === CameraType.EXPLORING) {
        this._getDistance();
      } else if (this.type === CameraType.TRACKING) {
        vec3_exports.add(this.focalPoint, pos, this.distanceVector);
      }
      this.triggerUpdate();
      return this;
    };
    AdvancedCamera2.prototype.cancelLandmarkAnimation = function() {
      if (this.landmarkAnimationID !== void 0) {
        this.canvas.cancelAnimationFrame(this.landmarkAnimationID);
      }
    };
    AdvancedCamera2.prototype.createLandmark = function(name2, params) {
      var _a2, _b, _c, _d;
      if (params === void 0) {
        params = {};
      }
      var _e = params.position, position = _e === void 0 ? this.position : _e, _f = params.focalPoint, focalPoint = _f === void 0 ? this.focalPoint : _f, roll = params.roll, zoom = params.zoom;
      var camera = new runtime.CameraContribution();
      camera.setType(this.type, void 0);
      camera.setPosition(position[0], (_a2 = position[1]) !== null && _a2 !== void 0 ? _a2 : this.position[1], (_b = position[2]) !== null && _b !== void 0 ? _b : this.position[2]);
      camera.setFocalPoint(focalPoint[0], (_c = focalPoint[1]) !== null && _c !== void 0 ? _c : this.focalPoint[1], (_d = focalPoint[2]) !== null && _d !== void 0 ? _d : this.focalPoint[2]);
      camera.setRoll(roll !== null && roll !== void 0 ? roll : this.roll);
      camera.setZoom(zoom !== null && zoom !== void 0 ? zoom : this.zoom);
      var landmark = {
        name: name2,
        matrix: mat4_exports.clone(camera.getWorldTransform()),
        right: vec3_exports.clone(camera.right),
        up: vec3_exports.clone(camera.up),
        forward: vec3_exports.clone(camera.forward),
        position: vec3_exports.clone(camera.getPosition()),
        focalPoint: vec3_exports.clone(camera.getFocalPoint()),
        distanceVector: vec3_exports.clone(camera.getDistanceVector()),
        distance: camera.getDistance(),
        dollyingStep: camera.getDollyingStep(),
        azimuth: camera.getAzimuth(),
        elevation: camera.getElevation(),
        roll: camera.getRoll(),
        relAzimuth: camera.relAzimuth,
        relElevation: camera.relElevation,
        relRoll: camera.relRoll,
        zoom: camera.getZoom()
      };
      this.landmarks.push(landmark);
      return landmark;
    };
    AdvancedCamera2.prototype.gotoLandmark = function(name2, options) {
      var _this2 = this;
      if (options === void 0) {
        options = {};
      }
      var landmark = is_string_default(name2) ? this.landmarks.find(function(l) {
        return l.name === name2;
      }) : name2;
      if (landmark) {
        var _a2 = is_number_default(options) ? { duration: options } : options, _b = _a2.easing, easing = _b === void 0 ? "linear" : _b, _c = _a2.duration, duration_1 = _c === void 0 ? 100 : _c, _d = _a2.easingFunction, easingFunction = _d === void 0 ? void 0 : _d, _e = _a2.onfinish, onfinish_1 = _e === void 0 ? void 0 : _e, _f = _a2.onframe, onframe_1 = _f === void 0 ? void 0 : _f;
        var epsilon_1 = 0.01;
        if (duration_1 === 0) {
          this.syncFromLandmark(landmark);
          if (onfinish_1) {
            onfinish_1();
          }
          return;
        }
        this.cancelLandmarkAnimation();
        var destPosition_1 = landmark.position;
        var destFocalPoint_1 = landmark.focalPoint;
        var destZoom_1 = landmark.zoom;
        var destRoll_1 = landmark.roll;
        var easingFunc_1 = easingFunction || runtime.EasingFunction(easing);
        var timeStart_1;
        var endAnimation_1 = function() {
          _this2.setFocalPoint(destFocalPoint_1);
          _this2.setPosition(destPosition_1);
          _this2.setRoll(destRoll_1);
          _this2.setZoom(destZoom_1);
          _this2.computeMatrix();
          _this2.triggerUpdate();
          if (onfinish_1) {
            onfinish_1();
          }
        };
        var animate_1 = function(timestamp) {
          if (timeStart_1 === void 0) {
            timeStart_1 = timestamp;
          }
          var elapsed = timestamp - timeStart_1;
          if (elapsed > duration_1) {
            endAnimation_1();
            return;
          }
          var t = easingFunc_1(elapsed / duration_1);
          var interFocalPoint = vec3_exports.create();
          var interPosition = vec3_exports.create();
          var interZoom = 1;
          var interRoll = 0;
          vec3_exports.lerp(interFocalPoint, _this2.focalPoint, destFocalPoint_1, t);
          vec3_exports.lerp(interPosition, _this2.position, destPosition_1, t);
          interRoll = _this2.roll * (1 - t) + destRoll_1 * t;
          interZoom = _this2.zoom * (1 - t) + destZoom_1 * t;
          _this2.setFocalPoint(interFocalPoint);
          _this2.setPosition(interPosition);
          _this2.setRoll(interRoll);
          _this2.setZoom(interZoom);
          var dist5 = vec3_exports.dist(interFocalPoint, destFocalPoint_1) + vec3_exports.dist(interPosition, destPosition_1);
          if (dist5 <= epsilon_1 && destZoom_1 == void 0 && destRoll_1 == void 0) {
            endAnimation_1();
            return;
          }
          _this2.computeMatrix();
          _this2.triggerUpdate();
          if (elapsed < duration_1) {
            if (onframe_1) {
              onframe_1(t);
            }
            _this2.landmarkAnimationID = _this2.canvas.requestAnimationFrame(animate_1);
          }
        };
        this.canvas.requestAnimationFrame(animate_1);
      }
    };
    AdvancedCamera2.prototype.syncFromLandmark = function(landmark) {
      this.matrix = mat4_exports.copy(this.matrix, landmark.matrix);
      this.right = vec3_exports.copy(this.right, landmark.right);
      this.up = vec3_exports.copy(this.up, landmark.up);
      this.forward = vec3_exports.copy(this.forward, landmark.forward);
      this.position = vec3_exports.copy(this.position, landmark.position);
      this.focalPoint = vec3_exports.copy(this.focalPoint, landmark.focalPoint);
      this.distanceVector = vec3_exports.copy(this.distanceVector, landmark.distanceVector);
      this.azimuth = landmark.azimuth;
      this.elevation = landmark.elevation;
      this.roll = landmark.roll;
      this.relAzimuth = landmark.relAzimuth;
      this.relElevation = landmark.relElevation;
      this.relRoll = landmark.relRoll;
      this.dollyingStep = landmark.dollyingStep;
      this.distance = landmark.distance;
      this.zoom = landmark.zoom;
    };
    return AdvancedCamera2;
  }(Camera)
);
runtime.CameraContribution = AdvancedCamera;

// node_modules/@antv/g-dom-mutation-observer-api/dist/index.esm.js
var MutationRecord = (
  /** @class */
  function() {
    function MutationRecord2(type, target) {
      this.type = type;
      this.target = target;
      this.addedNodes = [];
      this.attributeName = null;
      this.attributeNamespace = null;
      this.nextSibling = null;
      this.oldValue = null;
      this.previousSibling = null;
      this.removedNodes = [];
    }
    MutationRecord2.copy = function(original) {
      var record = new MutationRecord2(original.type, original.target);
      record.addedNodes = original.addedNodes.slice();
      record.removedNodes = original.removedNodes.slice();
      record.previousSibling = original.previousSibling;
      record.nextSibling = original.nextSibling;
      record.attributeName = original.attributeName;
      record.attributeNamespace = original.attributeNamespace;
      record.oldValue = original.oldValue;
      return record;
    };
    return MutationRecord2;
  }()
);
var uidCounter = 0;
var registrationsTable = /* @__PURE__ */ new WeakMap();
var Registration = (
  /** @class */
  function() {
    function Registration2(observer, target, options) {
      this.observer = observer;
      this.target = target;
      this.options = options;
      this.transientObservedNodes = [];
    }
    Registration2.prototype.enqueue = function(record) {
      var records = this.observer.records;
      var length5 = records.length;
      if (records.length > 0) {
        var lastRecord = records[length5 - 1];
        var recordToReplaceLast = selectRecord(lastRecord, record);
        if (recordToReplaceLast) {
          records[length5 - 1] = recordToReplaceLast;
          return;
        }
      } else {
        scheduleCallback(this.observer);
      }
      records[length5] = record;
    };
    Registration2.prototype.addListeners = function() {
      this.addListeners_(this.target);
    };
    Registration2.prototype.addListeners_ = function(node) {
      var options = this.options;
      if (options.attributes)
        node.addEventListener(ElementEvent.ATTR_MODIFIED, this, true);
      if (options.childList)
        node.addEventListener(ElementEvent.INSERTED, this, true);
      if (options.childList || options.subtree)
        node.addEventListener(ElementEvent.REMOVED, this, true);
    };
    Registration2.prototype.removeListeners = function() {
      this.removeListeners_(this.target);
    };
    Registration2.prototype.removeListeners_ = function(node) {
      var options = this.options;
      if (options.attributes)
        node.removeEventListener(ElementEvent.ATTR_MODIFIED, this, true);
      if (options.childList)
        node.removeEventListener(ElementEvent.INSERTED, this, true);
      if (options.childList || options.subtree)
        node.removeEventListener(ElementEvent.REMOVED, this, true);
    };
    Registration2.prototype.removeTransientObservers = function() {
      var transientObservedNodes = this.transientObservedNodes;
      this.transientObservedNodes = [];
      transientObservedNodes.forEach(function(node) {
        this.removeListeners_(node);
        var registrations = registrationsTable.get(node);
        for (var i = 0; i < registrations.length; i++) {
          if (registrations[i] === this) {
            registrations.splice(i, 1);
            break;
          }
        }
      }, this);
    };
    Registration2.prototype.handleEvent = function(e) {
      e.stopImmediatePropagation();
      var record;
      var target;
      switch (e.type) {
        case ElementEvent.ATTR_MODIFIED:
          var name_1 = e.attrName;
          var namespace_1 = e.relatedNode.namespaceURI;
          target = e.target;
          record = getRecord("attributes", target);
          record.attributeName = name_1;
          record.attributeNamespace = namespace_1;
          var oldValue_1 = e.attrChange === MutationEvent.ADDITION ? null : e.prevValue;
          forEachAncestorAndObserverEnqueueRecord(target, function(options) {
            if (!options.attributes)
              return;
            if (options.attributeFilter && options.attributeFilter.length && options.attributeFilter.indexOf(name_1) === -1 && options.attributeFilter.indexOf(namespace_1) === -1) {
              return;
            }
            if (options.attributeOldValue)
              return getRecordWithOldValue(oldValue_1);
            return record;
          });
          break;
        case ElementEvent.REMOVED:
        case ElementEvent.INSERTED:
          target = e.relatedNode;
          var changedNode = e.target;
          var addedNodes = void 0;
          var removedNodes = void 0;
          if (e.type === ElementEvent.INSERTED) {
            addedNodes = [changedNode];
            removedNodes = [];
          } else {
            addedNodes = [];
            removedNodes = [changedNode];
          }
          var previousSibling = changedNode.previousSibling;
          var nextSibling = changedNode.nextSibling;
          record = getRecord("childList", target);
          record.addedNodes = addedNodes;
          record.removedNodes = removedNodes;
          record.previousSibling = previousSibling;
          record.nextSibling = nextSibling;
          forEachAncestorAndObserverEnqueueRecord(target, function(options) {
            if (!options.childList)
              return;
            return record;
          });
      }
      clearRecords();
    };
    return Registration2;
  }()
);
var MutationObserver = (
  /** @class */
  function() {
    function MutationObserver2(callback) {
      this.callback = callback;
      this.nodes = [];
      this.records = [];
      this.uid = uidCounter++;
    }
    MutationObserver2.prototype.observe = function(target, options) {
      if (!options.childList && !options.attributes && !options.characterData || // 1.2
      options.attributeOldValue && !options.attributes || // 1.3
      options.attributeFilter && options.attributeFilter.length && !options.attributes || // 1.4
      options.characterDataOldValue && !options.characterData) {
        throw new SyntaxError();
      }
      var registrations = registrationsTable.get(target);
      if (!registrations)
        registrationsTable.set(target, registrations = []);
      var registration;
      for (var i = 0; i < registrations.length; i++) {
        if (registrations[i].observer === this) {
          registration = registrations[i];
          registration.removeListeners();
          registration.options = options;
          break;
        }
      }
      if (!registration) {
        registration = new Registration(this, target, options);
        registrations.push(registration);
        this.nodes.push(target);
      }
      registration.addListeners();
    };
    MutationObserver2.prototype.disconnect = function() {
      var _this2 = this;
      this.nodes.forEach(function(node) {
        var registrations = registrationsTable.get(node);
        for (var i = 0; i < registrations.length; i++) {
          var registration = registrations[i];
          if (registration.observer === _this2) {
            registration.removeListeners();
            registrations.splice(i, 1);
            break;
          }
        }
      }, this);
      this.records = [];
    };
    MutationObserver2.prototype.takeRecords = function() {
      var copyOfRecords = this.records;
      this.records = [];
      return copyOfRecords;
    };
    return MutationObserver2;
  }()
);
var currentRecord;
var recordWithOldValue;
function getRecord(type, target) {
  return currentRecord = new MutationRecord(type, target);
}
function getRecordWithOldValue(oldValue) {
  if (recordWithOldValue)
    return recordWithOldValue;
  recordWithOldValue = MutationRecord.copy(currentRecord);
  recordWithOldValue.oldValue = oldValue;
  return recordWithOldValue;
}
function clearRecords() {
  currentRecord = recordWithOldValue = void 0;
}
function recordRepresentsCurrentMutation(record) {
  return record === recordWithOldValue || record === currentRecord;
}
function selectRecord(lastRecord, newRecord) {
  if (lastRecord === newRecord)
    return lastRecord;
  if (recordWithOldValue && recordRepresentsCurrentMutation(lastRecord))
    return recordWithOldValue;
  return null;
}
function removeTransientObserversFor(observer) {
  observer.nodes.forEach(function(node) {
    var registrations = registrationsTable.get(node);
    if (!registrations)
      return;
    registrations.forEach(function(registration) {
      if (registration.observer === observer)
        registration.removeTransientObservers();
    });
  });
}
function forEachAncestorAndObserverEnqueueRecord(target, callback) {
  for (var node = target; node; node = node.parentNode) {
    var registrations = registrationsTable.get(node);
    if (registrations) {
      for (var j = 0; j < registrations.length; j++) {
        var registration = registrations[j];
        var options = registration.options;
        if (node !== target && !options.subtree)
          continue;
        var record = callback(options);
        if (record)
          registration.enqueue(record);
      }
    }
  }
}
var isScheduled = false;
var scheduledObservers = [];
function scheduleCallback(observer) {
  scheduledObservers.push(observer);
  if (!isScheduled) {
    isScheduled = true;
    if (typeof runtime.globalThis !== "undefined") {
      runtime.globalThis.setTimeout(dispatchCallbacks);
    } else {
      dispatchCallbacks();
    }
  }
}
function dispatchCallbacks() {
  isScheduled = false;
  var observers = scheduledObservers;
  scheduledObservers = [];
  observers.sort(function(o1, o2) {
    return o1.uid - o2.uid;
  });
  var anyNonEmpty = false;
  observers.forEach(function(observer) {
    var queue = observer.takeRecords();
    removeTransientObserversFor(observer);
    if (queue.length) {
      observer.callback(queue, observer);
      anyNonEmpty = true;
    }
  });
  if (anyNonEmpty)
    dispatchCallbacks();
}

// node_modules/@antv/g-web-animations-api/dist/index.esm.js
var AnimationEvent = (
  /** @class */
  function(_super) {
    __extends(AnimationEvent2, _super);
    function AnimationEvent2(manager, target, currentTime, timelineTime) {
      var _this2 = _super.call(this, manager) || this;
      _this2.currentTime = currentTime;
      _this2.timelineTime = timelineTime;
      _this2.target = target;
      _this2.type = "finish";
      _this2.bubbles = false;
      _this2.currentTarget = target;
      _this2.defaultPrevented = false;
      _this2.eventPhase = _this2.AT_TARGET;
      _this2.timeStamp = Date.now();
      _this2.currentTime = currentTime;
      _this2.timelineTime = timelineTime;
      return _this2;
    }
    return AnimationEvent2;
  }(FederatedEvent)
);
var sequenceNumber = 0;
var Animation = (
  /** @class */
  function() {
    function Animation2(effect, timeline) {
      var _a2;
      this.currentTimePending = false;
      this._idle = true;
      this._paused = false;
      this._finishedFlag = true;
      this._currentTime = 0;
      this._playbackRate = 1;
      this._inTimeline = true;
      this.effect = effect;
      effect.animation = this;
      this.timeline = timeline;
      this.id = "".concat(sequenceNumber++);
      this._inEffect = !!this.effect.update(0);
      this._totalDuration = Number((_a2 = this.effect) === null || _a2 === void 0 ? void 0 : _a2.getComputedTiming().endTime);
      this._holdTime = 0;
      this._paused = false;
      this.oldPlayState = "idle";
      this.updatePromises();
    }
    Object.defineProperty(Animation2.prototype, "pending", {
      // animation: InternalAnimation | null;
      /**
       * @see https://developer.mozilla.org/en-US/docs/Web/API/Animation/pending
       */
      get: function() {
        return this._startTime === null && !this._paused && this.playbackRate !== 0 || this.currentTimePending;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Animation2.prototype, "playState", {
      get: function() {
        if (this._idle)
          return "idle";
        if (this._isFinished)
          return "finished";
        if (this._paused)
          return "paused";
        return "running";
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Animation2.prototype, "ready", {
      /**
       * @see https://developer.mozilla.org/en-US/docs/Web/API/Animation/ready
       * @example
        animation.pause();
        animation.ready.then(function() {
          // Displays 'running'
          alert(animation.playState);
        });
        animation.play();
       */
      get: function() {
        var _this2 = this;
        if (!this.readyPromise) {
          if (this.timeline.animationsWithPromises.indexOf(this) === -1) {
            this.timeline.animationsWithPromises.push(this);
          }
          this.readyPromise = new Promise(function(resolve, reject2) {
            _this2.resolveReadyPromise = function() {
              resolve(_this2);
            };
            _this2.rejectReadyPromise = function() {
              reject2(new Error());
            };
          });
          if (!this.pending) {
            this.resolveReadyPromise();
          }
        }
        return this.readyPromise;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Animation2.prototype, "finished", {
      /**
       * @see https://developer.mozilla.org/en-US/docs/Web/API/Animation/finished
       * @example
        Promise.all(
          elem.getAnimations().map(
            function(animation) {
              return animation.finished
            }
          )
        ).then(
          function() {
            return elem.remove();
          }
        );
       */
      get: function() {
        var _this2 = this;
        if (!this.finishedPromise) {
          if (this.timeline.animationsWithPromises.indexOf(this) === -1) {
            this.timeline.animationsWithPromises.push(this);
          }
          this.finishedPromise = new Promise(function(resolve, reject2) {
            _this2.resolveFinishedPromise = function() {
              resolve(_this2);
            };
            _this2.rejectFinishedPromise = function() {
              reject2(new Error());
            };
          });
          if (this.playState === "finished") {
            this.resolveFinishedPromise();
          }
        }
        return this.finishedPromise;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Animation2.prototype, "currentTime", {
      get: function() {
        this.updatePromises();
        return this._idle || this.currentTimePending ? null : this._currentTime;
      },
      set: function(newTime) {
        var _a2;
        newTime = Number(newTime);
        if (isNaN(newTime))
          return;
        this.timeline.restart();
        if (!this._paused && this._startTime !== null) {
          this._startTime = Number((_a2 = this.timeline) === null || _a2 === void 0 ? void 0 : _a2.currentTime) - newTime / this.playbackRate;
        }
        this.currentTimePending = false;
        if (this._currentTime === newTime) {
          return;
        }
        if (this._idle) {
          this._idle = false;
          this._paused = true;
        }
        this.tickCurrentTime(newTime, true);
        this.timeline.applyDirtiedAnimation(this);
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Animation2.prototype, "startTime", {
      get: function() {
        return this._startTime;
      },
      set: function(newTime) {
        if (newTime !== null) {
          this.updatePromises();
          newTime = Number(newTime);
          if (isNaN(newTime))
            return;
          if (this._paused || this._idle)
            return;
          this._startTime = newTime;
          this.tickCurrentTime((Number(this.timeline.currentTime) - this._startTime) * this.playbackRate);
          this.timeline.applyDirtiedAnimation(this);
          this.updatePromises();
        }
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Animation2.prototype, "playbackRate", {
      get: function() {
        return this._playbackRate;
      },
      set: function(value2) {
        if (value2 === this._playbackRate) {
          return;
        }
        this.updatePromises();
        var oldCurrentTime = this.currentTime;
        this._playbackRate = value2;
        this.startTime = null;
        if (this.playState !== "paused" && this.playState !== "idle") {
          this._finishedFlag = false;
          this._idle = false;
          this.ensureAlive();
          this.timeline.applyDirtiedAnimation(this);
        }
        if (oldCurrentTime !== null) {
          this.currentTime = oldCurrentTime;
        }
        this.updatePromises();
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Animation2.prototype, "_isFinished", {
      get: function() {
        return !this._idle && (this._playbackRate > 0 && Number(this._currentTime) >= this._totalDuration || this._playbackRate < 0 && Number(this._currentTime) <= 0);
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Animation2.prototype, "totalDuration", {
      get: function() {
        return this._totalDuration;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Animation2.prototype, "_needsTick", {
      get: function() {
        return this.pending || this.playState === "running" || !this._finishedFlag;
      },
      enumerable: false,
      configurable: true
    });
    Animation2.prototype.updatePromises = function() {
      var oldPlayState = this.oldPlayState;
      var newPlayState = this.pending ? "pending" : this.playState;
      if (this.readyPromise && newPlayState !== oldPlayState) {
        if (newPlayState === "idle") {
          this.rejectReadyPromise();
          this.readyPromise = void 0;
        } else if (oldPlayState === "pending") {
          this.resolveReadyPromise();
        } else if (newPlayState === "pending") {
          this.readyPromise = void 0;
        }
      }
      if (this.finishedPromise && newPlayState !== oldPlayState) {
        if (newPlayState === "idle") {
          this.rejectFinishedPromise();
          this.finishedPromise = void 0;
        } else if (newPlayState === "finished") {
          this.resolveFinishedPromise();
        } else if (oldPlayState === "finished") {
          this.finishedPromise = void 0;
        }
      }
      this.oldPlayState = newPlayState;
      return this.readyPromise || this.finishedPromise;
    };
    Animation2.prototype.play = function() {
      this.updatePromises();
      this._paused = false;
      if (this._isFinished || this._idle) {
        this.rewind();
        this._startTime = null;
      }
      this._finishedFlag = false;
      this._idle = false;
      this.ensureAlive();
      this.timeline.applyDirtiedAnimation(this);
      if (this.timeline.animations.indexOf(this) === -1) {
        this.timeline.animations.push(this);
      }
      this.updatePromises();
    };
    Animation2.prototype.pause = function() {
      this.updatePromises();
      if (this.currentTime) {
        this._holdTime = this.currentTime;
      }
      if (!this._isFinished && !this._paused && !this._idle) {
        this.currentTimePending = true;
      } else if (this._idle) {
        this.rewind();
        this._idle = false;
      }
      this._startTime = null;
      this._paused = true;
      this.updatePromises();
    };
    Animation2.prototype.finish = function() {
      this.updatePromises();
      if (this._idle)
        return;
      this.currentTime = this._playbackRate > 0 ? this._totalDuration : 0;
      this._startTime = this._totalDuration - this.currentTime;
      this.currentTimePending = false;
      this.timeline.applyDirtiedAnimation(this);
      this.updatePromises();
    };
    Animation2.prototype.cancel = function() {
      var _this2 = this;
      this.updatePromises();
      if (!this._inEffect)
        return;
      this._inEffect = false;
      this._idle = true;
      this._paused = false;
      this._finishedFlag = true;
      this._currentTime = 0;
      this._startTime = null;
      this.effect.update(null);
      this.timeline.applyDirtiedAnimation(this);
      this.updatePromises();
      if (this.oncancel) {
        var event_1 = new AnimationEvent(null, this, this.currentTime, null);
        setTimeout(function() {
          _this2.oncancel(event_1);
        });
      }
    };
    Animation2.prototype.reverse = function() {
      this.updatePromises();
      var oldCurrentTime = this.currentTime;
      this.playbackRate *= -1;
      this.play();
      if (oldCurrentTime !== null) {
        this.currentTime = oldCurrentTime;
      }
      this.updatePromises();
    };
    Animation2.prototype.updatePlaybackRate = function(playbackRate) {
      this.playbackRate = playbackRate;
    };
    Animation2.prototype.targetAnimations = function() {
      var _a2;
      var target = (_a2 = this.effect) === null || _a2 === void 0 ? void 0 : _a2.target;
      return target.getAnimations();
    };
    Animation2.prototype.markTarget = function() {
      var animations = this.targetAnimations();
      if (animations.indexOf(this) === -1) {
        animations.push(this);
      }
    };
    Animation2.prototype.unmarkTarget = function() {
      var animations = this.targetAnimations();
      var index3 = animations.indexOf(this);
      if (index3 !== -1) {
        animations.splice(index3, 1);
      }
    };
    Animation2.prototype.tick = function(timelineTime, isAnimationFrame) {
      if (!this._idle && !this._paused) {
        if (this._startTime === null) {
          if (isAnimationFrame) {
            this.startTime = timelineTime - this._currentTime / this.playbackRate;
          }
        } else if (!this._isFinished) {
          this.tickCurrentTime((timelineTime - this._startTime) * this.playbackRate);
        }
      }
      if (isAnimationFrame) {
        this.currentTimePending = false;
        this.fireEvents(timelineTime);
      }
    };
    Animation2.prototype.rewind = function() {
      if (this.playbackRate >= 0) {
        this.currentTime = 0;
      } else if (this._totalDuration < Infinity) {
        this.currentTime = this._totalDuration;
      } else {
        throw new Error("Unable to rewind negative playback rate animation with infinite duration");
      }
    };
    Animation2.prototype.persist = function() {
      throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
    };
    Animation2.prototype.addEventListener = function(type, listener, options) {
      throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
    };
    Animation2.prototype.removeEventListener = function(type, listener, options) {
      throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
    };
    Animation2.prototype.dispatchEvent = function(event) {
      throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
    };
    Animation2.prototype.commitStyles = function() {
      throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
    };
    Animation2.prototype.ensureAlive = function() {
      var _a2, _b;
      if (this.playbackRate < 0 && this.currentTime === 0) {
        this._inEffect = !!((_a2 = this.effect) === null || _a2 === void 0 ? void 0 : _a2.update(-1));
      } else {
        this._inEffect = !!((_b = this.effect) === null || _b === void 0 ? void 0 : _b.update(this.currentTime));
      }
      if (!this._inTimeline && (this._inEffect || !this._finishedFlag)) {
        this._inTimeline = true;
        this.timeline.animations.push(this);
      }
    };
    Animation2.prototype.tickCurrentTime = function(newTime, ignoreLimit) {
      if (newTime !== this._currentTime) {
        this._currentTime = newTime;
        if (this._isFinished && !ignoreLimit) {
          this._currentTime = this._playbackRate > 0 ? this._totalDuration : 0;
        }
        this.ensureAlive();
      }
    };
    Animation2.prototype.fireEvents = function(baseTime) {
      var _this2 = this;
      if (this._isFinished) {
        if (!this._finishedFlag) {
          if (this.onfinish) {
            var event_2 = new AnimationEvent(null, this, this.currentTime, baseTime);
            setTimeout(function() {
              if (_this2.onfinish) {
                _this2.onfinish(event_2);
              }
            });
          }
          this._finishedFlag = true;
        }
      } else {
        if (this.onframe && this.playState === "running") {
          var event_3 = new AnimationEvent(null, this, this.currentTime, baseTime);
          this.onframe(event_3);
        }
        this._finishedFlag = false;
      }
    };
    return Animation2;
  }()
);
var NEWTON_ITERATIONS = 4;
var NEWTON_MIN_SLOPE = 1e-3;
var SUBDIVISION_PRECISION = 1e-7;
var SUBDIVISION_MAX_ITERATIONS = 10;
var kSplineTableSize = 11;
var kSampleStepSize = 1 / (kSplineTableSize - 1);
var float32ArraySupported = typeof Float32Array === "function";
var A2 = function(aA1, aA2) {
  return 1 - 3 * aA2 + 3 * aA1;
};
var B2 = function(aA1, aA2) {
  return 3 * aA2 - 6 * aA1;
};
var C2 = function(aA1) {
  return 3 * aA1;
};
var calcBezier = function(aT, aA1, aA2) {
  return ((A2(aA1, aA2) * aT + B2(aA1, aA2)) * aT + C2(aA1)) * aT;
};
var getSlope = function(aT, aA1, aA2) {
  return 3 * A2(aA1, aA2) * aT * aT + 2 * B2(aA1, aA2) * aT + C2(aA1);
};
var binarySubdivide = function(aX, aA, aB, mX1, mX2) {
  var currentX, currentT, i = 0;
  do {
    currentT = aA + (aB - aA) / 2;
    currentX = calcBezier(currentT, mX1, mX2) - aX;
    if (currentX > 0)
      aB = currentT;
    else
      aA = currentT;
  } while (Math.abs(currentX) > SUBDIVISION_PRECISION && ++i < SUBDIVISION_MAX_ITERATIONS);
  return currentT;
};
var newtonRaphsonIterate = function(aX, aGuessT, mX1, mX2) {
  for (var i = 0; i < NEWTON_ITERATIONS; ++i) {
    var currentSlope = getSlope(aGuessT, mX1, mX2);
    if (currentSlope === 0)
      return aGuessT;
    var currentX = calcBezier(aGuessT, mX1, mX2) - aX;
    aGuessT -= currentX / currentSlope;
  }
  return aGuessT;
};
var bezier2 = function(mX1, mY1, mX2, mY2) {
  if (!(0 <= mX1 && mX1 <= 1 && 0 <= mX2 && mX2 <= 1))
    throw new Error("bezier x values must be in [0, 1] range");
  if (mX1 === mY1 && mX2 === mY2)
    return function(t) {
      return t;
    };
  var sampleValues = float32ArraySupported ? new Float32Array(kSplineTableSize) : new Array(kSplineTableSize);
  for (var i = 0; i < kSplineTableSize; ++i) {
    sampleValues[i] = calcBezier(i * kSampleStepSize, mX1, mX2);
  }
  var getTForX = function(aX) {
    var intervalStart = 0;
    var currentSample = 1;
    var lastSample = kSplineTableSize - 1;
    for (; currentSample !== lastSample && sampleValues[currentSample] <= aX; ++currentSample)
      intervalStart += kSampleStepSize;
    --currentSample;
    var dist5 = (aX - sampleValues[currentSample]) / (sampleValues[currentSample + 1] - sampleValues[currentSample]);
    var guessForT = intervalStart + dist5 * kSampleStepSize;
    var initialSlope = getSlope(guessForT, mX1, mX2);
    if (initialSlope >= NEWTON_MIN_SLOPE)
      return newtonRaphsonIterate(aX, guessForT, mX1, mX2);
    else if (initialSlope === 0)
      return guessForT;
    else {
      return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize, mX1, mX2);
    }
  };
  return function(t) {
    if (t === 0 || t === 1)
      return t;
    return calcBezier(getTForX(t), mY1, mY2);
  };
};
var convertToDash = function(str7) {
  str7 = str7.replace(/([A-Z])/g, function(letter) {
    return "-".concat(letter.toLowerCase());
  });
  return str7.charAt(0) === "-" ? str7.substring(1) : str7;
};
var Quad = function(t) {
  return Math.pow(t, 2);
};
var Cubic = function(t) {
  return Math.pow(t, 3);
};
var Quart = function(t) {
  return Math.pow(t, 4);
};
var Quint = function(t) {
  return Math.pow(t, 5);
};
var Expo = function(t) {
  return Math.pow(t, 6);
};
var Sine = function(t) {
  return 1 - Math.cos(t * Math.PI / 2);
};
var Circ = function(t) {
  return 1 - Math.sqrt(1 - t * t);
};
var Back = function(t) {
  return t * t * (3 * t - 2);
};
var Bounce = function(t) {
  var pow22, b = 4;
  while (t < ((pow22 = Math.pow(2, --b)) - 1) / 11) {
  }
  return 1 / Math.pow(4, 3 - b) - 7.5625 * Math.pow((pow22 * 3 - 2) / 22 - t, 2);
};
var Elastic = function(t, params) {
  if (params === void 0) {
    params = [];
  }
  var _a2 = __read(params, 2), _b = _a2[0], amplitude = _b === void 0 ? 1 : _b, _c = _a2[1], period = _c === void 0 ? 0.5 : _c;
  var a4 = clamp_default(Number(amplitude), 1, 10);
  var p2 = clamp_default(Number(period), 0.1, 2);
  if (t === 0 || t === 1)
    return t;
  return -a4 * Math.pow(2, 10 * (t - 1)) * Math.sin((t - 1 - p2 / (Math.PI * 2) * Math.asin(1 / a4)) * (Math.PI * 2) / p2);
};
var Spring = function(t, params, duration) {
  if (params === void 0) {
    params = [];
  }
  var _a2 = __read(params, 4), _b = _a2[0], mass = _b === void 0 ? 1 : _b, _c = _a2[1], stiffness = _c === void 0 ? 100 : _c, _d = _a2[2], damping = _d === void 0 ? 10 : _d, _e = _a2[3], velocity = _e === void 0 ? 0 : _e;
  mass = clamp_default(mass, 0.1, 1e3);
  stiffness = clamp_default(stiffness, 0.1, 1e3);
  damping = clamp_default(damping, 0.1, 1e3);
  velocity = clamp_default(velocity, 0.1, 1e3);
  var w0 = Math.sqrt(stiffness / mass);
  var zeta = damping / (2 * Math.sqrt(stiffness * mass));
  var wd = zeta < 1 ? w0 * Math.sqrt(1 - zeta * zeta) : 0;
  var a4 = 1;
  var b = zeta < 1 ? (zeta * w0 + -velocity) / wd : -velocity + w0;
  var progress = duration ? duration * t / 1e3 : t;
  if (zeta < 1) {
    progress = Math.exp(-progress * zeta * w0) * (a4 * Math.cos(wd * progress) + b * Math.sin(wd * progress));
  } else {
    progress = (a4 + b * progress) * Math.exp(-progress * w0);
  }
  if (t === 0 || t === 1)
    return t;
  return 1 - progress;
};
var Steps = function(t, params) {
  if (params === void 0) {
    params = [];
  }
  var _a2 = __read(params, 2), _b = _a2[0], steps = _b === void 0 ? 10 : _b, type = _a2[1];
  var trunc = type == "start" ? Math.ceil : Math.floor;
  return trunc(clamp_default(t, 0, 1) * steps) / steps;
};
var Bezier = function(t, params) {
  if (params === void 0) {
    params = [];
  }
  var _a2 = __read(params, 4), mX1 = _a2[0], mY1 = _a2[1], mX2 = _a2[2], mY2 = _a2[3];
  return bezier2(mX1, mY1, mX2, mY2)(t);
};
var easein = bezier2(0.42, 0, 1, 1);
var EaseOut = function(ease) {
  return function(t, params, duration) {
    if (params === void 0) {
      params = [];
    }
    return 1 - ease(1 - t, params, duration);
  };
};
var EaseInOut = function(ease) {
  return function(t, params, duration) {
    if (params === void 0) {
      params = [];
    }
    return t < 0.5 ? ease(t * 2, params, duration) / 2 : 1 - ease(t * -2 + 2, params, duration) / 2;
  };
};
var EaseOutIn = function(ease) {
  return function(t, params, duration) {
    if (params === void 0) {
      params = [];
    }
    return t < 0.5 ? (1 - ease(1 - t * 2, params, duration)) / 2 : (ease(t * 2 - 1, params, duration) + 1) / 2;
  };
};
var EasingFunctions = {
  steps: Steps,
  "step-start": function(t) {
    return Steps(t, [1, "start"]);
  },
  "step-end": function(t) {
    return Steps(t, [1, "end"]);
  },
  linear: function(t) {
    return t;
  },
  "cubic-bezier": Bezier,
  ease: function(t) {
    return Bezier(t, [0.25, 0.1, 0.25, 1]);
  },
  in: easein,
  out: EaseOut(easein),
  "in-out": EaseInOut(easein),
  "out-in": EaseOutIn(easein),
  "in-quad": Quad,
  "out-quad": EaseOut(Quad),
  "in-out-quad": EaseInOut(Quad),
  "out-in-quad": EaseOutIn(Quad),
  "in-cubic": Cubic,
  "out-cubic": EaseOut(Cubic),
  "in-out-cubic": EaseInOut(Cubic),
  "out-in-cubic": EaseOutIn(Cubic),
  "in-quart": Quart,
  "out-quart": EaseOut(Quart),
  "in-out-quart": EaseInOut(Quart),
  "out-in-quart": EaseOutIn(Quart),
  "in-quint": Quint,
  "out-quint": EaseOut(Quint),
  "in-out-quint": EaseInOut(Quint),
  "out-in-quint": EaseOutIn(Quint),
  "in-expo": Expo,
  "out-expo": EaseOut(Expo),
  "in-out-expo": EaseInOut(Expo),
  "out-in-expo": EaseOutIn(Expo),
  "in-sine": Sine,
  "out-sine": EaseOut(Sine),
  "in-out-sine": EaseInOut(Sine),
  "out-in-sine": EaseOutIn(Sine),
  "in-circ": Circ,
  "out-circ": EaseOut(Circ),
  "in-out-circ": EaseInOut(Circ),
  "out-in-circ": EaseOutIn(Circ),
  "in-back": Back,
  "out-back": EaseOut(Back),
  "in-out-back": EaseInOut(Back),
  "out-in-back": EaseOutIn(Back),
  "in-bounce": Bounce,
  "out-bounce": EaseOut(Bounce),
  "in-out-bounce": EaseInOut(Bounce),
  "out-in-bounce": EaseOutIn(Bounce),
  "in-elastic": Elastic,
  "out-elastic": EaseOut(Elastic),
  "in-out-elastic": EaseInOut(Elastic),
  "out-in-elastic": EaseOutIn(Elastic),
  spring: Spring,
  "spring-in": Spring,
  "spring-out": EaseOut(Spring),
  "spring-in-out": EaseInOut(Spring),
  "spring-out-in": EaseOutIn(Spring)
};
var complexEasingSyntax = function(ease) {
  return convertToDash(ease).replace(/^ease-/, "").replace(/(\(|\s).+/, "").toLowerCase().trim();
};
var getEasingFunction = function(ease) {
  return EasingFunctions[complexEasingSyntax(ease)] || EasingFunctions.linear;
};
var linear = function(x3) {
  return x3;
};
var Start = 1;
var Middle = 0.5;
var End = 0;
function step(count4, pos) {
  return function(x3) {
    if (x3 >= 1) {
      return 1;
    }
    var stepSize = 1 / count4;
    x3 += pos * stepSize;
    return x3 - x3 % stepSize;
  };
}
var numberString = "\\s*(-?\\d+\\.?\\d*|-?\\.\\d+)\\s*";
var cubicBezierRe = new RegExp("cubic-bezier\\(" + numberString + "," + numberString + "," + numberString + "," + numberString + "\\)");
var step1Re = /steps\(\s*(\d+)\s*\)/;
var step2Re = /steps\(\s*(\d+)\s*,\s*(start|middle|end)\s*\)/;
function parseEasingFunction(normalizedEasing) {
  var cubicData = cubicBezierRe.exec(normalizedEasing);
  if (cubicData) {
    return bezier2.apply(void 0, __spreadArray([], __read(cubicData.slice(1).map(Number)), false));
  }
  var step1Data = step1Re.exec(normalizedEasing);
  if (step1Data) {
    return step(Number(step1Data[1]), End);
  }
  var step2Data = step2Re.exec(normalizedEasing);
  if (step2Data) {
    return step(Number(step2Data[1]), { start: Start, middle: Middle, end: End }[step2Data[2]]);
  }
  return getEasingFunction(normalizedEasing);
}
function calculateActiveDuration(timing) {
  return Math.abs(repeatedDuration(timing) / (timing.playbackRate || 1));
}
function repeatedDuration(timing) {
  var _a2;
  if (timing.duration === 0 || timing.iterations === 0) {
    return 0;
  }
  return (timing.duration === "auto" ? 0 : Number(timing.duration)) * ((_a2 = timing.iterations) !== null && _a2 !== void 0 ? _a2 : 1);
}
var PhaseNone = 0;
var PhaseBefore = 1;
var PhaseAfter = 2;
var PhaseActive = 3;
function calculatePhase(activeDuration, localTime, timing) {
  if (localTime === null) {
    return PhaseNone;
  }
  var endTime = timing.endTime;
  if (localTime < Math.min(timing.delay, endTime)) {
    return PhaseBefore;
  }
  if (localTime >= Math.min(timing.delay + activeDuration + timing.endDelay, endTime)) {
    return PhaseAfter;
  }
  return PhaseActive;
}
function calculateActiveTime(activeDuration, fillMode, localTime, phase, delay2) {
  switch (phase) {
    case PhaseBefore:
      if (fillMode === "backwards" || fillMode === "both")
        return 0;
      return null;
    case PhaseActive:
      return localTime - delay2;
    case PhaseAfter:
      if (fillMode === "forwards" || fillMode === "both")
        return activeDuration;
      return null;
    case PhaseNone:
      return null;
  }
}
function calculateOverallProgress(iterationDuration, phase, iterations2, activeTime, iterationStart) {
  var overallProgress = iterationStart;
  if (iterationDuration === 0) {
    if (phase !== PhaseBefore) {
      overallProgress += iterations2;
    }
  } else {
    overallProgress += activeTime / iterationDuration;
  }
  return overallProgress;
}
function calculateSimpleIterationProgress(overallProgress, iterationStart, phase, iterations2, activeTime, iterationDuration) {
  var simpleIterationProgress = overallProgress === Infinity ? iterationStart % 1 : overallProgress % 1;
  if (simpleIterationProgress === 0 && phase === PhaseAfter && iterations2 !== 0 && (activeTime !== 0 || iterationDuration === 0)) {
    simpleIterationProgress = 1;
  }
  return simpleIterationProgress;
}
function calculateCurrentIteration(phase, iterations2, simpleIterationProgress, overallProgress) {
  if (phase === PhaseAfter && iterations2 === Infinity) {
    return Infinity;
  }
  if (simpleIterationProgress === 1) {
    return Math.floor(overallProgress) - 1;
  }
  return Math.floor(overallProgress);
}
function calculateDirectedProgress(playbackDirection, currentIteration, simpleIterationProgress) {
  var currentDirection = playbackDirection;
  if (playbackDirection !== "normal" && playbackDirection !== "reverse") {
    var d2 = currentIteration;
    if (playbackDirection === "alternate-reverse") {
      d2 += 1;
    }
    currentDirection = "normal";
    if (d2 !== Infinity && d2 % 2 !== 0) {
      currentDirection = "reverse";
    }
  }
  if (currentDirection === "normal") {
    return simpleIterationProgress;
  }
  return 1 - simpleIterationProgress;
}
function calculateIterationProgress(activeDuration, localTime, timing) {
  var phase = calculatePhase(activeDuration, localTime, timing);
  var activeTime = calculateActiveTime(activeDuration, timing.fill, localTime, phase, timing.delay);
  if (activeTime === null)
    return null;
  var duration = timing.duration === "auto" ? 0 : timing.duration;
  var overallProgress = calculateOverallProgress(duration, phase, timing.iterations, activeTime, timing.iterationStart);
  var simpleIterationProgress = calculateSimpleIterationProgress(overallProgress, timing.iterationStart, phase, timing.iterations, activeTime, duration);
  var currentIteration = calculateCurrentIteration(phase, timing.iterations, simpleIterationProgress, overallProgress);
  var directedProgress = calculateDirectedProgress(timing.direction, currentIteration, simpleIterationProgress);
  timing.currentIteration = currentIteration;
  timing.progress = directedProgress;
  return timing.easingFunction(directedProgress);
}
function convertEffectInput(keyframes, timing, target) {
  var propertySpecificKeyframeGroups = makePropertySpecificKeyframeGroups(keyframes, timing);
  var interpolations = makeInterpolations(propertySpecificKeyframeGroups, target);
  return function(target2, fraction) {
    if (fraction !== null) {
      interpolations.filter(function(interpolation) {
        return fraction >= interpolation.applyFrom && fraction < interpolation.applyTo;
      }).forEach(function(interpolation) {
        var offsetFraction = fraction - interpolation.startOffset;
        var localDuration = interpolation.endOffset - interpolation.startOffset;
        var scaledLocalTime = localDuration === 0 ? 0 : interpolation.easingFunction(offsetFraction / localDuration);
        target2.setAttribute(interpolation.property, interpolation.interpolation(scaledLocalTime));
      });
    } else {
      for (var property2 in propertySpecificKeyframeGroups)
        if (isNotReservedWord(property2)) {
          target2.setAttribute(property2, null);
        }
    }
  };
}
function isNotReservedWord(member) {
  return member !== "offset" && member !== "easing" && member !== "composite" && member !== "computedOffset";
}
function makePropertySpecificKeyframeGroups(keyframes, timing) {
  var propertySpecificKeyframeGroups = {};
  for (var i = 0; i < keyframes.length; i++) {
    for (var member in keyframes[i]) {
      if (isNotReservedWord(member)) {
        var propertySpecificKeyframe = {
          offset: keyframes[i].offset,
          computedOffset: keyframes[i].computedOffset,
          easing: keyframes[i].easing,
          easingFunction: parseEasingFunction(keyframes[i].easing) || timing.easingFunction,
          value: keyframes[i][member]
        };
        propertySpecificKeyframeGroups[member] = propertySpecificKeyframeGroups[member] || [];
        propertySpecificKeyframeGroups[member].push(propertySpecificKeyframe);
      }
    }
  }
  return propertySpecificKeyframeGroups;
}
function makeInterpolations(propertySpecificKeyframeGroups, target) {
  var interpolations = [];
  for (var groupName in propertySpecificKeyframeGroups) {
    var keyframes = propertySpecificKeyframeGroups[groupName];
    for (var i = 0; i < keyframes.length - 1; i++) {
      var startIndex = i;
      var endIndex = i + 1;
      var startOffset = keyframes[startIndex].computedOffset;
      var endOffset = keyframes[endIndex].computedOffset;
      var applyFrom = startOffset;
      var applyTo = endOffset;
      if (i === 0) {
        applyFrom = -Infinity;
        if (endOffset === 0) {
          endIndex = startIndex;
        }
      }
      if (i === keyframes.length - 2) {
        applyTo = Infinity;
        if (startOffset === 1) {
          startIndex = endIndex;
        }
      }
      interpolations.push({
        applyFrom,
        applyTo,
        startOffset: keyframes[startIndex].computedOffset,
        endOffset: keyframes[endIndex].computedOffset,
        easingFunction: keyframes[startIndex].easingFunction,
        property: groupName,
        interpolation: propertyInterpolation(groupName, keyframes[startIndex].value, keyframes[endIndex].value, target)
      });
    }
  }
  interpolations.sort(function(leftInterpolation, rightInterpolation) {
    return leftInterpolation.startOffset - rightInterpolation.startOffset;
  });
  return interpolations;
}
var InterpolationFactory = function(from, to, convertToString) {
  return function(f) {
    var interpolated = interpolate2(from, to, f);
    return !runtime.enableCSSParsing && is_number_default(interpolated) ? interpolated : convertToString(interpolated);
  };
};
function propertyInterpolation(property2, left2, right2, target) {
  var metadata = propertyMetadataCache[property2];
  if (metadata && metadata.syntax && metadata.int) {
    var propertyHandler = runtime.styleValueRegistry.getPropertySyntax(metadata.syntax);
    if (propertyHandler) {
      var usedLeft = void 0;
      var usedRight = void 0;
      if (runtime.enableCSSParsing) {
        var computedLeft = runtime.styleValueRegistry.parseProperty(property2, left2, target);
        var computedRight = runtime.styleValueRegistry.parseProperty(property2, right2, target);
        usedLeft = runtime.styleValueRegistry.computeProperty(property2, computedLeft, target);
        usedRight = runtime.styleValueRegistry.computeProperty(property2, computedRight, target);
      } else {
        var parser = propertyHandler.parserWithCSSDisabled;
        usedLeft = parser ? parser(left2, target) : left2;
        usedRight = parser ? parser(right2, target) : right2;
      }
      var interpolationArgs = propertyHandler.mixer(usedLeft, usedRight, target);
      if (interpolationArgs) {
        var interp_1 = InterpolationFactory.apply(void 0, __spreadArray([], __read(interpolationArgs), false));
        return function(t) {
          if (t === 0)
            return left2;
          if (t === 1)
            return right2;
          return interp_1(t);
        };
      }
    }
  }
  return InterpolationFactory(false, true, function(bool) {
    return bool ? right2 : left2;
  });
}
function interpolate2(from, to, f) {
  if (typeof from === "number" && typeof to === "number") {
    return from * (1 - f) + to * f;
  }
  if (typeof from === "boolean" && typeof to === "boolean" || typeof from === "string" && typeof to === "string") {
    return f < 0.5 ? from : to;
  }
  if (Array.isArray(from) && Array.isArray(to)) {
    var fromLength = from.length;
    var toLength2 = to.length;
    var length_1 = Math.max(fromLength, toLength2);
    var r = [];
    for (var i = 0; i < length_1; i++) {
      r.push(interpolate2(from[i < fromLength ? i : fromLength - 1], to[i < toLength2 ? i : toLength2 - 1], f));
    }
    return r;
  }
  throw new Error("Mismatched interpolation arguments " + from + ":" + to);
}
var AnimationEffectTiming = (
  /** @class */
  function() {
    function AnimationEffectTiming2() {
      this.delay = 0;
      this.direction = "normal";
      this.duration = "auto";
      this._easing = "linear";
      this.easingFunction = linear;
      this.endDelay = 0;
      this.fill = "auto";
      this.iterationStart = 0;
      this.iterations = 1;
      this.currentIteration = null;
      this.progress = null;
    }
    Object.defineProperty(AnimationEffectTiming2.prototype, "easing", {
      get: function() {
        return this._easing;
      },
      set: function(value2) {
        this.easingFunction = parseEasingFunction(value2);
        this._easing = value2;
      },
      enumerable: false,
      configurable: true
    });
    return AnimationEffectTiming2;
  }()
);
function convertToArrayForm(effectInput) {
  var normalizedEffectInput = [];
  for (var property2 in effectInput) {
    if (property2 in ["easing", "offset", "composite"]) {
      continue;
    }
    var values4 = effectInput[property2];
    if (!Array.isArray(values4)) {
      values4 = [values4];
    }
    var numKeyframes = values4.length;
    for (var i = 0; i < numKeyframes; i++) {
      if (!normalizedEffectInput[i]) {
        var keyframe = {};
        if ("offset" in effectInput) {
          keyframe.offset = Number(effectInput.offset);
        }
        if ("easing" in effectInput) {
          keyframe.easing = effectInput.easing;
        }
        if ("composite" in effectInput) {
          keyframe.composite = effectInput.composite;
        }
        normalizedEffectInput[i] = keyframe;
      }
      if (values4[i] !== void 0 && values4[i] !== null) {
        normalizedEffectInput[i][property2] = values4[i];
      }
    }
  }
  normalizedEffectInput.sort(function(a4, b) {
    return (a4.computedOffset || 0) - (b.computedOffset || 0);
  });
  return normalizedEffectInput;
}
function normalizeKeyframes(effectInput, timing) {
  if (effectInput === null) {
    return [];
  }
  if (!Array.isArray(effectInput)) {
    effectInput = convertToArrayForm(effectInput);
  }
  var keyframes = effectInput.map(function(originalKeyframe) {
    var keyframe = {};
    if (timing === null || timing === void 0 ? void 0 : timing.composite) {
      keyframe.composite = "auto";
    }
    for (var member in originalKeyframe) {
      var memberValue = originalKeyframe[member];
      if (member === "offset") {
        if (memberValue !== null) {
          memberValue = Number(memberValue);
          if (!isFinite(memberValue))
            throw new Error("Keyframe offsets must be numbers.");
          if (memberValue < 0 || memberValue > 1)
            throw new Error("Keyframe offsets must be between 0 and 1.");
          keyframe.computedOffset = memberValue;
        }
      } else if (member === "composite") {
        if (["replace", "add", "accumulate", "auto"].indexOf(memberValue) === -1) {
          throw new Error("".concat(memberValue, " compositing is not supported"));
        }
      } else
        ;
      keyframe[member] = memberValue;
    }
    if (keyframe.offset === void 0) {
      keyframe.offset = null;
    }
    if (keyframe.easing === void 0) {
      keyframe.easing = (timing === null || timing === void 0 ? void 0 : timing.easing) || "linear";
    }
    if (keyframe.composite === void 0) {
      keyframe.composite = "auto";
    }
    return keyframe;
  });
  var everyFrameHasOffset = true;
  var previousOffset = -Infinity;
  for (var i = 0; i < keyframes.length; i++) {
    var offset2 = keyframes[i].offset;
    if (!is_nil_default(offset2)) {
      if (offset2 < previousOffset) {
        throw new TypeError("Keyframes are not loosely sorted by offset. Sort or specify offsets.");
      }
      previousOffset = offset2;
    } else {
      everyFrameHasOffset = false;
    }
  }
  keyframes = keyframes.filter(function(keyframe) {
    return Number(keyframe.offset) >= 0 && Number(keyframe.offset) <= 1;
  });
  function spaceKeyframes() {
    var _a2, _b;
    var length5 = keyframes.length;
    keyframes[length5 - 1].computedOffset = Number((_a2 = keyframes[length5 - 1].offset) !== null && _a2 !== void 0 ? _a2 : 1);
    if (length5 > 1) {
      keyframes[0].computedOffset = Number((_b = keyframes[0].offset) !== null && _b !== void 0 ? _b : 0);
    }
    var previousIndex = 0;
    var previousOffset2 = Number(keyframes[0].computedOffset);
    for (var i2 = 1; i2 < length5; i2++) {
      var offset3 = keyframes[i2].computedOffset;
      if (!is_nil_default(offset3) && !is_nil_default(previousOffset2)) {
        for (var j = 1; j < i2 - previousIndex; j++)
          keyframes[previousIndex + j].computedOffset = previousOffset2 + (Number(offset3) - previousOffset2) * j / (i2 - previousIndex);
        previousIndex = i2;
        previousOffset2 = Number(offset3);
      }
    }
  }
  if (!everyFrameHasOffset)
    spaceKeyframes();
  return keyframes;
}
var fills = "backwards|forwards|both|none".split("|");
var directions = "reverse|alternate|alternate-reverse".split("|");
function makeTiming(timingInput, forGroup) {
  var timing = new AnimationEffectTiming();
  if (forGroup) {
    timing.fill = "both";
    timing.duration = "auto";
  }
  if (typeof timingInput === "number" && !isNaN(timingInput)) {
    timing.duration = timingInput;
  } else if (timingInput !== void 0) {
    Object.keys(timingInput).forEach(function(property2) {
      if (timingInput[property2] !== void 0 && timingInput[property2] !== null && timingInput[property2] !== "auto") {
        if (typeof timing[property2] === "number" || property2 === "duration") {
          if (typeof timingInput[property2] !== "number" || isNaN(timingInput[property2])) {
            return;
          }
        }
        if (property2 === "fill" && fills.indexOf(timingInput[property2]) === -1) {
          return;
        }
        if (property2 === "direction" && directions.indexOf(timingInput[property2]) === -1) {
          return;
        }
        timing[property2] = timingInput[property2];
      }
    });
  }
  return timing;
}
function normalizeTimingInput(timingInput, forGroup) {
  timingInput = numericTimingToObject(timingInput !== null && timingInput !== void 0 ? timingInput : { duration: "auto" });
  return makeTiming(timingInput, forGroup);
}
function numericTimingToObject(timingInput) {
  if (typeof timingInput === "number") {
    if (isNaN(timingInput)) {
      timingInput = { duration: "auto" };
    } else {
      timingInput = { duration: timingInput };
    }
  }
  return timingInput;
}
var KeyframeEffect = (
  /** @class */
  function() {
    function KeyframeEffect2(target, effectInput, timingInput) {
      var _this2 = this;
      this.composite = "replace";
      this.iterationComposite = "replace";
      this.target = target;
      this.timing = normalizeTimingInput(timingInput, false);
      this.timing.effect = this;
      this.timing.activeDuration = calculateActiveDuration(this.timing);
      this.timing.endTime = Math.max(0, this.timing.delay + this.timing.activeDuration + this.timing.endDelay);
      this.normalizedKeyframes = normalizeKeyframes(effectInput, this.timing);
      this.interpolations = convertEffectInput(this.normalizedKeyframes, this.timing, this.target);
      var Proxy = runtime.globalThis.Proxy;
      this.computedTiming = Proxy ? new Proxy(this.timing, {
        get: function(target2, prop) {
          if (prop === "duration") {
            return target2.duration === "auto" ? 0 : target2.duration;
          } else if (prop === "fill") {
            return target2.fill === "auto" ? "none" : target2.fill;
          } else if (prop === "localTime") {
            return _this2.animation && _this2.animation.currentTime || null;
          } else if (prop === "currentIteration") {
            if (!_this2.animation || _this2.animation.playState !== "running") {
              return null;
            }
            return target2.currentIteration || 0;
          } else if (prop === "progress") {
            if (!_this2.animation || _this2.animation.playState !== "running") {
              return null;
            }
            return target2.progress || 0;
          }
          return target2[prop];
        },
        set: function() {
          return true;
        }
      }) : this.timing;
    }
    KeyframeEffect2.prototype.applyInterpolations = function() {
      this.interpolations(this.target, Number(this.timeFraction));
    };
    KeyframeEffect2.prototype.update = function(localTime) {
      if (localTime === null) {
        return false;
      }
      this.timeFraction = calculateIterationProgress(this.timing.activeDuration, localTime, this.timing);
      return this.timeFraction !== null;
    };
    KeyframeEffect2.prototype.getKeyframes = function() {
      return this.normalizedKeyframes;
    };
    KeyframeEffect2.prototype.setKeyframes = function(keyframes) {
      this.normalizedKeyframes = normalizeKeyframes(keyframes);
    };
    KeyframeEffect2.prototype.getComputedTiming = function() {
      return this.computedTiming;
    };
    KeyframeEffect2.prototype.getTiming = function() {
      return this.timing;
    };
    KeyframeEffect2.prototype.updateTiming = function(timing) {
      var _this2 = this;
      Object.keys(timing || {}).forEach(function(name2) {
        _this2.timing[name2] = timing[name2];
      });
    };
    return KeyframeEffect2;
  }()
);
function compareAnimations(leftAnimation, rightAnimation) {
  return Number(leftAnimation.id) - Number(rightAnimation.id);
}
var AnimationTimeline = (
  /** @class */
  function() {
    function AnimationTimeline2(document2) {
      var _this2 = this;
      this.document = document2;
      this.animations = [];
      this.ticking = false;
      this.timelineTicking = false;
      this.hasRestartedThisFrame = false;
      this.animationsWithPromises = [];
      this.inTick = false;
      this.pendingEffects = [];
      this.currentTime = null;
      this.rafId = 0;
      this.rafCallbacks = [];
      this.webAnimationsNextTick = function(t) {
        _this2.currentTime = t;
        _this2.discardAnimations();
        if (_this2.animations.length === 0) {
          _this2.timelineTicking = false;
        } else {
          _this2.requestAnimationFrame(_this2.webAnimationsNextTick);
        }
      };
      this.processRafCallbacks = function(t) {
        var processing = _this2.rafCallbacks;
        _this2.rafCallbacks = [];
        if (t < Number(_this2.currentTime))
          t = Number(_this2.currentTime);
        _this2.animations.sort(compareAnimations);
        _this2.animations = _this2.tick(t, true, _this2.animations)[0];
        processing.forEach(function(entry) {
          entry[1](t);
        });
        _this2.applyPendingEffects();
      };
    }
    AnimationTimeline2.prototype.getAnimations = function() {
      this.discardAnimations();
      return this.animations.slice();
    };
    AnimationTimeline2.prototype.isTicking = function() {
      return this.inTick;
    };
    AnimationTimeline2.prototype.play = function(target, keyframes, options) {
      var effect = new KeyframeEffect(target, keyframes, options);
      var animation = new Animation(effect, this);
      this.animations.push(animation);
      this.restartWebAnimationsNextTick();
      animation.updatePromises();
      animation.play();
      animation.updatePromises();
      return animation;
    };
    AnimationTimeline2.prototype.applyDirtiedAnimation = function(animation) {
      var _this2 = this;
      if (this.inTick) {
        return;
      }
      animation.markTarget();
      var animations = animation.targetAnimations();
      animations.sort(compareAnimations);
      var inactiveAnimations = this.tick(Number(this.currentTime), false, animations.slice())[1];
      inactiveAnimations.forEach(function(animation2) {
        var index3 = _this2.animations.indexOf(animation2);
        if (index3 !== -1) {
          _this2.animations.splice(index3, 1);
        }
      });
      this.applyPendingEffects();
    };
    AnimationTimeline2.prototype.restart = function() {
      if (!this.ticking) {
        this.ticking = true;
        this.requestAnimationFrame(function() {
        });
        this.hasRestartedThisFrame = true;
      }
      return this.hasRestartedThisFrame;
    };
    AnimationTimeline2.prototype.destroy = function() {
      this.document.defaultView.cancelAnimationFrame(this.frameId);
    };
    AnimationTimeline2.prototype.applyPendingEffects = function() {
      this.pendingEffects.forEach(function(effect) {
        effect === null || effect === void 0 ? void 0 : effect.applyInterpolations();
      });
      this.pendingEffects = [];
    };
    AnimationTimeline2.prototype.updateAnimationsPromises = function() {
      this.animationsWithPromises = this.animationsWithPromises.filter(function(animation) {
        return animation.updatePromises();
      });
    };
    AnimationTimeline2.prototype.discardAnimations = function() {
      this.updateAnimationsPromises();
      this.animations = this.animations.filter(function(animation) {
        return animation.playState !== "finished" && animation.playState !== "idle";
      });
    };
    AnimationTimeline2.prototype.restartWebAnimationsNextTick = function() {
      if (!this.timelineTicking) {
        this.timelineTicking = true;
        this.requestAnimationFrame(this.webAnimationsNextTick);
      }
    };
    AnimationTimeline2.prototype.rAF = function(f) {
      var id3 = this.rafId++;
      if (this.rafCallbacks.length === 0) {
        this.frameId = this.document.defaultView.requestAnimationFrame(this.processRafCallbacks);
      }
      this.rafCallbacks.push([id3, f]);
      return id3;
    };
    AnimationTimeline2.prototype.requestAnimationFrame = function(f) {
      var _this2 = this;
      return this.rAF(function(x3) {
        _this2.updateAnimationsPromises();
        f(x3);
        _this2.updateAnimationsPromises();
      });
    };
    AnimationTimeline2.prototype.tick = function(t, isAnimationFrame, updatingAnimations) {
      var _a2, _b;
      var _this2 = this;
      this.inTick = true;
      this.hasRestartedThisFrame = false;
      this.currentTime = t;
      this.ticking = false;
      var newPendingClears = [];
      var newPendingEffects = [];
      var activeAnimations = [];
      var inactiveAnimations = [];
      updatingAnimations.forEach(function(animation) {
        animation.tick(t, isAnimationFrame);
        if (!animation._inEffect) {
          newPendingClears.push(animation.effect);
          animation.unmarkTarget();
        } else {
          newPendingEffects.push(animation.effect);
          animation.markTarget();
        }
        if (animation._needsTick)
          _this2.ticking = true;
        var alive = animation._inEffect || animation._needsTick;
        animation._inTimeline = alive;
        if (alive) {
          activeAnimations.push(animation);
        } else {
          inactiveAnimations.push(animation);
        }
      });
      (_a2 = this.pendingEffects).push.apply(_a2, __spreadArray([], __read(newPendingClears), false));
      (_b = this.pendingEffects).push.apply(_b, __spreadArray([], __read(newPendingEffects), false));
      if (this.ticking)
        this.requestAnimationFrame(function() {
        });
      this.inTick = false;
      return [activeAnimations, inactiveAnimations];
    };
    return AnimationTimeline2;
  }()
);
runtime.EasingFunction = parseEasingFunction;
runtime.AnimationTimeline = AnimationTimeline;

// node_modules/@antv/g2/esm/utils/selection.js
function select(node) {
  return new Selection([node], null, node, node.ownerDocument);
}
var Selection = class _Selection {
  constructor(elements = null, data2 = null, parent2 = null, document2 = null, selections = [
    null,
    null,
    null,
    null,
    null
  ], transitions = [], updateElements = []) {
    this._elements = Array.from(elements);
    this._data = data2;
    this._parent = parent2;
    this._document = document2;
    this._enter = selections[0];
    this._update = selections[1];
    this._exit = selections[2];
    this._merge = selections[3];
    this._split = selections[4];
    this._transitions = transitions;
    this._facetElements = updateElements;
  }
  selectAll(selector) {
    const elements = typeof selector === "string" ? this._parent.querySelectorAll(selector) : selector;
    return new _Selection(elements, null, this._elements[0], this._document);
  }
  selectFacetAll(selector) {
    const elements = typeof selector === "string" ? this._parent.querySelectorAll(selector) : selector;
    return new _Selection(this._elements, null, this._parent, this._document, void 0, void 0, elements);
  }
  /**
   * @todo Replace with querySelector which has bug now.
   */
  select(selector) {
    const element = typeof selector === "string" ? this._parent.querySelectorAll(selector)[0] || null : selector;
    return new _Selection([element], null, element, this._document);
  }
  append(node) {
    const callback = typeof node === "function" ? node : () => this.createElement(node);
    const elements = [];
    if (this._data !== null) {
      for (let i = 0; i < this._data.length; i++) {
        const d2 = this._data[i];
        const [datum, from] = Array.isArray(d2) ? d2 : [d2, null];
        const newElement = callback(datum, i);
        newElement.__data__ = datum;
        if (from !== null)
          newElement.__fromElements__ = from;
        this._parent.appendChild(newElement);
        elements.push(newElement);
      }
      return new _Selection(elements, null, this._parent, this._document);
    } else {
      for (let i = 0; i < this._elements.length; i++) {
        const element = this._elements[i];
        const datum = element.__data__;
        const newElement = callback(datum, i);
        element.appendChild(newElement);
        elements.push(newElement);
      }
      return new _Selection(elements, null, elements[0], this._document);
    }
  }
  maybeAppend(id3, node, className2) {
    const element = this._elements[0];
    const child = element.getElementById(id3);
    if (child) {
      return new _Selection([child], null, this._parent, this._document);
    }
    const newChild = typeof node === "string" ? this.createElement(node) : node();
    newChild.id = id3;
    if (className2)
      newChild.className = className2;
    element.appendChild(newChild);
    return new _Selection([newChild], null, this._parent, this._document);
  }
  /**
   * Bind data to elements, and produce three selection:
   * Enter: Selection with empty elements and data to be bind to elements.
   * Update: Selection with elements to be updated.
   * Exit: Selection with elements to be removed.
   */
  data(data2, id3 = (d2) => d2, groupId = () => null) {
    const enter = [];
    const update3 = [];
    const exit = new Set(this._elements);
    const merge3 = [];
    const split2 = /* @__PURE__ */ new Set();
    const keyElement = new Map(this._elements.map((d2, i) => [id3(d2.__data__, i), d2]));
    const keyUpdateElement = new Map(this._facetElements.map((d2, i) => [id3(d2.__data__, i), d2]));
    const groupKeyElements = group(this._elements, (d2) => groupId(d2.__data__));
    for (let i = 0; i < data2.length; i++) {
      const datum = data2[i];
      const key = id3(datum, i);
      const groupKey = groupId(datum, i);
      if (keyElement.has(key)) {
        const element = keyElement.get(key);
        element.__data__ = datum;
        element.__facet__ = false;
        update3.push(element);
        exit.delete(element);
        keyElement.delete(key);
      } else if (keyUpdateElement.has(key)) {
        const element = keyUpdateElement.get(key);
        element.__data__ = datum;
        element.__facet__ = true;
        update3.push(element);
        keyUpdateElement.delete(key);
      } else if (groupKeyElements.has(key)) {
        const group3 = groupKeyElements.get(key);
        merge3.push([datum, group3]);
        for (const element of group3)
          exit.delete(element);
        groupKeyElements.delete(key);
      } else if (keyElement.has(groupKey)) {
        const element = keyElement.get(groupKey);
        if (element.__toData__)
          element.__toData__.push(datum);
        else
          element.__toData__ = [datum];
        split2.add(element);
        exit.delete(element);
      } else {
        enter.push(datum);
      }
    }
    const S = [
      new _Selection([], enter, this._parent, this._document),
      new _Selection(update3, null, this._parent, this._document),
      new _Selection(exit, null, this._parent, this._document),
      new _Selection([], merge3, this._parent, this._document),
      new _Selection(split2, null, this._parent, this._document)
    ];
    return new _Selection(this._elements, null, this._parent, this._document, S);
  }
  merge(other) {
    const elements = [...this._elements, ...other._elements];
    const transitions = [...this._transitions, ...other._transitions];
    return new _Selection(elements, null, this._parent, this._document, void 0, transitions);
  }
  createElement(type) {
    if (this._document) {
      return this._document.createElement(type, {});
    }
    const Ctor = _Selection.registry[type];
    if (Ctor)
      return new Ctor();
    return error(`Unknown node type: ${type}`);
  }
  /**
   * Apply callback for each selection(enter, update, exit)
   * and merge them into one selection.
   */
  join(enter = (d2) => d2, update3 = (d2) => d2, exit = (d2) => d2.remove(), merge3 = (d2) => d2, split2 = (d2) => d2.remove()) {
    const newEnter = enter(this._enter);
    const newUpdate = update3(this._update);
    const newExit = exit(this._exit);
    const newMerge = merge3(this._merge);
    const newSplit = split2(this._split);
    return newUpdate.merge(newEnter).merge(newExit).merge(newMerge).merge(newSplit);
  }
  remove() {
    for (let i = 0; i < this._elements.length; i++) {
      const transition2 = this._transitions[i];
      if (transition2) {
        const T = Array.isArray(transition2) ? transition2 : [transition2];
        Promise.all(T.map((d2) => d2.finished)).then(() => {
          const element = this._elements[i];
          element.remove();
        });
      } else {
        const element = this._elements[i];
        element.remove();
      }
    }
    return new _Selection([], null, this._parent, this._document, void 0, this._transitions);
  }
  each(callback) {
    for (let i = 0; i < this._elements.length; i++) {
      const element = this._elements[i];
      const datum = element.__data__;
      callback(datum, i, element);
    }
    return this;
  }
  attr(key, value2) {
    const callback = typeof value2 !== "function" ? () => value2 : value2;
    return this.each(function(d2, i, element) {
      if (value2 !== void 0)
        element[key] = callback(d2, i, element);
    });
  }
  style(key, value2) {
    const callback = typeof value2 !== "function" ? () => value2 : value2;
    return this.each(function(d2, i, element) {
      if (value2 !== void 0)
        element.style[key] = callback(d2, i, element);
    });
  }
  transition(value2) {
    const callback = typeof value2 !== "function" ? () => value2 : value2;
    const { _transitions: T } = this;
    return this.each(function(d2, i, element) {
      T[i] = callback(d2, i, element);
    });
  }
  on(event, handler) {
    this.each(function(d2, i, element) {
      element.addEventListener(event, handler);
    });
    return this;
  }
  call(callback, ...args) {
    callback(this, ...args);
    return this;
  }
  node() {
    return this._elements[0];
  }
  nodes() {
    return this._elements;
  }
  transitions() {
    return this._transitions;
  }
  parent() {
    return this._parent;
  }
};
Selection.registry = {
  g: Group2,
  rect: Rect,
  circle: Circle,
  path: Path2,
  text: Text,
  ellipse: Ellipse,
  image: Image2,
  line: Line,
  polygon: Polygon,
  polyline: Polyline,
  html: HTML
};

// node_modules/@antv/g2/esm/utils/number.js
function clamp2(v, lower2, upper2) {
  return Math.max(lower2, Math.min(v, upper2));
}
function prettyNumber2(n, precision = 10) {
  if (typeof n !== "number")
    return n;
  return Math.abs(n) < 1e-15 ? n : parseFloat(n.toFixed(precision));
}

// node_modules/@antv/g2/esm/shape/utils.js
function applyStyle(selection, style) {
  for (const [key, value2] of Object.entries(style)) {
    selection.style(key, value2);
  }
}
function appendPolygon(path2, points) {
  points.forEach((p2, idx) => idx === 0 ? path2.moveTo(p2[0], p2[1]) : path2.lineTo(p2[0], p2[1]));
  path2.closePath();
  return path2;
}
function arrowPoints(from, to, options) {
  const { arrowSize } = options;
  const size5 = typeof arrowSize === "string" ? +parseFloat(arrowSize) / 100 * dist4(from, to) : arrowSize;
  const arrowAngle = Math.PI / 6;
  const angle4 = Math.atan2(to[1] - from[1], to[0] - from[0]);
  const arrowAngle1 = Math.PI / 2 - angle4 - arrowAngle;
  const arrow1 = [
    to[0] - size5 * Math.sin(arrowAngle1),
    to[1] - size5 * Math.cos(arrowAngle1)
  ];
  const arrowAngle2 = angle4 - arrowAngle;
  const arrow2 = [
    to[0] - size5 * Math.cos(arrowAngle2),
    to[1] - size5 * Math.sin(arrowAngle2)
  ];
  return [arrow1, arrow2];
}
function appendArc(path2, from, to, center2, radius) {
  const startAngle = angle3(sub6(center2, from)) + Math.PI;
  const endAngle = angle3(sub6(center2, to)) + Math.PI;
  path2.arc(center2[0], center2[1], radius, startAngle, endAngle, endAngle - startAngle < 0);
  return path2;
}
function computeGradient(C3, X, Y, from = "y", mode2 = "between", tpShape = false) {
  const getTheta = (from2, tpShape2) => {
    if (from2 === "y" || from2 === true) {
      if (tpShape2) {
        return 180;
      } else {
        return 90;
      }
    } else {
      if (tpShape2) {
        return 90;
      } else {
        return 0;
      }
    }
  };
  const P = from === "y" || from === true ? Y : X;
  const theta = getTheta(from, tpShape);
  const I = indexOf2(P);
  const [min11, max11] = extent(I, (i) => P[i]);
  const p2 = new Linear({
    domain: [min11, max11],
    range: [0, 100]
  });
  const percentage = (i) => p2.map(P[i]);
  const gradientMode = {
    // Interpolate the colors for this segment.
    between: (i) => `${C3[i]} ${percentage(i)}%`,
    // Use the color of the start point as the color for this segment.
    start: (i) => i === 0 ? `${C3[i]} ${percentage(i)}%` : `${C3[i - 1]} ${percentage(i)}%, ${C3[i]} ${percentage(i)}%`,
    // Use the color of the end point as the color for this segment.
    end: (i) => i === C3.length - 1 ? `${C3[i]} ${percentage(i)}%` : `${C3[i]} ${percentage(i)}%, ${C3[i + 1]} ${percentage(i)}%`
  };
  const gradient2 = I.sort((a4, b) => percentage(a4) - percentage(b)).map(gradientMode[mode2] || gradientMode["between"]).join(",");
  return `linear-gradient(${theta}deg, ${gradient2})`;
}
function reorder(points) {
  const [p0, p1, p2, p3] = points;
  return [p3, p0, p1, p2];
}
function getArcObject(coordinate2, points, Y) {
  const [p0, p1, , p3] = isTranspose(coordinate2) ? reorder(points) : points;
  const [y3, y12] = Y;
  const center2 = coordinate2.getCenter();
  const a1 = angleWithQuadrant(sub6(p0, center2));
  const a22 = angleWithQuadrant(sub6(p1, center2));
  const a32 = a22 === a1 && y3 !== y12 ? a22 + Math.PI * 2 : a22;
  return {
    startAngle: a1,
    endAngle: a32 - a1 >= 0 ? a32 : Math.PI * 2 + a32,
    innerRadius: dist4(p3, center2),
    outerRadius: dist4(p0, center2)
  };
}
function toOpacityKey(options) {
  const { colorAttribute, opacityAttribute = colorAttribute } = options;
  return `${opacityAttribute}Opacity`;
}
function getTransform(coordinate2, value2) {
  if (!isPolar(coordinate2))
    return "";
  const center2 = coordinate2.getCenter();
  const { transform: suffix } = value2;
  return `translate(${center2[0]}, ${center2[1]}) ${suffix || ""}`;
}
function getOrigin(points) {
  if (points.length === 1)
    return points[0];
  const [[x05, y05, z0 = 0], [x22, y22, z2 = 0]] = points;
  return [(x05 + x22) / 2, (y05 + y22) / 2, (z0 + z2) / 2];
}

// node_modules/@antv/g2/esm/shape/interval/color.js
var __rest13 = function(s2, e) {
  var t = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
      t[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t[p2[i]] = s2[p2[i]];
    }
  return t;
};
function rect(document2, points, value2, coordinate2, style = {}) {
  const { inset = 0, radius = 0, insetLeft = inset, insetTop = inset, insetRight = inset, insetBottom = inset, radiusBottomLeft = radius, radiusBottomRight = radius, radiusTopLeft = radius, radiusTopRight = radius, minWidth = -Infinity, maxWidth = Infinity, minHeight = -Infinity } = style, rest2 = __rest13(style, ["inset", "radius", "insetLeft", "insetTop", "insetRight", "insetBottom", "radiusBottomLeft", "radiusBottomRight", "radiusTopLeft", "radiusTopRight", "minWidth", "maxWidth", "minHeight"]);
  if (!isPolar(coordinate2) && !isHelix(coordinate2)) {
    const tpShape = !!isTranspose(coordinate2);
    const [p0, , p2] = tpShape ? reorder(points) : points;
    const [x3, y4] = p0;
    const [width, height] = sub6(p2, p0);
    const absX = width > 0 ? x3 : x3 + width;
    const absY = height > 0 ? y4 : y4 + height;
    const absWidth = Math.abs(width);
    const absHeight = Math.abs(height);
    const finalX = absX + insetLeft;
    const finalY = absY + insetTop;
    const finalWidth = absWidth - (insetLeft + insetRight);
    const finalHeight = absHeight - (insetTop + insetBottom);
    const clampWidth = tpShape ? clamp2(finalWidth, minHeight, Infinity) : clamp2(finalWidth, minWidth, maxWidth);
    const clampHeight = tpShape ? clamp2(finalHeight, minWidth, maxWidth) : clamp2(finalHeight, minHeight, Infinity);
    const clampX = tpShape ? finalX : finalX - (clampWidth - finalWidth) / 2;
    const clampY = tpShape ? finalY - (clampHeight - finalHeight) / 2 : finalY - (clampHeight - finalHeight);
    return select(document2.createElement("rect", {})).style("x", clampX).style("y", clampY).style("width", clampWidth).style("height", clampHeight).style("radius", [
      radiusTopLeft,
      radiusTopRight,
      radiusBottomRight,
      radiusBottomLeft
    ]).call(applyStyle, rest2).node();
  }
  const { y: y3, y1: y12 } = value2;
  const center2 = coordinate2.getCenter();
  const arcObject = getArcObject(coordinate2, points, [y3, y12]);
  const path2 = arc_default().cornerRadius(radius).padAngle(inset * Math.PI / 180);
  return select(document2.createElement("path", {})).style("path", path2(arcObject)).style("transform", `translate(${center2[0]}, ${center2[1]})`).style("radius", radius).style("inset", inset).call(applyStyle, rest2).node();
}
var Color2 = (options, context) => {
  const { colorAttribute, opacityAttribute = "fill", first: first3 = true, last: last7 = true } = options, style = __rest13(options, ["colorAttribute", "opacityAttribute", "first", "last"]);
  const { coordinate: coordinate2, document: document2 } = context;
  return (points, value2, defaults5) => {
    const { color: defaultColor, radius: defaultRadius2 = 0 } = defaults5, restDefaults = __rest13(defaults5, ["color", "radius"]);
    const defaultLineWidth = restDefaults.lineWidth || 1;
    const { stroke: stroke2, radius = defaultRadius2, radiusTopLeft = radius, radiusTopRight = radius, radiusBottomRight = radius, radiusBottomLeft = radius, innerRadius = 0, innerRadiusTopLeft = innerRadius, innerRadiusTopRight = innerRadius, innerRadiusBottomRight = innerRadius, innerRadiusBottomLeft = innerRadius, lineWidth = colorAttribute === "stroke" || stroke2 ? defaultLineWidth : 0, inset = 0, insetLeft = inset, insetRight = inset, insetBottom = inset, insetTop = inset, minWidth, maxWidth, minHeight } = style, rest2 = __rest13(style, ["stroke", "radius", "radiusTopLeft", "radiusTopRight", "radiusBottomRight", "radiusBottomLeft", "innerRadius", "innerRadiusTopLeft", "innerRadiusTopRight", "innerRadiusBottomRight", "innerRadiusBottomLeft", "lineWidth", "inset", "insetLeft", "insetRight", "insetBottom", "insetTop", "minWidth", "maxWidth", "minHeight"]);
    const { color: color2 = defaultColor, opacity } = value2;
    const standardDirRadius = [
      first3 ? radiusTopLeft : innerRadiusTopLeft,
      first3 ? radiusTopRight : innerRadiusTopRight,
      last7 ? radiusBottomRight : innerRadiusBottomRight,
      last7 ? radiusBottomLeft : innerRadiusBottomLeft
    ];
    const standardDir = [
      "radiusTopLeft",
      "radiusTopRight",
      "radiusBottomRight",
      "radiusBottomLeft"
    ];
    if (isTranspose(coordinate2)) {
      standardDir.push(standardDir.shift());
    }
    const extendedStyle = Object.assign(Object.assign({ radius }, Object.fromEntries(standardDir.map((d2, i) => [d2, standardDirRadius[i]]))), {
      inset,
      insetLeft,
      insetRight,
      insetBottom,
      insetTop,
      minWidth,
      maxWidth,
      minHeight
    });
    return select(rect(document2, points, value2, coordinate2, extendedStyle)).call(applyStyle, restDefaults).style("fill", "transparent").style(colorAttribute, color2).style(toOpacityKey(options), opacity).style("lineWidth", lineWidth).style("stroke", stroke2 === void 0 ? color2 : stroke2).call(applyStyle, rest2).node();
  };
};
Color2.props = {
  defaultEnterAnimation: "scaleInY",
  defaultUpdateAnimation: "morphing",
  defaultExitAnimation: "fadeOut"
};

// node_modules/@antv/g2/esm/shape/interval/rect.js
var Rect2 = (options, context) => {
  return Color2(Object.assign({ colorAttribute: "fill" }, options), context);
};
Rect2.props = Object.assign(Object.assign({}, Color2.props), { defaultMarker: "square" });

// node_modules/@antv/g2/esm/shape/interval/hollow.js
var Hollow = (options, context) => {
  return Color2(Object.assign({ colorAttribute: "stroke" }, options), context);
};
Hollow.props = Object.assign(Object.assign({}, Color2.props), { defaultMarker: "hollowSquare" });

// node_modules/@antv/g2/esm/shape/interval/funnel.js
var __rest14 = function(s2, e) {
  var t = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
      t[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t[p2[i]] = s2[p2[i]];
    }
  return t;
};
function getFunnelPoints(points, nextPoints, coordinate2) {
  const [p0, p1, p2, p3] = points;
  if (isTranspose(coordinate2)) {
    const newP12 = [nextPoints ? nextPoints[0][0] : p1[0], p1[1]];
    const newP22 = [nextPoints ? nextPoints[3][0] : p2[0], p2[1]];
    return [p0, newP12, newP22, p3];
  }
  const newP1 = [p1[0], nextPoints ? nextPoints[0][1] : p1[1]];
  const newP2 = [p2[0], nextPoints ? nextPoints[3][1] : p2[1]];
  return [p0, newP1, newP2, p3];
}
var Funnel = (options, context) => {
  const { adjustPoints = getFunnelPoints } = options, style = __rest14(options, ["adjustPoints"]);
  const { coordinate: coordinate2, document: document2 } = context;
  return (points, value2, defaults5, point2d) => {
    const { index: index3 } = value2;
    const { color: defaultColor } = defaults5, rest2 = __rest14(defaults5, ["color"]);
    const nextPoints = point2d[index3 + 1];
    const funnelPoints = adjustPoints(points, nextPoints, coordinate2);
    const tpShape = !!isTranspose(coordinate2);
    const [p0, p1, p2, p3] = tpShape ? reorder(funnelPoints) : funnelPoints;
    const { color: color2 = defaultColor, opacity } = value2;
    const b = line_default().curve(linearClosed_default)([p0, p1, p2, p3]);
    return select(document2.createElement("path", {})).call(applyStyle, rest2).style("path", b).style("fill", color2).style("fillOpacity", opacity).call(applyStyle, style).node();
  };
};
Funnel.props = {
  defaultMarker: "square"
};

// node_modules/@antv/g2/esm/shape/interval/pyramid.js
function getPyramidPoints(points, nextPoints, coordinate2) {
  const [p0, p1, p2, p3] = points;
  if (isTranspose(coordinate2)) {
    const newP12 = [
      nextPoints ? nextPoints[0][0] : (p1[0] + p2[0]) / 2,
      p1[1]
    ];
    const newP22 = [
      nextPoints ? nextPoints[3][0] : (p1[0] + p2[0]) / 2,
      p2[1]
    ];
    return [p0, newP12, newP22, p3];
  }
  const newP1 = [
    p1[0],
    nextPoints ? nextPoints[0][1] : (p1[1] + p2[1]) / 2
  ];
  const newP2 = [
    p2[0],
    nextPoints ? nextPoints[3][1] : (p1[1] + p2[1]) / 2
  ];
  return [p0, newP1, newP2, p3];
}
var Pyramid = (options, context) => {
  return Funnel(Object.assign({ adjustPoints: getPyramidPoints }, options), context);
};
Pyramid.props = {
  defaultMarker: "square"
};

// node_modules/@antv/g2/esm/utils/createElement.js
function createElement(descriptor) {
  const render3 = typeof descriptor === "function" ? descriptor : descriptor.render;
  return class extends CustomElement {
    connectedCallback() {
      this.draw();
    }
    attributeChangedCallback() {
      this.draw();
    }
    draw() {
      render3(this);
    }
  };
}

// node_modules/@antv/g2/esm/shape/line/curve.js
var __rest15 = function(s2, e) {
  var t = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
      t[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t[p2[i]] = s2[p2[i]];
    }
  return t;
};
var DoublePath = createElement((g) => {
  const { d1, d2, style1, style2 } = g.attributes;
  const document2 = g.ownerDocument;
  select(g).maybeAppend("line", () => document2.createElement("path", {})).style("d", d1).call(applyStyle, style1);
  select(g).maybeAppend("line1", () => document2.createElement("path", {})).style("d", d2).call(applyStyle, style2);
});
function segmentation(points, defined4) {
  const definedPoints = [];
  const segments = [];
  let m3 = false;
  let dp = null;
  for (const p2 of points) {
    if (!defined4(p2[0]) || !defined4(p2[1]))
      m3 = true;
    else {
      definedPoints.push(p2);
      if (m3) {
        m3 = false;
        segments.push([dp, p2]);
      }
      dp = p2;
    }
  }
  return [definedPoints, segments];
}
var Curve = (options, context) => {
  const {
    curve,
    gradient: gradient2 = false,
    // The color for each segment.
    gradientColor = "between",
    defined: defined4 = (d2) => !Number.isNaN(d2) && d2 !== void 0 && d2 !== null,
    connect: connectNulls = false
  } = options, style = __rest15(options, ["curve", "gradient", "gradientColor", "defined", "connect"]);
  const { coordinate: coordinate2, document: document2 } = context;
  return (P, value2, defaults5) => {
    const { color: defaultColor, lineWidth: defaultSize } = defaults5, rest2 = __rest15(defaults5, ["color", "lineWidth"]);
    const { color: color2 = defaultColor, size: size5 = defaultSize, seriesColor: sc, seriesX: sx, seriesY: sy } = value2;
    const transform3 = getTransform(coordinate2, value2);
    const tpShape = isTranspose(coordinate2);
    const stroke2 = gradient2 && sc ? computeGradient(sc, sx, sy, gradient2, gradientColor, tpShape) : color2;
    const finalStyle = Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, rest2), stroke2 && { stroke: stroke2 }), size5 && { lineWidth: size5 }), transform3 && { transform: transform3 }), style);
    let linePath;
    if (isPolar(coordinate2)) {
      const center2 = coordinate2.getCenter();
      linePath = (points) => lineRadial_default().angle((_2, idx) => angleWithQuadrant(sub6(points[idx], center2))).radius((_2, idx) => dist4(points[idx], center2)).defined(([x3, y3]) => defined4(x3) && defined4(y3)).curve(curve)(points);
    } else {
      linePath = line_default().x((d2) => d2[0]).y((d2) => d2[1]).defined(([x3, y3]) => defined4(x3) && defined4(y3)).curve(curve);
    }
    const [DP, MS] = segmentation(P, defined4);
    const connectStyle = subObject(finalStyle, "connect");
    const missing = !!MS.length;
    if (!missing || connectNulls && !Object.keys(connectStyle).length) {
      return select(document2.createElement("path", {})).style("d", linePath(DP) || []).call(applyStyle, finalStyle).node();
    }
    if (missing && !connectNulls) {
      return select(document2.createElement("path", {})).style("d", linePath(P)).call(applyStyle, finalStyle).node();
    }
    const connectPath = (segments) => segments.map(linePath).join(",");
    return select(new DoublePath()).style("style1", Object.assign(Object.assign({}, finalStyle), connectStyle)).style("style2", finalStyle).style("d1", connectPath(MS)).style("d2", linePath(P)).node();
  };
};
Curve.props = {
  defaultMarker: "smooth",
  defaultEnterAnimation: "fadeIn",
  defaultUpdateAnimation: "morphing",
  defaultExitAnimation: "fadeOut"
};

// node_modules/@antv/g2/esm/shape/line/line.js
var Line2 = (options, context) => {
  const { coordinate: coordinate2 } = context;
  return (...params) => {
    const curve = isPolar(coordinate2) ? linearClosed_default : linear_default;
    return Curve(Object.assign({ curve }, options), context)(...params);
  };
};
Line2.props = Object.assign(Object.assign({}, Curve.props), { defaultMarker: "line" });

// node_modules/@antv/g2/esm/shape/line/smooth.js
var __rest16 = function(s2, e) {
  var t = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
      t[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t[p2[i]] = s2[p2[i]];
    }
  return t;
};
var Smooth = (options, context) => {
  const rest2 = __rest16(options, []);
  const { coordinate: coordinate2 } = context;
  return (...params) => {
    const curve = isPolar(coordinate2) ? catmullRomClosed_default : isTranspose(coordinate2) ? monotoneY : monotoneX;
    return Curve(Object.assign({ curve }, rest2), context)(...params);
  };
};
Smooth.props = Object.assign(Object.assign({}, Curve.props), { defaultMarker: "smooth" });

// node_modules/@antv/g2/esm/shape/line/hv.js
var HV = (options, context) => {
  return Curve(Object.assign({ curve: stepAfter }, options), context);
};
HV.props = Object.assign(Object.assign({}, Curve.props), { defaultMarker: "hv" });

// node_modules/@antv/g2/esm/shape/line/vh.js
var VH = (options, context) => {
  return Curve(Object.assign({ curve: stepBefore }, options), context);
};
VH.props = Object.assign(Object.assign({}, Curve.props), { defaultMarker: "vh" });

// node_modules/@antv/g2/esm/shape/line/hvh.js
var HVH = (options, context) => {
  return Curve(Object.assign({ curve: step_default }, options), context);
};
HVH.props = Object.assign(Object.assign({}, Curve.props), { defaultMarker: "hvh" });

// node_modules/@antv/g2/esm/shape/line/trail.js
var __rest17 = function(s2, e) {
  var t = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
      t[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t[p2[i]] = s2[p2[i]];
    }
  return t;
};
function stroke(path2, p0, p1, s0, s1) {
  const v = sub6(p1, p0);
  const a4 = angle3(v);
  const a1 = a4 + Math.PI / 2;
  const r1 = [s0 / 2 * Math.cos(a1), s0 / 2 * Math.sin(a1)];
  const r2 = [s1 / 2 * Math.cos(a1), s1 / 2 * Math.sin(a1)];
  const r3 = [s1 / 2 * Math.cos(a4), s1 / 2 * Math.sin(a4)];
  const r4 = [s0 / 2 * Math.cos(a4), s0 / 2 * Math.sin(a4)];
  const x05 = add7(p0, r1);
  const x12 = add7(p1, r2);
  const x22 = add7(x12, r3);
  const x3 = add7(p1, r3);
  const x4 = sub6(x3, r2);
  const x5 = sub6(p1, r2);
  const x6 = sub6(p0, r1);
  const x7 = sub6(x6, r4);
  const x8 = sub6(p0, r4);
  const x9 = sub6(x05, r4);
  path2.moveTo(...x05);
  path2.lineTo(...x12);
  path2.arcTo(...x22, ...x3, s1 / 2);
  path2.arcTo(...x4, ...x5, s1 / 2);
  path2.lineTo(...x6);
  path2.arcTo(...x7, ...x8, s0 / 2);
  path2.arcTo(...x9, ...x05, s0 / 2);
  path2.closePath();
}
var Trail = (options, context) => {
  const { document: document2 } = context;
  return (P, value2, defaults5) => {
    const { seriesSize, color: color2 } = value2;
    const { color: defaultColor } = defaults5, rest2 = __rest17(defaults5, ["color"]);
    const path2 = path();
    for (let i = 0; i < P.length - 1; i++) {
      const p0 = P[i];
      const p1 = P[i + 1];
      const s0 = seriesSize[i];
      const s1 = seriesSize[i + 1];
      if ([...p0, ...p1].every(defined))
        stroke(path2, p0, p1, s0, s1);
    }
    return select(document2.createElement("path", {})).call(applyStyle, rest2).style("fill", color2 || defaultColor).style("d", path2.toString()).call(applyStyle, options).node();
  };
};
Trail.props = Object.assign(Object.assign({}, Curve.props), { defaultMarker: "line" });

// node_modules/@antv/g2/esm/utils/marker.js
var __rest18 = function(s2, e) {
  var t = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
      t[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t[p2[i]] = s2[p2[i]];
    }
  return t;
};
var point5 = (x3, y3, r) => {
  return [
    ["M", x3 - r, y3],
    ["A", r, r, 0, 1, 0, x3 + r, y3],
    ["A", r, r, 0, 1, 0, x3 - r, y3],
    ["Z"]
  ];
};
point5.style = ["fill"];
var hollowPoint = point5.bind(void 0);
hollowPoint.style = ["stroke", "lineWidth"];
var square = (x3, y3, r) => {
  return [
    ["M", x3 - r, y3 - r],
    ["L", x3 + r, y3 - r],
    ["L", x3 + r, y3 + r],
    ["L", x3 - r, y3 + r],
    ["Z"]
  ];
};
square.style = ["fill"];
var rect2 = square.bind(void 0);
rect2.style = ["fill"];
var hollowSquare = square.bind(void 0);
hollowSquare.style = ["stroke", "lineWidth"];
var diamond = (x3, y3, r) => {
  const hr = r * 0.618;
  return [
    ["M", x3 - hr, y3],
    ["L", x3, y3 - r],
    ["L", x3 + hr, y3],
    ["L", x3, y3 + r],
    ["Z"]
  ];
};
diamond.style = ["fill"];
var hollowDiamond = diamond.bind(void 0);
hollowDiamond.style = ["stroke", "lineWidth"];
var triangle = (x3, y3, r) => {
  const diffY = r * Math.sin(1 / 3 * Math.PI);
  return [
    ["M", x3 - r, y3 + diffY],
    ["L", x3, y3 - diffY],
    ["L", x3 + r, y3 + diffY],
    ["Z"]
  ];
};
triangle.style = ["fill"];
var hollowTriangle = triangle.bind(void 0);
hollowTriangle.style = ["stroke", "lineWidth"];
var triangleDown = (x3, y3, r) => {
  const diffY = r * Math.sin(1 / 3 * Math.PI);
  return [
    ["M", x3 - r, y3 - diffY],
    ["L", x3 + r, y3 - diffY],
    ["L", x3, y3 + diffY],
    ["Z"]
  ];
};
triangleDown.style = ["fill"];
var hollowTriangleDown = triangleDown.bind(void 0);
hollowTriangleDown.style = ["stroke", "lineWidth"];
var hexagon = (x3, y3, r) => {
  const diffX = r / 2 * Math.sqrt(3);
  return [
    ["M", x3, y3 - r],
    ["L", x3 + diffX, y3 - r / 2],
    ["L", x3 + diffX, y3 + r / 2],
    ["L", x3, y3 + r],
    ["L", x3 - diffX, y3 + r / 2],
    ["L", x3 - diffX, y3 - r / 2],
    ["Z"]
  ];
};
hexagon.style = ["fill"];
var hollowHexagon = hexagon.bind(void 0);
hollowHexagon.style = ["stroke", "lineWidth"];
var bowtie = (x3, y3, r) => {
  const diffY = r - 1.5;
  return [
    ["M", x3 - r, y3 - diffY],
    ["L", x3 + r, y3 + diffY],
    ["L", x3 + r, y3 - diffY],
    ["L", x3 - r, y3 + diffY],
    ["Z"]
  ];
};
bowtie.style = ["fill"];
var hollowBowtie = bowtie.bind(void 0);
hollowBowtie.style = ["stroke", "lineWidth"];
var line = (x3, y3, r) => {
  return [
    ["M", x3, y3 + r],
    ["L", x3, y3 - r]
  ];
};
line.style = ["stroke", "lineWidth"];
var cross5 = (x3, y3, r) => {
  return [
    ["M", x3 - r, y3 - r],
    ["L", x3 + r, y3 + r],
    ["M", x3 + r, y3 - r],
    ["L", x3 - r, y3 + r]
  ];
};
cross5.style = ["stroke", "lineWidth"];
var tick = (x3, y3, r) => {
  return [
    ["M", x3 - r / 2, y3 - r],
    ["L", x3 + r / 2, y3 - r],
    ["M", x3, y3 - r],
    ["L", x3, y3 + r],
    ["M", x3 - r / 2, y3 + r],
    ["L", x3 + r / 2, y3 + r]
  ];
};
tick.style = ["stroke", "lineWidth"];
var plus = (x3, y3, r) => {
  return [
    ["M", x3 - r, y3],
    ["L", x3 + r, y3],
    ["M", x3, y3 - r],
    ["L", x3, y3 + r]
  ];
};
plus.style = ["stroke", "lineWidth"];
var hyphen = (x3, y3, r) => {
  return [
    ["M", x3 - r, y3],
    ["L", x3 + r, y3]
  ];
};
hyphen.style = ["stroke", "lineWidth"];
var dot6 = (x3, y3, r) => {
  return [
    ["M", x3 - r, y3],
    ["L", x3 + r, y3]
  ];
};
dot6.style = ["stroke", "lineWidth"];
var dash = dot6.bind(void 0);
dash.style = ["stroke", "lineWidth"];
var smooth = (x3, y3, r) => {
  return [
    ["M", x3 - r, y3],
    ["A", r / 2, r / 2, 0, 1, 1, x3, y3],
    ["A", r / 2, r / 2, 0, 1, 0, x3 + r, y3]
  ];
};
smooth.style = ["stroke", "lineWidth"];
var hv = (x3, y3, r) => {
  return [
    ["M", x3 - r - 1, y3 - 2.5],
    ["L", x3, y3 - 2.5],
    ["L", x3, y3 + 2.5],
    ["L", x3 + r + 1, y3 + 2.5]
  ];
};
hv.style = ["stroke", "lineWidth"];
var vh = (x3, y3, r) => {
  return [
    ["M", x3 - r - 1, y3 + 2.5],
    ["L", x3, y3 + 2.5],
    ["L", x3, y3 - 2.5],
    ["L", x3 + r + 1, y3 - 2.5]
  ];
};
vh.style = ["stroke", "lineWidth"];
var hvh = (x3, y3, r) => {
  return [
    ["M", x3 - (r + 1), y3 + 2.5],
    ["L", x3 - r / 2, y3 + 2.5],
    ["L", x3 - r / 2, y3 - 2.5],
    ["L", x3 + r / 2, y3 - 2.5],
    ["L", x3 + r / 2, y3 + 2.5],
    ["L", x3 + r + 1, y3 + 2.5]
  ];
};
hvh.style = ["stroke", "lineWidth"];
var vhv = (x3, y3, r) => {
  return [
    ["M", x3 - 5, y3 + 2.5],
    ["L", x3 - 5, y3],
    ["L", x3, y3],
    ["L", x3, y3 - 3],
    ["L", x3, y3 + 3],
    ["L", x3 + 6.5, y3 + 3]
  ];
};
vhv.style = ["stroke", "lineWidth"];
var Symbols = /* @__PURE__ */ new Map([
  ["bowtie", bowtie],
  ["cross", cross5],
  ["dash", dash],
  ["diamond", diamond],
  ["dot", dot6],
  ["hexagon", hexagon],
  ["hollowBowtie", hollowBowtie],
  ["hollowDiamond", hollowDiamond],
  ["hollowHexagon", hollowHexagon],
  ["hollowPoint", hollowPoint],
  ["hollowSquare", hollowSquare],
  ["hollowTriangle", hollowTriangle],
  ["hollowTriangleDown", hollowTriangleDown],
  ["hv", hv],
  ["hvh", hvh],
  ["hyphen", hyphen],
  ["line", line],
  ["plus", plus],
  ["point", point5],
  ["rect", rect2],
  ["smooth", smooth],
  ["square", square],
  ["tick", tick],
  ["triangleDown", triangleDown],
  ["triangle", triangle],
  ["vh", vh],
  ["vhv", vhv]
]);
function useMarker(type, _a2) {
  var { d: d2, fill: fill2, strokeWidth, path: path2, stroke: stroke2, lineWidth, color: color2 } = _a2, style = __rest18(_a2, ["d", "fill", "strokeWidth", "path", "stroke", "lineWidth", "color"]);
  const symbol = Symbols.get(type) || Symbols.get("point");
  return (...args) => {
    const path3 = new Path2({
      style: Object.assign(Object.assign({}, style), { path: symbol(...args), stroke: symbol.style.includes("stroke") ? color2 || stroke2 : "", fill: symbol.style.includes("fill") ? color2 || fill2 : "", lineWidth: symbol.style.includes("lineWidth") ? lineWidth || lineWidth || 2 : 0 })
    });
    return path3;
  };
}

// node_modules/@antv/g2/esm/shape/point/color.js
var __rest19 = function(s2, e) {
  var t = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
      t[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t[p2[i]] = s2[p2[i]];
    }
  return t;
};
function getRadius2(mode2, points, value2, coordinate2) {
  if (points.length === 1)
    return void 0;
  const { size: size5 } = value2;
  if (mode2 === "fixed")
    return size5;
  if (mode2 === "normal" || isFisheye(coordinate2)) {
    const [[x05, y05], [x22, y22]] = points;
    const a4 = Math.abs((x22 - x05) / 2);
    const b = Math.abs((y22 - y05) / 2);
    return Math.max(0, (a4 + b) / 2);
  }
  return size5;
}
var Color3 = (options, context) => {
  const { colorAttribute, symbol, mode: mode2 = "auto" } = options, style = __rest19(options, ["colorAttribute", "symbol", "mode"]);
  const path2 = Symbols.get(symbol) || Symbols.get("point");
  const { coordinate: coordinate2, document: document2 } = context;
  return (points, value2, defaults5) => {
    const { lineWidth, color: defaultColor } = defaults5;
    const finalLineWidth = style.stroke ? lineWidth || 1 : lineWidth;
    const { color: color2 = defaultColor, transform: transform3, opacity } = value2;
    const [cx, cy] = getOrigin(points);
    const r = getRadius2(mode2, points, value2, coordinate2);
    const finalRadius = r || style.r || defaults5.r;
    return select(document2.createElement("path", {})).call(applyStyle, defaults5).style("fill", "transparent").style("d", path2(cx, cy, finalRadius)).style("lineWidth", finalLineWidth).style("transform", transform3).style("stroke", color2).style(toOpacityKey(options), opacity).style(colorAttribute, color2).call(applyStyle, style).node();
  };
};
Color3.props = {
  defaultEnterAnimation: "fadeIn",
  defaultUpdateAnimation: "morphing",
  defaultExitAnimation: "fadeOut"
};

// node_modules/@antv/g2/esm/shape/point/hollowBowtie.js
var HollowBowtie = (options, context) => {
  return Color3(Object.assign({ colorAttribute: "stroke", symbol: "bowtie" }, options), context);
};
HollowBowtie.props = Object.assign({ defaultMarker: "hollowBowtie" }, Color3.props);

// node_modules/@antv/g2/esm/shape/point/hollowDiamond.js
var HollowDiamond = (options, context) => {
  return Color3(Object.assign({ colorAttribute: "stroke", symbol: "diamond" }, options), context);
};
HollowDiamond.props = Object.assign({ defaultMarker: "hollowDiamond" }, Color3.props);

// node_modules/@antv/g2/esm/shape/point/hollowHexagon.js
var HollowHexagon = (options, context) => {
  return Color3(Object.assign({ colorAttribute: "stroke", symbol: "hexagon" }, options), context);
};
HollowHexagon.props = Object.assign({ defaultMarker: "hollowHexagon" }, Color3.props);

// node_modules/@antv/g2/esm/shape/point/hollow.js
var HollowPoint = (options, context) => {
  return Color3(Object.assign({ colorAttribute: "stroke", symbol: "point" }, options), context);
};
HollowPoint.props = Object.assign({ defaultMarker: "hollowPoint" }, Color3.props);

// node_modules/@antv/g2/esm/shape/point/hollowSquare.js
var HollowSquare = (options, context) => {
  return Color3(Object.assign({ colorAttribute: "stroke", symbol: "square" }, options), context);
};
HollowSquare.props = Object.assign({ defaultMarker: "hollowSquare" }, Color3.props);

// node_modules/@antv/g2/esm/shape/point/hollowTriangle.js
var HollowTriangle = (options, context) => {
  return Color3(Object.assign({ colorAttribute: "stroke", symbol: "triangle" }, options), context);
};
HollowTriangle.props = Object.assign({ defaultMarker: "hollowTriangle" }, Color3.props);

// node_modules/@antv/g2/esm/shape/point/hollowTriangleDown.js
var HollowTriangleDown = (options, context) => {
  return Color3(Object.assign({ colorAttribute: "stroke", symbol: "triangle-down" }, options), context);
};
HollowTriangleDown.props = Object.assign({ defaultMarker: "hollowTriangleDown" }, Color3.props);

// node_modules/@antv/g2/esm/shape/point/bowtie.js
var Bowtie = (options, context) => {
  return Color3(Object.assign({ colorAttribute: "fill", symbol: "bowtie" }, options), context);
};
Bowtie.props = Object.assign({ defaultMarker: "bowtie" }, Color3.props);

// node_modules/@antv/g2/esm/shape/point/cross.js
var Cross = (options, context) => {
  return Color3(Object.assign({ colorAttribute: "stroke", symbol: "cross" }, options), context);
};
Cross.props = Object.assign({ defaultMarker: "cross" }, Color3.props);

// node_modules/@antv/g2/esm/shape/point/diamond.js
var Diamond = (options, context) => {
  return Color3(Object.assign({ colorAttribute: "fill", symbol: "diamond" }, options), context);
};
Diamond.props = Object.assign({ defaultMarker: "diamond" }, Color3.props);

// node_modules/@antv/g2/esm/shape/point/hexagon.js
var Hexagon = (options, context) => {
  return Color3(Object.assign({ colorAttribute: "fill", symbol: "hexagon" }, options), context);
};
Hexagon.props = Object.assign({ defaultMarker: "hexagon" }, Color3.props);

// node_modules/@antv/g2/esm/shape/point/hyphen.js
var Hyphen = (options, context) => {
  return Color3(Object.assign({ colorAttribute: "stroke", symbol: "hyphen" }, options), context);
};
Hyphen.props = Object.assign({ defaultMarker: "hyphen" }, Color3.props);

// node_modules/@antv/g2/esm/shape/point/line.js
var Line3 = (options, context) => {
  return Color3(Object.assign({ colorAttribute: "stroke", symbol: "line" }, options), context);
};
Line3.props = Object.assign({ defaultMarker: "line" }, Color3.props);

// node_modules/@antv/g2/esm/shape/point/plus.js
var Plus = (options, context) => {
  return Color3(Object.assign({ colorAttribute: "stroke", symbol: "plus" }, options), context);
};
Plus.props = Object.assign({ defaultMarker: "plus" }, Color3.props);

// node_modules/@antv/g2/esm/shape/point/point.js
var Point3 = (options, context) => {
  return Color3(Object.assign({ colorAttribute: "fill", symbol: "point" }, options), context);
};
Point3.props = Object.assign({ defaultMarker: "point" }, Color3.props);

// node_modules/@antv/g2/esm/shape/point/square.js
var Square = (options, context) => {
  return Color3(Object.assign({ colorAttribute: "fill", symbol: "square" }, options), context);
};
Square.props = Object.assign({ defaultMarker: "square" }, Color3.props);

// node_modules/@antv/g2/esm/shape/point/tick.js
var Tick = (options, context) => {
  return Color3(Object.assign({ colorAttribute: "stroke", symbol: "tick" }, options), context);
};
Tick.props = Object.assign({ defaultMarker: "tick" }, Color3.props);

// node_modules/@antv/g2/esm/shape/point/triangle.js
var Triangle = (options, context) => {
  return Color3(Object.assign({ colorAttribute: "fill", symbol: "triangle" }, options), context);
};
Triangle.props = Object.assign({ defaultMarker: "triangle" }, Color3.props);

// node_modules/@antv/g2/esm/shape/point/triangleDown.js
var TriangleDown = (options, context) => {
  return Color3(Object.assign({ colorAttribute: "fill", symbol: "triangle-down" }, options), context);
};
TriangleDown.props = Object.assign({ defaultMarker: "triangleDown" }, Color3.props);

// node_modules/@antv/g2/esm/shape/vector/vector.js
var __rest20 = function(s2, e) {
  var t = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
      t[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t[p2[i]] = s2[p2[i]];
    }
  return t;
};
var Vector = (options, context) => {
  const { arrow: arrow2 = true, arrowSize = "40%" } = options, style = __rest20(options, ["arrow", "arrowSize"]);
  const { document: document2 } = context;
  return (points, value2, defaults5) => {
    const { defaultColor } = defaults5, rest2 = __rest20(defaults5, ["defaultColor"]);
    const { color: color2 = defaultColor, transform: transform3 } = value2;
    const [from, to] = points;
    const path2 = path();
    path2.moveTo(...from);
    path2.lineTo(...to);
    if (arrow2) {
      const [arrow1, arrow22] = arrowPoints(from, to, { arrowSize });
      path2.moveTo(...to);
      path2.lineTo(...arrow1);
      path2.moveTo(...to);
      path2.lineTo(...arrow22);
    }
    return select(document2.createElement("path", {})).call(applyStyle, rest2).style("d", path2.toString()).style("stroke", color2).style("transform", transform3).call(applyStyle, style).node();
  };
};
Vector.props = {
  defaultMarker: "line",
  defaultEnterAnimation: "fadeIn",
  defaultUpdateAnimation: "morphing",
  defaultExitAnimation: "fadeOut"
};

// node_modules/@antv/component/esm/util/traverse.js
function traverse(element, callback) {
  callback(element);
  if (element.children) {
    element.children.forEach(function(child) {
      if (child)
        traverse(child, callback);
    });
  }
}

// node_modules/@antv/component/esm/util/visibility.js
function show(element) {
  visibility(element, true);
}
function hide(element) {
  visibility(element, false);
}
function visibility(element, visible) {
  var value2 = visible ? "visible" : "hidden";
  traverse(element, function(node) {
    node.attr("visibility", value2);
  });
}

// node_modules/@antv/component/esm/util/offscreen.js
var OffscreenGroup = (
  /** @class */
  function(_super) {
    __extends(OffscreenGroup2, _super);
    function OffscreenGroup2() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      var _this2 = _super.apply(this, __spreadArray([], __read(args), false)) || this;
      _this2.addEventListener(ElementEvent.INSERTED, function() {
        hide(_this2);
      });
      return _this2;
    }
    return OffscreenGroup2;
  }(Group2)
);
function createOffscreenGroup(container) {
  var group3 = container.appendChild(new OffscreenGroup({
    class: "offscreen"
  }));
  hide(group3);
  return group3;
}
function isInOffscreenGroup(group3) {
  var ancestor = group3;
  while (ancestor) {
    if (ancestor.className === "offscreen") {
      return true;
    }
    ancestor = ancestor.parent;
  }
  return false;
}

// node_modules/@antv/component/esm/shapes/Text.js
var Text2 = (
  /** @class */
  function(_super) {
    __extends(Text6, _super);
    function Text6(_a2) {
      if (_a2 === void 0) {
        _a2 = {};
      }
      var style = _a2.style, restOptions = __rest(_a2, ["style"]);
      return _super.call(this, __assign({ style: __assign({ text: "", fill: "black", fontFamily: "sans-serif", fontSize: 16, fontStyle: "normal", fontVariant: "normal", fontWeight: "normal", lineWidth: 1, textAlign: "start", textBaseline: "middle" }, style) }, restOptions)) || this;
    }
    Object.defineProperty(Text6.prototype, "offscreenGroup", {
      get: function() {
        if (!this._offscreen)
          this._offscreen = createOffscreenGroup(this);
        return this._offscreen;
      },
      enumerable: false,
      configurable: true
    });
    Text6.prototype.disconnectedCallback = function() {
      var _a2;
      (_a2 = this._offscreen) === null || _a2 === void 0 ? void 0 : _a2.destroy();
    };
    return Text6;
  }(Text)
);

// node_modules/@antv/component/esm/util/angle-converter.js
function degToRad(deg) {
  return deg * Math.PI / 180;
}
function radToDeg(rad) {
  return Number((rad * 180 / Math.PI).toPrecision(5));
}

// node_modules/@antv/component/esm/util/bbox.js
var BBox = (
  /** @class */
  function() {
    function BBox2(x3, y3, width, height) {
      if (x3 === void 0) {
        x3 = 0;
      }
      if (y3 === void 0) {
        y3 = 0;
      }
      if (width === void 0) {
        width = 0;
      }
      if (height === void 0) {
        height = 0;
      }
      this.x = 0;
      this.y = 0;
      this.width = 0;
      this.height = 0;
      this.x = x3;
      this.y = y3;
      this.width = width;
      this.height = height;
    }
    Object.defineProperty(BBox2.prototype, "bottom", {
      get: function() {
        return this.y + this.height;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(BBox2.prototype, "left", {
      get: function() {
        return this.x;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(BBox2.prototype, "right", {
      get: function() {
        return this.x + this.width;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(BBox2.prototype, "top", {
      get: function() {
        return this.y;
      },
      enumerable: false,
      configurable: true
    });
    BBox2.fromRect = function(other) {
      return new BBox2(other.x, other.y, other.width, other.height);
    };
    BBox2.prototype.toJSON = function() {
      return {
        x: this.x,
        y: this.y,
        width: this.width,
        height: this.height,
        top: this.top,
        right: this.right,
        bottom: this.bottom,
        left: this.left
      };
    };
    BBox2.prototype.isPointIn = function(x3, y3) {
      return x3 >= this.left && x3 <= this.right && y3 >= this.top && y3 <= this.bottom;
    };
    return BBox2;
  }()
);

// node_modules/@antv/component/esm/util/callback.js
function getCallbackValue(value2, params) {
  return is_function_default(value2) ? value2.apply(void 0, __spreadArray([], __read(params), false)) : value2;
}

// node_modules/@antv/component/esm/util/classnames.js
var classNames = function(cls, prefix) {
  var PREFIX = function(str7) {
    return "".concat(prefix, "-").concat(str7);
  };
  var obj = Object.fromEntries(Object.entries(cls).map(function(_a2) {
    var _b = __read(_a2, 2), k2 = _b[0], v = _b[1];
    var name2 = PREFIX(v);
    return [
      k2,
      {
        name: name2,
        class: ".".concat(name2),
        id: "#".concat(name2),
        toString: function() {
          return name2;
        }
      }
    ];
  }));
  Object.assign(obj, { prefix: PREFIX });
  return obj;
};

// node_modules/@antv/component/esm/util/deep-assign.js
var MAX_MIX_LEVEL3 = 5;
var deep = function(dist5, src, level, maxLevel) {
  if (level === void 0) {
    level = 0;
  }
  if (maxLevel === void 0) {
    maxLevel = MAX_MIX_LEVEL3;
  }
  Object.entries(src).forEach(function(_a2) {
    var _b = __read(_a2, 2), key = _b[0], value2 = _b[1];
    var res = dist5;
    if (Object.prototype.hasOwnProperty.call(src, key)) {
      if (!value2) {
        res[key] = value2;
      } else if (is_plain_object_default(value2)) {
        if (!is_plain_object_default(dist5[key])) {
          res[key] = {};
        }
        if (level < maxLevel) {
          deep(dist5[key], value2, level + 1, maxLevel);
        } else {
          res[key] = src[key];
        }
      } else if (is_array_default(value2)) {
        res[key] = [];
        res[key] = res[key].concat(value2);
      } else {
        res[key] = value2;
      }
    }
  });
};
var deepAssign2 = function(rst) {
  var args = [];
  for (var _i = 1; _i < arguments.length; _i++) {
    args[_i - 1] = arguments[_i];
  }
  for (var i = 0; i < args.length; i += 1) {
    deep(rst, args[i]);
  }
  return rst;
};

// node_modules/@antv/component/esm/util/defined.js
var defined2 = function(x3) {
  return x3 !== void 0 && x3 != null && !Number.isNaN(x3);
};

// node_modules/@antv/component/esm/util/text.js
var ctx2;
var mockMeasureTextWidth;
var measureTextWidth = memoize_default(function(text, font) {
  var fontSize = font.fontSize, fontFamily = font.fontFamily, fontWeight = font.fontWeight, fontStyle = font.fontStyle, fontVariant = font.fontVariant;
  if (mockMeasureTextWidth) {
    return mockMeasureTextWidth(text, fontSize);
  }
  if (!ctx2) {
    ctx2 = runtime.offscreenCanvasCreator.getOrCreateContext(void 0);
  }
  ctx2.font = [fontStyle, fontVariant, fontWeight, "".concat(fontSize, "px"), fontFamily].join(" ");
  return ctx2.measureText(text).width;
}, function(text, font) {
  return [text, Object.values(font || getFont(text)).join()].join("");
}, 4096);
var getFont = function(textShape) {
  var fontFamily = textShape.style.fontFamily || "sans-serif";
  var fontWeight = textShape.style.fontWeight || "normal";
  var fontStyle = textShape.style.fontStyle || "normal";
  var fontVariant = textShape.style.fontVariant;
  var fontSize = textShape.style.fontSize;
  fontSize = typeof fontSize === "object" ? fontSize.value : fontSize;
  return { fontSize, fontFamily, fontWeight, fontStyle, fontVariant };
};
function textOf(node) {
  if (node.nodeName === "text") {
    return node;
  }
  if (node.nodeName === "g" && node.children.length === 1 && node.children[0].nodeName === "text") {
    return node.children[0];
  }
  return null;
}
function applyToText(node, style) {
  var text = textOf(node);
  if (text)
    text.attr(style);
}

// node_modules/@antv/component/esm/util/ellipsis.js
function ellipsisIt(node, w, suffix) {
  if (suffix === void 0) {
    suffix = "...";
  }
  applyToText(node, { wordWrap: true, wordWrapWidth: w, maxLines: 1, textOverflow: suffix });
}

// node_modules/@antv/component/esm/util/wrap.js
function wrapIt(node, wordWrapWidth, maxLines, textBaseline) {
  if (maxLines === void 0) {
    maxLines = 2;
  }
  if (textBaseline === void 0) {
    textBaseline = "top";
  }
  applyToText(node, { wordWrap: true, wordWrapWidth, maxLines, textBaseline });
}

// node_modules/@antv/component/esm/util/event.js
function getEventPos(e) {
  var canvas = e.canvas, touches = e.touches, offsetX = e.offsetX, offsetY = e.offsetY;
  if (canvas) {
    var x3 = canvas.x, y3 = canvas.y;
    return [x3, y3];
  }
  if (touches) {
    var _a2 = touches[0], clientX = _a2.clientX, clientY = _a2.clientY;
    return [clientX, clientY];
  }
  if (offsetX && offsetY)
    return [offsetX, offsetY];
  return [0, 0];
}

// node_modules/@antv/component/esm/util/extend-display-object.js
function renderExtDo(el) {
  if (typeof el === "function")
    return el();
  return is_string_default(el) || is_number_default(el) ? new Text2({ style: { text: String(el) } }) : el;
}

// node_modules/@antv/component/esm/util/geometry/lines-intersection.js
function inside(x12, x22, y12, y22, xk, yk) {
  return (x12 === x22 || Math.min(x12, x22) <= xk && xk <= Math.max(x12, x22)) && (y12 === y22 || Math.min(y12, y22) <= yk && yk <= Math.max(y12, y22));
}
function update(ans, x3, y3) {
  var out = ans;
  if (!ans.length || x3 < ans[0] || x3 === ans[0] && y3 < ans[1]) {
    out[0] = x3;
    out[1] = y3;
  }
}
function intersection2(_a2, _b, _c, _d) {
  var _e = __read(_a2, 2), x12 = _e[0], y12 = _e[1];
  var _f = __read(_b, 2), x22 = _f[0], y22 = _f[1];
  var _g = __read(_c, 2), x3 = _g[0], y3 = _g[1];
  var _h = __read(_d, 2), x4 = _h[0], y4 = _h[1];
  var ans = [];
  if ((y4 - y3) * (x22 - x12) === (y22 - y12) * (x4 - x3)) {
    if ((y22 - y12) * (x3 - x12) === (y3 - y12) * (x22 - x12)) {
      if (inside(x12, x22, y12, y22, x3, y3)) {
        update(ans, x3, y3);
      }
      if (inside(x12, x22, y12, y22, x4, y4)) {
        update(ans, x4, y4);
      }
      if (inside(x3, x4, y3, y4, x12, y12)) {
        update(ans, x12, y12);
      }
      if (inside(x3, x4, y3, y4, x22, y22)) {
        update(ans, x22, y22);
      }
    }
  } else {
    var t12 = (x3 * (y4 - y3) + y12 * (x4 - x3) - y3 * (x4 - x3) - x12 * (y4 - y3)) / ((x22 - x12) * (y4 - y3) - (x4 - x3) * (y22 - y12));
    var t22 = (x12 * (y22 - y12) + y3 * (x22 - x12) - y12 * (x22 - x12) - x3 * (y22 - y12)) / ((x4 - x3) * (y22 - y12) - (x22 - x12) * (y4 - y3));
    if (t12 >= 0 && t12 <= 1 && t22 >= 0 && t22 <= 1) {
      ans[0] = x12 + t12 * (x22 - x12);
      ans[1] = y12 + t12 * (y22 - y12);
    }
  }
  return ans;
}

// node_modules/@antv/component/esm/util/geometry/line-length.js
function lineLen(_a2, _b) {
  var _c = __read(_a2, 2), x12 = _c[0], y12 = _c[1];
  var _d = __read(_b, 2), x22 = _d[0], y22 = _d[1];
  return Math.pow(Math.pow(x12 - x22, 2) + Math.pow(y12 - y22, 2), 0.5);
}

// node_modules/@antv/component/esm/util/group-by.js
function groupBy(source, by) {
  return source.reduce(function(acc, curr) {
    (acc[curr[by]] = acc[curr[by]] || []).push(curr);
    return acc;
  }, {});
}

// node_modules/@antv/component/esm/util/if-show.js
function ifShow(show3, container, creator, removeChildren, removeHandler) {
  if (removeChildren === void 0) {
    removeChildren = true;
  }
  if (removeHandler === void 0) {
    removeHandler = function(g) {
      g.node().removeChildren();
    };
  }
  if (show3) {
    return creator(container);
  }
  if (removeChildren)
    removeHandler(container);
  return null;
}

// node_modules/@antv/component/esm/util/in-range.js
function inRange(n, start, end, includeLeft, includeRight) {
  if (includeLeft === void 0) {
    includeLeft = true;
  }
  if (includeRight === void 0) {
    includeRight = false;
  }
  if (includeLeft && n === start || includeRight && n === end)
    return true;
  return n > start && n < end;
}

// node_modules/@antv/component/esm/util/interpolate.js
var numberInterpolate = function(from, to) {
  return function(t) {
    return from * (1 - t) + to * t;
  };
};
function arrayInterpolate(from, to) {
  var nb = to ? to.length : 0;
  var na = from ? Math.min(nb, from.length) : 0;
  return function(t) {
    var x3 = new Array(na);
    var c5 = new Array(nb);
    var i = 0;
    for (i = 0; i < na; ++i)
      x3[i] = interpolate3(from[i], to[i]);
    for (; i < nb; ++i)
      c5[i] = to[i];
    for (i = 0; i < na; ++i)
      c5[i] = x3[i](t);
    return c5;
  };
}
function objectInterpolate(from, to) {
  if (from === void 0) {
    from = {};
  }
  if (to === void 0) {
    to = {};
  }
  var i = {};
  var c5 = {};
  Object.entries(to).forEach(function(_a2) {
    var _b = __read(_a2, 2), k2 = _b[0], v = _b[1];
    if (k2 in from)
      i[k2] = interpolate3(from[k2], v);
    else
      c5[k2] = v;
  });
  return function(t) {
    Object.entries(i).forEach(function(_a2) {
      var _b = __read(_a2, 2), k2 = _b[0], v = _b[1];
      return c5[k2] = v(t);
    });
    return c5;
  };
}
function interpolate3(from, to) {
  if (typeof from === "number" && typeof to === "number") {
    return numberInterpolate(from, to);
  }
  if (Array.isArray(from) && Array.isArray(to)) {
    return arrayInterpolate(from, to);
  }
  if (typeof from === "object" && typeof to === "object") {
    return objectInterpolate(from, to);
  }
  return function(t) {
    return from;
  };
}

// node_modules/@antv/component/esm/util/keyframe-interpolate.js
function keyframeInterpolate(element, from, to, options) {
  if (!options) {
    element.attr("__keyframe_data__", to);
    return null;
  }
  var _a2 = options.duration, duration = _a2 === void 0 ? 0 : _a2;
  var int = interpolate3(from, to);
  var count4 = Math.ceil(+duration / 16);
  var keyframes = new Array(count4).fill(0).map(function(datum, index3, array2) {
    return { __keyframe_data__: int(index3 / (array2.length - 1)) };
  });
  return element.animate(keyframes, __assign({ fill: "both" }, options));
}

// node_modules/@antv/component/esm/util/layout/utils/helper.js
function getItemsBBox(items) {
  var minX = Infinity;
  var minY = Infinity;
  var maxX = -Infinity;
  var maxY2 = -Infinity;
  for (var i = 0; i < items.length; i++) {
    var _a2 = items[i], x3 = _a2.x, y3 = _a2.y, width = _a2.width, height = _a2.height;
    var _b = __read([x3 + width, y3 + height], 2), X = _b[0], Y = _b[1];
    if (x3 < minX)
      minX = x3;
    if (y3 < minY)
      minY = y3;
    if (X > maxX)
      maxX = X;
    if (Y > maxY2)
      maxY2 = Y;
  }
  return new BBox(minX, minY, maxX - minX, maxY2 - minY);
}

// node_modules/@antv/component/esm/util/layout/flex/index.js
var flex = function(container, children, config) {
  var width = container.width, height = container.height;
  var _a2 = config.flexDirection, flexDirection = _a2 === void 0 ? "row" : _a2, _b = config.flexWrap, flexWrap = _b === void 0 ? "nowrap" : _b, _c = config.justifyContent, justifyContent = _c === void 0 ? "flex-start" : _c, _d = config.alignContent, alignContent = _d === void 0 ? "flex-start" : _d, _e = config.alignItems, alignItems = _e === void 0 ? "flex-start" : _e;
  var isHorizontalFlow = flexDirection === "row";
  var isLeftToRightFlow = flexDirection === "row" || flexDirection === "column";
  var direction3 = isHorizontalFlow ? isLeftToRightFlow ? [1, 0] : [-1, 0] : isLeftToRightFlow ? [0, 1] : [0, -1];
  var _f = __read([0, 0], 2), offsetX = _f[0], offsetY = _f[1];
  var itemsFromDirection = children.map(function(child) {
    var _a3;
    var width2 = child.width, height2 = child.height;
    var _b2 = __read([offsetX, offsetY], 2), x3 = _b2[0], y3 = _b2[1];
    _a3 = __read([offsetX + width2 * direction3[0], offsetY + height2 * direction3[1]], 2), offsetX = _a3[0], offsetY = _a3[1];
    return new BBox(x3, y3, width2, height2);
  });
  var itemsForJustifyContentBBox = getItemsBBox(itemsFromDirection);
  var justifyContentOffset = {
    "flex-start": 0,
    "flex-end": isHorizontalFlow ? width - itemsForJustifyContentBBox.width : height - itemsForJustifyContentBBox.height,
    center: isHorizontalFlow ? (width - itemsForJustifyContentBBox.width) / 2 : (height - itemsForJustifyContentBBox.height) / 2
  };
  var itemsFromJustifyContent = itemsFromDirection.map(function(item) {
    var x3 = item.x, y3 = item.y;
    var itemBox = BBox.fromRect(item);
    itemBox.x = isHorizontalFlow ? x3 + justifyContentOffset[justifyContent] : x3;
    itemBox.y = isHorizontalFlow ? y3 : y3 + justifyContentOffset[justifyContent];
    return itemBox;
  });
  var itemsForAlignItemsBBox = getItemsBBox(itemsFromJustifyContent);
  var calcAlignItemsOffset = function(box2) {
    var _a3 = __read(isHorizontalFlow ? ["height", height] : ["width", width], 2), key = _a3[0], size5 = _a3[1];
    switch (alignItems) {
      case "flex-start":
        return 0;
      case "flex-end":
        return size5 - box2[key];
      case "center":
        return size5 / 2 - box2[key] / 2;
      default:
        return 0;
    }
  };
  var itemsFromAlignItems = itemsFromJustifyContent.map(function(item) {
    var x3 = item.x, y3 = item.y;
    var itemBox = BBox.fromRect(item);
    itemBox.x = isHorizontalFlow ? x3 : x3 + calcAlignItemsOffset(itemBox);
    itemBox.y = isHorizontalFlow ? y3 + calcAlignItemsOffset(itemBox) : y3;
    return itemBox;
  });
  var finalItems = itemsFromAlignItems.map(function(item) {
    var _a3, _b2;
    var itemBox = BBox.fromRect(item);
    itemBox.x += (_a3 = container.x) !== null && _a3 !== void 0 ? _a3 : 0;
    itemBox.y += (_b2 = container.y) !== null && _b2 !== void 0 ? _b2 : 0;
    return itemBox;
  });
  return finalItems;
};

// node_modules/@antv/component/esm/util/layout/grid/index.js
var grid = function(container, children, config) {
  return [];
};

// node_modules/@antv/component/esm/util/layout/executer.js
var executer_default = function(container, children, config) {
  if (children.length === 0)
    return [];
  var callers = { flex, grid };
  var caller = config.display in callers ? callers[config.display] : null;
  return (caller === null || caller === void 0 ? void 0 : caller.call(null, container, children, config)) || [];
};

// node_modules/@antv/component/esm/util/matrix.js
function scale7(vec, s2) {
  return [vec[0] * s2, vec[1] * s2];
}
function add8(vec1, vec2) {
  return [vec1[0] + vec2[0], vec1[1] + vec2[1]];
}
function sub7(vec1, vec2) {
  return [vec1[0] - vec2[0], vec1[1] - vec2[1]];
}
function min8(vec1, vec2) {
  return [Math.min(vec1[0], vec2[0]), Math.min(vec1[1], vec2[1])];
}
function max8(vec1, vec2) {
  return [Math.max(vec1[0], vec2[0]), Math.max(vec1[1], vec2[1])];
}
function distance5(vec1, vec2) {
  return Math.sqrt(Math.pow(vec1[0] - vec2[0], 2) + Math.pow(vec1[1] - vec2[1], 2));
}
function normalize7(vec) {
  if (vec[0] === 0 && vec[1] === 0)
    return [0, 0];
  var len5 = Math.sqrt(Math.pow(vec[0], 2) + Math.pow(vec[1], 2));
  return [vec[0] / len5, vec[1] / len5];
}
function rotate4(vec, origin, angle4) {
  var _a2 = __read(vec, 2), x3 = _a2[0], y3 = _a2[1];
  var _b = __read(origin, 2), ox = _b[0], oy = _b[1];
  var dx = x3 - ox;
  var dy = y3 - oy;
  var sin3 = Math.sin(angle4);
  var cos4 = Math.cos(angle4);
  return [dx * cos4 - dy * sin3 + ox, dx * sin3 + dy * cos4 + oy];
}
function vertical2(vec, flag) {
  return flag ? [vec[1], -vec[0]] : [-vec[1], vec[0]];
}

// node_modules/@antv/component/esm/util/number.js
function toPrecision(num, precision) {
  return +num.toPrecision(precision);
}

// node_modules/@antv/component/esm/util/omit.js
function omit(obj, keys3) {
  var res = {};
  var innerKeys = Array.isArray(keys3) ? keys3 : [keys3];
  for (var key in obj) {
    if (!innerKeys.includes(key)) {
      res[key] = obj[key];
    }
  }
  return res;
}

// node_modules/@antv/component/esm/util/path.js
function smoothBezier(points, smooth3, isLoop, constraint) {
  var _a2;
  var cps = [];
  var hasConstraint = !!constraint;
  var prevPoint;
  var nextPoint;
  var min11 = [Infinity, Infinity];
  var max11 = [-Infinity, -Infinity];
  var nextCp0;
  var cp1;
  var cp0;
  if (hasConstraint) {
    _a2 = __read(constraint, 2), min11 = _a2[0], max11 = _a2[1];
    for (var i = 0, l = points.length; i < l; i += 1) {
      var point7 = points[i];
      min11 = min8(min11, point7);
      max11 = max8(max11, point7);
    }
  }
  for (var i = 0, len5 = points.length; i < len5; i += 1) {
    var point7 = points[i];
    if (i === 0 && !isLoop) {
      cp0 = point7;
    } else if (i === len5 - 1 && !isLoop) {
      cp1 = point7;
      cps.push(cp0);
      cps.push(cp1);
    } else {
      var prevIdx = [i ? i - 1 : len5 - 1, i - 1][isLoop ? 0 : 1];
      prevPoint = points[prevIdx];
      nextPoint = points[isLoop ? (i + 1) % len5 : i + 1];
      var v = [0, 0];
      v = sub7(nextPoint, prevPoint);
      v = scale7(v, smooth3);
      var d0 = distance5(point7, prevPoint);
      var d1 = distance5(point7, nextPoint);
      var sum5 = d0 + d1;
      if (sum5 !== 0) {
        d0 /= sum5;
        d1 /= sum5;
      }
      var v1 = scale7(v, -d0);
      var v2 = scale7(v, d1);
      cp1 = add8(point7, v1);
      nextCp0 = add8(point7, v2);
      nextCp0 = min8(nextCp0, max8(nextPoint, point7));
      nextCp0 = max8(nextCp0, min8(nextPoint, point7));
      v1 = sub7(nextCp0, point7);
      v1 = scale7(v1, -d0 / d1);
      cp1 = add8(point7, v1);
      cp1 = min8(cp1, max8(prevPoint, point7));
      cp1 = max8(cp1, min8(prevPoint, point7));
      v2 = sub7(point7, cp1);
      v2 = scale7(v2, d1 / d0);
      nextCp0 = add8(point7, v2);
      if (hasConstraint) {
        cp1 = max8(cp1, min11);
        cp1 = min8(cp1, max11);
        nextCp0 = max8(nextCp0, min11);
        nextCp0 = min8(nextCp0, max11);
      }
      cps.push(cp0);
      cps.push(cp1);
      cp0 = nextCp0;
    }
  }
  if (isLoop) {
    cps.push(cps.shift());
  }
  return cps;
}
function catmullRom2Bezier(crp, z, constraint) {
  var _a2;
  if (z === void 0) {
    z = false;
  }
  if (constraint === void 0) {
    constraint = [
      [0, 0],
      [1, 1]
    ];
  }
  var isLoop = !!z;
  var pointList = [];
  for (var i = 0, l = crp.length; i < l; i += 2) {
    pointList.push([crp[i], crp[i + 1]]);
  }
  var controlPointList = smoothBezier(pointList, 0.4, isLoop, constraint);
  var len5 = pointList.length;
  var d1 = [];
  var cp1;
  var cp2;
  var p2;
  for (var i = 0; i < len5 - 1; i += 1) {
    cp1 = controlPointList[i * 2];
    cp2 = controlPointList[i * 2 + 1];
    p2 = pointList[i + 1];
    d1.push(["C", cp1[0], cp1[1], cp2[0], cp2[1], p2[0], p2[1]]);
  }
  if (isLoop) {
    cp1 = controlPointList[len5];
    cp2 = controlPointList[len5 + 1];
    _a2 = __read(pointList, 1), p2 = _a2[0];
    d1.push(["C", cp1[0], cp1[1], cp2[0], cp2[1], p2[0], p2[1]]);
  }
  return d1;
}

// node_modules/@antv/component/esm/util/primitive.js
var PRIMILTIVE_ATTRIBUTES = [
  "$el",
  "anchor",
  "cx",
  "cy",
  "d",
  "defX",
  "defY",
  "dx",
  "dy",
  "fill",
  "fillOpacity",
  "filter",
  "fontFamily",
  "fontSize",
  "fontStyle",
  "fontVariant",
  "fontWeight",
  "height",
  "img",
  "increasedLineWidthForHitTesting",
  "innerHTML",
  "isBillboard",
  "billboardRotation",
  "isSizeAttenuation",
  "isClosed",
  "isOverflowing",
  "leading",
  "letterSpacing",
  "lineDash",
  "lineHeight",
  "lineWidth",
  "markerEnd",
  "markerEndOffset",
  "markerMid",
  "markerStart",
  "markerStartOffset",
  "maxLines",
  "metrics",
  "miterLimit",
  "offsetX",
  "offsetY",
  "opacity",
  "path",
  "points",
  "r",
  "radius",
  "rx",
  "ry",
  "shadowColor",
  "src",
  "stroke",
  "strokeOpacity",
  "text",
  "textAlign",
  "textBaseline",
  "textDecorationColor",
  "textDecorationLine",
  "textDecorationStyle",
  "textOverflow",
  "textPath",
  "textPathSide",
  "textPathStartOffset",
  "transform",
  "transformOrigin",
  "visibility",
  "width",
  "wordWrap",
  "wordWrapWidth",
  "x",
  "x1",
  "x2",
  "y",
  "y1",
  "y2",
  "z1",
  "z2",
  "zIndex"
];
function isPrimitiveAttribute(key) {
  return PRIMILTIVE_ATTRIBUTES.includes(key);
}
function getPrimitiveAttributes(attributes) {
  var object = {};
  for (var key in attributes) {
    if (isPrimitiveAttribute(key))
      object[key] = attributes[key];
  }
  return object;
}

// node_modules/@antv/component/esm/util/sampling.js
function sampling(data2, size5) {
  if (data2.length <= size5)
    return data2;
  var step2 = Math.floor(data2.length / size5);
  var result2 = [];
  for (var i = 0; i < data2.length; i += step2) {
    result2.push(data2[i]);
  }
  return result2;
}

// node_modules/@antv/component/esm/util/scale-to-pixel.js
function scaleToPixel(el, size5, applyScale2) {
  if (applyScale2 === void 0) {
    applyScale2 = false;
  }
  var _a2 = el.getBBox(), width = _a2.width, height = _a2.height;
  var scale10 = size5 / Math.max(width, height);
  if (applyScale2)
    el.scale(scale10);
  return scale10;
}

// node_modules/@antv/component/esm/util/group.js
function group2(array2, keyFunc) {
  var grouped = /* @__PURE__ */ new Map();
  array2.forEach(function(item) {
    var key = keyFunc(item);
    if (!grouped.has(key)) {
      grouped.set(key, []);
    }
    grouped.get(key).push(item);
  });
  return grouped;
}

// node_modules/@antv/component/esm/util/selection.js
function error2(msg) {
  throw new Error(msg);
}
var Selection2 = (
  /** @class */
  function() {
    function Selection3(elements, data2, parent2, document2, selections, transitions, updateElements) {
      if (elements === void 0) {
        elements = null;
      }
      if (data2 === void 0) {
        data2 = null;
      }
      if (parent2 === void 0) {
        parent2 = null;
      }
      if (document2 === void 0) {
        document2 = null;
      }
      if (selections === void 0) {
        selections = [null, null, null, null, null];
      }
      if (transitions === void 0) {
        transitions = [];
      }
      if (updateElements === void 0) {
        updateElements = [];
      }
      _Selection_instances.add(this);
      this._elements = Array.from(elements);
      this._data = data2;
      this._parent = parent2;
      this._document = document2;
      this._enter = selections[0];
      this._update = selections[1];
      this._exit = selections[2];
      this._merge = selections[3];
      this._split = selections[4];
      this._transitions = transitions;
      this._facetElements = updateElements;
    }
    Selection3.prototype.selectAll = function(selector) {
      var elements = typeof selector === "string" ? this._parent.querySelectorAll(selector) : selector;
      return new _a2(elements, null, this._elements[0], this._document);
    };
    Selection3.prototype.selectFacetAll = function(selector) {
      var elements = typeof selector === "string" ? this._parent.querySelectorAll(selector) : selector;
      return new _a2(this._elements, null, this._parent, this._document, void 0, void 0, elements);
    };
    Selection3.prototype.select = function(selector) {
      var element = typeof selector === "string" ? this._parent.querySelectorAll(selector)[0] || null : selector;
      return new _a2([element], null, element, this._document);
    };
    Selection3.prototype.append = function(node) {
      var _this2 = this;
      var callback = typeof node === "function" ? node : function() {
        return _this2.createElement(node);
      };
      var elements = [];
      if (this._data !== null) {
        for (var i = 0; i < this._data.length; i++) {
          var d2 = this._data[i];
          var _b = __read(Array.isArray(d2) ? d2 : [d2, null], 2), datum = _b[0], from = _b[1];
          var newElement = callback(datum, i);
          newElement.__data__ = datum;
          if (from !== null)
            newElement.__fromElements__ = from;
          this._parent.appendChild(newElement);
          elements.push(newElement);
        }
        return new _a2(elements, null, this._parent, this._document);
      }
      for (var i = 0; i < this._elements.length; i++) {
        var element = this._elements[i];
        var datum = element.__data__;
        var newElement = callback(datum, i);
        element.appendChild(newElement);
        elements.push(newElement);
      }
      return new _a2(elements, null, elements[0], this._document);
    };
    Selection3.prototype.maybeAppend = function(id3, node) {
      var element = __classPrivateFieldGet(this, _Selection_instances, "m", _Selection_maybeAppend).call(this, id3[0] === "#" ? id3 : "#".concat(id3), node);
      element.attr("id", id3);
      return element;
    };
    Selection3.prototype.maybeAppendByClassName = function(className2, node) {
      var cls = className2.toString();
      var element = __classPrivateFieldGet(this, _Selection_instances, "m", _Selection_maybeAppend).call(this, cls[0] === "." ? cls : ".".concat(cls), node);
      element.attr("className", cls);
      return element;
    };
    Selection3.prototype.maybeAppendByName = function(name2, node) {
      var element = __classPrivateFieldGet(this, _Selection_instances, "m", _Selection_maybeAppend).call(this, '[name="'.concat(name2, '"]'), node);
      element.attr("name", name2);
      return element;
    };
    Selection3.prototype.data = function(data2, id3, groupId) {
      var e_1, _b;
      if (id3 === void 0) {
        id3 = function(d2) {
          return d2;
        };
      }
      if (groupId === void 0) {
        groupId = function() {
          return null;
        };
      }
      var enter = [];
      var update3 = [];
      var exit = new Set(this._elements);
      var merge3 = [];
      var split2 = /* @__PURE__ */ new Set();
      var keyElement = new Map(this._elements.map(function(d2, i2) {
        return [id3(d2.__data__, i2), d2];
      }));
      var keyUpdateElement = new Map(this._facetElements.map(function(d2, i2) {
        return [id3(d2.__data__, i2), d2];
      }));
      var groupKeyElements = group2(this._elements, function(d2) {
        return groupId(d2.__data__);
      });
      for (var i = 0; i < data2.length; i++) {
        var datum = data2[i];
        var key = id3(datum, i);
        var groupKey = groupId(datum, i);
        if (keyElement.has(key)) {
          var element = keyElement.get(key);
          element.__data__ = datum;
          element.__facet__ = false;
          update3.push(element);
          exit.delete(element);
          keyElement.delete(key);
        } else if (keyUpdateElement.has(key)) {
          var element = keyUpdateElement.get(key);
          element.__data__ = datum;
          element.__facet__ = true;
          update3.push(element);
          keyUpdateElement.delete(key);
        } else if (groupKeyElements.has(key)) {
          var group_2 = groupKeyElements.get(key);
          merge3.push([datum, group_2]);
          try {
            for (var group_1 = (e_1 = void 0, __values(group_2)), group_1_1 = group_1.next(); !group_1_1.done; group_1_1 = group_1.next()) {
              var element = group_1_1.value;
              exit.delete(element);
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (group_1_1 && !group_1_1.done && (_b = group_1.return))
                _b.call(group_1);
            } finally {
              if (e_1)
                throw e_1.error;
            }
          }
          groupKeyElements.delete(key);
        } else if (keyElement.has(groupKey)) {
          var element = keyElement.get(groupKey);
          if (element.__toData__)
            element.__toData__.push(datum);
          else
            element.__toData__ = [datum];
          split2.add(element);
          exit.delete(element);
        } else {
          enter.push(datum);
        }
      }
      var S = [
        new _a2([], enter, this._parent, this._document),
        new _a2(update3, null, this._parent, this._document),
        new _a2(exit, null, this._parent, this._document),
        new _a2([], merge3, this._parent, this._document),
        new _a2(split2, null, this._parent, this._document)
      ];
      return new _a2(this._elements, null, this._parent, this._document, S);
    };
    Selection3.prototype.merge = function(other) {
      var elements = __spreadArray(__spreadArray([], __read(this._elements), false), __read(other._elements), false);
      var transitions = __spreadArray(__spreadArray([], __read(this._transitions), false), __read(other._transitions), false);
      return new _a2(elements, null, this._parent, this._document, void 0, transitions);
    };
    Selection3.prototype.createElement = function(type) {
      if (this._document) {
        return this._document.createElement(type, {});
      }
      var Ctor = _a2.registry[type];
      if (Ctor)
        return new Ctor();
      return error2("Unknown node type: ".concat(type));
    };
    Selection3.prototype.join = function(enter, update3, exit, merge3, split2) {
      if (enter === void 0) {
        enter = function(d2) {
          return d2;
        };
      }
      if (update3 === void 0) {
        update3 = function(d2) {
          return d2;
        };
      }
      if (exit === void 0) {
        exit = function(d2) {
          return d2.remove();
        };
      }
      if (merge3 === void 0) {
        merge3 = function(d2) {
          return d2;
        };
      }
      if (split2 === void 0) {
        split2 = function(d2) {
          return d2.remove();
        };
      }
      var newEnter = enter(this._enter);
      var newUpdate = update3(this._update);
      var newExit = exit(this._exit);
      var newMerge = merge3(this._merge);
      var newSplit = split2(this._split);
      return newUpdate.merge(newEnter).merge(newExit).merge(newMerge).merge(newSplit);
    };
    Selection3.prototype.remove = function() {
      var _loop_1 = function(i2) {
        var element = this_1._elements[i2];
        var transition2 = this_1._transitions[i2];
        if (transition2) {
          transition2.then(function() {
            return element.remove();
          });
        } else {
          element.remove();
        }
      };
      var this_1 = this;
      for (var i = 0; i < this._elements.length; i++) {
        _loop_1(i);
      }
      return new _a2([], null, this._parent, this._document, void 0, this._transitions);
    };
    Selection3.prototype.each = function(callback) {
      for (var i = 0; i < this._elements.length; i++) {
        var element = this._elements[i];
        var datum = element.__data__;
        callback.call(element, datum, i);
      }
      return this;
    };
    Selection3.prototype.attr = function(key, value2) {
      var callback = typeof value2 !== "function" ? function() {
        return value2;
      } : value2;
      return this.each(function(d2, i) {
        if (value2 !== void 0)
          this[key] = callback.call(this, d2, i);
      });
    };
    Selection3.prototype.style = function(key, value2, callable) {
      if (callable === void 0) {
        callable = true;
      }
      var callback = typeof value2 !== "function" || !callable ? function() {
        return value2;
      } : value2;
      return this.each(function(d2, i) {
        if (value2 !== void 0)
          this.style[key] = callback.call(this, d2, i);
      });
    };
    Selection3.prototype.styles = function(style, callable) {
      if (style === void 0) {
        style = {};
      }
      if (callable === void 0) {
        callable = true;
      }
      return this.each(function(d2, i) {
        var _this2 = this;
        Object.entries(style).forEach(function(_b) {
          var _c = __read(_b, 2), key = _c[0], value2 = _c[1];
          var callback = typeof value2 !== "function" || !callable ? function() {
            return value2;
          } : value2;
          if (value2 !== void 0)
            _this2.attr(key, callback.call(_this2, d2, i));
        });
      });
    };
    Selection3.prototype.update = function(option, callable) {
      if (callable === void 0) {
        callable = true;
      }
      var callback = typeof option !== "function" || !callable ? function() {
        return option;
      } : option;
      return this.each(function(d2, i) {
        if (option && this.update)
          this.update(callback.call(this, d2, i));
      });
    };
    Selection3.prototype.maybeUpdate = function(option, callable) {
      if (callable === void 0) {
        callable = true;
      }
      var callback = typeof option !== "function" || !callable ? function() {
        return option;
      } : option;
      return this.each(function(d2, i) {
        if (option && this.update)
          this.update(callback.call(this, d2, i));
      });
    };
    Selection3.prototype.transition = function(callback) {
      var T = this._transitions;
      return this.each(function(d2, i) {
        T[i] = callback.call(this, d2, i);
      });
    };
    Selection3.prototype.on = function(event, handler) {
      this.each(function() {
        this.addEventListener(event, handler);
      });
      return this;
    };
    Selection3.prototype.call = function(callback) {
      var args = [];
      for (var _i = 1; _i < arguments.length; _i++) {
        args[_i - 1] = arguments[_i];
      }
      callback.call.apply(callback, __spreadArray([this._parent, this], __read(args), false));
      return this;
    };
    Selection3.prototype.node = function() {
      return this._elements[0];
    };
    Selection3.prototype.nodes = function() {
      return this._elements;
    };
    Selection3.prototype.transitions = function() {
      return this._transitions.filter(function(t) {
        return !!t;
      });
    };
    Selection3.prototype.parent = function() {
      return this._parent;
    };
    var _Selection_instances, _a2, _Selection_maybeAppend;
    _a2 = Selection3, _Selection_instances = /* @__PURE__ */ new WeakSet(), _Selection_maybeAppend = function _Selection_maybeAppend2(selector, node) {
      var element = this._elements[0];
      var child = element.querySelector(selector);
      if (child)
        return new _a2([child], null, this._parent, this._document);
      var newChild = typeof node === "string" ? this.createElement(node) : node();
      element.appendChild(newChild);
      return new _a2([newChild], null, this._parent, this._document);
    };
    Selection3.registry = {
      g: Group2,
      rect: Rect,
      circle: Circle,
      path: Path2,
      text: Text2,
      ellipse: Ellipse,
      image: Image2,
      line: Line,
      polygon: Polygon,
      polyline: Polyline,
      html: HTML
    };
    return Selection3;
  }()
);
function select2(node) {
  return new Selection2([node], null, node, node.ownerDocument);
}
function maybeAppend(parent2, selector, node) {
  if (!parent2.querySelector(selector)) {
    return select2(parent2).append(node);
  }
  return select2(parent2).select(selector);
}

// node_modules/@antv/component/esm/util/series.js
function parseSeriesAttr(series) {
  if (is_number_default(series)) {
    return [series, series, series, series];
  }
  if (is_array_default(series)) {
    var len5 = series.length;
    if (len5 === 1) {
      return [series[0], series[0], series[0], series[0]];
    }
    if (len5 === 2) {
      return [series[0], series[1], series[0], series[1]];
    }
    if (len5 === 3) {
      return [series[0], series[1], series[2], series[1]];
    }
    if (len5 === 4) {
      return series;
    }
  }
  return [0, 0, 0, 0];
}

// node_modules/@antv/component/esm/util/shape.js
function getShapeSpace(shape23) {
  var bounds = shape23 && shape23.getRenderBounds();
  if (!bounds)
    return {
      width: 0,
      height: 0
    };
  var max11 = bounds.getMax();
  var min11 = bounds.getMin();
  return {
    width: max11[0] - min11[0],
    height: max11[1] - min11[1]
  };
}
function getLocalBBox(shape23) {
  var _a2 = shape23.getLocalBounds(), min11 = _a2.min, max11 = _a2.max;
  var _b = __read([min11, max11], 2), _c = __read(_b[0], 2), x12 = _c[0], y12 = _c[1], _d = __read(_b[1], 2), x22 = _d[0], y22 = _d[1];
  return { x: x12, y: y12, width: x22 - x12, height: y22 - y12, left: x12, bottom: y22, top: y12, right: x22 };
}
function isHorizontal(p1, p2) {
  var _a2 = __read(p1, 2), x12 = _a2[0], y12 = _a2[1];
  var _b = __read(p2, 2), x22 = _b[0], y22 = _b[1];
  return x12 !== x22 && y12 === y22;
}
function copyAttributes2(target, source) {
  var e_1, _a2;
  var attributes = source.attributes;
  try {
    for (var _b = __values(Object.entries(attributes)), _c = _b.next(); !_c.done; _c = _b.next()) {
      var _d = __read(_c.value, 2), key = _d[0], value2 = _d[1];
      if (key !== "id" && key !== "className")
        target.attr(key, value2);
    }
  } catch (e_1_1) {
    e_1 = { error: e_1_1 };
  } finally {
    try {
      if (_c && !_c.done && (_a2 = _b.return))
        _a2.call(_b);
    } finally {
      if (e_1)
        throw e_1.error;
    }
  }
}

// node_modules/@antv/component/esm/util/string.js
function toUppercaseFirstLetter(string) {
  return string.toString().charAt(0).toUpperCase() + string.toString().slice(1);
}
function toLowercaseFirstLetter(string) {
  return string.toString().charAt(0).toLowerCase() + string.toString().slice(1);
}
function addPrefix(string, prefix) {
  return "".concat(prefix).concat(toUppercaseFirstLetter(string));
}
function removePrefix(string, prefix, lowercaseFirstLetter) {
  var _a2;
  if (lowercaseFirstLetter === void 0) {
    lowercaseFirstLetter = true;
  }
  var inferPrefix = prefix || ((_a2 = string.match(/^([a-z][a-z0-9]+)/)) === null || _a2 === void 0 ? void 0 : _a2[0]) || "";
  var withoutPrefix = string.replace(new RegExp("^(".concat(inferPrefix, ")")), "");
  return lowercaseFirstLetter ? toLowercaseFirstLetter(withoutPrefix) : withoutPrefix;
}

// node_modules/@antv/component/esm/util/style.js
function applyStyleSheet(element, style) {
  Object.entries(style).forEach(function(_a2) {
    var _b = __read(_a2, 2), selector = _b[0], styleString = _b[1];
    __spreadArray([element], __read(element.querySelectorAll(selector)), false).filter(function(el) {
      return el.matches(selector);
    }).forEach(function(target) {
      if (!target)
        return;
      var temp = target;
      temp.style.cssText += Object.entries(styleString).reduce(function(total, currVal) {
        return "".concat(total).concat(currVal.join(":"), ";");
      }, "");
    });
  });
}
var startsWith = function(text, prefix) {
  if (!(text === null || text === void 0 ? void 0 : text.startsWith(prefix)))
    return false;
  var nextChart = text[prefix.length];
  return nextChart >= "A" && nextChart <= "Z";
};
function subStyleProps(style, prefix, invert6) {
  if (invert6 === void 0) {
    invert6 = false;
  }
  var result2 = {};
  Object.entries(style).forEach(function(_a2) {
    var _b = __read(_a2, 2), key = _b[0], value2 = _b[1];
    if (key === "className" || key === "class") {
    } else if (startsWith(key, "show") && startsWith(removePrefix(key, "show"), prefix) !== invert6) {
      if (key === addPrefix(prefix, "show"))
        result2[key] = value2;
      else
        result2[key.replace(new RegExp(toUppercaseFirstLetter(prefix)), "")] = value2;
    } else if (!startsWith(key, "show") && startsWith(key, prefix) !== invert6) {
      var name_1 = removePrefix(key, prefix);
      if (name_1 === "filter" && typeof value2 === "function") {
      } else
        result2[name_1] = value2;
    }
  });
  return result2;
}
function superStyleProps(style, prefix) {
  return Object.entries(style).reduce(function(acc, _a2) {
    var _b = __read(_a2, 2), key = _b[0], value2 = _b[1];
    if (key.startsWith("show"))
      acc["show".concat(prefix).concat(key.slice(4))] = value2;
    else
      acc["".concat(prefix).concat(toUppercaseFirstLetter(key))] = value2;
    return acc;
  }, {});
}
function splitStyle(style, ignoreStyleDict) {
  if (ignoreStyleDict === void 0) {
    ignoreStyleDict = ["x", "y", "class", "className"];
  }
  var groupStyleDict = [
    "transform",
    "transformOrigin",
    "anchor",
    "visibility",
    "pointerEvents",
    "zIndex",
    "cursor",
    "clipPath",
    "clipPathTargets",
    "offsetPath",
    "offsetPathTargets",
    "offsetDistance",
    "draggable",
    "droppable"
  ];
  var output = {};
  var groupStyle = {};
  Object.entries(style).forEach(function(_a2) {
    var _b = __read(_a2, 2), key = _b[0], val = _b[1];
    if (ignoreStyleDict.includes(key)) {
    } else if (groupStyleDict.indexOf(key) !== -1)
      groupStyle[key] = val;
    else
      output[key] = val;
  });
  return [output, groupStyle];
}

// node_modules/@antv/component/esm/util/svg2marker.js
var import_svg_path_parser = __toESM(require_svg_path_parser());

// node_modules/@antv/component/esm/util/time.js
function formatTime(date, mask) {
  var timeMap = {
    YYYY: date.getFullYear(),
    MM: date.getMonth() + 1,
    DD: date.getDate(),
    HH: date.getHours(),
    mm: date.getMinutes(),
    ss: date.getSeconds()
  };
  var strftime = mask;
  Object.keys(timeMap).forEach(function(key) {
    var val = timeMap[key];
    strftime = strftime.replace(key, key === "YYYY" ? "".concat(val) : "".concat(val).padStart(2, "0"));
  });
  return strftime;
}

// node_modules/@antv/component/esm/util/transform.js
function getTranslate(node, x3, y3) {
  var _a2 = node.getBBox(), width = _a2.width, height = _a2.height;
  var _b = __read([x3, y3].map(function(v, i) {
    var _a3;
    return v.includes("%") ? parseFloat(((_a3 = v.match(/[+-]?([0-9]*[.])?[0-9]+/)) === null || _a3 === void 0 ? void 0 : _a3[0]) || "0") / 100 * (i === 0 ? width : height) : v;
  }), 2), tx = _b[0], ty = _b[1];
  return [tx, ty];
}
function percentTransform(node, val) {
  if (!val)
    return;
  try {
    var reg = /translate\(([+-]*[\d]+[%]*),[ ]*([+-]*[\d]+[%]*)\)/g;
    var computedVal = val.replace(reg, function(match, x3, y3) {
      return "translate(".concat(getTranslate(node, x3, y3), ")");
    });
    node.attr("transform", computedVal);
  } catch (e) {
  }
}

// node_modules/@antv/component/esm/util/transpose.js
function transpose4(m3) {
  var _a2;
  return ((_a2 = m3[0]) === null || _a2 === void 0 ? void 0 : _a2.map(function(x3, i) {
    return m3.map(function(x4) {
      return x4[i];
    });
  })) || [];
}

// node_modules/@antv/component/esm/core/component.js
function applyVisibility() {
  visibility(this, this.attributes.visibility !== "hidden");
}
var Component = (
  /** @class */
  function(_super) {
    __extends(Component2, _super);
    function Component2(options, defaultStyleProps) {
      if (defaultStyleProps === void 0) {
        defaultStyleProps = {};
      }
      var _this2 = _super.call(this, deepAssign2({}, { style: defaultStyleProps }, options)) || this;
      _this2.initialized = false;
      _this2._defaultOptions = defaultStyleProps;
      return _this2;
    }
    Object.defineProperty(Component2.prototype, "offscreenGroup", {
      get: function() {
        if (!this._offscreen)
          this._offscreen = createOffscreenGroup(this);
        return this._offscreen;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Component2.prototype, "defaultOptions", {
      get: function() {
        return this._defaultOptions;
      },
      enumerable: false,
      configurable: true
    });
    Component2.prototype.connectedCallback = function() {
      this.render(this.attributes, this);
      this.bindEvents(this.attributes, this);
      this.initialized = true;
    };
    Component2.prototype.disconnectedCallback = function() {
      var _a2;
      (_a2 = this._offscreen) === null || _a2 === void 0 ? void 0 : _a2.destroy();
    };
    Component2.prototype.attributeChangedCallback = function(name2) {
      if (name2 === "visibility") {
        applyVisibility.call(this);
      }
    };
    Component2.prototype.update = function(attr2, animate2) {
      var _a2;
      this.attr(deepAssign2({}, this.attributes, attr2 || {}));
      return (_a2 = this.render) === null || _a2 === void 0 ? void 0 : _a2.call(this, this.attributes, this, animate2);
    };
    Component2.prototype.clear = function() {
      this.removeChildren();
    };
    Component2.prototype.bindEvents = function(attributes, container) {
    };
    return Component2;
  }(CustomElement)
);

// node_modules/@antv/component/esm/ui/marker/symbol.js
var circle = function(x3, y3, r) {
  return [["M", x3 - r, y3], ["A", r, r, 0, 1, 0, x3 + r, y3], ["A", r, r, 0, 1, 0, x3 - r, y3], ["Z"]];
};
var point6 = circle;
var square2 = function(x3, y3, r) {
  return [["M", x3 - r, y3 - r], ["L", x3 + r, y3 - r], ["L", x3 + r, y3 + r], ["L", x3 - r, y3 + r], ["Z"]];
};
var diamond2 = function(x3, y3, r) {
  return [["M", x3 - r, y3], ["L", x3, y3 - r], ["L", x3 + r, y3], ["L", x3, y3 + r], ["Z"]];
};
var triangle2 = function(x3, y3, r) {
  var diffY = r * Math.sin(1 / 3 * Math.PI);
  return [["M", x3 - r, y3 + diffY], ["L", x3, y3 - diffY], ["L", x3 + r, y3 + diffY], ["Z"]];
};
var triangleDown2 = function(x3, y3, r) {
  var diffY = r * Math.sin(1 / 3 * Math.PI);
  return [["M", x3 - r, y3 - diffY], ["L", x3 + r, y3 - diffY], ["L", x3, y3 + diffY], ["Z"]];
};
var hexagon2 = function(x3, y3, r) {
  var diffX = r / 2 * Math.sqrt(3);
  return [
    ["M", x3, y3 - r],
    ["L", x3 + diffX, y3 - r / 2],
    ["L", x3 + diffX, y3 + r / 2],
    ["L", x3, y3 + r],
    ["L", x3 - diffX, y3 + r / 2],
    ["L", x3 - diffX, y3 - r / 2],
    ["Z"]
  ];
};
var bowtie2 = function(x3, y3, r) {
  var diffY = r - 1.5;
  return [["M", x3 - r, y3 - diffY], ["L", x3 + r, y3 + diffY], ["L", x3 + r, y3 - diffY], ["L", x3 - r, y3 + diffY], ["Z"]];
};
var line2 = function(x3, y3, r) {
  return [
    ["M", x3, y3 + r],
    ["L", x3, y3 - r]
  ];
};
var cross6 = function(x3, y3, r) {
  return [
    ["M", x3 - r, y3 - r],
    ["L", x3 + r, y3 + r],
    ["M", x3 + r, y3 - r],
    ["L", x3 - r, y3 + r]
  ];
};
var tick2 = function(x3, y3, r) {
  return [
    ["M", x3 - r / 2, y3 - r],
    ["L", x3 + r / 2, y3 - r],
    ["M", x3, y3 - r],
    ["L", x3, y3 + r],
    ["M", x3 - r / 2, y3 + r],
    ["L", x3 + r / 2, y3 + r]
  ];
};
var plus2 = function(x3, y3, r) {
  return [
    ["M", x3 - r, y3],
    ["L", x3 + r, y3],
    ["M", x3, y3 - r],
    ["L", x3, y3 + r]
  ];
};
var hyphen2 = function(x3, y3, r) {
  return [
    ["M", x3 - r, y3],
    ["L", x3 + r, y3]
  ];
};
var dot7 = function(x3, y3, r) {
  return [
    ["M", x3 - r, y3],
    ["L", x3 + r, y3]
  ];
};
var dash2 = dot7;
var smooth2 = function(x3, y3, r) {
  return [
    ["M", x3 - r, y3],
    ["A", r / 2, r / 2, 0, 1, 1, x3, y3],
    ["A", r / 2, r / 2, 0, 1, 0, x3 + r, y3]
  ];
};
var hv2 = function(x3, y3, r) {
  return [
    ["M", x3 - r - 1, y3 - 2.5],
    ["L", x3, y3 - 2.5],
    ["L", x3, y3 + 2.5],
    ["L", x3 + r + 1, y3 + 2.5]
  ];
};
var vh2 = function(x3, y3, r) {
  return [
    ["M", x3 - r - 1, y3 + 2.5],
    ["L", x3, y3 + 2.5],
    ["L", x3, y3 - 2.5],
    ["L", x3 + r + 1, y3 - 2.5]
  ];
};
var hvh2 = function(x3, y3, r) {
  return [
    ["M", x3 - (r + 1), y3 + 2.5],
    ["L", x3 - r / 2, y3 + 2.5],
    ["L", x3 - r / 2, y3 - 2.5],
    ["L", x3 + r / 2, y3 - 2.5],
    ["L", x3 + r / 2, y3 + 2.5],
    ["L", x3 + r + 1, y3 + 2.5]
  ];
};
function vhv2(x3, y3) {
  return [
    ["M", x3 - 5, y3 + 2.5],
    ["L", x3 - 5, y3],
    ["L", x3, y3],
    ["L", x3, y3 - 3],
    ["L", x3, y3 + 3],
    ["L", x3 + 6.5, y3 + 3]
  ];
}
var button = function(x3, y3, r) {
  return [["M", x3 - r, y3 - r], ["L", x3 + r, y3], ["L", x3 - r, y3 + r], ["Z"]];
};

// node_modules/@antv/component/esm/ui/marker/utils.js
function parseMarker(icon) {
  var type = "default";
  if (is_object_default(icon) && icon instanceof Image)
    type = "image";
  else if (is_function_default(icon))
    type = "symbol";
  else if (is_string_default(icon)) {
    var dataURLsPattern = new RegExp("data:(image|text)");
    if (icon.match(dataURLsPattern)) {
      type = "base64";
    } else if (/^(https?:\/\/(([a-zA-Z0-9]+-?)+[a-zA-Z0-9]+\.)+[a-zA-Z]+)(:\d+)?(\/.*)?(\?.*)?(#.*)?$/.test(icon)) {
      type = "url";
    } else {
      type = "symbol";
    }
  }
  return type;
}

// node_modules/@antv/component/esm/ui/marker/index.js
function getType(symbol) {
  var markerType = parseMarker(symbol);
  if (["base64", "url", "image"].includes(markerType)) {
    return "image";
  }
  if (symbol && markerType === "symbol") {
    return "path";
  }
  return null;
}
var Marker = (
  /** @class */
  function(_super) {
    __extends(Marker2, _super);
    function Marker2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Marker2.prototype.render = function(attributes, container) {
      var symbol = attributes.symbol, _a2 = attributes.size, size5 = _a2 === void 0 ? 16 : _a2, style = __rest(attributes, ["symbol", "size"]);
      var type = getType(symbol);
      ifShow(!!type, select2(container), function(group3) {
        group3.maybeAppendByClassName("marker", type).attr("className", "marker ".concat(type, "-marker")).call(function(selection) {
          if (type === "image") {
            var r = size5 * 2;
            selection.styles({
              img: symbol,
              width: r,
              height: r,
              x: -size5,
              y: -size5
            });
          } else {
            var r = size5 / 2;
            var symbolFn = is_function_default(symbol) ? symbol : Marker2.getSymbol(symbol);
            selection.styles(__assign({ path: symbolFn === null || symbolFn === void 0 ? void 0 : symbolFn(0, 0, r) }, style));
          }
        });
      });
    };
    Marker2.MARKER_SYMBOL_MAP = /* @__PURE__ */ new Map();
    Marker2.registerSymbol = function(type, symbol) {
      Marker2.MARKER_SYMBOL_MAP.set(type, symbol);
    };
    Marker2.getSymbol = function(type) {
      return Marker2.MARKER_SYMBOL_MAP.get(type);
    };
    Marker2.getSymbols = function() {
      return Array.from(Marker2.MARKER_SYMBOL_MAP.keys());
    };
    return Marker2;
  }(Component)
);
Marker.registerSymbol("cross", cross6);
Marker.registerSymbol("hyphen", hyphen2);
Marker.registerSymbol("line", line2);
Marker.registerSymbol("plus", plus2);
Marker.registerSymbol("tick", tick2);
Marker.registerSymbol("circle", circle);
Marker.registerSymbol("point", point6);
Marker.registerSymbol("bowtie", bowtie2);
Marker.registerSymbol("hexagon", hexagon2);
Marker.registerSymbol("square", square2);
Marker.registerSymbol("diamond", diamond2);
Marker.registerSymbol("triangle", triangle2);
Marker.registerSymbol("triangle-down", triangleDown2);
Marker.registerSymbol("line", line2);
Marker.registerSymbol("dot", dot7);
Marker.registerSymbol("dash", dash2);
Marker.registerSymbol("smooth", smooth2);
Marker.registerSymbol("hv", hv2);
Marker.registerSymbol("vh", vh2);
Marker.registerSymbol("hvh", hvh2);
Marker.registerSymbol("vhv", vhv2);

// node_modules/@antv/component/esm/ui/tag/index.js
function adjust(container, paddingLeft, paddingTop, align, baseline) {
  var bounds = container.getLocalBounds();
  var x3 = 0;
  var y3 = 0;
  if (align === "start")
    x3 = paddingLeft;
  if (align === "center")
    x3 = -bounds.halfExtents[0];
  if (align === "end")
    x3 = -paddingLeft - bounds.halfExtents[0] * 2;
  if (baseline === "top")
    y3 = paddingTop + bounds.halfExtents[1];
  if (baseline === "middle")
    y3 = 0;
  if (baseline === "bottom")
    y3 = paddingTop - bounds.halfExtents[1] * 2;
  container.setLocalPosition([x3, y3]);
}
function getTextPosition(markerShape, spacing) {
  var bounds = markerShape.getLocalBounds();
  return {
    x: bounds.halfExtents[0] ? bounds.max[0] + (spacing || 0) : markerShape.style.x,
    y: bounds.halfExtents[1] ? (bounds.min[1] + bounds.max[1]) / 2 : markerShape.style.y
  };
}
var Tag = (
  /** @class */
  function(_super) {
    __extends(Tag2, _super);
    function Tag2(options) {
      return _super.call(this, options, {
        padding: 4,
        spacing: 4
      }) || this;
    }
    Tag2.prototype.render = function(attributes, container) {
      var _a2 = attributes.padding, padding = _a2 === void 0 ? 0 : _a2, marker = attributes.marker, text = attributes.text, radius = attributes.radius, spacing = attributes.spacing, align = attributes.align, verticalAlign = attributes.verticalAlign;
      var labelStyle = subStyleProps(attributes, "label");
      var backgroundStyle = subStyleProps(attributes, "background");
      var _b = __read(parseSeriesAttr(padding), 4), pt = _b[0], pr = _b[1], pb = _b[2], pl = _b[3];
      var group3 = maybeAppend(container, ".tag-content", "g").attr("className", "tag-content").style("zIndex", 0).node();
      var markerStyle = marker || { symbol: "triangle", size: 0 };
      var markerShape = maybeAppend(group3, ".tag-marker", function() {
        return new Marker({ style: markerStyle });
      }).attr("className", "tag-marker").call(function(selection) {
        selection.node().clear();
      }).update(markerStyle).node();
      var _c = getTextPosition(markerShape, spacing), x3 = _c.x, y3 = _c.y;
      select2(group3).maybeAppendByClassName("tag-text", function() {
        return new Text2();
      }).styles(__assign(__assign({ fontSize: 12, text: is_nil_default(text) ? "" : "".concat(text), x: x3, y: y3 }, labelStyle), { textBaseline: "middle" })).call(function(selection) {
        if (!text)
          selection.remove();
      });
      adjust(group3, pl, pt, align || "start", verticalAlign || "top");
      var bounds = group3.getLocalBounds();
      select2(container).maybeAppendByClassName("tag-background", "rect").styles(__assign({ zIndex: -1, y: bounds.min[1] - pt, x: bounds.min[0] - pl, width: backgroundStyle !== null ? pl + pr + bounds.halfExtents[0] * 2 : 0, height: backgroundStyle !== null ? pt + pb + bounds.halfExtents[1] * 2 : 0, radius: radius !== null && radius !== void 0 ? radius : 2, fill: "#fafafa", stroke: "#d9d9d9", lineWidth: 1 }, backgroundStyle));
    };
    Tag2.tag = "tag";
    return Tag2;
  }(Component)
);

// node_modules/@antv/component/esm/ui/button/constant.js
var SIZE_STYLE = {
  small: {
    textFontSize: 10,
    buttonWidth: 40,
    buttonHeight: 20,
    markerSize: 8
  },
  middle: {
    textFontSize: 12,
    buttonWidth: 60,
    buttonHeight: 30,
    markerSize: 12
  },
  large: {
    textFontSize: 16,
    buttonWidth: 80,
    buttonHeight: 40,
    markerSize: 16
  }
};
var TYPE_STYLE = {
  primary: {
    default: { textFill: "#fff", buttonFill: "#1890ff", buttonLineWidth: 0, markerFill: "#1890ff" },
    active: {
      buttonFill: "#40a9ff",
      markerFill: "#40a9ff"
    },
    disabled: {}
  },
  dashed: {
    default: {
      buttonFill: "transparent",
      buttonStroke: "#bbb",
      buttonLineDash: [5, 5]
    },
    active: {},
    disabled: {}
  },
  link: {
    default: { textFill: "#1890ff", buttonFill: "transparent", buttonLineWidth: 0, markerFill: "#1890ff" },
    active: {},
    disabled: {}
  },
  text: {
    default: { textFill: "#000", buttonFill: "transparent", buttonLineWidth: 0, markerFill: "#000" },
    active: {},
    disabled: {}
  },
  default: {
    default: { textFill: "#000", buttonFill: "transparent", buttonStroke: "#bbb", markerFill: "#bbb" },
    active: { textFill: "#1890ff", buttonStroke: "#1890ff", markerStroke: "#1890ff" },
    disabled: {}
  }
};
var DISABLED_STYLE = {
  // 
  strict: {
    textFill: "#b8b8b8"
  },
  buttonStroke: "#d9d9d9",
  buttonFill: "#f5f5f5",
  markerStroke: "#d9d9d9"
};

// node_modules/@antv/component/esm/ui/button/index.js
var Button = (
  /** @class */
  function(_super) {
    __extends(Button2, _super);
    function Button2(options) {
      var _this2 = _super.call(this, options, {
        cursor: "pointer",
        padding: 10,
        size: "middle",
        type: "default",
        text: "",
        state: "default",
        markerAlign: "left",
        markerSpacing: 5,
        default: {
          buttonLineWidth: 1,
          buttonRadius: 5
        },
        active: {}
      }) || this;
      _this2.state = "default";
      _this2.clickEvents = function() {
        var _a2 = _this2.attributes, onClick = _a2.onClick, state = _a2.state;
        if (state !== "disabled")
          onClick === null || onClick === void 0 ? void 0 : onClick.call(_this2, _this2);
      };
      _this2.mouseenterEvent = function() {
        var state = _this2.attributes.state;
        if (state !== "disabled") {
          _this2.state = "active";
          _this2.render(_this2.attributes, _this2);
        }
      };
      _this2.mouseleaveEvent = function() {
        var state = _this2.attributes.state;
        _this2.state = state;
        _this2.render(_this2.attributes, _this2);
      };
      return _this2;
    }
    Object.defineProperty(Button2.prototype, "markerSize", {
      get: function() {
        var markerSymbol = this.attributes.markerSymbol;
        var markerStyle = this.getStyle("marker");
        var markerSize = !markerSymbol ? 0 : (markerStyle === null || markerStyle === void 0 ? void 0 : markerStyle.size) || 2;
        return markerSize;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Button2.prototype, "textAvailableWidth", {
      /*  */
      get: function() {
        var _a2 = this.attributes, markerSymbol = _a2.markerSymbol, padding = _a2.padding, ellipsis = _a2.ellipsis, bWidth = _a2.width, spacing = _a2.markerSpacing;
        if (!ellipsis)
          return Infinity;
        var width = is_undefined_default(bWidth) ? this.getStyle("button").width : bWidth;
        if (markerSymbol)
          return width - padding * 2 - spacing - this.markerSize;
        return width - padding * 2;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Button2.prototype, "buttonHeight", {
      get: function() {
        var height = this.attributes.height;
        if (height)
          return +height;
        return +this.getStyle("button").height;
      },
      enumerable: false,
      configurable: true
    });
    Button2.prototype.getStyle = function(name2) {
      var _a2 = this.attributes, size5 = _a2.size, type = _a2.type;
      var state = this.state;
      var mixedStyle = deep_mix_default({}, SIZE_STYLE[size5], TYPE_STYLE[type][state], this.attributes.default, this.attributes[state]);
      if (state === "disabled") {
        Object.keys(mixedStyle).forEach(function(key) {
          if (key in DISABLED_STYLE) {
            mixedStyle[key] = DISABLED_STYLE[key];
          }
        });
        Object.keys(DISABLED_STYLE.strict).forEach(function(key) {
          mixedStyle[key] = DISABLED_STYLE.strict[key];
        });
        deep_mix_default(mixedStyle, this.attributes.disabled || {});
      }
      return subStyleProps(mixedStyle, name2);
    };
    Button2.prototype.render = function(attributes, container) {
      var _a2 = attributes.text, text = _a2 === void 0 ? "" : _a2, _b = attributes.padding, padding = _b === void 0 ? 0 : _b, markerSymbol = attributes.markerSymbol, _c = attributes.markerSpacing, markerSpacing = _c === void 0 ? 0 : _c;
      container.attr("cursor", this.state === "disabled" ? "not-allowed" : "pointer");
      var _d = __read(parseSeriesAttr(padding), 4), pt = _d[0], pr = _d[1], pb = _d[2], pl = _d[3];
      var height = this.buttonHeight;
      var markerStyle = this.getStyle("marker");
      var markerSize = this.markerSize;
      var style = __assign(__assign({}, markerStyle), { symbol: markerSymbol, x: pl + markerSize / 2, y: height / 2, size: markerSize });
      var markerShape = maybeAppend(container, ".marker", function() {
        return new Marker({ className: "marker", style });
      }).update({ style }).node();
      var bounds = markerShape.getLocalBounds();
      var textStyle = this.getStyle("text");
      this.textShape = maybeAppend(container, ".text", "text").attr("className", "text").styles(__assign(__assign({ x: markerSize ? bounds.max[0] + markerSpacing : pl, y: height / 2 }, textStyle), { text, textAlign: "left", textBaseline: "middle", wordWrap: true, wordWrapWidth: this.textAvailableWidth, maxLines: 1, textOverflow: "..." })).node();
      var textBounds = this.textShape.getLocalBounds();
      var buttonStyle = this.getStyle("button");
      select2(container).maybeAppendByClassName(".background", "rect").styles(__assign(__assign({ zIndex: -1 }, buttonStyle), { height, width: pl + (markerSize ? markerSize + markerSpacing : 0) + textBounds.halfExtents[0] * 2 + pr }));
    };
    Button2.prototype.update = function(attr2) {
      if (attr2 === void 0) {
        attr2 = {};
      }
      this.attr(deep_mix_default({}, this.attributes, attr2));
      var state = this.attributes.state;
      this.state = state;
      this.render(this.attributes, this);
    };
    Button2.prototype.setState = function(state) {
      this.update({ state });
    };
    Button2.prototype.hide = function() {
      this.style.visibility = "hidden";
    };
    Button2.prototype.show = function() {
      this.style.visibility = "visible";
    };
    Button2.prototype.bindEvents = function() {
      this.addEventListener("click", this.clickEvents);
      this.addEventListener("mouseenter", this.mouseenterEvent);
      this.addEventListener("mouseleave", this.mouseleaveEvent);
    };
    Button2.tag = "button";
    return Button2;
  }(Component)
);

// node_modules/@antv/component/esm/ui/breadcrumb/index.js
var Breadcrumb = (
  /** @class */
  function(_super) {
    __extends(Breadcrumb2, _super);
    function Breadcrumb2(options) {
      return _super.call(this, deep_mix_default({}, Breadcrumb2.defaultOptions, options)) || this;
    }
    Breadcrumb2.prototype.render = function(attributes, container) {
      var x3 = attributes.x, y3 = attributes.y, items = attributes.items, textStyle = attributes.textStyle, _a2 = attributes.padding, padding = _a2 === void 0 ? 0 : _a2, width = attributes.width, separator = attributes.separator;
      var _b = __read(parseSeriesAttr(padding), 3), top = _b[0], right2 = _b[1], left2 = _b[2];
      var tagStyle = subStyleProps(attributes, "tag");
      var selection = maybeAppend(container, ".container", "g").styles({
        className: "container",
        x: x3 + left2,
        y: y3 + top
      });
      var cursorX = 0;
      var cursorY = 0;
      selection.node().removeChildren();
      var _loop_1 = function(i2) {
        var datum = items[i2];
        var shape23 = new Tag({
          className: "breadcrumb-item",
          style: __assign(__assign(__assign(__assign({ x: cursorX, y: cursorY }, tagStyle), { text: is_nil_default(datum.text) ? datum.id : datum.text }), pick_default(datum, ["marker"])), {
            // 
            padding: 0
          })
        });
        selection.append(function() {
          return shape23;
        });
        var bounds = shape23.getLocalBounds();
        var shapeW = bounds.halfExtents[0] * 2;
        var shapeH = bounds.halfExtents[1] * 2;
        cursorX += shapeW;
        if (!is_nil_default(width)) {
          var avaliableWidth = width - right2;
          if (cursorX > avaliableWidth) {
            shape23.attr({ x: 0, y: cursorY + shapeH });
            cursorX = shapeW;
            cursorY += shapeH;
          }
        }
        this_1.bindInnerEvents(shape23, datum);
        var _c = separator || {}, _d = _c.spacing, spacing = _d === void 0 ? 0 : _d, _e = _c.text, text = _e === void 0 ? "/" : _e, style = _c.style;
        if (i2 !== items.length - 1) {
          var shape_1 = new Text2({
            className: "".concat(Breadcrumb2.tag, "-separator"),
            id: "".concat(Breadcrumb2.tag, "-separator-").concat(i2),
            style: __assign(__assign({ x: cursorX + spacing, y: cursorY + shapeH / 2 }, style), { text, textAlign: "end", textBaseline: "middle" })
          });
          selection.append(function() {
            return shape_1;
          });
          var bounds_1 = shape_1.getLocalBounds();
          cursorX += bounds_1.halfExtents[0] * 2 + spacing;
        }
      };
      var this_1 = this;
      for (var i = 0; i < items.length; i++) {
        _loop_1(i);
      }
    };
    Breadcrumb2.prototype.update = function(cfg) {
      this.attr(deep_mix_default({}, this.attributes, cfg));
      this.render(this.attributes, this);
    };
    Breadcrumb2.prototype.bindInnerEvents = function(shape23, item) {
      var _a2 = this.attributes, items = _a2.items, onClick = _a2.onClick;
      if (onClick) {
        shape23.addEventListener("click", function() {
          onClick.call(shape23, item.id, item, items);
        });
      }
    };
    Breadcrumb2.tag = "breadcrumb";
    Breadcrumb2.defaultOptions = {
      style: {
        separator: {
          text: "/",
          style: {
            fontSize: 14,
            fill: "rgba(0, 0, 0, 0.45)"
          },
          spacing: 8
        },
        textStyle: {
          default: {
            fontSize: 14,
            fill: "rgba(0, 0, 0, 0.45)"
          },
          active: {
            fill: "#5468ff",
            cursor: "pointer"
          }
        },
        padding: [8, 8, 8, 8]
      }
    };
    return Breadcrumb2;
  }(Component)
);

// node_modules/@antv/component/esm/ui/sparkline/columns.js
var Columns = (
  /** @class */
  function(_super) {
    __extends(Columns2, _super);
    function Columns2(_a2) {
      var _this2 = this;
      var style = _a2.style, rest2 = __rest(_a2, ["style"]);
      _this2 = _super.call(this, deep_mix_default({}, { type: "column" }, __assign({ style }, rest2))) || this;
      _this2.columnsGroup = new Group2({ name: "columns" });
      _this2.appendChild(_this2.columnsGroup);
      _this2.render();
      return _this2;
    }
    Columns2.prototype.render = function() {
      var columns = this.attributes.columns;
      select2(this.columnsGroup).selectAll(".column").data(columns.flat()).join(function(enter) {
        return enter.append("rect").attr("className", "column").each(function(style) {
          this.attr(style);
        });
      }, function(update3) {
        return update3.each(function(style) {
          this.attr(style);
        });
      }, function(exit) {
        return exit.remove();
      });
    };
    Columns2.prototype.update = function(attr2) {
      this.attr(deepAssign2({}, this.attributes, attr2));
      this.render();
    };
    Columns2.prototype.clear = function() {
      this.removeChildren();
    };
    return Columns2;
  }(DisplayObject)
);

// node_modules/@antv/component/esm/ui/sparkline/lines.js
var Lines = (
  /** @class */
  function(_super) {
    __extends(Lines2, _super);
    function Lines2(_a2) {
      var _this2 = this;
      var style = _a2.style, rest2 = __rest(_a2, ["style"]);
      _this2 = _super.call(this, deep_mix_default({}, { type: "lines" }, __assign({ style }, rest2))) || this;
      _this2.linesGroup = _this2.appendChild(new Group2());
      _this2.areasGroup = _this2.appendChild(new Group2());
      _this2.render();
      return _this2;
    }
    Lines2.prototype.render = function() {
      var _a2 = this.attributes, lines = _a2.lines, areas = _a2.areas;
      if (lines)
        this.renderLines(lines);
      if (areas)
        this.renderAreas(areas);
    };
    Lines2.prototype.clear = function() {
      this.linesGroup.removeChildren();
      this.areasGroup.removeChildren();
    };
    Lines2.prototype.update = function(attr2) {
      this.attr(deepAssign2({}, this.attributes, attr2));
      this.render();
    };
    Lines2.prototype.renderLines = function(lines) {
      select2(this.linesGroup).selectAll(".line").data(lines).join(function(enter) {
        return enter.append("path").attr("className", "line").each(function(style) {
          this.attr(style);
        });
      }, function(update3) {
        return update3.each(function(style) {
          this.attr(style);
        });
      }, function(exit) {
        return exit.remove();
      });
    };
    Lines2.prototype.renderAreas = function(areas) {
      select2(this.linesGroup).selectAll(".area").data(areas).join(function(enter) {
        return enter.append("path").attr("className", "area").each(function(style) {
          this.attr(style);
        });
      }, function(update3) {
        return update3.each(function(style) {
          this.style(style);
        });
      }, function(exit) {
        return exit.remove();
      });
    };
    return Lines2;
  }(DisplayObject)
);

// node_modules/@antv/component/esm/ui/sparkline/path.js
function dataToLines(data2, scales) {
  var _a2;
  var x3 = scales.x, y3 = scales.y;
  var _b = __read(y3.getOptions().range || [0, 0], 2), max11 = _b[0], min11 = _b[1];
  if (min11 > max11)
    _a2 = __read([max11, min11], 2), min11 = _a2[0], max11 = _a2[1];
  return data2.map(function(points) {
    var lines = points.map(function(val, idx) {
      return [x3.map(idx), clamp_default(y3.map(val), min11, max11)];
    });
    return lines;
  });
}
function lineToLinePath(line4, reverse3) {
  if (reverse3 === void 0) {
    reverse3 = false;
  }
  var M2 = reverse3 ? line4.length - 1 : 0;
  var linePath = line4.map(function(point7, idx) {
    return __spreadArray([idx === M2 ? "M" : "L"], __read(point7), false);
  });
  return reverse3 ? linePath.reverse() : linePath;
}
function lineToCurvePath(line4, reverse3) {
  if (reverse3 === void 0) {
    reverse3 = false;
  }
  if (line4.length <= 2) {
    return lineToLinePath(line4);
  }
  var data2 = [];
  var len5 = line4.length;
  for (var idx = 0; idx < len5; idx += 1) {
    var point7 = reverse3 ? line4[len5 - idx - 1] : line4[idx];
    if (!is_equal_default(point7, data2.slice(-2))) {
      data2.push.apply(data2, __spreadArray([], __read(point7), false));
    }
  }
  var path2 = catmullRom2Bezier(data2, false);
  if (reverse3) {
    path2.unshift(__spreadArray(["M"], __read(line4[len5 - 1]), false));
  } else {
    path2.unshift(__spreadArray(["M"], __read(line4[0]), false));
  }
  return path2;
}
function closePathByBaseLine(path2, width, baseline) {
  var closedPath = clone_default(path2);
  closedPath.push(["L", width, baseline], ["L", 0, baseline], ["Z"]);
  return closedPath;
}
function linesToAreaPaths(lines, smooth3, width, baseline) {
  return lines.map(function(line4) {
    return closePathByBaseLine(smooth3 ? lineToCurvePath(line4) : lineToLinePath(line4), width, baseline);
  });
}
function linesToStackAreaPaths(lines, width, baseline) {
  var paths = [];
  for (var idx = lines.length - 1; idx >= 0; idx -= 1) {
    var currLine = lines[idx];
    var currCurvePath = lineToLinePath(currLine);
    var path2 = void 0;
    if (idx === 0) {
      path2 = closePathByBaseLine(currCurvePath, width, baseline);
    } else {
      var belowLine = lines[idx - 1];
      var belowCurvePath = lineToLinePath(belowLine, true);
      belowCurvePath[0][0] = "L";
      path2 = __spreadArray(__spreadArray(__spreadArray([], __read(currCurvePath), false), __read(belowCurvePath), false), [["Z"]], false);
    }
    paths.push(path2);
  }
  return paths;
}
function linesToStackCurveAreaPaths(lines, width, baseline) {
  var paths = [];
  for (var idx = lines.length - 1; idx >= 0; idx -= 1) {
    var currLine = lines[idx];
    var currCurvePath = lineToCurvePath(currLine);
    var path2 = void 0;
    if (idx === 0) {
      path2 = closePathByBaseLine(currCurvePath, width, baseline);
    } else {
      var belowLine = lines[idx - 1];
      var belowCurvePath = lineToCurvePath(belowLine, true);
      var A5 = currLine[0];
      belowCurvePath[0][0] = "L";
      path2 = __spreadArray(__spreadArray(__spreadArray([], __read(currCurvePath), false), __read(belowCurvePath), false), [__spreadArray(["M"], __read(A5), false), ["Z"]], false);
    }
    paths.push(path2);
  }
  return paths;
}

// node_modules/@antv/component/esm/ui/sparkline/utils.js
function getRange(data2) {
  if (data2.length === 0)
    return [0, 0];
  return [min_default(min_by_default(data2, function(arr) {
    return min_default(arr) || 0;
  })), max_default(max_by_default(data2, function(arr) {
    return max_default(arr) || 0;
  }))];
}
function getStackedData(_2) {
  var data2 = clone_default(_2);
  var datumLen = data2[0].length;
  var _a2 = __read([Array(datumLen).fill(0), Array(datumLen).fill(0)], 2), positivePrev = _a2[0], negativePrev = _a2[1];
  for (var i = 0; i < data2.length; i += 1) {
    var datum = data2[i];
    for (var j = 0; j < datumLen; j += 1) {
      if (datum[j] >= 0) {
        datum[j] += positivePrev[j];
        positivePrev[j] = datum[j];
      } else {
        datum[j] += negativePrev[j];
        negativePrev[j] = datum[j];
      }
    }
  }
  return data2;
}

// node_modules/@antv/component/esm/ui/sparkline/index.js
var Sparkline = (
  /** @class */
  function(_super) {
    __extends(Sparkline2, _super);
    function Sparkline2(options) {
      return _super.call(this, options, {
        type: "line",
        width: 200,
        height: 20,
        isStack: false,
        color: ["#83daad", "#edbf45", "#d2cef9", "#e290b3", "#6f63f4"],
        smooth: true,
        lineLineWidth: 1,
        areaOpacity: 0,
        isGroup: false,
        columnLineWidth: 1,
        columnStroke: "#fff",
        scale: 1,
        spacing: 0
      }) || this;
    }
    Object.defineProperty(Sparkline2.prototype, "rawData", {
      /**
       * data
       * 
       */
      get: function() {
        var rawData = this.attributes.data;
        if (!rawData || (rawData === null || rawData === void 0 ? void 0 : rawData.length) === 0)
          return [[]];
        var data2 = clone_default(rawData);
        return is_number_default(data2[0]) ? [data2] : data2;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Sparkline2.prototype, "data", {
      get: function() {
        if (this.attributes.isStack)
          return getStackedData(this.rawData);
        return this.rawData;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Sparkline2.prototype, "scales", {
      get: function() {
        return this.createScales(this.data);
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Sparkline2.prototype, "baseline", {
      /**
       *  0
       */
      get: function() {
        var y3 = this.scales.y;
        var _a2 = __read(y3.getOptions().domain || [0, 0], 2), y12 = _a2[0], y22 = _a2[1];
        if (y22 < 0) {
          return y3.map(y22);
        }
        return y3.map(y12 < 0 ? 0 : y12);
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Sparkline2.prototype, "containerShape", {
      get: function() {
        var _a2 = this.attributes, width = _a2.width, height = _a2.height;
        return { width, height };
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Sparkline2.prototype, "linesStyle", {
      get: function() {
        var _this2 = this;
        var _a2 = this.attributes, type = _a2.type, isStack = _a2.isStack, smooth3 = _a2.smooth;
        if (type !== "line")
          throw new Error("linesStyle can only be used in line type");
        var areaStyle = subStyleProps(this.attributes, "area");
        var lineStyle = subStyleProps(this.attributes, "line");
        var width = this.containerShape.width;
        var data2 = this.data;
        if (data2[0].length === 0)
          return { lines: [], areas: [] };
        var _b = this.scales, x3 = _b.x, y3 = _b.y;
        var lines = dataToLines(data2, { type: "line", x: x3, y: y3 });
        var areas = [];
        if (areaStyle) {
          var baseline = this.baseline;
          if (isStack) {
            areas = smooth3 ? linesToStackCurveAreaPaths(lines, width, baseline) : linesToStackAreaPaths(lines, width, baseline);
          } else {
            areas = linesToAreaPaths(lines, smooth3, width, baseline);
          }
        }
        return {
          lines: lines.map(function(line4, idx) {
            return __assign({ stroke: _this2.getColor(idx), path: smooth3 ? lineToCurvePath(line4) : lineToLinePath(line4) }, lineStyle);
          }),
          areas: areas.map(function(path2, idx) {
            return __assign({ path: path2, fill: _this2.getColor(idx) }, areaStyle);
          })
        };
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Sparkline2.prototype, "columnsStyle", {
      get: function() {
        var _this2 = this;
        var columnStyle = subStyleProps(this.attributes, "column");
        var _a2 = this.attributes, isStack = _a2.isStack, type = _a2.type, scale10 = _a2.scale;
        if (type !== "column")
          throw new Error("columnsStyle can only be used in column type");
        var height = this.containerShape.height;
        var data2 = this.rawData;
        if (!data2)
          return { columns: [] };
        if (isStack)
          data2 = getStackedData(data2);
        var _b = this.createScales(data2), x3 = _b.x, y3 = _b.y;
        var _c = __read(getRange(data2), 2), minVal = _c[0], maxVal = _c[1];
        var heightScale = new Linear({
          domain: [0, maxVal - (minVal > 0 ? 0 : minVal)],
          range: [0, height * scale10]
        });
        var bandWidth3 = x3.getBandWidth();
        var rawData = this.rawData;
        return {
          columns: data2.map(function(column2, i) {
            return column2.map(function(val, j) {
              var barWidth = bandWidth3 / data2.length;
              var getShape2 = function() {
                return {
                  x: x3.map(j) + barWidth * i,
                  y: val >= 0 ? y3.map(val) : y3.map(0),
                  width: barWidth,
                  height: heightScale.map(Math.abs(val))
                };
              };
              var getStackShape = function() {
                return {
                  x: x3.map(j),
                  y: y3.map(val),
                  width: bandWidth3,
                  height: heightScale.map(rawData[i][j])
                };
              };
              return __assign(__assign({ fill: _this2.getColor(i) }, columnStyle), isStack ? getStackShape() : getShape2());
            });
          })
        };
      },
      enumerable: false,
      configurable: true
    });
    Sparkline2.prototype.render = function(attributes, container) {
      maybeAppend(container, ".container", "rect").attr("className", "container").node();
      var type = attributes.type;
      var className2 = "spark".concat(type);
      var style = type === "line" ? this.linesStyle : this.columnsStyle;
      select2(container).selectAll(".spark").data([type]).join(function(enter) {
        return enter.append(function(type2) {
          if (type2 === "line")
            return new Lines({ className: className2, style });
          return new Columns({ className: className2, style });
        }).attr("className", "spark ".concat(className2));
      }, function(update3) {
        return update3.update(style);
      }, function(exit) {
        return exit.remove();
      });
    };
    Sparkline2.prototype.getColor = function(index3) {
      var color2 = this.attributes.color;
      if (is_array_default(color2)) {
        return color2[index3 % color2.length];
      }
      if (is_function_default(color2)) {
        return color2.call(null, index3);
      }
      return color2;
    };
    Sparkline2.prototype.createScales = function(data2) {
      var _a2, _b;
      var _c = this.attributes, type = _c.type, scale10 = _c.scale, _d = _c.range, range4 = _d === void 0 ? [] : _d, spacing = _c.spacing;
      var _e = this.containerShape, width = _e.width, height = _e.height;
      var _f = __read(getRange(data2), 2), minVal = _f[0], maxVal = _f[1];
      var yScale = new Linear({
        domain: [(_a2 = range4[0]) !== null && _a2 !== void 0 ? _a2 : minVal, (_b = range4[1]) !== null && _b !== void 0 ? _b : maxVal],
        range: [height, height * (1 - scale10)]
      });
      if (type === "line") {
        return {
          type,
          x: new Linear({
            domain: [0, data2[0].length - 1],
            range: [0, width]
          }),
          y: yScale
        };
      }
      return {
        type,
        x: new Band({
          domain: data2[0].map(function(val, idx) {
            return idx;
          }),
          range: [0, width],
          paddingInner: spacing,
          paddingOuter: spacing / 2,
          align: 0.5
        }),
        y: yScale
      };
    };
    Sparkline2.tag = "sparkline";
    return Sparkline2;
  }(Component)
);

// node_modules/@antv/component/esm/animation/utils.js
function isStandardAnimationOption(option) {
  if (typeof option === "boolean")
    return false;
  return "enter" in option && "update" in option && "exit" in option;
}
function parseAnimationOption(option) {
  if (!option)
    return { enter: false, update: false, exit: false };
  var keys3 = ["enter", "update", "exit"];
  var baseOption = Object.fromEntries(Object.entries(option).filter(function(_a2) {
    var _b = __read(_a2, 1), k2 = _b[0];
    return !keys3.includes(k2);
  }));
  return Object.fromEntries(keys3.map(function(k2) {
    if (isStandardAnimationOption(option)) {
      if (option[k2] === false)
        return [k2, false];
      return [k2, __assign(__assign({}, option[k2]), baseOption)];
    }
    return [k2, baseOption];
  }));
}
function onAnimateFinished(animation, callback) {
  if (!animation)
    callback();
  else
    animation.finished.then(callback);
}
function onAnimatesFinished(animations, callback) {
  if (animations.length === 0)
    callback();
  else
    Promise.all(animations.map(function(a4) {
      return a4 === null || a4 === void 0 ? void 0 : a4.finished;
    })).then(callback);
}
function attr(target, value2) {
  if ("update" in target)
    target.update(value2);
  else
    target.attr(value2);
}
function animate(target, keyframes, options) {
  if (keyframes.length === 0)
    return null;
  if (!options) {
    var state = keyframes.slice(-1)[0];
    attr(target, { style: state });
    return null;
  }
  return target.animate(keyframes, options);
}
function identicalTextNode(source, target) {
  if (source.nodeName !== "text" || target.nodeName !== "text")
    return false;
  if (source.attributes.text !== target.attributes.text)
    return false;
  return true;
}
function transitionShape(source, target, options, after2) {
  if (after2 === void 0) {
    after2 = "destroy";
  }
  if (identicalTextNode(source, target)) {
    source.remove();
    return [null];
  }
  var afterTransition = function() {
    if (after2 === "destroy")
      source.destroy();
    else if (after2 === "hide")
      hide(source);
    if (target.isVisible())
      show(target);
  };
  if (!options) {
    afterTransition();
    return [null];
  }
  var _a2 = options.duration, duration = _a2 === void 0 ? 0 : _a2, _b = options.delay, delay2 = _b === void 0 ? 0 : _b;
  var middle = Math.ceil(+duration / 2);
  var offset2 = +duration / 4;
  var getPosition = function(shape23) {
    if (shape23.nodeName === "circle") {
      var _a3 = __read(shape23.getLocalPosition(), 2), cx = _a3[0], cy = _a3[1];
      var r = shape23.attr("r");
      return [cx - r, cy - r];
    }
    return shape23.getLocalPosition();
  };
  var _c = __read(getPosition(source), 2), sx = _c[0], sy = _c[1];
  var _d = __read(getPosition(target), 2), ex = _d[0], ey = _d[1];
  var _e = __read([(sx + ex) / 2 - sx, (sy + ey) / 2 - sy], 2), mx = _e[0], my = _e[1];
  var _f = source.style.opacity, so = _f === void 0 ? 1 : _f;
  var _g = target.style.opacity, to = _g === void 0 ? 1 : _g;
  var sourceAnimation = source.animate([
    { opacity: so, transform: "translate(0, 0)" },
    { opacity: 0, transform: "translate(".concat(mx, ", ").concat(my, ")") }
  ], __assign(__assign({ fill: "both" }, options), { duration: delay2 + middle + offset2 }));
  var targetAnimation = target.animate([
    { opacity: 0, transform: "translate(".concat(-mx, ", ").concat(-my, ")"), offset: 0.01 },
    { opacity: to, transform: "translate(0, 0)" }
  ], __assign(__assign({ fill: "both" }, options), { duration: middle + offset2, delay: delay2 + middle - offset2 }));
  onAnimateFinished(targetAnimation, afterTransition);
  return [sourceAnimation, targetAnimation];
}
function transition(target, state, options) {
  var from = {};
  var to = {};
  Object.entries(state).forEach(function(_a2) {
    var _b = __read(_a2, 2), key = _b[0], tarStyle = _b[1];
    if (!is_nil_default(tarStyle)) {
      var currStyle = target.style[key] || target.parsedStyle[key] || 0;
      if (currStyle !== tarStyle) {
        from[key] = currStyle;
        to[key] = tarStyle;
      }
    }
  });
  if (!options) {
    attr(target, to);
    return null;
  }
  return animate(target, [from, to], __assign({ fill: "both" }, options));
}

// node_modules/@antv/component/esm/animation/fadeOut.js
function fadeOut_default(element, options) {
  if (!element.style.opacity)
    element.style.opacity = 1;
  return transition(element, { opacity: 0 }, options);
}

// node_modules/@antv/component/esm/ui/slider/constant.js
var HANDLE_ICON_DEFAULT_CFG = {
  fill: "#fff",
  lineWidth: 1,
  radius: 2,
  size: 10,
  stroke: "#bfbfbf",
  strokeOpacity: 1,
  zIndex: 0
};
var HANDLE_LABEL_DEFAULT_CFG = {
  fill: "#000",
  fillOpacity: 0.45,
  fontSize: 12,
  textAlign: "center",
  textBaseline: "middle",
  zIndex: 1
};
var HANDLE_DEFAULT_CFG = {
  orientation: "horizontal",
  showLabel: true,
  type: "start"
};
var CLASS_NAMES = classNames({
  foreground: "foreground",
  handle: "handle",
  selection: "selection",
  sparkline: "sparkline",
  sparklineGroup: "sparkline-group",
  track: "track",
  brushArea: "brush-area"
}, "slider");

// node_modules/@antv/component/esm/ui/slider/handle.js
var CLASS_NAMES2 = classNames({
  labelGroup: "label-group",
  label: "label",
  iconGroup: "icon-group",
  icon: "icon",
  iconRect: "icon-rect",
  iconLine: "icon-line"
}, "handle");
var HandleIcon = (
  /** @class */
  function(_super) {
    __extends(HandleIcon2, _super);
    function HandleIcon2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    HandleIcon2.prototype.render = function(attributes, container) {
      var _a2 = attributes.size, size5 = _a2 === void 0 ? 10 : _a2, _b = attributes.radius, radius = _b === void 0 ? size5 / 4 : _b, orientation = attributes.orientation, iconStyle = __rest(attributes, ["size", "radius", "orientation"]);
      var width = size5;
      var height = width * 2.4;
      var rect4 = select2(container).maybeAppendByClassName(CLASS_NAMES2.iconRect, "rect").styles(__assign(__assign({}, iconStyle), { width, height, radius, x: -width / 2, y: -height / 2 }));
      var x12 = 1 / 3 * width;
      var x22 = 2 / 3 * width;
      var y12 = 1 / 4 * height;
      var y22 = 3 / 4 * height;
      rect4.maybeAppendByClassName("".concat(CLASS_NAMES2.iconLine, "-1"), "line").styles(__assign({ x1: x12, x2: x12, y1: y12, y2: y22 }, iconStyle));
      rect4.maybeAppendByClassName("".concat(CLASS_NAMES2.iconLine, "-2"), "line").styles(__assign({ x1: x22, x2: x22, y1: y12, y2: y22 }, iconStyle));
      rect4.node().setOrigin(width / 2, height / 2);
      if (orientation === "vertical")
        container.setLocalEulerAngles(90);
      else
        container.setLocalEulerAngles(0);
    };
    return HandleIcon2;
  }(Component)
);
var Handle = (
  /** @class */
  function(_super) {
    __extends(Handle3, _super);
    function Handle3(options) {
      return _super.call(this, options, HANDLE_DEFAULT_CFG) || this;
    }
    Handle3.prototype.renderLabel = function(container) {
      var _this2 = this;
      var showLabel = this.attributes.showLabel;
      var _a2 = subStyleProps(this.attributes, "label"), transform3 = _a2.transform, style = __rest(_a2, ["transform"]);
      var _b = __read(splitStyle(style, []), 2), labelStyle = _b[0], groupStyle = _b[1];
      var labelGroup = select2(container).maybeAppendByClassName(CLASS_NAMES2.labelGroup, "g").styles(groupStyle);
      var _c = __assign(__assign({}, HANDLE_LABEL_DEFAULT_CFG), labelStyle), text = _c.text, rest2 = __rest(_c, ["text"]);
      ifShow(!!showLabel, labelGroup, function(group3) {
        _this2.label = group3.maybeAppendByClassName(CLASS_NAMES2.label, "text").styles(__assign(__assign({}, rest2), { transform: transform3, text: "".concat(text) }));
        _this2.label.on("mousedown", function(e) {
          e.stopPropagation();
        });
        _this2.label.on("touchstart", function(e) {
          e.stopPropagation();
        });
      });
    };
    Handle3.prototype.renderIcon = function(container) {
      var _a2 = this.attributes, orientation = _a2.orientation, type = _a2.type;
      var iconStyle = __assign(__assign({ orientation }, HANDLE_ICON_DEFAULT_CFG), subStyleProps(this.attributes, "icon"));
      var _b = this.attributes.iconShape, iconShape = _b === void 0 ? function() {
        return new HandleIcon({ style: iconStyle });
      } : _b;
      var iconGroup = select2(container).maybeAppendByClassName(CLASS_NAMES2.iconGroup, "g");
      iconGroup.selectAll(CLASS_NAMES2.icon.class).data([iconShape]).join(function(enter) {
        return enter.append(typeof iconShape === "string" ? iconShape : function() {
          return iconShape(type);
        }).attr("className", CLASS_NAMES2.icon.name);
      }, function(update3) {
        return update3.update(iconStyle);
      }, function(exit) {
        return exit.remove();
      });
    };
    Handle3.prototype.render = function(attributes, container) {
      this.renderIcon(container);
      this.renderLabel(container);
    };
    return Handle3;
  }(Component)
);

// node_modules/@antv/component/esm/ui/slider/index.js
var Slider = (
  /** @class */
  function(_super) {
    __extends(Slider3, _super);
    function Slider3(options) {
      var _this2 = _super.call(this, options, __assign(__assign(__assign({ animate: { duration: 100, fill: "both" }, brushable: true, formatter: function(val) {
        return val.toString();
      }, handleSpacing: 2, orientation: "horizontal", padding: 0, autoFitLabel: true, scrollable: true, selectionFill: "#5B8FF9", selectionFillOpacity: 0.45, selectionZIndex: 2, showHandle: true, showLabel: true, slidable: true, trackFill: "#416180", trackLength: 200, trackOpacity: 0.05, trackSize: 20, trackZIndex: -1, values: [0, 1], type: "range", selectionType: "select", handleIconOffset: 0 }, superStyleProps(HANDLE_DEFAULT_CFG, "handle")), superStyleProps(HANDLE_ICON_DEFAULT_CFG, "handleIcon")), superStyleProps(HANDLE_LABEL_DEFAULT_CFG, "handleLabel"))) || this;
      _this2.range = [0, 1];
      _this2.onDragStart = function(target) {
        return function(e) {
          e.stopPropagation();
          _this2.target = target;
          _this2.prevPos = _this2.getOrientVal(getEventPos(e));
          var _a2 = _this2.availableSpace, x3 = _a2.x, y3 = _a2.y;
          var _b = _this2.getBBox(), X = _b.x, Y = _b.y;
          _this2.selectionStartPos = _this2.getRatio(_this2.prevPos - _this2.getOrientVal([x3, y3]) - _this2.getOrientVal([+X, +Y]));
          _this2.selectionWidth = 0;
          document.addEventListener("pointermove", _this2.onDragging);
          document.addEventListener("pointerup", _this2.onDragEnd);
        };
      };
      _this2.onDragging = function(e) {
        var _a2 = _this2.attributes, slidable = _a2.slidable, brushable = _a2.brushable, type = _a2.type;
        e.stopPropagation();
        var currPos = _this2.getOrientVal(getEventPos(e));
        var diffPos = currPos - _this2.prevPos;
        if (!diffPos)
          return;
        var deltaVal = _this2.getRatio(diffPos);
        switch (_this2.target) {
          case "start":
            if (slidable)
              _this2.setValuesOffset(deltaVal);
            break;
          case "end":
            if (slidable)
              _this2.setValuesOffset(0, deltaVal);
            break;
          case "selection":
            if (slidable)
              _this2.setValuesOffset(deltaVal, deltaVal);
            break;
          case "track":
            if (!brushable)
              return;
            _this2.selectionWidth += deltaVal;
            if (type === "range") {
              _this2.innerSetValues([_this2.selectionStartPos, _this2.selectionStartPos + _this2.selectionWidth].sort(), true);
            } else
              _this2.innerSetValues([0, _this2.selectionStartPos + _this2.selectionWidth], true);
            break;
          default:
            break;
        }
        _this2.prevPos = currPos;
      };
      _this2.onDragEnd = function() {
        document.removeEventListener("pointermove", _this2.onDragging);
        document.removeEventListener("pointermove", _this2.onDragging);
        document.removeEventListener("pointerup", _this2.onDragEnd);
        _this2.target = "";
        _this2.updateHandlesPosition(false);
      };
      _this2.onValueChange = function(oldValue) {
        var _a2 = _this2.attributes, onChange = _a2.onChange, type = _a2.type;
        var internalOldValue = type === "range" ? oldValue : oldValue[1];
        var value2 = type === "range" ? _this2.getValues() : _this2.getValues()[1];
        var evt = new CustomEvent("valuechange", {
          detail: { oldValue: internalOldValue, value: value2 }
        });
        _this2.dispatchEvent(evt);
        onChange === null || onChange === void 0 ? void 0 : onChange(value2);
      };
      _this2.selectionStartPos = 0;
      _this2.selectionWidth = 0;
      _this2.prevPos = 0;
      _this2.target = "";
      return _this2;
    }
    Object.defineProperty(Slider3.prototype, "values", {
      get: function() {
        return this.attributes.values;
      },
      set: function(values4) {
        this.attributes.values = this.clampValues(values4);
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Slider3.prototype, "sparklineStyle", {
      get: function() {
        var orientation = this.attributes.orientation;
        if (orientation !== "horizontal")
          return null;
        var attr2 = subStyleProps(this.attributes, "sparkline");
        return __assign(__assign({ zIndex: 0 }, this.availableSpace), attr2);
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Slider3.prototype, "shape", {
      get: function() {
        var _a2 = this.attributes, trackLength = _a2.trackLength, trackSize = _a2.trackSize;
        var _b = __read(this.getOrientVal([
          [trackLength, trackSize],
          [trackSize, trackLength]
        ]), 2), width = _b[0], height = _b[1];
        return { width, height };
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Slider3.prototype, "availableSpace", {
      get: function() {
        var padding = this.attributes.padding;
        var _a2 = __read(parseSeriesAttr(padding), 4), top = _a2[0], right2 = _a2[1], bottom = _a2[2], left2 = _a2[3];
        var _b = this.shape, width = _b.width, height = _b.height;
        return {
          x: left2,
          y: top,
          width: width - (left2 + right2),
          height: height - (top + bottom)
        };
      },
      enumerable: false,
      configurable: true
    });
    Slider3.prototype.getValues = function() {
      return this.values;
    };
    Slider3.prototype.setValues = function(values4, animate2) {
      if (values4 === void 0) {
        values4 = [0, 0];
      }
      if (animate2 === void 0) {
        animate2 = false;
      }
      this.attributes.values = values4;
      var animation = animate2 === false ? false : this.attributes.animate;
      this.updateSelectionArea(animation);
      this.updateHandlesPosition(animation);
    };
    Slider3.prototype.updateSelectionArea = function(animation) {
      var newSelectionArea = this.calcSelectionArea();
      this.foregroundGroup.selectAll(CLASS_NAMES.selection.class).each(function(datum, index3) {
        transition(this, newSelectionArea[index3], animation);
      });
    };
    Slider3.prototype.updateHandlesPosition = function(animation) {
      if (!this.attributes.showHandle)
        return;
      this.startHandle && transition(this.startHandle, this.getHandleStyle("start"), animation);
      this.endHandle && transition(this.endHandle, this.getHandleStyle("end"), animation);
    };
    Slider3.prototype.innerSetValues = function(values4, trigger) {
      if (values4 === void 0) {
        values4 = [0, 0];
      }
      if (trigger === void 0) {
        trigger = false;
      }
      var oldValues = this.values;
      var newValues = this.clampValues(values4);
      this.attributes.values = newValues;
      this.setValues(newValues);
      if (trigger) {
        this.onValueChange(oldValues);
      }
    };
    Slider3.prototype.renderTrack = function(container) {
      var style = subStyleProps(this.attributes, "track");
      this.trackShape = select2(container).maybeAppendByClassName(CLASS_NAMES.track, "rect").styles(__assign(__assign({}, this.shape), style));
    };
    Slider3.prototype.renderBrushArea = function(container) {
      var brushable = this.attributes.brushable;
      this.brushArea = select2(container).maybeAppendByClassName(CLASS_NAMES.brushArea, "rect").styles(__assign({ fill: "transparent", cursor: brushable ? "crosshair" : "default" }, this.shape));
    };
    Slider3.prototype.renderSparkline = function(container) {
      var _this2 = this;
      var orientation = this.attributes.orientation;
      var sparklineGroup = select2(container).maybeAppendByClassName(CLASS_NAMES.sparklineGroup, "g");
      ifShow(orientation === "horizontal", sparklineGroup, function(group3) {
        var style = _this2.sparklineStyle;
        group3.maybeAppendByClassName(CLASS_NAMES.sparkline, function() {
          return new Sparkline({ style });
        }).update(style);
      });
    };
    Slider3.prototype.renderHandles = function() {
      var _this2 = this;
      var _a2;
      var _b = this.attributes, showHandle = _b.showHandle, type = _b.type;
      var availableHandle = type === "range" ? ["start", "end"] : ["end"];
      var data2 = showHandle ? availableHandle : [];
      var that = this;
      (_a2 = this.foregroundGroup) === null || _a2 === void 0 ? void 0 : _a2.selectAll(CLASS_NAMES.handle.class).data(data2.map(function(type2) {
        return { type: type2 };
      }), function(d2) {
        return d2.type;
      }).join(function(enter) {
        return enter.append(function(_a3) {
          var type2 = _a3.type;
          return new Handle({ style: _this2.getHandleStyle(type2) });
        }).each(function(_a3) {
          var type2 = _a3.type;
          this.attr("class", "".concat(CLASS_NAMES.handle.name, " ").concat(type2, "-handle"));
          var name2 = "".concat(type2, "Handle");
          that[name2] = this;
          this.addEventListener("pointerdown", that.onDragStart(type2));
        });
      }, function(update3) {
        return update3.each(function(_a3) {
          var type2 = _a3.type;
          this.update(that.getHandleStyle(type2));
        });
      }, function(exit) {
        return exit.each(function(_a3) {
          var type2 = _a3.type;
          var name2 = "".concat(type2, "Handle");
          that[name2] = void 0;
        }).remove();
      });
    };
    Slider3.prototype.renderSelection = function(container) {
      var _a2 = this.attributes, type = _a2.type, selectionType = _a2.selectionType;
      this.foregroundGroup = select2(container).maybeAppendByClassName(CLASS_NAMES.foreground, "g");
      var selectionStyle = subStyleProps(this.attributes, "selection");
      var applyStyle4 = function(selection) {
        return selection.style("visibility", function(d2) {
          return d2.show ? "visible" : "hidden";
        }).style("cursor", function(d2) {
          if (selectionType === "select")
            return "grab";
          if (selectionType === "invert")
            return "crosshair";
          return "default";
        }).styles(selectionStyle);
      };
      var that = this;
      this.foregroundGroup.selectAll(CLASS_NAMES.selection.class).data(type === "value" ? [] : this.calcSelectionArea().map(function(area2, index3) {
        return {
          style: __assign({}, area2),
          index: index3,
          // 
          show: selectionType === "select" ? index3 === 1 : index3 !== 1
        };
      }), function(d2) {
        return d2.index;
      }).join(function(enter) {
        return enter.append("rect").attr("className", CLASS_NAMES.selection.name).call(applyStyle4).each(function(datum, index3) {
          var _this2 = this;
          if (index3 === 1) {
            that.selectionShape = select2(this);
            this.on("pointerdown", function(e) {
              _this2.attr("cursor", "grabbing");
              that.onDragStart("selection")(e);
            });
            that.dispatchCustomEvent(this, "pointerenter", "selectionMouseenter");
            that.dispatchCustomEvent(this, "pointerleave", "selectionMouseleave");
            that.dispatchCustomEvent(this, "click", "selectionClick");
            this.addEventListener("pointerdown", function() {
              _this2.attr("cursor", "grabbing");
            });
            this.addEventListener("pointerup", function() {
              _this2.attr("cursor", "pointer");
            });
            this.addEventListener("pointerover", function() {
              _this2.attr("cursor", "pointer");
            });
          } else {
            this.on("pointerdown", that.onDragStart("track"));
          }
        });
      }, function(update3) {
        return update3.call(applyStyle4);
      }, function(exit) {
        return exit.remove();
      });
      this.updateSelectionArea(false);
      this.renderHandles();
    };
    Slider3.prototype.render = function(attributes, container) {
      this.renderTrack(container);
      this.renderSparkline(container);
      this.renderBrushArea(container);
      this.renderSelection(container);
    };
    Slider3.prototype.clampValues = function(values4, precision) {
      var _a2;
      if (precision === void 0) {
        precision = 4;
      }
      var _b = __read(this.range, 2), min11 = _b[0], max11 = _b[1];
      var _c = __read(this.getValues().map(function(num) {
        return toPrecision(num, precision);
      }), 2), prevStart = _c[0], prevEnd = _c[1];
      var internalValues = Array.isArray(values4) ? values4 : [prevStart, values4 !== null && values4 !== void 0 ? values4 : prevEnd];
      var _d = __read((internalValues || [prevStart, prevEnd]).map(function(num) {
        return toPrecision(num, precision);
      }), 2), startVal = _d[0], endVal = _d[1];
      if (this.attributes.type === "value")
        return [0, clamp_default(endVal, min11, max11)];
      if (startVal > endVal) {
        _a2 = __read([endVal, startVal], 2), startVal = _a2[0], endVal = _a2[1];
      }
      var range4 = endVal - startVal;
      if (range4 > max11 - min11)
        return [min11, max11];
      if (startVal < min11) {
        if (prevStart === min11 && prevEnd === endVal)
          return [min11, endVal];
        return [min11, range4 + min11];
      }
      if (endVal > max11) {
        if (prevEnd === max11 && prevStart === startVal)
          return [startVal, max11];
        return [max11 - range4, max11];
      }
      return [startVal, endVal];
    };
    Slider3.prototype.calcSelectionArea = function(values4) {
      var _a2 = __read(this.clampValues(values4), 2), start = _a2[0], end = _a2[1];
      var _b = this.availableSpace, x3 = _b.x, y3 = _b.y, width = _b.width, height = _b.height;
      return this.getOrientVal([
        [
          { y: y3, height, x: x3, width: start * width },
          { y: y3, height, x: start * width + x3, width: (end - start) * width },
          { y: y3, height, x: end * width, width: (1 - end) * width }
        ],
        [
          { x: x3, width, y: y3, height: start * height },
          { x: x3, width, y: start * height + y3, height: (end - start) * height },
          { x: x3, width, y: end * height, height: (1 - end) * height }
        ]
      ]);
    };
    Slider3.prototype.calcHandlePosition = function(handleType) {
      var handleIconOffset = this.attributes.handleIconOffset;
      var _a2 = this.availableSpace, x3 = _a2.x, y3 = _a2.y, width = _a2.width, height = _a2.height;
      var _b = __read(this.clampValues(), 2), stVal = _b[0], endVal = _b[1];
      var offset2 = handleType === "start" ? -handleIconOffset : handleIconOffset;
      var L = (handleType === "start" ? stVal : endVal) * this.getOrientVal([width, height]) + offset2;
      return {
        x: x3 + this.getOrientVal([L, width / 2]),
        y: y3 + this.getOrientVal([height / 2, L])
      };
    };
    Slider3.prototype.inferTextStyle = function(handleType) {
      var orientation = this.attributes.orientation;
      if (orientation === "horizontal")
        return {};
      if (handleType === "start")
        return { transform: "rotate(90)", textAlign: "start" };
      if (handleType === "end")
        return { transform: "rotate(90)", textAlign: "end" };
      return {};
    };
    Slider3.prototype.calcHandleText = function(handleType) {
      var _a2;
      var _b = this.attributes, type = _b.type, orientation = _b.orientation, formatter2 = _b.formatter, autoFitLabel = _b.autoFitLabel;
      var handleStyle = subStyleProps(this.attributes, "handle");
      var labelStyle = subStyleProps(handleStyle, "label");
      var spacing = handleStyle.spacing;
      var size5 = this.getHandleSize();
      var values4 = this.clampValues();
      var value2 = handleType === "start" ? values4[0] : values4[1];
      var text = formatter2(value2);
      var temp = new Text2({
        style: __assign(__assign(__assign({}, labelStyle), this.inferTextStyle(handleType)), { text })
      });
      var _c = temp.getBBox(), textWidth = _c.width, textHeight = _c.height;
      temp.destroy();
      if (!autoFitLabel) {
        if (type === "value")
          return { text, x: 0, y: -textHeight - spacing };
        var finaleWidth = spacing + size5 + (orientation === "horizontal" ? textWidth / 2 : 0);
        return _a2 = { text }, _a2[orientation === "horizontal" ? "x" : "y"] = handleType === "start" ? -finaleWidth : finaleWidth, _a2;
      }
      var x3 = 0;
      var y3 = 0;
      var _d = this.availableSpace, iW = _d.width, iH = _d.height;
      var _e = this.calcSelectionArea()[1], fX = _e.x, fY = _e.y, fW = _e.width, fH = _e.height;
      var totalSpacing = spacing + size5;
      if (orientation === "horizontal") {
        var finalWidth = totalSpacing + textWidth / 2;
        if (handleType === "start") {
          var left2 = fX - totalSpacing - textWidth;
          x3 = left2 > 0 ? -finalWidth : finalWidth;
        } else {
          var sign3 = iW - fX - fW - totalSpacing > textWidth;
          x3 = sign3 ? finalWidth : -finalWidth;
        }
      } else {
        var positiveSize = totalSpacing;
        var negativeSize = textHeight + totalSpacing;
        if (handleType === "start") {
          y3 = fY - size5 > textHeight ? -negativeSize : positiveSize;
        } else {
          y3 = iH - (fY + fH) - size5 > textHeight ? negativeSize : -positiveSize;
        }
      }
      return { x: x3, y: y3, text };
    };
    Slider3.prototype.getHandleLabelStyle = function(handleType) {
      var style = subStyleProps(this.attributes, "handleLabel");
      return __assign(__assign(__assign({}, style), this.calcHandleText(handleType)), this.inferTextStyle(handleType));
    };
    Slider3.prototype.getHandleIconStyle = function() {
      var shape23 = this.attributes.handleIconShape;
      var style = subStyleProps(this.attributes, "handleIcon");
      var cursor = this.getOrientVal(["ew-resize", "ns-resize"]);
      var size5 = this.getHandleSize();
      return __assign({ cursor, shape: shape23, size: size5 }, style);
    };
    Slider3.prototype.getHandleStyle = function(handleType) {
      var _a2 = this.attributes, showLabel = _a2.showLabel, showLabelOnInteraction = _a2.showLabelOnInteraction, orientation = _a2.orientation;
      var handlePosition = this.calcHandlePosition(handleType);
      var textStyle = this.calcHandleText(handleType);
      var internalShowLabel = showLabel;
      if (!showLabel && showLabelOnInteraction) {
        if (this.target)
          internalShowLabel = true;
        else
          internalShowLabel = false;
      }
      return __assign(__assign(__assign(__assign({}, superStyleProps(this.getHandleIconStyle(), "icon")), superStyleProps(__assign(__assign({}, this.getHandleLabelStyle(handleType)), textStyle), "label")), handlePosition), { orientation, showLabel: internalShowLabel, type: handleType, zIndex: 3 });
    };
    Slider3.prototype.getHandleSize = function() {
      var _a2 = this.attributes, size5 = _a2.handleIconSize, width = _a2.width, height = _a2.height;
      if (size5)
        return size5;
      return Math.floor((this.getOrientVal([+height, +width]) + 4) / 2.4);
    };
    Slider3.prototype.getOrientVal = function(_a2) {
      var _b = __read(_a2, 2), x3 = _b[0], y3 = _b[1];
      var orientation = this.attributes.orientation;
      return orientation === "horizontal" ? x3 : y3;
    };
    Slider3.prototype.setValuesOffset = function(stOffset, endOffset, animate2) {
      if (endOffset === void 0) {
        endOffset = 0;
      }
      if (animate2 === void 0) {
        animate2 = false;
      }
      var type = this.attributes.type;
      var _a2 = __read(this.getValues(), 2), oldStartVal = _a2[0], oldEndVal = _a2[1];
      var internalStartOffset = type === "range" ? stOffset : 0;
      var values4 = [oldStartVal + internalStartOffset, oldEndVal + endOffset].sort();
      if (animate2)
        this.setValues(values4);
      else
        this.innerSetValues(values4, true);
    };
    Slider3.prototype.getRatio = function(val) {
      var _a2 = this.availableSpace, width = _a2.width, height = _a2.height;
      return val / this.getOrientVal([width, height]);
    };
    Slider3.prototype.dispatchCustomEvent = function(target, event, name2) {
      var _this2 = this;
      target.on(event, function(e) {
        e.stopPropagation();
        _this2.dispatchEvent(new CustomEvent(name2, { detail: e }));
      });
    };
    Slider3.prototype.bindEvents = function() {
      this.addEventListener("wheel", this.onScroll);
      var brushArea = this.brushArea;
      this.dispatchCustomEvent(brushArea, "click", "trackClick");
      this.dispatchCustomEvent(brushArea, "pointerenter", "trackMouseenter");
      this.dispatchCustomEvent(brushArea, "pointerleave", "trackMouseleave");
      brushArea.on("pointerdown", this.onDragStart("track"));
    };
    Slider3.prototype.onScroll = function(event) {
      var scrollable = this.attributes.scrollable;
      if (scrollable) {
        var deltaX = event.deltaX, deltaY = event.deltaY;
        var offset2 = deltaY || deltaX;
        var deltaVal = this.getRatio(offset2);
        this.setValuesOffset(deltaVal, deltaVal, true);
      }
    };
    Slider3.tag = "slider";
    return Slider3;
  }(Component)
);

// node_modules/@antv/component/esm/ui/scrollbar/index.js
var Scrollbar = (
  /** @class */
  function(_super) {
    __extends(Scrollbar3, _super);
    function Scrollbar3(options) {
      var _this2 = _super.call(this, options, {
        isRound: true,
        orientation: "vertical",
        padding: [2, 2, 2, 2],
        scrollable: true,
        slidable: true,
        thumbCursor: "default",
        trackSize: 10,
        value: 0
      }) || this;
      _this2.range = [0, 1];
      _this2.onValueChange = function(oldValue) {
        var newValue = _this2.attributes.value;
        if (oldValue === newValue)
          return;
        var evtVal = {
          detail: {
            oldValue,
            value: newValue
          }
        };
        _this2.dispatchEvent(new CustomEvent("scroll", evtVal));
        _this2.dispatchEvent(new CustomEvent("valuechange", evtVal));
      };
      _this2.onTrackClick = function(e) {
        var slidable = _this2.attributes.slidable;
        if (!slidable)
          return;
        var _a2 = __read(_this2.getLocalPosition(), 2), x3 = _a2[0], y3 = _a2[1];
        var _b = __read(_this2.padding, 4), top = _b[0], left2 = _b[3];
        var basePos = _this2.getOrientVal([x3 + left2, y3 + top]);
        var clickPos = _this2.getOrientVal(getEventPos(e));
        var value2 = (clickPos - basePos) / _this2.trackLength;
        _this2.setValue(value2, true);
      };
      _this2.onThumbMouseenter = function(e) {
        _this2.dispatchEvent(new CustomEvent("thumbMouseenter", { detail: e.detail }));
      };
      _this2.onTrackMouseenter = function(e) {
        _this2.dispatchEvent(new CustomEvent("trackMouseenter", { detail: e.detail }));
      };
      _this2.onThumbMouseleave = function(e) {
        _this2.dispatchEvent(new CustomEvent("thumbMouseleave", { detail: e.detail }));
      };
      _this2.onTrackMouseleave = function(e) {
        _this2.dispatchEvent(new CustomEvent("trackMouseleave", { detail: e.detail }));
      };
      return _this2;
    }
    Object.defineProperty(Scrollbar3.prototype, "padding", {
      get: function() {
        var padding = this.attributes.padding;
        return parseSeriesAttr(padding);
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Scrollbar3.prototype, "value", {
      get: function() {
        var value2 = this.attributes.value;
        var _a2 = __read(this.range, 2), min11 = _a2[0], max11 = _a2[1];
        return clamp_default(value2, min11, max11);
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Scrollbar3.prototype, "trackLength", {
      get: function() {
        var _a2 = this.attributes, viewportLength = _a2.viewportLength, _b = _a2.trackLength, trackLength = _b === void 0 ? viewportLength : _b;
        return trackLength;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Scrollbar3.prototype, "availableSpace", {
      get: function() {
        var trackSize = this.attributes.trackSize;
        var trackLength = this.trackLength;
        var _a2 = __read(this.padding, 4), top = _a2[0], right2 = _a2[1], bottom = _a2[2], left2 = _a2[3];
        var _b = __read(this.getOrientVal([
          [trackLength, trackSize],
          [trackSize, trackLength]
        ]), 2), width = _b[0], height = _b[1];
        return {
          x: left2,
          y: top,
          width: +width - (left2 + right2),
          height: +height - (top + bottom)
        };
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Scrollbar3.prototype, "trackRadius", {
      get: function() {
        var _a2 = this.attributes, isRound = _a2.isRound, trackSize = _a2.trackSize;
        if (!isRound)
          return 0;
        return trackSize / 2;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Scrollbar3.prototype, "thumbRadius", {
      get: function() {
        var _a2 = this.attributes, isRound = _a2.isRound, thumbRadius = _a2.thumbRadius;
        if (!isRound)
          return 0;
        var _b = this.availableSpace, width = _b.width, height = _b.height;
        return thumbRadius || this.getOrientVal([height, width]) / 2;
      },
      enumerable: false,
      configurable: true
    });
    Scrollbar3.prototype.getValues = function(value2) {
      if (value2 === void 0) {
        value2 = this.value;
      }
      var _a2 = this.attributes, viewportLength = _a2.viewportLength, contentLength = _a2.contentLength;
      var unit = viewportLength / contentLength;
      var _b = __read(this.range, 2), min11 = _b[0], max11 = _b[1];
      var start = value2 * (max11 - min11 - unit);
      return [start, start + unit];
    };
    Scrollbar3.prototype.getValue = function() {
      return this.value;
    };
    Scrollbar3.prototype.renderSlider = function(container) {
      var _a2 = this.attributes, orientation = _a2.orientation, trackSize = _a2.trackSize, padding = _a2.padding, slidable = _a2.slidable;
      var trackStyle = subStyleProps(this.attributes, "track");
      var selectionStyle = subStyleProps(this.attributes, "thumb");
      var style = __assign(__assign({ brushable: false, orientation, padding, selectionRadius: this.thumbRadius, showHandle: false, slidable, trackLength: this.trackLength, trackRadius: this.trackRadius, trackSize, values: this.getValues() }, superStyleProps(trackStyle, "track")), superStyleProps(selectionStyle, "selection"));
      this.slider = select2(container).maybeAppendByClassName("scrollbar", function() {
        return new Slider({ style });
      }).update(style).node();
    };
    Scrollbar3.prototype.render = function(attributes, container) {
      this.renderSlider(container);
    };
    Scrollbar3.prototype.setValue = function(value2, animate2) {
      if (animate2 === void 0) {
        animate2 = false;
      }
      var oldValue = this.attributes.value;
      var _a2 = __read(this.range, 2), min11 = _a2[0], max11 = _a2[1];
      this.slider.setValues(this.getValues(clamp_default(value2, min11, max11)), animate2);
      this.onValueChange(oldValue);
    };
    Scrollbar3.prototype.bindEvents = function() {
      var _this2 = this;
      this.slider.addEventListener("trackClick", function(e) {
        e.stopPropagation();
        _this2.onTrackClick(e.detail);
      });
      this.onHover();
    };
    Scrollbar3.prototype.getOrientVal = function(values4) {
      var orientation = this.attributes.orientation;
      return orientation === "horizontal" ? values4[0] : values4[1];
    };
    Scrollbar3.prototype.onHover = function() {
      this.slider.addEventListener("selectionMouseenter", this.onThumbMouseenter);
      this.slider.addEventListener("trackMouseenter", this.onTrackMouseenter);
      this.slider.addEventListener("selectionMouseleave", this.onThumbMouseleave);
      this.slider.addEventListener("trackMouseleave", this.onTrackMouseleave);
    };
    Scrollbar3.tag = "scrollbar";
    return Scrollbar3;
  }(Component)
);

// node_modules/@antv/component/esm/ui/axis/constant.js
var AXIS_BASE_DEFAULT_ATTR = {
  data: [],
  animate: {
    enter: false,
    update: {
      duration: 100,
      easing: "ease-in-out-sine",
      fill: "both"
    },
    exit: {
      duration: 100,
      fill: "both"
    }
  },
  showArrow: true,
  showGrid: true,
  showLabel: true,
  showLine: true,
  showTick: true,
  showTitle: true,
  showTrunc: false,
  dataThreshold: 100,
  lineLineWidth: 1,
  lineStroke: "black",
  crossPadding: 10,
  titleFill: "black",
  titleFontSize: 12,
  titlePosition: "lb",
  titleSpacing: 0,
  titleTextAlign: "center",
  titleTextBaseline: "middle",
  lineArrow: function() {
    return new Path2({
      style: {
        path: [["M", 10, 10], ["L", -10, 0], ["L", 10, -10], ["L", 0, 0], ["L", 10, 10], ["Z"]],
        anchor: "0.5 0.5",
        fill: "black",
        transformOrigin: "center"
      }
    });
  },
  labelAlign: "parallel",
  labelDirection: "positive",
  labelFontSize: 12,
  labelSpacing: 0,
  gridConnect: "line",
  gridControlAngles: [],
  gridDirection: "positive",
  gridLength: 0,
  gridType: "segment",
  lineArrowOffset: 15,
  lineArrowSize: 10,
  tickDirection: "positive",
  tickLength: 5,
  tickLineWidth: 1,
  tickStroke: "black",
  labelOverlap: [
    // { type: 'rotate', optionalAngles: [0, 45, 90] },
    // { type: 'ellipsis', suffix: '...', minLength: 14, maxLength: 160 },
    // { type: 'hide' },
  ]
};
var ARC_DEFAULT_OPTIONS = deep_mix_default({}, AXIS_BASE_DEFAULT_ATTR, {
  style: {
    type: "arc"
  }
});
var HELIX_DEFAULT_OPTIONS = deep_mix_default({}, AXIS_BASE_DEFAULT_ATTR, {
  style: {}
});
var CLASS_NAMES3 = classNames({
  mainGroup: "main-group",
  gridGroup: "grid-group",
  grid: "grid",
  lineGroup: "line-group",
  line: "line",
  tickGroup: "tick-group",
  tick: "tick",
  tickItem: "tick-item",
  labelGroup: "label-group",
  label: "label",
  labelItem: "label-item",
  titleGroup: "title-group",
  title: "title",
  lineFirst: "line-first",
  lineSecond: "line-second"
}, "axis");

// node_modules/@antv/component/esm/ui/grid/index.js
var CLASS_NAMES4 = classNames({
  lineGroup: "line-group",
  line: "line",
  regionGroup: "region-group",
  region: "region"
}, "grid");
function getStraightPath(points) {
  return points.reduce(function(acc, curr, idx) {
    acc.push(__spreadArray([idx === 0 ? "M" : "L"], __read(curr), false));
    return acc;
  }, []);
}
function getSurroundPath(points, attr2, reversed) {
  var _a2 = attr2.connect, connect = _a2 === void 0 ? "line" : _a2, center2 = attr2.center;
  if (connect === "line")
    return getStraightPath(points);
  if (!center2)
    return [];
  var radius = distance5(points[0], center2);
  var sweepFlag = reversed ? 0 : 1;
  return points.reduce(function(r, p2, idx) {
    if (idx === 0)
      r.push(__spreadArray(["M"], __read(p2), false));
    else
      r.push(__spreadArray(["A", radius, radius, 0, 0, sweepFlag], __read(p2), false));
    return r;
  }, []);
}
function getLinePath(points, cfg, reversed) {
  if (cfg.type === "surround")
    return getSurroundPath(points, cfg, reversed);
  return getStraightPath(points);
}
function connectPaths(from, to, cfg) {
  var type = cfg.type, connect = cfg.connect, center2 = cfg.center, closed = cfg.closed;
  var closeFlag = closed ? [["Z"]] : [];
  var _a2 = __read([getLinePath(from, cfg), getLinePath(to.slice().reverse(), cfg, true)], 2), path1 = _a2[0], path2 = _a2[1];
  var _b = __read([from[0], to.slice(-1)[0]], 2), startOfFrom = _b[0], endOfTo = _b[1];
  var createPath = function(insertA, insertB) {
    return [path1, insertA, path2, insertB, closeFlag].flat();
  };
  if (connect === "line" || type === "surround") {
    return createPath([__spreadArray(["L"], __read(endOfTo), false)], [__spreadArray(["L"], __read(startOfFrom), false)]);
  }
  if (!center2)
    throw new Error("Arc grid need to specified center");
  var _c = __read([distance5(endOfTo, center2), distance5(startOfFrom, center2)], 2), raduis1 = _c[0], radius2 = _c[1];
  return createPath([
    __spreadArray(["A", raduis1, raduis1, 0, 0, 1], __read(endOfTo), false),
    __spreadArray(["L"], __read(endOfTo), false)
  ], [
    __spreadArray(["A", radius2, radius2, 0, 0, 0], __read(startOfFrom), false),
    __spreadArray(["L"], __read(startOfFrom), false)
  ]);
}
function renderGridLine(container, data2, attr2, style) {
  var animate2 = attr2.animate, isBillboard = attr2.isBillboard;
  var lines = data2.map(function(item, idx) {
    return {
      id: item.id || "grid-line-".concat(idx),
      path: getLinePath(item.points, attr2)
    };
  });
  return container.selectAll(CLASS_NAMES4.line.class).data(lines, function(d2) {
    return d2.id;
  }).join(function(enter) {
    return enter.append("path").each(function(datum, index3) {
      var lineStyle = getCallbackValue(getPrimitiveAttributes(__assign({ path: datum.path }, style)), [datum, index3, lines]);
      this.attr(__assign({ class: CLASS_NAMES4.line.name, stroke: "#D9D9D9", lineWidth: 1, lineDash: [4, 4], isBillboard }, lineStyle));
    });
  }, function(update3) {
    return update3.transition(function(datum, index3) {
      var lineStyle = getCallbackValue(getPrimitiveAttributes(__assign({ path: datum.path }, style)), [datum, index3, lines]);
      return transition(this, lineStyle, animate2.update);
    });
  }, function(exit) {
    return exit.transition(function() {
      var _this2 = this;
      var animation = fadeOut_default(this, animate2.exit);
      onAnimateFinished(animation, function() {
        return _this2.remove();
      });
      return animation;
    });
  }).transitions();
}
function renderAlternateRegion(container, data2, style) {
  var animate2 = style.animate, connect = style.connect, areaFill = style.areaFill;
  if (data2.length < 2 || !areaFill || !connect)
    return [];
  var colors = Array.isArray(areaFill) ? areaFill : [areaFill, "transparent"];
  var getColor2 = function(idx2) {
    return colors[idx2 % colors.length];
  };
  var regions = [];
  for (var idx = 0; idx < data2.length - 1; idx++) {
    var _a2 = __read([data2[idx].points, data2[idx + 1].points], 2), prev = _a2[0], curr = _a2[1];
    var path2 = connectPaths(prev, curr, style);
    regions.push({ path: path2, fill: getColor2(idx) });
  }
  return container.selectAll(CLASS_NAMES4.region.class).data(regions, function(_2, i) {
    return i;
  }).join(function(enter) {
    return enter.append("path").each(function(datum, index3) {
      var regionStyle = getCallbackValue(datum, [datum, index3, regions]);
      this.attr(regionStyle);
    }).attr("className", CLASS_NAMES4.region.name);
  }, function(update3) {
    return update3.transition(function(datum, index3) {
      var regionStyle = getCallbackValue(datum, [datum, index3, regions]);
      return transition(this, regionStyle, animate2.update);
    });
  }, function(exit) {
    return exit.transition(function() {
      var _this2 = this;
      var animation = fadeOut_default(this, animate2.exit);
      onAnimateFinished(animation, function() {
        return _this2.remove();
      });
      return animation;
    });
  }).transitions();
}
function getData(attr2) {
  var _a2 = attr2.data, data2 = _a2 === void 0 ? [] : _a2, closed = attr2.closed;
  if (!closed)
    return data2;
  return data2.map(function(datum) {
    var points = datum.points;
    var _a3 = __read(points, 1), start = _a3[0];
    return __assign(__assign({}, datum), { points: __spreadArray(__spreadArray([], __read(points), false), [start], false) });
  });
}
var Grid = (
  /** @class */
  function(_super) {
    __extends(Grid2, _super);
    function Grid2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Grid2.prototype.render = function(attributes, container) {
      var type = attributes.type, center2 = attributes.center, areaFill = attributes.areaFill, closed = attributes.closed, style = __rest(attributes, ["type", "center", "areaFill", "closed"]);
      var data2 = getData(attributes);
      var lineGroup = select2(container).maybeAppendByClassName(CLASS_NAMES4.lineGroup, "g");
      var regionGroup = select2(container).maybeAppendByClassName(CLASS_NAMES4.regionGroup, "g");
      var lineTransitions = renderGridLine(lineGroup, data2, attributes, style);
      var reigionTransitions = renderAlternateRegion(regionGroup, data2, attributes);
      return __spreadArray(__spreadArray([], __read(lineTransitions), false), __read(reigionTransitions), false);
    };
    return Grid2;
  }(Component)
);

// node_modules/@antv/component/esm/ui/axis/guides/utils.js
function getCallbackStyle(style, params) {
  return Object.fromEntries(Object.entries(style).map(function(_a2) {
    var _b = __read(_a2, 2), key = _b[0], val = _b[1];
    return [key, getCallbackValue(val, params)];
  }));
}
function filterExec(data2, filter4) {
  return !!filter4 && is_function_default(filter4) ? data2.filter(filter4) : data2;
}
function getLineAngle(value2, attr2) {
  var startAngle = attr2.startAngle, endAngle = attr2.endAngle;
  return (endAngle - startAngle) * value2 + startAngle;
}
function getLineTangentVector(value2, attr2) {
  if (attr2.type === "linear") {
    var _a2 = __read(attr2.startPos, 2), startX = _a2[0], startY = _a2[1], _b = __read(attr2.endPos, 2), endX = _b[0], endY = _b[1];
    var _c = __read([endX - startX, endY - startY], 2), dx = _c[0], dy = _c[1];
    return normalize7([dx, dy]);
  }
  var angle4 = degToRad(getLineAngle(value2, attr2));
  return [-Math.sin(angle4), Math.cos(angle4)];
}
function getDirectionVector(value2, direction3, attr2) {
  var tangentVector = getLineTangentVector(value2, attr2);
  return vertical2(tangentVector, direction3 !== "positive");
}
function getLabelVector(value2, attr2) {
  return getDirectionVector(value2, attr2.labelDirection, attr2);
}

// node_modules/@antv/component/esm/ui/axis/guides/line.js
function getLinearValuePos(value2, attr2) {
  var _a2 = __read(attr2.startPos, 2), sx = _a2[0], sy = _a2[1], _b = __read(attr2.endPos, 2), ex = _b[0], ey = _b[1];
  var _c = __read([ex - sx, ey - sy], 2), dx = _c[0], dy = _c[1];
  return [sx + dx * value2, sy + dy * value2];
}
function getArcValuePos(value2, attr2) {
  var radius = attr2.radius, _a2 = __read(attr2.center, 2), cx = _a2[0], cy = _a2[1];
  var angle4 = degToRad(getLineAngle(value2, attr2));
  return [cx + radius * Math.cos(angle4), cy + radius * Math.sin(angle4)];
}
function getValuePos(value2, attr2) {
  if (attr2.type === "linear")
    return getLinearValuePos(value2, attr2);
  return getArcValuePos(value2, attr2);
}
function isAxisHorizontal(attr2) {
  return getLineTangentVector(0, attr2)[1] === 0;
}
function isAxisVertical(attr2) {
  return getLineTangentVector(0, attr2)[0] === 0;
}
function isCircle(startAngle, endAngle) {
  return endAngle - startAngle === 360;
}
function getArcPath(startAngle, endAngle, cx, cy, radius) {
  var diffAngle = endAngle - startAngle;
  var _a2 = __read([radius, radius], 2), rx = _a2[0], ry = _a2[1];
  var _b = __read([degToRad(startAngle), degToRad(endAngle)], 2), startAngleRadians = _b[0], endAngleRadians = _b[1];
  var getPosByAngle = function(angle4) {
    return [cx + radius * Math.cos(angle4), cy + radius * Math.sin(angle4)];
  };
  var _c = __read(getPosByAngle(startAngleRadians), 2), x12 = _c[0], y12 = _c[1];
  var _d = __read(getPosByAngle(endAngleRadians), 2), x22 = _d[0], y22 = _d[1];
  if (isCircle(startAngle, endAngle)) {
    var middleAngleRadians = (endAngleRadians + startAngleRadians) / 2;
    var _e = __read(getPosByAngle(middleAngleRadians), 2), xm = _e[0], ym = _e[1];
    return [
      ["M", x12, y12],
      ["A", rx, ry, 0, 1, 0, xm, ym],
      ["A", rx, ry, 0, 1, 0, x22, y22]
    ];
  }
  var large = diffAngle > 180 ? 1 : 0;
  var sweep = startAngle > endAngle ? 0 : 1;
  var isClosePath = false;
  return isClosePath ? "M".concat(cx, ",").concat(cy, ",L").concat(x12, ",").concat(y12, ",A").concat(rx, ",").concat(ry, ",0,").concat(large, ",").concat(sweep, ",").concat(x22, ",").concat(y22, ",L").concat(cx, ",").concat(cy) : "M".concat(x12, ",").concat(y12, ",A").concat(rx, ",").concat(ry, ",0,").concat(large, ",").concat(sweep, ",").concat(x22, ",").concat(y22);
}
function getArcAttr(arc) {
  var _a2 = arc.attributes, startAngle = _a2.startAngle, endAngle = _a2.endAngle, center2 = _a2.center, radius = _a2.radius;
  return __spreadArray(__spreadArray([startAngle, endAngle], __read(center2), false), [radius], false);
}
function renderArc(container, attr2, style, animate2) {
  var startAngle = attr2.startAngle, endAngle = attr2.endAngle, center2 = attr2.center, radius = attr2.radius;
  return container.selectAll(CLASS_NAMES3.line.class).data([{ path: getArcPath.apply(void 0, __spreadArray(__spreadArray([startAngle, endAngle], __read(center2), false), [radius], false)) }], function(d2, i) {
    return i;
  }).join(function(enter) {
    return enter.append("path").attr("className", CLASS_NAMES3.line.name).styles(attr2).styles({ path: function(d2) {
      return d2.path;
    } });
  }, function(update3) {
    return update3.transition(function() {
      var _this2 = this;
      var animation = keyframeInterpolate(this, getArcAttr(this), __spreadArray(__spreadArray([startAngle, endAngle], __read(center2), false), [radius], false), animate2.update);
      if (animation) {
        var layout = function() {
          var data2 = get_default(_this2.attributes, "__keyframe_data__");
          _this2.style.path = getArcPath.apply(void 0, __spreadArray([], __read(data2), false));
        };
        animation.onframe = layout;
        animation.onfinish = layout;
      }
      return animation;
    }).styles(attr2);
  }, function(exit) {
    return exit.remove();
  }).styles(style).transitions();
}
function renderTruncation(container, _a2) {
  var truncRange = _a2.truncRange, truncShape = _a2.truncShape, lineExtension = _a2.lineExtension;
}
function extendLine(startPos, endPos, range4) {
  if (range4 === void 0) {
    range4 = [0, 0];
  }
  var _a2 = __read([startPos, endPos, range4], 3), _b = __read(_a2[0], 2), x12 = _b[0], y12 = _b[1], _c = __read(_a2[1], 2), x22 = _c[0], y22 = _c[1], _d = __read(_a2[2], 2), l1 = _d[0], l2 = _d[1];
  var _e = __read([x22 - x12, y22 - y12], 2), x3 = _e[0], y3 = _e[1];
  var L = Math.sqrt(Math.pow(x3, 2) + Math.pow(y3, 2));
  var _f = __read([-l1 / L, l2 / L], 2), s1 = _f[0], s2 = _f[1];
  return [s1 * x3, s1 * y3, s2 * x3, s2 * y3];
}
function getLinePath2(points) {
  var _a2 = __read(points, 2), _b = __read(_a2[0], 2), x12 = _b[0], y12 = _b[1], _c = __read(_a2[1], 2), x22 = _c[0], y22 = _c[1];
  return { x1: x12, y1: y12, x2: x22, y2: y22 };
}
function renderLinear(container, attr2, style, animate2) {
  var showTrunc = attr2.showTrunc, startPos = attr2.startPos, endPos = attr2.endPos, truncRange = attr2.truncRange, lineExtension = attr2.lineExtension;
  var _a2 = __read([startPos, endPos], 2), _b = __read(_a2[0], 2), x12 = _b[0], y12 = _b[1], _c = __read(_a2[1], 2), x22 = _c[0], y22 = _c[1];
  var _d = __read(lineExtension ? extendLine(startPos, endPos, lineExtension) : new Array(4).fill(0), 4), ox1 = _d[0], oy1 = _d[1], ox2 = _d[2], oy2 = _d[3];
  var renderLine = function(data2) {
    return container.selectAll(CLASS_NAMES3.line.class).data(data2, function(d2, i) {
      return i;
    }).join(function(enter) {
      return enter.append("line").attr("className", function(d2) {
        return "".concat(CLASS_NAMES3.line.name, " ").concat(d2.className);
      }).styles(style).transition(function(d2) {
        return transition(this, getLinePath2(d2.line), false);
      });
    }, function(update3) {
      return update3.styles(style).transition(function(_a3) {
        var line4 = _a3.line;
        return transition(this, getLinePath2(line4), animate2.update);
      });
    }, function(exit) {
      return exit.remove();
    }).transitions();
  };
  if (!showTrunc || !truncRange) {
    return renderLine([
      {
        line: [
          [x12 + ox1, y12 + oy1],
          [x22 + ox2, y22 + oy2]
        ],
        className: CLASS_NAMES3.line.name
      }
    ]);
  }
  var _e = __read(truncRange, 2), r1 = _e[0], r2 = _e[1];
  var dx = x22 - x12;
  var dy = y22 - y12;
  var _f = __read([x12 + dx * r1, y12 + dy * r1], 2), x3 = _f[0], y3 = _f[1];
  var _g = __read([x12 + dx * r2, y12 + dy * r2], 2), x4 = _g[0], y4 = _g[1];
  var animation = renderLine([
    {
      line: [
        [x12 + ox1, y12 + oy1],
        [x3, y3]
      ],
      className: CLASS_NAMES3.lineFirst.name
    },
    {
      line: [
        [x4, y4],
        [x22 + ox2, y22 + oy2]
      ],
      className: CLASS_NAMES3.lineSecond.name
    }
  ]);
  renderTruncation(container, attr2);
  return animation;
}
function renderAxisArrow(container, type, attr2, style) {
  var showArrow = attr2.showArrow, showTrunc = attr2.showTrunc, lineArrow = attr2.lineArrow, lineArrowOffset = attr2.lineArrowOffset, lineArrowSize = attr2.lineArrowSize;
  var shapeToAddArrow;
  if (type === "arc")
    shapeToAddArrow = container.select(CLASS_NAMES3.line.class);
  else if (showTrunc)
    shapeToAddArrow = container.select(CLASS_NAMES3.lineSecond.class);
  else
    shapeToAddArrow = container.select(CLASS_NAMES3.line.class);
  if (!showArrow || !lineArrow || attr2.type === "arc" && isCircle(attr2.startAngle, attr2.endAngle)) {
    var node = shapeToAddArrow.node();
    if (node)
      node.style.markerEnd = void 0;
    return;
  }
  var arrow2 = renderExtDo(lineArrow);
  arrow2.attr(style);
  scaleToPixel(arrow2, lineArrowSize, true);
  shapeToAddArrow.style("markerEnd", arrow2).style("markerEndOffset", -lineArrowOffset);
}
function renderAxisLine(container, attr2, animate2) {
  var type = attr2.type;
  var animation;
  var style = subStyleProps(attr2, "line");
  if (type === "linear")
    animation = renderLinear(container, attr2, omit(style, "arrow"), animate2);
  else
    animation = renderArc(container, attr2, omit(style, "arrow"), animate2);
  renderAxisArrow(container, type, attr2, style);
  return animation;
}

// node_modules/@antv/component/esm/ui/axis/guides/grid.js
function getGridVector(value2, attr2) {
  return getDirectionVector(value2, attr2.gridDirection, attr2);
}
function getGridCenter(attr2) {
  var type = attr2.type, gridCenter = attr2.gridCenter;
  if (type === "linear")
    return gridCenter;
  return gridCenter || attr2.center;
}
function renderStraight(data2, attr2) {
  var gridLength = attr2.gridLength;
  return data2.map(function(_a2, index3) {
    var value2 = _a2.value;
    var _b = __read(getValuePos(value2, attr2), 2), x3 = _b[0], y3 = _b[1];
    var _c = __read(scale7(getGridVector(value2, attr2), gridLength), 2), dx = _c[0], dy = _c[1];
    return {
      id: index3,
      points: [
        [x3, y3],
        [x3 + dx, y3 + dy]
      ]
    };
  });
}
function renderSurround(data2, attr2) {
  var controlAngles = attr2.gridControlAngles;
  var center2 = getGridCenter(attr2);
  if (!center2)
    throw new Error("grid center is not provide");
  if (data2.length < 2)
    throw new Error("Invalid grid data");
  if (!controlAngles || controlAngles.length === 0)
    throw new Error("Invalid gridControlAngles");
  var _a2 = __read(center2, 2), cx = _a2[0], cy = _a2[1];
  return data2.map(function(_a3, index3) {
    var value2 = _a3.value;
    var _b = __read(getValuePos(value2, attr2), 2), sx = _b[0], sy = _b[1];
    var _c = __read([sx - cx, sy - cy], 2), dx = _c[0], dy = _c[1];
    var points = [];
    controlAngles.forEach(function(angle4) {
      var angleInRad = degToRad(angle4);
      var _a4 = __read([Math.cos(angleInRad), Math.sin(angleInRad)], 2), cosa = _a4[0], sina = _a4[1];
      var x3 = dx * cosa - dy * sina + cx;
      var y3 = dx * sina + dy * cosa + cy;
      points.push([x3, y3]);
    });
    return { points, id: index3 };
  });
}
function renderGrid(container, data2, attr2, animate2) {
  var gridAttr = subStyleProps(attr2, "grid");
  var type = gridAttr.type, areaFill = gridAttr.areaFill;
  var center2 = getGridCenter(attr2);
  var finalData = filterExec(data2, attr2.gridFilter);
  var gridItems = type === "segment" ? renderStraight(finalData, attr2) : renderSurround(finalData, attr2);
  var style = __assign(__assign({}, gridAttr), { center: center2, areaFill: is_function_default(areaFill) ? finalData.map(function(datum, index3) {
    return getCallbackValue(areaFill, [datum, index3, finalData]);
  }) : areaFill, animate: animate2, data: gridItems });
  return container.selectAll(CLASS_NAMES3.grid.class).data([1]).join(function(enter) {
    return enter.append(function() {
      return new Grid({ style });
    }).attr("className", CLASS_NAMES3.grid.name);
  }, function(update3) {
    return update3.transition(function() {
      return this.update(style);
    });
  }, function(exit) {
    return exit.remove();
  }).transitions();
}

// node_modules/@antv/component/esm/ui/axis/utils/bounds.js
var Bounds = (
  /** @class */
  function() {
    function Bounds2(x12, y12, x22, y22) {
      this.set(x12, y12, x22, y22);
    }
    Object.defineProperty(Bounds2.prototype, "left", {
      get: function() {
        return this.x1;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Bounds2.prototype, "top", {
      get: function() {
        return this.y1;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Bounds2.prototype, "right", {
      get: function() {
        return this.x2;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Bounds2.prototype, "bottom", {
      get: function() {
        return this.y2;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Bounds2.prototype, "width", {
      get: function() {
        return this.defined("x2") && this.defined("x1") ? this.x2 - this.x1 : void 0;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Bounds2.prototype, "height", {
      get: function() {
        return this.defined("y2") && this.defined("y1") ? this.y2 - this.y1 : void 0;
      },
      enumerable: false,
      configurable: true
    });
    Bounds2.prototype.rotatedPoints = function(radian, x3, y3) {
      var _a2 = this, x12 = _a2.x1, y12 = _a2.y1, x22 = _a2.x2, y22 = _a2.y2;
      var cos4 = Math.cos(radian);
      var sin3 = Math.sin(radian);
      var cx = x3 - x3 * cos4 + y3 * sin3;
      var cy = y3 - x3 * sin3 - y3 * cos4;
      var points = [
        [cos4 * x12 - sin3 * y22 + cx, sin3 * x12 + cos4 * y22 + cy],
        [cos4 * x22 - sin3 * y22 + cx, sin3 * x22 + cos4 * y22 + cy],
        [cos4 * x12 - sin3 * y12 + cx, sin3 * x12 + cos4 * y12 + cy],
        [cos4 * x22 - sin3 * y12 + cx, sin3 * x22 + cos4 * y12 + cy]
      ];
      return points;
    };
    Bounds2.prototype.set = function(x12, y12, x22, y22) {
      if (x22 < x12) {
        this.x2 = x12;
        this.x1 = x22;
      } else {
        this.x1 = x12;
        this.x2 = x22;
      }
      if (y22 < y12) {
        this.y2 = y12;
        this.y1 = y22;
      } else {
        this.y1 = y12;
        this.y2 = y22;
      }
      return this;
    };
    Bounds2.prototype.defined = function(key) {
      return this[key] !== Number.MAX_VALUE && this[key] !== -Number.MAX_VALUE;
    };
    return Bounds2;
  }()
);
function getBounds(item, margin) {
  var angle4 = item.getEulerAngles() || 0;
  item.setEulerAngles(0);
  var _a2 = item.getLocalBounds(), _b = __read(_a2.min, 2), x3 = _b[0], y3 = _b[1], _c = __read(_a2.max, 2), right2 = _c[0], bottom = _c[1];
  var _d = getBBox(item), w = _d.width, h = _d.height;
  var height = h;
  var dx = 0;
  var dy = 0;
  var anchorX = x3;
  var anchorY = y3;
  var text = textOf(item);
  if (text) {
    height -= 1.5;
    var a4 = text.style.textAlign;
    var b_1 = text.style.textBaseline;
    if (a4 === "center") {
      anchorX = (x3 + right2) / 2;
    } else if (a4 === "right" || a4 === "end") {
      anchorX = right2;
    } else {
    }
    if (b_1 === "middle") {
      anchorY = (y3 + bottom) / 2;
    } else if (b_1 === "bottom") {
      anchorY = bottom;
    }
  }
  var _e = __read(parseSeriesAttr(margin), 4), _f = _e[0], t = _f === void 0 ? 0 : _f, _g = _e[1], r = _g === void 0 ? 0 : _g, _h = _e[2], b = _h === void 0 ? t : _h, _j = _e[3], l = _j === void 0 ? r : _j;
  var bounds = new Bounds((dx += x3) - l, (dy += y3) - t, dx + w + r, dy + height + b);
  item.setEulerAngles(angle4);
  return bounds.rotatedPoints(degToRad(angle4), anchorX, anchorY);
}
function getBBox(shape23) {
  if (shape23.__bbox__)
    return shape23.__bbox__;
  return shape23.getBBox();
}

// node_modules/@antv/component/esm/ui/axis/utils/contain.js
function onLine(line4, point7) {
  return point7[0] <= Math.max(line4[0][0], line4[1][0]) && point7[0] <= Math.min(line4[0][0], line4[1][0]) && point7[1] <= Math.max(line4[0][1], line4[1][1]) && point7[1] <= Math.min(line4[0][1], line4[1][1]);
}
function direction2(a4, b, c5) {
  var val = (b[1] - a4[1]) * (c5[0] - b[0]) - (b[0] - a4[0]) * (c5[1] - b[1]);
  if (val === 0)
    return 0;
  return val < 0 ? 2 : 1;
}
function isIntersect(line1, line22) {
  var dir1 = direction2(line1[0], line1[1], line22[0]);
  var dir2 = direction2(line1[0], line1[1], line22[1]);
  var dir3 = direction2(line22[0], line22[1], line1[0]);
  var dir4 = direction2(line22[0], line22[1], line1[1]);
  if (dir1 !== dir2 && dir3 !== dir4)
    return true;
  if (dir1 === 0 && onLine(line1, line22[0]))
    return true;
  if (dir2 === 0 && onLine(line1, line22[1]))
    return true;
  if (dir3 === 0 && onLine(line22, line1[0]))
    return true;
  if (dir4 === 0 && onLine(line22, line1[1]))
    return true;
  return false;
}
function isPointInsideRectangle(polygon, point7) {
  var n = polygon.length;
  if (n < 3)
    return false;
  var lineToInfinity = [point7, [9999, point7[1]]];
  var count4 = 0;
  var i = 0;
  do {
    var side = [polygon[i], polygon[(i + 1) % n]];
    if (isIntersect(side, lineToInfinity)) {
      if (direction2(side[0], point7, side[1]) === 0)
        return onLine(side, point7);
      count4++;
    }
    i = (i + 1) % n;
  } while (i !== 0);
  return !!(count4 & 1);
}
function isRectangleBInsideA(rectA, rectB) {
  return rectB.every(function(point7) {
    return isPointInsideRectangle(rectA, point7);
  });
}
function contain(container, child, margin) {
  var x12 = container.x1, x22 = container.x2, y12 = container.y1, y22 = container.y2;
  var parent2 = [
    [x12, y12],
    [x22, y12],
    [x22, y22],
    [x12, y22]
  ];
  var element = getBounds(child, margin);
  return isRectangleBInsideA(parent2, element);
}

// node_modules/@antv/component/esm/ui/axis/utils/intersect.js
function lineToLine(line1, line22) {
  var _a2 = __read(line1, 4), x05 = _a2[0], y05 = _a2[1], x12 = _a2[2], y12 = _a2[3];
  var _b = __read(line22, 4), x22 = _b[0], y22 = _b[1], x3 = _b[2], y3 = _b[3];
  var s10x = x12 - x05;
  var s10y = y12 - y05;
  var s32x = x3 - x22;
  var s32y = y3 - y22;
  var denom = s10x * s32y - s32x * s10y;
  if (denom === 0)
    return false;
  var denomPositive = denom > 0;
  var s02x = x05 - x22;
  var s02y = y05 - y22;
  var sNum = s10x * s02y - s10y * s02x;
  if (sNum < 0 === denomPositive)
    return false;
  var tNum = s32x * s02y - s32y * s02x;
  if (tNum < 0 === denomPositive)
    return false;
  if (sNum > denom === denomPositive || tNum > denom === denomPositive)
    return false;
  return true;
}
function intersectBoxLine(box2, line4) {
  var lines = [
    [box2[0], box2[1], box2[2], box2[3]],
    [box2[2], box2[3], box2[4], box2[5]],
    [box2[4], box2[5], box2[6], box2[7]],
    [box2[6], box2[7], box2[0], box2[1]]
  ];
  return lines.some(function(boxLine) {
    return lineToLine(line4, boxLine);
  });
}
function intersect2(a4, b, margin) {
  var e_1, _a2;
  var p2 = getBounds(a4, margin).flat(1);
  var q = getBounds(b, margin).flat(1);
  var linesP = [
    [p2[0], p2[1], p2[2], p2[3]],
    [p2[0], p2[1], p2[4], p2[5]],
    [p2[4], p2[5], p2[6], p2[7]],
    [p2[2], p2[3], p2[6], p2[7]]
  ];
  try {
    for (var linesP_1 = __values(linesP), linesP_1_1 = linesP_1.next(); !linesP_1_1.done; linesP_1_1 = linesP_1.next()) {
      var line4 = linesP_1_1.value;
      if (intersectBoxLine(q, line4))
        return true;
    }
  } catch (e_1_1) {
    e_1 = { error: e_1_1 };
  } finally {
    try {
      if (linesP_1_1 && !linesP_1_1.done && (_a2 = linesP_1.return))
        _a2.call(linesP_1);
    } finally {
      if (e_1)
        throw e_1.error;
    }
  }
  return false;
}

// node_modules/@antv/component/esm/ui/axis/utils/test.js
function createCrossBBox(attr2, padding) {
  var type = attr2.type, labelDirection = attr2.labelDirection, crossSize = attr2.crossSize;
  if (!crossSize)
    return false;
  if (type === "arc") {
    var center2 = attr2.center, radius = attr2.radius;
    var _a2 = __read(center2, 2), cx = _a2[0], cy = _a2[1];
    var size5 = labelDirection === "negative" ? 0 : crossSize;
    var dMin = -radius - size5;
    var dMax = radius + size5;
    var _b = __read(parseSeriesAttr(padding), 4), top_1 = _b[0], right_1 = _b[1], bottom_1 = _b[2], left_1 = _b[3];
    return new Bounds(cx + dMin - left_1, cy + dMin - top_1, cx + dMax + right_1, cy + dMax + bottom_1);
  }
  var _c = __read(attr2.startPos, 2), sx = _c[0], sy = _c[1], _d = __read(attr2.endPos, 2), ex = _d[0], ey = _d[1];
  var _e = __read(isAxisVertical(attr2) ? [-padding, 0, padding, 0] : [0, padding, 0, -padding], 4), top = _e[0], right2 = _e[1], bottom = _e[2], left2 = _e[3];
  var labelVector = getLabelVector(0, attr2);
  var diff = scale7(labelVector, crossSize);
  var bbox = new Bounds(sx, sy, ex, ey);
  bbox.x1 += left2;
  bbox.y1 += top;
  bbox.x2 += right2 + diff[0];
  bbox.y2 += bottom + diff[1];
  return bbox;
}
function boundTest(items, attr2, margin) {
  var e_1, _a2;
  var crossPadding = attr2.crossPadding;
  var resultSet = /* @__PURE__ */ new Set();
  var prev = null;
  var crossBBox = createCrossBBox(attr2, crossPadding);
  var testContain = function(item) {
    if (crossBBox)
      return contain(crossBBox, item);
    return true;
  };
  var testIntersect = function(prevItem, currItem) {
    if (!prevItem)
      return true;
    return !intersect2(prevItem, currItem, parseSeriesAttr(margin));
  };
  try {
    for (var items_1 = __values(items), items_1_1 = items_1.next(); !items_1_1.done; items_1_1 = items_1.next()) {
      var curr = items_1_1.value;
      if (!testContain(curr)) {
        resultSet.add(curr);
      } else if (!prev || testIntersect(prev, curr)) {
        prev = curr;
      } else {
        resultSet.add(prev);
        resultSet.add(curr);
      }
    }
  } catch (e_1_1) {
    e_1 = { error: e_1_1 };
  } finally {
    try {
      if (items_1_1 && !items_1_1.done && (_a2 = items_1.return))
        _a2.call(items_1);
    } finally {
      if (e_1)
        throw e_1.error;
    }
  }
  return Array.from(resultSet);
}

// node_modules/@antv/component/esm/ui/axis/overlap/autoEllipsis.js
function parseLengthString(str7, font) {
  if (font === void 0) {
    font = {};
  }
  if (is_nil_default(str7))
    return 0;
  if (typeof str7 === "number")
    return str7;
  return Math.floor(measureTextWidth(str7, font));
}
function ellipseLabels(labels, overlapCfg, attr2, utils) {
  if (labels.length <= 1)
    return;
  var _a2 = overlapCfg.suffix, suffix = _a2 === void 0 ? "..." : _a2, minLength = overlapCfg.minLength, _b = overlapCfg.maxLength, maxLength = _b === void 0 ? Infinity : _b, _c = overlapCfg.step, ellipsisStep = _c === void 0 ? " " : _c, _d = overlapCfg.margin, margin = _d === void 0 ? [0, 0, 0, 0] : _d;
  var font = getFont(utils.getTextShape(labels[0]));
  var step2 = parseLengthString(ellipsisStep, font);
  var min11 = minLength ? parseLengthString(minLength, font) : step2;
  var max11 = parseLengthString(maxLength, font);
  if (is_nil_default(max11) || max11 === Infinity) {
    max11 = Math.max.apply(null, labels.map(function(d2) {
      return getBBox(d2).width;
    }));
  }
  var source = labels.slice();
  var _e = __read(margin, 4), _f = _e[0], top = _f === void 0 ? 0 : _f, _g = _e[1], right2 = _g === void 0 ? 0 : _g, _h = _e[2], bottom = _h === void 0 ? top : _h, _j = _e[3], left2 = _j === void 0 ? right2 : _j;
  var _loop_1 = function(allowedLength2) {
    source.forEach(function(label) {
      utils.ellipsis(utils.getTextShape(label), allowedLength2, suffix);
    });
    source = boundTest(labels, attr2, margin);
    if (source.length < 1)
      return { value: void 0 };
  };
  for (var allowedLength = max11; allowedLength > min11 + step2; allowedLength -= step2) {
    var state_1 = _loop_1(allowedLength);
    if (typeof state_1 === "object")
      return state_1.value;
  }
}

// node_modules/@antv/component/esm/ui/axis/overlap/autoHide.js
var methods = {
  parity: function(items, _a2) {
    var _b = _a2.seq, seq = _b === void 0 ? 2 : _b;
    return items.filter(function(item, i) {
      return i % seq ? (hide(item), false) : true;
    });
  }
};
var filterDefined = function(arr) {
  return arr.filter(defined2);
};
function hideLabels(labels, overlapCfg, attr2, utils) {
  var count4 = labels.length;
  var keepHeader = overlapCfg.keepHeader, keepTail = overlapCfg.keepTail;
  if (count4 <= 1 || count4 === 2 && keepHeader && keepTail)
    return;
  var parityHide = methods.parity;
  var reset = function(els) {
    return els.forEach(utils.show), els;
  };
  var seq = 2;
  var source = labels.slice();
  var target = labels.slice();
  var minLabelWidth = Math.min.apply(Math, __spreadArray([1], __read(labels.map(function(d2) {
    return getBBox(d2).width;
  })), false));
  if (attr2.type === "linear" && (isAxisHorizontal(attr2) || isAxisVertical(attr2))) {
    var minX = getLocalBBox(labels[0]).left;
    var maxX = getLocalBBox(labels[count4 - 1]).right;
    var distance7 = Math.abs(maxX - minX) || 1;
    seq = Math.max(Math.floor(count4 * minLabelWidth / distance7), seq);
  }
  var first3;
  var last7;
  if (keepHeader)
    first3 = source.splice(0, 1)[0];
  if (keepTail) {
    last7 = source.splice(-1, 1)[0];
    source.reverse();
  }
  reset(source);
  while (seq < labels.length && boundTest(filterDefined(last7 ? __spreadArray(__spreadArray([last7], __read(target), false), [first3], false) : __spreadArray([first3], __read(target), false)), attr2, overlapCfg === null || overlapCfg === void 0 ? void 0 : overlapCfg.margin).length) {
    if (last7 && !first3 && seq % 2 === 0) {
      var rest2 = source.splice(0, 1);
      rest2.forEach(utils.hide);
    } else if (last7 && first3) {
      var rest2 = source.splice(0, 1);
      rest2.forEach(utils.hide);
    }
    target = parityHide(reset(source), { seq });
    seq++;
  }
}

// node_modules/@antv/component/esm/ui/axis/overlap/autoRotate.js
function rotateLabels(labels, overlapCfg, attr2, utils) {
  var e_1, _a2;
  var _b = overlapCfg.optionalAngles, optionalAngles = _b === void 0 ? [0, 45, 90] : _b, margin = overlapCfg.margin, _c = overlapCfg.recoverWhenFailed, recoverWhenFailed = _c === void 0 ? true : _c;
  var defaultAngles = labels.map(function(label) {
    return label.getLocalEulerAngles();
  });
  var runAndPassed = function() {
    return boundTest(labels, attr2, margin).length < 1;
  };
  var setLabelsRotate = function(angle5) {
    return labels.forEach(function(label, index3) {
      var rotate6 = Array.isArray(angle5) ? angle5[index3] : angle5;
      utils.rotate(label, +rotate6);
    });
  };
  try {
    for (var optionalAngles_1 = __values(optionalAngles), optionalAngles_1_1 = optionalAngles_1.next(); !optionalAngles_1_1.done; optionalAngles_1_1 = optionalAngles_1.next()) {
      var angle4 = optionalAngles_1_1.value;
      setLabelsRotate(angle4);
      if (runAndPassed())
        return;
    }
  } catch (e_1_1) {
    e_1 = { error: e_1_1 };
  } finally {
    try {
      if (optionalAngles_1_1 && !optionalAngles_1_1.done && (_a2 = optionalAngles_1.return))
        _a2.call(optionalAngles_1);
    } finally {
      if (e_1)
        throw e_1.error;
    }
  }
  if (recoverWhenFailed) {
    setLabelsRotate(defaultAngles);
  }
}

// node_modules/@antv/component/esm/ui/axis/overlap/autoWrap.js
function inferTextBaseline(attr2) {
  var type = attr2.type, labelDirection = attr2.labelDirection;
  if (type === "linear" && isAxisHorizontal(attr2)) {
    return labelDirection === "negative" ? "bottom" : "top";
  }
  return "middle";
}
function wrapLabels(labels, overlapCfg, attr2, utils) {
  var _a2 = overlapCfg.wordWrapWidth, wordWrapWidth = _a2 === void 0 ? 50 : _a2, _b = overlapCfg.maxLines, maxLines = _b === void 0 ? 3 : _b, _c = overlapCfg.recoverWhenFailed, recoverWhenFailed = _c === void 0 ? true : _c, _d = overlapCfg.margin, margin = _d === void 0 ? [0, 0, 0, 0] : _d;
  var defaultLines = labels.map(function(label) {
    return label.attr("maxLines") || 1;
  });
  var minLines = Math.min.apply(Math, __spreadArray([], __read(defaultLines), false));
  var runAndPassed = function() {
    return boundTest(labels, attr2, margin).length < 1;
  };
  var textBaseline = inferTextBaseline(attr2);
  var setLabelsWrap = function(lines2) {
    return labels.forEach(function(label, index3) {
      var maxLines2 = Array.isArray(lines2) ? lines2[index3] : lines2;
      utils.wrap(label, wordWrapWidth, maxLines2, textBaseline);
    });
  };
  if (minLines > maxLines)
    return;
  for (var lines = minLines; lines <= maxLines; lines++) {
    setLabelsWrap(lines);
    if (runAndPassed())
      return;
  }
  if (recoverWhenFailed) {
    setLabelsWrap(defaultLines);
  }
}

// node_modules/@antv/component/esm/ui/axis/overlap/index.js
var OverlapUtils = /* @__PURE__ */ new Map([
  ["hide", hideLabels],
  ["rotate", rotateLabels],
  ["ellipsis", ellipseLabels],
  ["wrap", wrapLabels]
]);
function canProcessOverlap(labels, attr2, type) {
  if (attr2.labelOverlap.length < 1)
    return false;
  if (type === "hide")
    return !isInOffscreenGroup(labels[0]);
  if (type === "rotate")
    return !labels.some(function(label) {
      var _a2;
      return !!((_a2 = label.attr("transform")) === null || _a2 === void 0 ? void 0 : _a2.includes("rotate"));
    });
  if (type === "ellipsis" || type === "wrap")
    return labels.filter(function(item) {
      return item.querySelector("text");
    }).length > 1;
  return true;
}
function processOverlap(labels, attr2, utils) {
  var _a2 = attr2.labelOverlap, labelOverlap = _a2 === void 0 ? [] : _a2;
  if (!labelOverlap.length)
    return;
  labelOverlap.forEach(function(overlapCfg) {
    var type = overlapCfg.type;
    var util = OverlapUtils.get(type);
    if (canProcessOverlap(labels, attr2, type))
      util === null || util === void 0 ? void 0 : util(labels, overlapCfg, attr2, utils);
  });
}

// node_modules/@antv/component/esm/ui/axis/utils/index.js
function getFactor() {
  var args = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }
  var fn = function(str7) {
    return str7 === "positive" ? -1 : 1;
  };
  return args.reduce(function(acc, cur) {
    return acc * fn(cur);
  }, 1);
}

// node_modules/@antv/component/esm/ui/axis/guides/labels.js
function angleNormalizer(angle4) {
  var normalizedAngle = angle4;
  while (normalizedAngle < 0)
    normalizedAngle += 360;
  return Math.round(normalizedAngle % 360);
}
function getAngle3(v1, v2) {
  var _a2 = __read(v1, 2), x12 = _a2[0], y12 = _a2[1];
  var _b = __read(v2, 2), x22 = _b[0], y22 = _b[1];
  var _c = __read([x12 * x22 + y12 * y22, x12 * y22 - y12 * x22], 2), dot9 = _c[0], det = _c[1];
  return Math.atan2(det, dot9);
}
function correctLabelRotation(_rotate) {
  var rotate6 = (_rotate + 360) % 180;
  if (!inRange(rotate6, -90, 90))
    rotate6 += 180;
  return rotate6;
}
function getLabelRotation(datum, label, attr2) {
  var _a2;
  var labelAlign = attr2.labelAlign;
  var customRotate = (_a2 = label.style.transform) === null || _a2 === void 0 ? void 0 : _a2.includes("rotate");
  if (customRotate)
    return label.getLocalEulerAngles();
  var rotate6 = 0;
  var labelVector = getLabelVector(datum.value, attr2);
  var tangentVector = getLineTangentVector(datum.value, attr2);
  if (labelAlign === "horizontal")
    return 0;
  if (labelAlign === "perpendicular")
    rotate6 = getAngle3([1, 0], labelVector);
  else
    rotate6 = getAngle3([tangentVector[0] < 0 ? -1 : 1, 0], tangentVector);
  return correctLabelRotation(radToDeg(rotate6));
}
function getLabelStyle(value2, rotate6, attr2) {
  var type = attr2.type, labelAlign = attr2.labelAlign;
  var labelVector = getLabelVector(value2, attr2);
  var labelAngle = angleNormalizer(rotate6);
  var tickAngle = angleNormalizer(radToDeg(getAngle3([1, 0], labelVector)));
  var textAlign = "center";
  var textBaseline = "middle";
  if (type === "linear") {
    if ([90, 270].includes(tickAngle) && labelAngle === 0) {
      textAlign = "center";
      textBaseline = labelVector[1] === 1 ? "top" : "bottom";
    } else if (!(tickAngle % 180) && [90, 270].includes(labelAngle)) {
      textAlign = "center";
    } else if (tickAngle === 0) {
      if (inRange(labelAngle, 0, 90, false, true)) {
        textAlign = "start";
      } else if (inRange(labelAngle, 0, 90) || inRange(labelAngle, 270, 360)) {
        textAlign = "start";
      }
    } else if (tickAngle === 90) {
      if (inRange(labelAngle, 0, 90, false, true)) {
        textAlign = "start";
      } else if (inRange(labelAngle, 90, 180) || inRange(labelAngle, 270, 360)) {
        textAlign = "end";
      }
    } else if (tickAngle === 270) {
      if (inRange(labelAngle, 0, 90, false, true)) {
        textAlign = "end";
      } else if (inRange(labelAngle, 90, 180) || inRange(labelAngle, 270, 360)) {
        textAlign = "start";
      }
    } else if (tickAngle === 180) {
      if (labelAngle === 90) {
        textAlign = "start";
      } else if (inRange(labelAngle, 0, 90) || inRange(labelAngle, 270, 360)) {
        textAlign = "end";
      }
    }
  } else {
    if (labelAlign === "parallel") {
      if (inRange(tickAngle, 0, 180, true)) {
        textBaseline = "top";
      } else {
        textBaseline = "bottom";
      }
    } else if (labelAlign === "horizontal") {
      if (inRange(tickAngle, 90, 270, false)) {
        textAlign = "end";
      } else if (inRange(tickAngle, 270, 360, false) || inRange(tickAngle, 0, 90)) {
        textAlign = "start";
      }
    } else if (labelAlign === "perpendicular") {
      if (inRange(tickAngle, 90, 270)) {
        textAlign = "end";
      } else {
        textAlign = "start";
      }
    }
  }
  return { textAlign, textBaseline };
}
function setRotateAndAdjustLabelAlign(rotate6, group3, attr2) {
  group3.setLocalEulerAngles(rotate6);
  var value2 = group3.__data__.value;
  var textStyle = getLabelStyle(value2, rotate6, attr2);
  var label = group3.querySelector(CLASS_NAMES3.labelItem.class);
  if (label)
    applyTextStyle(label, textStyle);
}
function getLabelPos(datum, data2, attr2) {
  var showTick = attr2.showTick, tickLength = attr2.tickLength, tickDirection = attr2.tickDirection, labelDirection = attr2.labelDirection, labelSpacing = attr2.labelSpacing;
  var index3 = data2.indexOf(datum);
  var finalLabelSpacing = getCallbackValue(labelSpacing, [datum, index3, data2]);
  var _a2 = __read([getLabelVector(datum.value, attr2), getFactor(labelDirection, tickDirection)], 2), labelVector = _a2[0], unionFactor = _a2[1];
  var extraLength = unionFactor === 1 ? getCallbackValue(showTick ? tickLength : 0, [datum, index3, data2]) : 0;
  var _b = __read(add8(scale7(labelVector, finalLabelSpacing + extraLength), getValuePos(datum.value, attr2)), 2), x3 = _b[0], y3 = _b[1];
  return { x: x3, y: y3 };
}
function formatter(datum, index3, data2, attr2) {
  var labelFormatter2 = attr2.labelFormatter;
  var element = is_function_default(labelFormatter2) ? function() {
    return renderExtDo(getCallbackValue(labelFormatter2, [datum, index3, data2, getLabelVector(datum.value, attr2)]));
  } : function() {
    return renderExtDo(datum.label || "");
  };
  return element;
}
function applyTextStyle(node, style) {
  if (node.nodeName === "text")
    node.attr(style);
}
function overlapHandler(attr2) {
  processOverlap(this.node().childNodes, attr2, {
    hide,
    show,
    rotate: function(label, angle4) {
      setRotateAndAdjustLabelAlign(+angle4, label, attr2);
    },
    ellipsis: function(label, len5, suffix) {
      label && ellipsisIt(label, len5 || Infinity, suffix);
    },
    wrap: function(label, width, lines) {
      label && wrapIt(label, width, lines);
    },
    getTextShape: function(label) {
      return label.querySelector("text");
    }
  });
}
function renderLabel(container, datum, data2, style, attr2) {
  var index3 = data2.indexOf(datum);
  var label = select2(container).append(formatter(datum, index3, data2, attr2)).attr("className", CLASS_NAMES3.labelItem.name).node();
  var _a2 = __read(splitStyle(getCallbackStyle(style, [datum, index3, data2])), 2), labelStyle = _a2[0], _b = _a2[1], transform3 = _b.transform, groupStyle = __rest(_b, ["transform"]);
  percentTransform(container, transform3);
  var rotate6 = getLabelRotation(datum, container, attr2);
  container.setLocalEulerAngles(+rotate6);
  applyTextStyle(label, __assign(__assign({}, getLabelStyle(datum.value, rotate6, attr2)), labelStyle));
  percentTransform(container, transform3);
  container.attr(groupStyle);
  return label;
}
function renderLabels(container, data2, attr2, animate2) {
  var finalData = filterExec(data2, attr2.labelFilter);
  var style = subStyleProps(attr2, "label");
  return container.selectAll(CLASS_NAMES3.label.class).data(finalData, function(d2, i) {
    return i;
  }).join(function(enter) {
    return enter.append("g").attr("className", CLASS_NAMES3.label.name).transition(function(datum) {
      renderLabel(this, datum, data2, style, attr2);
      this.attr(getLabelPos(datum, data2, attr2));
      this.__bbox__ = datum.bbox;
      return null;
    }).call(function() {
      return overlapHandler.call(container, attr2);
    });
  }, function(update3) {
    return update3.transition(function(datum) {
      var prevLabel = this.querySelector(CLASS_NAMES3.labelItem.class);
      var label = renderLabel(this, datum, data2, style, attr2);
      var shapeAnimation = transitionShape(prevLabel, label, animate2.update);
      var animation = transition(this, getLabelPos(datum, data2, attr2), animate2.update);
      this.__bbox__ = datum.bbox;
      return __spreadArray(__spreadArray([], __read(shapeAnimation), false), [animation], false);
    }).call(function(selection) {
      var transitions = get_default(selection, "_transitions").flat().filter(defined2);
      onAnimatesFinished(transitions, function() {
        return overlapHandler.call(container, attr2);
      });
    });
  }, function(exit) {
    return exit.transition(function() {
      var _this2 = this;
      var animation = fadeOut_default(this.childNodes[0], animate2.exit);
      onAnimateFinished(animation, function() {
        return select2(_this2).remove();
      });
      return animation;
    });
  }).transitions();
}

// node_modules/@antv/component/esm/ui/axis/guides/ticks.js
function getTickVector(value2, attr2) {
  return getDirectionVector(value2, attr2.tickDirection, attr2);
}
function getTickPoints(unitVector, tickLength) {
  var _a2 = __read(unitVector, 2), dx = _a2[0], dy = _a2[1];
  return [
    [0, 0],
    [dx * tickLength, dy * tickLength]
  ];
}
function getTickLineLayout(datum, index3, data2, tickVector, attr2) {
  var tickLength = attr2.tickLength;
  var _a2 = __read(getTickPoints(tickVector, getCallbackValue(tickLength, [datum, index3, data2])), 2), _b = __read(_a2[0], 2), x12 = _b[0], y12 = _b[1], _c = __read(_a2[1], 2), x22 = _c[0], y22 = _c[1];
  return { x1: x12, x2: x22, y1: y12, y2: y22 };
}
function createTickEl(container, datum, index3, data2, attr2) {
  var formatter2 = attr2.tickFormatter;
  var tickVector = getTickVector(datum.value, attr2);
  var el = "line";
  if (is_function_default(formatter2))
    el = function() {
      return getCallbackValue(formatter2, [datum, index3, data2, tickVector]);
    };
  return container.append(el).attr("className", CLASS_NAMES3.tickItem.name);
}
function applyTickStyle(datum, index3, data2, tick3, group3, attr2, style) {
  var tickVector = getTickVector(datum.value, attr2);
  var _a2 = getTickLineLayout(datum, index3, data2, tickVector, attr2), x12 = _a2.x1, x22 = _a2.x2, y12 = _a2.y1, y22 = _a2.y2;
  var _b = __read(splitStyle(getCallbackStyle(style, [datum, index3, data2, tickVector])), 2), tickStyle = _b[0], groupStyle = _b[1];
  tick3.node().nodeName === "line" && tick3.styles(__assign({ x1: x12, x2: x22, y1: y12, y2: y22 }, tickStyle));
  group3.attr(groupStyle);
  tick3.styles(tickStyle);
}
function createTick(datum, index3, data2, attr2, tickAttr, animate2) {
  var tick3 = createTickEl(select2(this), datum, index3, data2, attr2);
  applyTickStyle(datum, index3, data2, tick3, this, attr2, tickAttr);
  var _a2 = __read(getValuePos(datum.value, attr2), 2), x3 = _a2[0], y3 = _a2[1];
  return transition(this, { x: x3, y: y3 }, animate2);
}
function renderTicks(container, axisData, attr2, animate2) {
  var finalData = filterExec(axisData, attr2.tickFilter);
  var tickAttr = subStyleProps(attr2, "tick");
  return container.selectAll(CLASS_NAMES3.tick.class).data(finalData, function(d2) {
    return d2.id || d2.label;
  }).join(function(enter) {
    return enter.append("g").attr("className", CLASS_NAMES3.tick.name).transition(function(datum, index3) {
      return createTick.call(this, datum, index3, finalData, attr2, tickAttr, false);
    });
  }, function(update3) {
    return update3.transition(function(datum, index3) {
      this.removeChildren();
      return createTick.call(this, datum, index3, finalData, attr2, tickAttr, animate2.update);
    });
  }, function(exit) {
    return exit.transition(function() {
      var _this2 = this;
      var animation = fadeOut_default(this.childNodes[0], animate2.exit);
      onAnimateFinished(animation, function() {
        return _this2.remove();
      });
      return animation;
    });
  }).transitions();
}

// node_modules/@antv/component/esm/ui/title/index.js
var CLASS_NAMES5 = classNames({
  text: "text"
}, "title");
function parsePosition(position) {
  if (!/\S+-\S+/g.test(position))
    return position.length > 2 ? [position[0]] : position.split("");
  return position.split("-").map(function(str7) {
    return str7[0];
  });
}
function getBBox2(title, content) {
  var _a2 = title.attributes, position = _a2.position, spacing = _a2.spacing, inset = _a2.inset, text = _a2.text;
  var titleBBox = title.getBBox();
  var contentBBox = content.getBBox();
  var pos = parsePosition(position);
  var _b = __read(parseSeriesAttr(text ? spacing : 0), 4), spacingTop = _b[0], spacingRight = _b[1], spacingBottom = _b[2], spacingLeft = _b[3];
  var _c = __read(parseSeriesAttr(inset), 4), insetTop = _c[0], insetRight = _c[1], insetBottom = _c[2], insetLeft = _c[3];
  var _d = __read([spacingLeft + spacingRight, spacingTop + spacingBottom], 2), spacingWidth = _d[0], spacingHeight = _d[1];
  var _e = __read([insetLeft + insetRight, insetTop + insetBottom], 2), insetWidth = _e[0], insetHeight = _e[1];
  if (pos[0] === "l") {
    return new BBox(titleBBox.x, titleBBox.y, contentBBox.width + titleBBox.width + spacingWidth + insetWidth, Math.max(contentBBox.height + insetHeight, titleBBox.height));
  }
  if (pos[0] === "t") {
    return new BBox(titleBBox.x, titleBBox.y, Math.max(contentBBox.width + insetWidth, titleBBox.width), contentBBox.height + titleBBox.height + spacingHeight + insetHeight);
  }
  var _f = __read([
    content.attributes.width || contentBBox.width,
    content.attributes.height || contentBBox.height
  ], 2), contentWidth = _f[0], contentHeight = _f[1];
  return new BBox(contentBBox.x, contentBBox.y, contentWidth + titleBBox.width + spacingWidth + insetWidth, contentHeight + titleBBox.height + spacingHeight + insetHeight);
}
function mayApplyStyle(el, style) {
  var finalStyle = Object.entries(style).reduce(function(acc, _a2) {
    var _b = __read(_a2, 2), key = _b[0], value2 = _b[1];
    var currAttr = el.node().attr(key);
    if (!currAttr)
      acc[key] = value2;
    return acc;
  }, {});
  el.styles(finalStyle);
}
function getTitleLayout(cfg) {
  var _a2, _b, _c, _d;
  var _e = cfg, width = _e.width, height = _e.height, position = _e.position;
  var _f = __read([+width / 2, +height / 2], 2), hW = _f[0], hH = _f[1];
  var _g = __read([+hW, +hH, "center", "middle"], 4), x3 = _g[0], y3 = _g[1], textAlign = _g[2], textBaseline = _g[3];
  var pos = parsePosition(position);
  if (pos.includes("l"))
    _a2 = __read([0, "start"], 2), x3 = _a2[0], textAlign = _a2[1];
  if (pos.includes("r"))
    _b = __read([+width, "end"], 2), x3 = _b[0], textAlign = _b[1];
  if (pos.includes("t"))
    _c = __read([0, "top"], 2), y3 = _c[0], textBaseline = _c[1];
  if (pos.includes("b"))
    _d = __read([+height, "bottom"], 2), y3 = _d[0], textBaseline = _d[1];
  return { x: x3, y: y3, textAlign, textBaseline };
}
var Title = (
  /** @class */
  function(_super) {
    __extends(Title3, _super);
    function Title3(options) {
      return _super.call(this, options, {
        text: "",
        width: 0,
        height: 0,
        fill: "#4a505a",
        fontWeight: "bold",
        fontSize: 12,
        fontFamily: "sans-serif",
        inset: 0,
        spacing: 0,
        position: "top-left"
      }) || this;
    }
    Title3.prototype.getAvailableSpace = function() {
      var container = this;
      var _a2 = this.attributes, containerWidth = _a2.width, containerHeight = _a2.height, position = _a2.position, spacing = _a2.spacing, inset = _a2.inset;
      var title = container.querySelector(CLASS_NAMES5.text.class);
      if (!title)
        return new BBox(0, 0, +containerWidth, +containerHeight);
      var _b = title.getBBox(), titleWidth = _b.width, titleHeight = _b.height;
      var _c = __read(parseSeriesAttr(spacing), 4), spacingTop = _c[0], spacingRight = _c[1], spacingBottom = _c[2], spacingLeft = _c[3];
      var _d = __read([0, 0, +containerWidth, +containerHeight], 4), x3 = _d[0], y3 = _d[1], width = _d[2], height = _d[3];
      var pos = parsePosition(position);
      if (pos.includes("i"))
        return new BBox(x3, y3, width, height);
      pos.forEach(function(p2, i) {
        var _a3, _b2, _c2, _d2;
        if (p2 === "t")
          _a3 = __read(i === 0 ? [titleHeight + spacingBottom, +containerHeight - titleHeight - spacingBottom] : [0, +containerHeight], 2), y3 = _a3[0], height = _a3[1];
        if (p2 === "r")
          _b2 = __read([+containerWidth - titleWidth - spacingLeft], 1), width = _b2[0];
        if (p2 === "b")
          _c2 = __read([+containerHeight - titleHeight - spacingTop], 1), height = _c2[0];
        if (p2 === "l")
          _d2 = __read(i === 0 ? [titleWidth + spacingRight, +containerWidth - titleWidth - spacingRight] : [0, +containerWidth], 2), x3 = _d2[0], width = _d2[1];
      });
      var _e = __read(parseSeriesAttr(inset), 4), insetTop = _e[0], insetRight = _e[1], insetBottom = _e[2], insetLeft = _e[3];
      var _f = __read([insetLeft + insetRight, insetTop + insetBottom], 2), insetWidth = _f[0], insetHeight = _f[1];
      return new BBox(x3 + insetLeft, y3 + insetTop, width - insetWidth, height - insetHeight);
    };
    Title3.prototype.getBBox = function() {
      if (this.title)
        return this.title.getBBox();
      return new BBox(0, 0, 0, 0);
    };
    Title3.prototype.render = function(attributes, container) {
      var _this2 = this;
      var width = attributes.width, height = attributes.height, position = attributes.position, spacing = attributes.spacing, restStyle = __rest(attributes, ["width", "height", "position", "spacing"]);
      var _a2 = __read(splitStyle(restStyle), 1), titleStyle = _a2[0];
      var _b = getTitleLayout(attributes), x3 = _b.x, y3 = _b.y, textAlign = _b.textAlign, textBaseline = _b.textBaseline;
      ifShow(!!restStyle.text, select2(container), function(group3) {
        _this2.title = group3.maybeAppendByClassName(CLASS_NAMES5.text, "text").styles(titleStyle).call(mayApplyStyle, { x: x3, y: y3, textAlign, textBaseline }).node();
      });
    };
    return Title3;
  }(Component)
);

// node_modules/@antv/component/esm/ui/axis/guides/title.js
function getTitlePosition(mainGroup, titleGroup, attr2) {
  var _a2 = attr2.titlePosition, position = _a2 === void 0 ? "lb" : _a2, spacing = attr2.titleSpacing;
  var pos = parsePosition(position);
  var _b = mainGroup.node().getLocalBounds(), _c = __read(_b.min, 2), mainX = _c[0], mainY = _c[1], _d = __read(_b.halfExtents, 2), mainHalfWidth = _d[0], mainHalfHeight = _d[1];
  var _e = __read(titleGroup.node().getLocalBounds().halfExtents, 2), titleHalfWidth = _e[0], titleHalfHeight = _e[1];
  var _f = __read([mainX + mainHalfWidth, mainY + mainHalfHeight], 2), x3 = _f[0], y3 = _f[1];
  var _g = __read(parseSeriesAttr(spacing), 4), spacingTop = _g[0], spacingRight = _g[1], spacingBottom = _g[2], spacingLeft = _g[3];
  if (["start", "end"].includes(position) && attr2.type === "linear") {
    var startPos = attr2.startPos, endPos = attr2.endPos;
    var _h = __read(position === "start" ? [startPos, endPos] : [endPos, startPos], 2), from = _h[0], to = _h[1];
    var direction3 = normalize7([-to[0] + from[0], -to[1] + from[1]]);
    var _j = __read(scale7(direction3, spacingTop), 2), dx = _j[0], dy = _j[1];
    return { x: from[0] + dx, y: from[1] + dy };
  }
  if (pos.includes("t"))
    y3 -= mainHalfHeight + titleHalfHeight + spacingTop;
  if (pos.includes("r"))
    x3 += mainHalfWidth + titleHalfWidth + spacingRight;
  if (pos.includes("l"))
    x3 -= mainHalfWidth + titleHalfWidth * 2 + spacingLeft;
  if (pos.includes("b"))
    y3 += mainHalfHeight + titleHalfHeight * 2 + spacingBottom;
  return { x: x3, y: y3 };
}
function inferTransform(n, direction3, position) {
  var node = n.cloneNode(true);
  node.style.transform = "scale(1, 1)";
  node.style.transform = "none";
  var height = node.getBBox().height;
  if (direction3 === "vertical") {
    if (position === "left")
      return "rotate(-90) translate(0, ".concat(height / 2, ")");
    if (position === "right")
      return "rotate(-90) translate(0, -".concat(height / 2, ")");
  }
  return "";
}
function applyTitleStyle(title, group3, axis, attr2, animate2) {
  var style = subStyleProps(attr2, "title");
  var _a2 = __read(splitStyle(style), 2), titleStyle = _a2[0], _b = _a2[1], specified = _b.transform, groupStyle = __rest(_b, ["transform"]);
  title.styles(titleStyle);
  group3.styles(groupStyle);
  var transform3 = specified || inferTransform(title.node(), titleStyle.direction, titleStyle.position);
  percentTransform(title.node(), transform3);
  var _c = getTitlePosition(
    // @ts-ignore
    select2(axis._offscreen || axis.querySelector(CLASS_NAMES3.mainGroup.class)),
    group3,
    attr2
  ), x3 = _c.x, y3 = _c.y;
  var animation = transition(group3.node(), { x: x3, y: y3 }, animate2);
  percentTransform(title.node(), transform3);
  return animation;
}
function renderTitle(container, axis, attr2, animate2) {
  var titleText = attr2.titleText;
  return container.selectAll(CLASS_NAMES3.title.class).data([{ title: titleText }].filter(function(d2) {
    return !!d2.title;
  }), function(d2, i) {
    return d2.title;
  }).join(function(enter) {
    return enter.append(function() {
      return renderExtDo(titleText);
    }).attr("className", CLASS_NAMES3.title.name).transition(function() {
      return applyTitleStyle(select2(this), container, axis, attr2, animate2.enter);
    });
  }, function(update3) {
    return update3.transition(function() {
      return applyTitleStyle(select2(this), container, axis, attr2, animate2.update);
    });
  }, function(exit) {
    return exit.remove();
  }).transitions();
}

// node_modules/@antv/component/esm/ui/axis/axis.js
function renderAxisMain(attributes, container, data2, animation) {
  var showLine = attributes.showLine, showTick = attributes.showTick, showLabel = attributes.showLabel;
  var lineGroup = container.maybeAppendByClassName(CLASS_NAMES3.lineGroup, "g");
  var lineTransitions = ifShow(showLine, lineGroup, function(group3) {
    return renderAxisLine(group3, attributes, animation);
  }) || [];
  var tickGroup = container.maybeAppendByClassName(CLASS_NAMES3.tickGroup, "g");
  var tickTransitions = ifShow(showTick, tickGroup, function(group3) {
    return renderTicks(group3, data2, attributes, animation);
  }) || [];
  var labelGroup = container.maybeAppendByClassName(CLASS_NAMES3.labelGroup, "g");
  var labelTransitions = ifShow(showLabel, labelGroup, function(group3) {
    return renderLabels(group3, data2, attributes, animation);
  }) || [];
  return __spreadArray(__spreadArray(__spreadArray([], __read(lineTransitions), false), __read(tickTransitions), false), __read(labelTransitions), false).filter(function(t) {
    return !!t;
  });
}
var Axis = (
  /** @class */
  function(_super) {
    __extends(Axis2, _super);
    function Axis2(options) {
      return _super.call(this, options, AXIS_BASE_DEFAULT_ATTR) || this;
    }
    Axis2.prototype.render = function(attributes, container, specificAnimation) {
      var _this2 = this;
      var titleText = attributes.titleText, data2 = attributes.data, animate2 = attributes.animate, showTitle = attributes.showTitle, showGrid = attributes.showGrid, dataThreshold = attributes.dataThreshold, truncRange = attributes.truncRange;
      var sampledData = sampling(data2, dataThreshold).filter(function(_a2) {
        var value2 = _a2.value;
        if (truncRange && value2 > truncRange[0] && value2 < truncRange[1])
          return false;
        return true;
      });
      var finalAnimation = parseAnimationOption(specificAnimation === void 0 ? animate2 : specificAnimation);
      var gridGroup = select2(container).maybeAppendByClassName(CLASS_NAMES3.gridGroup, "g");
      var gridTransitions = ifShow(showGrid, gridGroup, function(group3) {
        return renderGrid(group3, sampledData, attributes, finalAnimation);
      }) || [];
      var mainGroup = select2(container).maybeAppendByClassName(CLASS_NAMES3.mainGroup, "g");
      if (titleText && (!this.initialized && finalAnimation.enter || this.initialized && finalAnimation.update)) {
        renderAxisMain(attributes, select2(this.offscreenGroup), sampledData, parseAnimationOption(false));
      }
      var mainTransitions = renderAxisMain(attributes, select2(mainGroup.node()), sampledData, finalAnimation);
      var titleGroup = select2(container).maybeAppendByClassName(CLASS_NAMES3.titleGroup, "g");
      var titleTransitions = ifShow(showTitle, titleGroup, function(group3) {
        return renderTitle(group3, _this2, attributes, finalAnimation);
      }) || [];
      return __spreadArray(__spreadArray(__spreadArray([], __read(gridTransitions), false), __read(mainTransitions), false), __read(titleTransitions), false).flat().filter(function(t) {
        return !!t;
      });
    };
    return Axis2;
  }(Component)
);

// node_modules/@antv/component/esm/ui/timeline/index.js
var Timeline = (
  /** @class */
  function() {
    function Timeline2() {
    }
    return Timeline2;
  }()
);

// node_modules/@antv/component/esm/ui/navigator/index.js
var CLASS_NAMES6 = classNames({
  prevBtnGroup: "prev-btn-group",
  prevBtn: "prev-btn",
  nextBtnGroup: "next-btn-group",
  nextBtn: "next-btn",
  pageInfoGroup: "page-info-group",
  pageInfo: "page-info",
  playWindow: "play-window",
  contentGroup: "content-group",
  controller: "controller",
  clipPath: "clip-path"
}, "navigator");
var Navigator = (
  /** @class */
  function(_super) {
    __extends(Navigator2, _super);
    function Navigator2(options) {
      var _this2 = _super.call(this, options, {
        animate: {
          easing: "linear",
          duration: 200,
          fill: "both"
        },
        buttonCursor: "pointer",
        buttonFill: "black",
        buttonPath: button(0, 0, 6),
        buttonSize: 12,
        controllerPadding: 5,
        controllerSpacing: 5,
        formatter: function(curr, total) {
          return "".concat(curr, "/").concat(total);
        },
        defaultPage: 0,
        loop: false,
        orientation: "horizontal",
        pageNumFill: "black",
        pageNumFontSize: 12,
        pageNumTextAlign: "start",
        pageNumTextBaseline: "middle"
      }) || this;
      _this2.playState = "idle";
      _this2.contentGroup = _this2.appendChild(new Group2({ class: CLASS_NAMES6.contentGroup.name }));
      _this2.playWindow = _this2.contentGroup.appendChild(new Group2({ class: CLASS_NAMES6.playWindow.name }));
      _this2.innerCurrPage = _this2.defaultPage;
      return _this2;
    }
    Object.defineProperty(Navigator2.prototype, "defaultPage", {
      get: function() {
        var defaultPage = this.attributes.defaultPage;
        return clamp_default(defaultPage, 0, Math.max(this.pageViews.length - 1, 0));
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Navigator2.prototype, "pageViews", {
      get: function() {
        return this.playWindow.children;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Navigator2.prototype, "controllerShape", {
      // todo fixme
      get: function() {
        return this.totalPages > 1 ? { width: 55, height: 0 } : { width: 0, height: 0 };
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Navigator2.prototype, "pageShape", {
      get: function() {
        var pageViews = this.pageViews;
        var _a2 = __read(transpose4(pageViews.map(function(pageView) {
          var _a3 = pageView.getBBox(), width = _a3.width, height = _a3.height;
          return [width, height];
        })).map(function(arr) {
          return Math.max.apply(Math, __spreadArray([], __read(arr), false));
        }), 2), maxWidth = _a2[0], maxHeight = _a2[1];
        var _b = this.attributes, _c = _b.pageWidth, pageWidth = _c === void 0 ? maxWidth : _c, _d = _b.pageHeight, pageHeight = _d === void 0 ? maxHeight : _d;
        return { pageWidth, pageHeight };
      },
      enumerable: false,
      configurable: true
    });
    Navigator2.prototype.getContainer = function() {
      return this.playWindow;
    };
    Object.defineProperty(Navigator2.prototype, "totalPages", {
      get: function() {
        return this.pageViews.length;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Navigator2.prototype, "currPage", {
      get: function() {
        return this.innerCurrPage;
      },
      enumerable: false,
      configurable: true
    });
    Navigator2.prototype.getBBox = function() {
      var _a2 = _super.prototype.getBBox.call(this), x3 = _a2.x, y3 = _a2.y;
      var controllerShape = this.controllerShape;
      var _b = this.pageShape, pageWidth = _b.pageWidth, pageHeight = _b.pageHeight;
      return new BBox(x3, y3, pageWidth + controllerShape.width, pageHeight);
    };
    Navigator2.prototype.goTo = function(pageNum) {
      var _this2 = this;
      var animateOptions = this.attributes.animate;
      var _a2 = this, currPage = _a2.currPage, playState = _a2.playState, playWindow = _a2.playWindow, pageViews = _a2.pageViews;
      if (playState !== "idle" || pageNum < 0 || pageViews.length <= 0 || pageNum >= pageViews.length)
        return null;
      pageViews[currPage].setLocalPosition(0, 0);
      this.prepareFollowingPage(pageNum);
      var _b = __read(this.getFollowingPageDiff(pageNum), 2), dx = _b[0], dy = _b[1];
      this.playState = "running";
      var animation = animate(playWindow, [{ transform: "translate(0, 0)" }, { transform: "translate(".concat(-dx, ", ").concat(-dy, ")") }], animateOptions);
      onAnimateFinished(animation, function() {
        _this2.innerCurrPage = pageNum;
        _this2.playState = "idle";
        _this2.setVisiblePages([pageNum]);
        _this2.updatePageInfo();
      });
      return animation;
    };
    Navigator2.prototype.prev = function() {
      var loop = this.attributes.loop;
      var pages = this.pageViews.length;
      var page = this.currPage;
      if (!loop && page <= 0)
        return null;
      var following = loop ? (page - 1 + pages) % pages : clamp_default(page - 1, 0, pages);
      return this.goTo(following);
    };
    Navigator2.prototype.next = function() {
      var loop = this.attributes.loop;
      var pages = this.pageViews.length;
      var page = this.currPage;
      if (!loop && page >= pages - 1)
        return null;
      var following = loop ? (page + 1) % pages : clamp_default(page + 1, 0, pages);
      return this.goTo(following);
    };
    Navigator2.prototype.renderClipPath = function(container) {
      var _a2 = this.pageShape, pageWidth = _a2.pageWidth, pageHeight = _a2.pageHeight;
      if (!pageWidth || !pageHeight) {
        this.contentGroup.style.clipPath = void 0;
        return;
      }
      this.clipPath = container.maybeAppendByClassName(CLASS_NAMES6.clipPath, "rect").styles({
        width: pageWidth,
        height: pageHeight
      });
      this.contentGroup.attr("clipPath", this.clipPath.node());
    };
    Navigator2.prototype.setVisiblePages = function(pages) {
      this.playWindow.children.forEach(function(page, index3) {
        if (pages.includes(index3))
          show(page);
        else
          hide(page);
      });
    };
    Navigator2.prototype.adjustControllerLayout = function() {
      var _a2 = this, prevBtn = _a2.prevBtnGroup, nextBtn = _a2.nextBtnGroup, pageNum = _a2.pageInfoGroup;
      var _b = this.attributes, orientation = _b.orientation, padding = _b.controllerPadding;
      var _c = pageNum.getBBox(), pW = _c.width, pH = _c.height;
      var _d = __read(orientation === "horizontal" ? [-180, 0] : [-90, 90], 2), r1 = _d[0], r2 = _d[1];
      prevBtn.setLocalEulerAngles(r1);
      nextBtn.setLocalEulerAngles(r2);
      var _e = prevBtn.getBBox(), bpW = _e.width, bpH = _e.height;
      var _f = nextBtn.getBBox(), bnW = _f.width, bnH = _f.height;
      var maxWidth = Math.max(bpW, pW, bnW);
      var _g = orientation === "horizontal" ? {
        offset: [
          [0, 0],
          [bpW / 2 + padding, 0],
          [bpW + pW + padding * 2, 0]
        ],
        textAlign: "start"
      } : {
        offset: [
          [maxWidth / 2, -bpH - padding],
          [maxWidth / 2, 0],
          [maxWidth / 2, bnH + padding]
        ],
        textAlign: "center"
      }, _h = __read(_g.offset, 3), _j = __read(_h[0], 2), o1x = _j[0], o1y = _j[1], _k = __read(_h[1], 2), o2x = _k[0], o2y = _k[1], _l = __read(_h[2], 2), o3x = _l[0], o3y = _l[1], textAlign = _g.textAlign;
      var pageNumText = pageNum.querySelector("text");
      pageNumText && (pageNumText.style.textAlign = textAlign);
      prevBtn.setLocalPosition(o1x, o1y);
      pageNum.setLocalPosition(o2x, o2y);
      nextBtn.setLocalPosition(o3x, o3y);
    };
    Navigator2.prototype.updatePageInfo = function() {
      var _a2;
      var _b = this, currPage = _b.currPage, pageViews = _b.pageViews, formatter2 = _b.attributes.formatter;
      if (pageViews.length < 2)
        return;
      (_a2 = this.pageInfoGroup.querySelector(CLASS_NAMES6.pageInfo.class)) === null || _a2 === void 0 ? void 0 : _a2.attr("text", formatter2(currPage + 1, pageViews.length));
      this.adjustControllerLayout();
    };
    Navigator2.prototype.getFollowingPageDiff = function(pageNum) {
      var currPage = this.currPage;
      if (currPage === pageNum)
        return [0, 0];
      var orientation = this.attributes.orientation;
      var _a2 = this.pageShape, pageWidth = _a2.pageWidth, pageHeight = _a2.pageHeight;
      var sign3 = pageNum < currPage ? -1 : 1;
      return orientation === "horizontal" ? [sign3 * pageWidth, 0] : [0, sign3 * pageHeight];
    };
    Navigator2.prototype.prepareFollowingPage = function(pageNum) {
      var _a2 = this, currPage = _a2.currPage, pageViews = _a2.pageViews;
      this.setVisiblePages([pageNum, currPage]);
      if (pageNum !== currPage) {
        var _b = __read(this.getFollowingPageDiff(pageNum), 2), dx = _b[0], dy = _b[1];
        pageViews[pageNum].setLocalPosition(dx, dy);
      }
    };
    Navigator2.prototype.renderController = function(container) {
      var _this2 = this;
      var spacing = this.attributes.controllerSpacing;
      var _a2 = this.pageShape, pageWidth = _a2.pageWidth, pageHeight = _a2.pageHeight;
      var visible = this.pageViews.length >= 2;
      var group3 = container.maybeAppendByClassName(CLASS_NAMES6.controller, "g");
      visibility(group3.node(), visible);
      if (!visible)
        return;
      var style = subStyleProps(this.attributes, "button");
      var textStyle = subStyleProps(this.attributes, "pageNum");
      var _b = __read(splitStyle(style), 2), _c = _b[0], groupStyle = _b[1], size5 = _c.size, pathStyle = __rest(_c, ["size"]);
      var whetherToAddEventListener = !group3.select(CLASS_NAMES6.prevBtnGroup.class).node();
      var prevBtnGroup = group3.maybeAppendByClassName(CLASS_NAMES6.prevBtnGroup, "g").styles(groupStyle);
      this.prevBtnGroup = prevBtnGroup.node();
      var prevBtn = prevBtnGroup.maybeAppendByClassName(CLASS_NAMES6.prevBtn, "path");
      var nextBtnGroup = group3.maybeAppendByClassName(CLASS_NAMES6.nextBtnGroup, "g").styles(groupStyle);
      this.nextBtnGroup = nextBtnGroup.node();
      var nextBtn = nextBtnGroup.maybeAppendByClassName(CLASS_NAMES6.nextBtn, "path");
      [prevBtn, nextBtn].forEach(function(btn) {
        btn.styles(__assign(__assign({}, pathStyle), { transformOrigin: "center" }));
        scaleToPixel(btn.node(), size5, true);
      });
      var pageInfoGroup = group3.maybeAppendByClassName(CLASS_NAMES6.pageInfoGroup, "g");
      this.pageInfoGroup = pageInfoGroup.node();
      pageInfoGroup.maybeAppendByClassName(CLASS_NAMES6.pageInfo, "text").styles(textStyle);
      this.updatePageInfo();
      group3.node().setLocalPosition(pageWidth + spacing, pageHeight / 2);
      if (whetherToAddEventListener) {
        this.prevBtnGroup.addEventListener("click", function() {
          _this2.prev();
        });
        this.nextBtnGroup.addEventListener("click", function() {
          _this2.next();
        });
      }
    };
    Navigator2.prototype.render = function(attributes, container) {
      var containerSelection = select2(container);
      this.renderClipPath(containerSelection);
      this.renderController(containerSelection);
      this.setVisiblePages([this.defaultPage]);
      this.goTo(this.defaultPage);
    };
    Navigator2.prototype.bindEvents = function() {
      var _this2 = this;
      var render3 = debounce_default(function() {
        return _this2.render(_this2.attributes, _this2);
      }, 50);
      this.playWindow.addEventListener(ElementEvent.INSERTED, render3);
      this.playWindow.addEventListener(ElementEvent.REMOVED, render3);
    };
    return Navigator2;
  }(Component)
);

// node_modules/@antv/component/esm/ui/legend/utils.js
function getStepValueByValue(value2, step2, min11) {
  var count4 = Math.round((value2 - min11) / step2);
  return min11 + count4 * step2;
}
function hiddenHandle(x3, y3, r) {
  var ratio = 1.4;
  var diffY = ratio * r;
  return [["M", x3 - r, y3 - diffY], ["L", x3 + r, y3 - diffY], ["L", x3 + r, y3 + diffY], ["L", x3 - r, y3 + diffY], ["Z"]];
}
var HANDLE_HEIGHT_RATIO = 1.4;
var HANDLE_TRIANGLE_RATIO = 0.4;
function verticalHandle(x3, y3, r) {
  var width = r;
  var height = width * HANDLE_HEIGHT_RATIO;
  var halfWidth = width / 2;
  var oneSixthWidth = width / 6;
  var triangleX = x3 + height * HANDLE_TRIANGLE_RATIO;
  return [
    ["M", x3, y3],
    ["L", triangleX, y3 + halfWidth],
    ["L", x3 + height, y3 + halfWidth],
    ["L", x3 + height, y3 - halfWidth],
    ["L", triangleX, y3 - halfWidth],
    ["Z"],
    // 
    ["M", triangleX, y3 + oneSixthWidth],
    ["L", x3 + height - 2, y3 + oneSixthWidth],
    ["M", triangleX, y3 - oneSixthWidth],
    ["L", x3 + height - 2, y3 - oneSixthWidth]
  ];
}
function horizontalHandle(x3, y3, r) {
  var width = r;
  var height = width * HANDLE_HEIGHT_RATIO;
  var halfWidth = width / 2;
  var oneSixthWidth = width / 6;
  var triangleY = y3 + height * HANDLE_TRIANGLE_RATIO;
  return [
    ["M", x3, y3],
    ["L", x3 - halfWidth, triangleY],
    ["L", x3 - halfWidth, y3 + height],
    ["L", x3 + halfWidth, y3 + height],
    ["L", x3 + halfWidth, triangleY],
    ["Z"],
    // 
    ["M", x3 - oneSixthWidth, triangleY],
    ["L", x3 - oneSixthWidth, y3 + height - 2],
    ["M", x3 + oneSixthWidth, triangleY],
    ["L", x3 + oneSixthWidth, y3 + height - 2]
  ];
}
Marker.registerSymbol("hiddenHandle", hiddenHandle);
Marker.registerSymbol("verticalHandle", verticalHandle);
Marker.registerSymbol("horizontalHandle", horizontalHandle);
function getSafetySelections(domain, newSelection, oldSelection, precision) {
  var _a2;
  if (precision === void 0) {
    precision = 4;
  }
  var _b = __read(domain, 2), min11 = _b[0], max11 = _b[1];
  var _c = __read(newSelection, 2), start = _c[0], end = _c[1];
  var _d = __read(oldSelection, 2), prevStart = _d[0], prevEnd = _d[1];
  var _e = __read([start, end], 2), startVal = _e[0], endVal = _e[1];
  var range4 = endVal - startVal;
  if (startVal > endVal) {
    _a2 = __read([endVal, startVal], 2), startVal = _a2[0], endVal = _a2[1];
  }
  if (range4 > max11 - min11) {
    return [min11, max11];
  }
  if (startVal < min11) {
    if (prevStart === min11 && prevEnd === endVal) {
      return [min11, endVal];
    }
    return [min11, range4 + min11];
  }
  if (endVal > max11) {
    if (prevEnd === max11 && prevStart === startVal) {
      return [startVal, max11];
    }
    return [max11 - range4, max11];
  }
  return [startVal, endVal];
}
function ifHorizontal(orientation, a4, b) {
  if (orientation === void 0) {
    orientation = "horizontal";
  }
  return orientation === "horizontal" ? a4 : b;
}

// node_modules/@antv/component/esm/ui/legend/category/item.js
var CLASS_NAMES7 = classNames({
  layout: "flex",
  markerGroup: "marker-group",
  marker: "marker",
  labelGroup: "label-group",
  label: "label",
  valueGroup: "value-group",
  value: "value",
  backgroundGroup: "background-group",
  background: "background"
}, "legend-category-item");
function styleOfMarker(group3) {
  var marker = group3.querySelector(CLASS_NAMES7.marker.class);
  if (marker)
    return marker.style;
  return {};
}
var CategoryItem = (
  /** @class */
  function(_super) {
    __extends(CategoryItem2, _super);
    function CategoryItem2(options) {
      return _super.call(this, options, {
        span: [1, 1],
        marker: function() {
          return new Circle({ style: { r: 6 } });
        },
        markerSize: 10,
        labelFill: "#646464",
        valueFill: "#646464",
        labelFontSize: 12,
        valueFontSize: 12,
        labelTextBaseline: "middle",
        valueTextBaseline: "middle"
      }) || this;
    }
    Object.defineProperty(CategoryItem2.prototype, "showValue", {
      get: function() {
        var valueText = this.attributes.valueText;
        if (!valueText)
          return false;
        if (typeof valueText === "string" || typeof valueText === "number")
          return valueText !== "";
        if (typeof valueText === "function")
          return true;
        return valueText.attr("text") !== "";
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(CategoryItem2.prototype, "actualSpace", {
      get: function() {
        var label = this.labelGroup;
        var value2 = this.valueGroup;
        var markerSize = this.attributes.markerSize;
        var _a2 = label.node().getBBox(), labelWidth = _a2.width, labelHeight = _a2.height;
        var _b = value2.node().getBBox(), valueWidth = _b.width, valueHeight = _b.height;
        return {
          markerWidth: markerSize,
          labelWidth,
          valueWidth,
          height: Math.max(markerSize, labelHeight, valueHeight)
        };
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(CategoryItem2.prototype, "span", {
      get: function() {
        var span = this.attributes.span;
        if (!span)
          return [1, 1];
        var _a2 = __read(parseSeriesAttr(span), 2), span1 = _a2[0], innerSpan = _a2[1];
        var span2 = this.showValue ? innerSpan : 0;
        var basis2 = span1 + span2;
        return [span1 / basis2, span2 / basis2];
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(CategoryItem2.prototype, "shape", {
      get: function() {
        var _a2;
        var _b = this.attributes, markerSize = _b.markerSize, fullWidth = _b.width;
        var actualSpace = this.actualSpace;
        var markerWidth = actualSpace.markerWidth, height = actualSpace.height;
        var _c = this.actualSpace, labelWidth = _c.labelWidth, valueWidth = _c.valueWidth;
        var _d = __read(this.spacing, 2), spacing1 = _d[0], spacing2 = _d[1];
        if (fullWidth) {
          var width_1 = fullWidth - markerSize - spacing1 - spacing2;
          var _e = __read(this.span, 2), span1 = _e[0], span2 = _e[1];
          _a2 = __read([span1 * width_1, span2 * width_1], 2), labelWidth = _a2[0], valueWidth = _a2[1];
        }
        var width = markerWidth + labelWidth + valueWidth + spacing1 + spacing2;
        return { width, height, markerWidth, labelWidth, valueWidth };
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(CategoryItem2.prototype, "spacing", {
      get: function() {
        var spacing = this.attributes.spacing;
        if (!spacing)
          return [0, 0];
        var _a2 = __read(parseSeriesAttr(spacing), 2), spacing1 = _a2[0], spacing2 = _a2[1];
        if (this.showValue)
          return [spacing1, spacing2];
        return [spacing1, 0];
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(CategoryItem2.prototype, "layout", {
      get: function() {
        var _a2 = this.shape, markerWidth = _a2.markerWidth, labelWidth = _a2.labelWidth, valueWidth = _a2.valueWidth, width = _a2.width, height = _a2.height;
        var _b = __read(this.spacing, 2), spacing1 = _b[0], spacing2 = _b[1];
        return {
          height,
          width,
          markerWidth,
          labelWidth,
          valueWidth,
          position: [markerWidth / 2, markerWidth + spacing1, markerWidth + labelWidth + spacing1 + spacing2]
        };
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(CategoryItem2.prototype, "scaleSize", {
      get: function() {
        var markerShapeStyle = styleOfMarker(this.markerGroup.node());
        var _a2 = this.attributes, markerSize = _a2.markerSize, _b = _a2.markerStrokeWidth, markerStrokeWidth = _b === void 0 ? markerShapeStyle.strokeWidth : _b, _c = _a2.markerLineWidth, markerLineWidth = _c === void 0 ? markerShapeStyle.lineWidth : _c, _d = _a2.markerStroke, markerStroke = _d === void 0 ? markerShapeStyle.stroke : _d;
        var strokeWidth = +(markerStrokeWidth || markerLineWidth || (markerStroke ? 1 : 0)) * Math.sqrt(2);
        var _e = this.markerGroup.node().getBBox(), width = _e.width, height = _e.height;
        return (1 - strokeWidth / Math.max(width, height)) * markerSize;
      },
      enumerable: false,
      configurable: true
    });
    CategoryItem2.prototype.renderMarker = function(container) {
      var _this2 = this;
      var marker = this.attributes.marker;
      var style = subStyleProps(this.attributes, "marker");
      this.markerGroup = container.maybeAppendByClassName(CLASS_NAMES7.markerGroup, "g").style("zIndex", 0);
      ifShow(!!marker, this.markerGroup, function() {
        var parent2 = _this2.markerGroup.node();
        var oldMarker = parent2.getElementsByClassName(CLASS_NAMES7.marker.name)[0];
        var newMarker = marker();
        if (!oldMarker) {
          select2(newMarker).attr("className", CLASS_NAMES7.marker.name).styles(style);
          parent2.appendChild(newMarker);
        } else if (newMarker.nodeName === oldMarker.nodeName) {
          copyAttributes2(oldMarker, newMarker);
          select2(oldMarker).styles(style);
        } else {
          oldMarker.remove();
          select2(newMarker).attr("className", CLASS_NAMES7.marker.name).styles(style);
          parent2.appendChild(newMarker);
        }
        _this2.markerGroup.node().scale(1 / _this2.markerGroup.node().getScale()[0]);
        scaleToPixel(_this2.markerGroup.node(), _this2.scaleSize, true);
      });
    };
    CategoryItem2.prototype.renderLabel = function(container) {
      var _a2 = subStyleProps(this.attributes, "label"), label = _a2.text, style = __rest(_a2, ["text"]);
      this.labelGroup = container.maybeAppendByClassName(CLASS_NAMES7.labelGroup, "g").style("zIndex", 0);
      this.labelGroup.maybeAppendByClassName(CLASS_NAMES7.label, function() {
        return renderExtDo(label);
      }).styles(style);
    };
    CategoryItem2.prototype.renderValue = function(container) {
      var _this2 = this;
      var _a2 = subStyleProps(this.attributes, "value"), value2 = _a2.text, style = __rest(_a2, ["text"]);
      this.valueGroup = container.maybeAppendByClassName(CLASS_NAMES7.valueGroup, "g").style("zIndex", 0);
      ifShow(this.showValue, this.valueGroup, function() {
        _this2.valueGroup.maybeAppendByClassName(CLASS_NAMES7.value, function() {
          return renderExtDo(value2);
        }).styles(style);
      });
    };
    CategoryItem2.prototype.renderBackground = function(container) {
      var _a2 = this.shape, width = _a2.width, height = _a2.height;
      var style = subStyleProps(this.attributes, "background");
      this.background = container.maybeAppendByClassName(CLASS_NAMES7.backgroundGroup, "g").style("zIndex", -1);
      this.background.maybeAppendByClassName(CLASS_NAMES7.background, "rect").styles(__assign({ width, height }, style));
    };
    CategoryItem2.prototype.adjustLayout = function() {
      var _a2 = this.layout, labelWidth = _a2.labelWidth, valueWidth = _a2.valueWidth, height = _a2.height, _b = __read(_a2.position, 3), markerX = _b[0], labelX = _b[1], valueX = _b[2];
      var halfHeight = height / 2;
      this.markerGroup.styles({ x: markerX, y: halfHeight });
      this.labelGroup.styles({ x: labelX, y: halfHeight });
      ellipsisIt(this.labelGroup.select(CLASS_NAMES7.label.class).node(), Math.ceil(labelWidth));
      if (this.showValue) {
        this.valueGroup.styles({ x: valueX, y: halfHeight });
        ellipsisIt(this.valueGroup.select(CLASS_NAMES7.value.class).node(), Math.ceil(valueWidth));
      }
    };
    CategoryItem2.prototype.render = function(attributes, container) {
      var ctn = select2(container);
      this.renderMarker(ctn);
      this.renderLabel(ctn);
      this.renderValue(ctn);
      this.renderBackground(ctn);
      this.adjustLayout();
    };
    return CategoryItem2;
  }(Component)
);

// node_modules/@antv/component/esm/ui/legend/category/items.js
var CLASS_NAMES8 = classNames({
  page: "item-page",
  navigator: "navigator",
  item: "item"
}, "items");
var ifSatisfied = function(value2, rule, defaultValue) {
  if (defaultValue === void 0) {
    defaultValue = true;
  }
  if (value2) {
    return rule(value2);
  }
  return defaultValue;
};
var CategoryItems = (
  /** @class */
  function(_super) {
    __extends(CategoryItems2, _super);
    function CategoryItems2(options) {
      var _this2 = _super.call(this, options, {
        data: [],
        gridRow: Infinity,
        gridCol: void 0,
        padding: 0,
        width: 1e3,
        height: 100,
        rowPadding: 0,
        colPadding: 0,
        layout: "flex",
        orientation: "horizontal",
        click: noop_default,
        mouseenter: noop_default,
        mouseleave: noop_default
      }) || this;
      _this2.navigatorShape = [0, 0];
      return _this2;
    }
    Object.defineProperty(CategoryItems2.prototype, "pageViews", {
      get: function() {
        return this.navigator.getContainer();
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(CategoryItems2.prototype, "grid", {
      get: function() {
        var _a2 = this.attributes, gridRow = _a2.gridRow, gridCol = _a2.gridCol, data2 = _a2.data;
        if (!gridRow && !gridCol)
          throw new Error("gridRow and gridCol can not be set null at the same time");
        if (!!gridRow && !!gridCol)
          return [gridRow, gridCol];
        if (gridRow)
          return [gridRow, data2.length];
        return [data2.length, gridCol];
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(CategoryItems2.prototype, "renderData", {
      get: function() {
        var _a2 = this.attributes, data2 = _a2.data, layout = _a2.layout;
        var style = subStyleProps(this.attributes, "item");
        var d2 = data2.map(function(datum, index3) {
          var _a3 = datum.id, id3 = _a3 === void 0 ? index3 : _a3, labelText = datum.label, valueText = datum.value;
          return {
            id: "".concat(id3),
            index: index3,
            style: __assign({ layout, labelText, valueText }, Object.fromEntries(Object.entries(style).map(function(_a4) {
              var _b = __read(_a4, 2), key = _b[0], val = _b[1];
              return [key, getCallbackValue(val, [datum, index3, data2])];
            })))
          };
        });
        return d2;
      },
      enumerable: false,
      configurable: true
    });
    CategoryItems2.prototype.getGridLayout = function() {
      var _this2 = this;
      var _a2 = this.attributes, orientation = _a2.orientation, width = _a2.width, rowPadding = _a2.rowPadding, colPadding = _a2.colPadding;
      var _b = __read(this.navigatorShape, 1), navWidth = _b[0];
      var _c = __read(this.grid, 2), gridRow = _c[0], gridCol = _c[1];
      var pageSize = gridCol * gridRow;
      var prevOffset = 0;
      return this.pageViews.children.map(function(item, index3) {
        var _a3, _b2;
        var page = Math.floor(index3 / pageSize);
        var pageIndex = index3 % pageSize;
        var dir = _this2.ifHorizontal(gridCol, gridRow);
        var pos = [Math.floor(pageIndex / dir), pageIndex % dir];
        if (orientation === "vertical")
          pos.reverse();
        var _c2 = __read(pos, 2), row2 = _c2[0], col = _c2[1];
        var colWidth = (width - navWidth - (gridCol - 1) * colPadding) / gridCol;
        var rowHeight = item.getBBox().height;
        var _d = __read([0, 0], 2), x3 = _d[0], y3 = _d[1];
        if (orientation === "horizontal") {
          _a3 = __read([prevOffset, row2 * (rowHeight + rowPadding)], 2), x3 = _a3[0], y3 = _a3[1];
          prevOffset = col === gridCol - 1 ? 0 : prevOffset + colWidth + colPadding;
        } else {
          _b2 = __read([col * (colWidth + colPadding), prevOffset], 2), x3 = _b2[0], y3 = _b2[1];
          prevOffset = row2 === gridRow - 1 ? 0 : prevOffset + rowHeight + rowPadding;
        }
        return { page, index: index3, row: row2, col, pageIndex, width: colWidth, height: rowHeight, x: x3, y: y3 };
      });
    };
    CategoryItems2.prototype.getFlexLayout = function() {
      var _a2 = this.attributes, maxWidth = _a2.width, maxHeight = _a2.height, rowPadding = _a2.rowPadding, cP = _a2.colPadding;
      var _b = __read(this.navigatorShape, 1), navWidth = _b[0];
      var _c = __read(this.grid, 2), gridRow = _c[0], gridCol = _c[1];
      var _d = __read([maxWidth - navWidth, maxHeight], 2), limitWidth = _d[0], limitHeight = _d[1];
      var _e = __read([0, 0, 0, 0, 0, 0, 0, 0], 8), x3 = _e[0], y3 = _e[1], page = _e[2], pageIndex = _e[3], col = _e[4], row2 = _e[5], prevWidth = _e[6], prevHeight = _e[7];
      return this.pageViews.children.map(function(item, index3) {
        var _a3, _b2, _c2, _d2;
        var _e2 = item.getBBox(), width = _e2.width, height = _e2.height;
        var colPadding = prevWidth === 0 ? 0 : cP;
        var nextWidth = prevWidth + colPadding + width;
        if (nextWidth <= limitWidth && ifSatisfied(col, function(c5) {
          return c5 < gridCol;
        })) {
          _a3 = __read([prevWidth + colPadding, prevHeight, nextWidth], 3), x3 = _a3[0], y3 = _a3[1], prevWidth = _a3[2];
          return { width, height, x: x3, y: y3, page, index: index3, pageIndex: pageIndex++, row: row2, col: col++ };
        }
        _b2 = __read([row2 + 1, 0, 0, prevHeight + height + rowPadding], 4), row2 = _b2[0], col = _b2[1], prevWidth = _b2[2], prevHeight = _b2[3];
        var nextHeight = prevHeight + height;
        if (nextHeight <= limitHeight && ifSatisfied(row2, function(r) {
          return r < gridRow;
        })) {
          _c2 = __read([prevWidth, prevHeight, width], 3), x3 = _c2[0], y3 = _c2[1], prevWidth = _c2[2];
          return { width, height, x: x3, y: y3, page, index: index3, pageIndex: pageIndex++, row: row2, col: col++ };
        }
        _d2 = __read([0, 0, width, 0, page + 1, 0, 0, 0], 8), x3 = _d2[0], y3 = _d2[1], prevWidth = _d2[2], prevHeight = _d2[3], page = _d2[4], pageIndex = _d2[5], row2 = _d2[6], col = _d2[7];
        return { width, height, x: x3, y: y3, page, index: index3, pageIndex: pageIndex++, row: row2, col: col++ };
      });
    };
    Object.defineProperty(CategoryItems2.prototype, "itemsLayout", {
      get: function() {
        this.navigatorShape = [0, 0];
        var cb = this.attributes.layout === "grid" ? this.getGridLayout : this.getFlexLayout;
        var layout = cb.call(this);
        if (layout.slice(-1)[0].page > 0) {
          this.navigatorShape = [55, 0];
          return cb.call(this);
        }
        return layout;
      },
      enumerable: false,
      configurable: true
    });
    CategoryItems2.prototype.ifHorizontal = function(a4, b) {
      var orientation = this.attributes.orientation;
      return ifHorizontal(orientation, a4, b);
    };
    CategoryItems2.prototype.flattenPage = function(container) {
      container.querySelectorAll(CLASS_NAMES8.item.class).forEach(function(item) {
        container.appendChild(item);
      });
      container.querySelectorAll(CLASS_NAMES8.page.class).forEach(function(page) {
        var removedPage = container.removeChild(page);
        removedPage.destroy();
      });
    };
    CategoryItems2.prototype.renderItems = function(container) {
      var _a2 = this.attributes, click = _a2.click, mouseenter = _a2.mouseenter, mouseleave = _a2.mouseleave;
      this.flattenPage(container);
      var dispatchCustomEvent = this.dispatchCustomEvent.bind(this);
      select2(container).selectAll(CLASS_NAMES8.item.class).data(this.renderData, function(d2) {
        return d2.id;
      }).join(function(enter) {
        return enter.append(function(_a3) {
          var style = _a3.style;
          return new CategoryItem({ style });
        }).attr("className", CLASS_NAMES8.item.name).on("click", function() {
          click === null || click === void 0 ? void 0 : click(this);
          dispatchCustomEvent("itemClick", { item: this });
        }).on("pointerenter", function() {
          mouseenter === null || mouseenter === void 0 ? void 0 : mouseenter(this);
          dispatchCustomEvent("itemMouseenter", { item: this });
        }).on("pointerleave", function() {
          mouseleave === null || mouseleave === void 0 ? void 0 : mouseleave(this);
          dispatchCustomEvent("itemMouseleave", { item: this });
        });
      }, function(update3) {
        return update3.each(function(_a3) {
          var style = _a3.style;
          this.update(style);
        });
      }, function(exit) {
        return exit.remove();
      });
    };
    CategoryItems2.prototype.relayoutNavigator = function() {
      var _a2;
      var _b = this.attributes, layout = _b.layout, width = _b.width;
      var height = ((_a2 = this.pageViews.children[0]) === null || _a2 === void 0 ? void 0 : _a2.getBBox().height) || 0;
      var _c = __read(this.navigatorShape, 2), navWidth = _c[0], navHeight = _c[1];
      this.navigator.update(layout === "grid" ? { pageWidth: width - navWidth, pageHeight: height - navHeight } : {});
    };
    CategoryItems2.prototype.adjustLayout = function() {
      var _this2 = this;
      var itemsLayouts = Object.entries(groupBy(this.itemsLayout, "page")).map(function(_a2) {
        var _b = __read(_a2, 2), page = _b[0], layouts = _b[1];
        return {
          page,
          layouts
        };
      });
      var categoryItems = __spreadArray([], __read(this.navigator.getContainer().children), false);
      itemsLayouts.forEach(function(_a2) {
        var layouts = _a2.layouts;
        var page = _this2.pageViews.appendChild(new Group2({ className: CLASS_NAMES8.page.name }));
        layouts.forEach(function(layout) {
          var x3 = layout.x, y3 = layout.y, index3 = layout.index, width = layout.width, height = layout.height;
          var item = categoryItems[index3];
          page.appendChild(item);
          set_default(item, "__layout__", layout);
          item.update({ x: x3, y: y3, width, height });
        });
      });
      this.relayoutNavigator();
    };
    CategoryItems2.prototype.renderNavigator = function(container) {
      var orientation = this.attributes.orientation;
      var navStyle = subStyleProps(this.attributes, "nav");
      var style = deepAssign2({ orientation }, navStyle);
      var that = this;
      container.selectAll(CLASS_NAMES8.navigator.class).data(["nav"]).join(function(enter) {
        return enter.append(function() {
          return new Navigator({ style });
        }).attr("className", CLASS_NAMES8.navigator.name).each(function() {
          that.navigator = this;
        });
      }, function(update3) {
        return update3.each(function() {
          this.update(style);
        });
      }, function(exit) {
        return exit.remove();
      });
      return this.navigator;
    };
    CategoryItems2.prototype.getBBox = function() {
      return this.navigator.getBBox();
    };
    CategoryItems2.prototype.render = function(attributes, container) {
      var data2 = this.attributes.data;
      if (!data2 || data2.length === 0)
        return;
      var navigator = this.renderNavigator(select2(container));
      this.renderItems(navigator.getContainer());
      this.adjustLayout();
    };
    CategoryItems2.prototype.dispatchCustomEvent = function(type, payload) {
      var evt = new CustomEvent(type, {
        detail: payload
      });
      this.dispatchEvent(evt);
    };
    return CategoryItems2;
  }(Component)
);

// node_modules/@antv/component/esm/ui/legend/continuous/handle.js
var CLASS_NAMES9 = classNames({
  markerGroup: "marker-group",
  marker: "marker",
  labelGroup: "label-group",
  label: "label"
}, "handle");
var DEFAULT_HANDLE_CFG = {
  showLabel: true,
  formatter: function(val) {
    return val.toString();
  },
  markerSize: 25,
  markerStroke: "#c5c5c5",
  markerFill: "#fff",
  markerLineWidth: 1,
  labelFontSize: 12,
  labelFill: "#c5c5c5",
  labelText: "",
  orientation: "vertical",
  spacing: 0
};
var Handle2 = (
  /** @class */
  function(_super) {
    __extends(Handle3, _super);
    function Handle3(options) {
      return _super.call(this, options, DEFAULT_HANDLE_CFG) || this;
    }
    Handle3.prototype.render = function(attributes, container) {
      var markerGroup = select2(container).maybeAppendByClassName(CLASS_NAMES9.markerGroup, "g");
      this.renderMarker(markerGroup);
      var labelGroup = select2(container).maybeAppendByClassName(CLASS_NAMES9.labelGroup, "g");
      this.renderLabel(labelGroup);
    };
    Handle3.prototype.renderMarker = function(container) {
      var _this2 = this;
      var _a2 = this.attributes, orientation = _a2.orientation, _b = _a2.markerSymbol, markerSymbol = _b === void 0 ? ifHorizontal(orientation, "horizontalHandle", "verticalHandle") : _b;
      ifShow(!!markerSymbol, container, function(group3) {
        var handleStyle = subStyleProps(_this2.attributes, "marker");
        var markerStyle = __assign({ symbol: markerSymbol }, handleStyle);
        _this2.marker = group3.maybeAppendByClassName(CLASS_NAMES9.marker, function() {
          return new Marker({ style: markerStyle });
        }).update(markerStyle);
      });
    };
    Handle3.prototype.renderLabel = function(container) {
      var _this2 = this;
      var _a2 = this.attributes, showLabel = _a2.showLabel, orientation = _a2.orientation, _b = _a2.spacing, spacing = _b === void 0 ? 0 : _b, formatter2 = _a2.formatter;
      ifShow(showLabel, container, function(group3) {
        var _a3;
        var _b2 = subStyleProps(_this2.attributes, "label"), text = _b2.text, labelStyle = __rest(_b2, ["text"]);
        var _c = ((_a3 = group3.select(CLASS_NAMES9.marker.class)) === null || _a3 === void 0 ? void 0 : _a3.node().getBBox()) || {}, _d = _c.width, width = _d === void 0 ? 0 : _d, _e = _c.height, height = _e === void 0 ? 0 : _e;
        var _f = __read(ifHorizontal(orientation, [0, height + spacing, "center", "top"], [width + spacing, 0, "start", "middle"]), 4), x3 = _f[0], y3 = _f[1], textAlign = _f[2], textBaseline = _f[3];
        group3.maybeAppendByClassName(CLASS_NAMES9.label, "text").styles(__assign(__assign({}, labelStyle), { x: x3, y: y3, text: formatter2(text).toString(), textAlign, textBaseline }));
      });
    };
    return Handle3;
  }(Component)
);

// node_modules/@antv/component/esm/ui/legend/constant.js
var LEGEND_BASE_DEFAULT_OPTIONS = {
  showTitle: true,
  padding: 0,
  orientation: "horizontal",
  backgroundFill: "transparent",
  titleText: "",
  titleSpacing: 4,
  titlePosition: "top-left",
  titleFill: "#2C3542",
  titleFontWeight: "bold",
  titleFontFamily: "sans-serif",
  titleFontSize: 12
};
var CATEGORY_DEFAULT_OPTIONS = deepAssign2({}, LEGEND_BASE_DEFAULT_OPTIONS, {});
var CONTINUOUS_DEFAULT_OPTIONS = deepAssign2({}, LEGEND_BASE_DEFAULT_OPTIONS, superStyleProps(DEFAULT_HANDLE_CFG, "handle"), {
  color: [
    "#d0e3fa",
    "#acc7f6",
    "#8daaf2",
    "#6d8eea",
    "#4d73cd",
    "#325bb1",
    "#5a3e75",
    "#8c3c79",
    "#e23455",
    "#e7655b"
  ],
  indicatorBackgroundFill: "#262626",
  indicatorLabelFill: "white",
  indicatorLabelFontSize: 12,
  indicatorVisibility: "hidden",
  labelAlign: "value",
  labelDirection: "positive",
  labelSpacing: 5,
  showHandle: true,
  showIndicator: true,
  showLabel: true,
  slidable: true,
  titleText: "",
  type: "continuous"
});
var STEP_RATIO = 0.01;
var CLASS_NAMES10 = classNames({
  title: "title",
  titleGroup: "title-group",
  items: "items",
  itemsGroup: "items-group",
  contentGroup: "content-group",
  ribbonGroup: "ribbon-group",
  ribbon: "ribbon",
  handlesGroup: "handles-group",
  handle: "handle",
  startHandle: "start-handle",
  endHandle: "end-handle",
  labelGroup: "label-group",
  label: "label",
  indicator: "indicator"
}, "legend");

// node_modules/@antv/component/esm/ui/legend/category.js
var Category = (
  /** @class */
  function(_super) {
    __extends(Category2, _super);
    function Category2(options) {
      return _super.call(this, options, CATEGORY_DEFAULT_OPTIONS) || this;
    }
    Category2.prototype.renderTitle = function(container, width, height) {
      var _a2 = this.attributes, showTitle = _a2.showTitle, titleText = _a2.titleText;
      var style = subStyleProps(this.attributes, "title");
      var _b = __read(splitStyle(style), 2), titleStyle = _b[0], groupStyle = _b[1];
      this.titleGroup = container.maybeAppendByClassName(CLASS_NAMES10.titleGroup, "g").styles(groupStyle);
      var finalTitleStyle = __assign(__assign({ width, height }, titleStyle), { text: showTitle ? titleText : "" });
      this.title = this.titleGroup.maybeAppendByClassName(CLASS_NAMES10.title, function() {
        return new Title({ style: finalTitleStyle });
      }).update(finalTitleStyle);
    };
    Category2.prototype.renderItems = function(container, bbox) {
      var x3 = bbox.x, y3 = bbox.y, width = bbox.width, height = bbox.height;
      var style = subStyleProps(this.attributes, "title", true);
      var _a2 = __read(splitStyle(style), 2), partialItemStyle = _a2[0], groupStyle = _a2[1];
      var itemStyle = __assign(__assign({}, partialItemStyle), { width, height, x: 0, y: 0 });
      this.itemsGroup = container.maybeAppendByClassName(CLASS_NAMES10.itemsGroup, "g").styles(__assign({ x: x3, y: y3 }, groupStyle));
      var that = this;
      this.itemsGroup.selectAll(CLASS_NAMES10.items.class).data(["items"]).join(function(enter) {
        return enter.append(function() {
          return new CategoryItems({ style: itemStyle });
        }).attr("className", CLASS_NAMES10.items.name).each(function() {
          that.items = select2(this);
        });
      }, function(update3) {
        return update3.update(itemStyle);
      }, function(exit) {
        return exit.remove();
      });
    };
    Category2.prototype.adjustLayout = function() {
      var showTitle = this.attributes.showTitle;
      if (showTitle) {
        var _a2 = this.title.node().getAvailableSpace(), x3 = _a2.x, y3 = _a2.y;
        this.itemsGroup.node().setLocalPosition(x3, y3);
      }
    };
    Object.defineProperty(Category2.prototype, "availableSpace", {
      get: function() {
        var _a2 = this.attributes, showTitle = _a2.showTitle, width = _a2.width, height = _a2.height;
        if (!showTitle)
          return new BBox(0, 0, width, height);
        return this.title.node().getAvailableSpace();
      },
      enumerable: false,
      configurable: true
    });
    Category2.prototype.getBBox = function() {
      var _a2, _b;
      var title = (_a2 = this.title) === null || _a2 === void 0 ? void 0 : _a2.node();
      var items = (_b = this.items) === null || _b === void 0 ? void 0 : _b.node();
      if (!title || !items)
        return _super.prototype.getBBox.call(this);
      return getBBox2(title, items);
    };
    Category2.prototype.render = function(attributes, container) {
      var width = attributes.width, height = attributes.height;
      var ctn = select2(container);
      this.renderTitle(ctn, width, height);
      this.renderItems(ctn, this.availableSpace);
      this.adjustLayout();
    };
    return Category2;
  }(Component)
);

// node_modules/@antv/component/esm/ui/indicator/constant.js
var DEFAULT_INDICATOR_STYLE_PROPS = {
  backgroundFill: "#262626",
  backgroundLineCap: "round",
  backgroundLineWidth: 1,
  backgroundStroke: "#333",
  backgroundZIndex: -1,
  formatter: function(val) {
    return val.toString();
  },
  labelFill: "#fff",
  labelFontSize: 12,
  labelTextBaseline: "middle",
  padding: [2, 4],
  position: "right",
  radius: 0,
  zIndex: 999
};

// node_modules/@antv/component/esm/ui/indicator/indicator.js
var CLASS_NAMES11 = classNames({
  background: "background",
  labelGroup: "label-group",
  label: "label"
}, "indicator");
var Indicator = (
  /** @class */
  function(_super) {
    __extends(Indicator2, _super);
    function Indicator2(options) {
      var _this2 = _super.call(this, options, DEFAULT_INDICATOR_STYLE_PROPS) || this;
      _this2.point = [0, 0];
      _this2.group = _this2.appendChild(new Group2({}));
      _this2.isMutationObserved = true;
      return _this2;
    }
    Indicator2.prototype.renderBackground = function() {
      if (!this.label)
        return;
      var _a2 = this.attributes, position = _a2.position, padding = _a2.padding;
      var _b = __read(parseSeriesAttr(padding), 4), t = _b[0], r = _b[1], b = _b[2], l = _b[3];
      var _c = this.label.node().getLocalBounds(), min11 = _c.min, max11 = _c.max;
      var bbox = new BBox(min11[0] - l, min11[1] - t, max11[0] + r - min11[0] + l, max11[1] + b - min11[1] + t);
      var path2 = this.getPath(position, bbox);
      var style = subStyleProps(this.attributes, "background");
      this.background = select2(this.group).maybeAppendByClassName(CLASS_NAMES11.background, "path").styles(__assign(__assign({}, style), { path: path2 }));
      this.group.appendChild(this.label.node());
    };
    Indicator2.prototype.renderLabel = function() {
      var _a2 = this.attributes, formatter2 = _a2.formatter, labelText = _a2.labelText;
      var style = subStyleProps(this.attributes, "label");
      var _b = __read(splitStyle(style), 2), _c = _b[0], groupStyle = _b[1], rawText = _c.text, textStyle = __rest(_c, ["text"]);
      this.label = select2(this.group).maybeAppendByClassName(CLASS_NAMES11.labelGroup, "g").styles(groupStyle);
      if (!labelText)
        return;
      var text = this.label.maybeAppendByClassName(CLASS_NAMES11.label, function() {
        return renderExtDo(formatter2(labelText));
      }).style("text", formatter2(labelText).toString());
      text.selectAll("text").styles(textStyle);
    };
    Indicator2.prototype.adjustLayout = function() {
      var _a2 = __read(this.point, 2), dx = _a2[0], dy = _a2[1];
      this.group.attr("x", -dx).attr("y", -dy);
    };
    Indicator2.prototype.getPath = function(position, bbox) {
      var r = this.attributes.radius;
      var x3 = bbox.x, y3 = bbox.y, width = bbox.width, height = bbox.height;
      var pathArray = [
        // 0 
        ["M", x3 + r, y3],
        // 1 
        ["L", x3 + width - r, y3],
        // 2 
        ["A", r, r, 0, 0, 1, x3 + width, y3 + r],
        // 3 
        ["L", x3 + width, y3 + height - r],
        // 4 
        ["A", r, r, 0, 0, 1, x3 + width - r, y3 + height],
        // 5 
        ["L", x3 + r, y3 + height],
        // 6 
        ["A", r, r, 0, 0, 1, x3, y3 + height - r],
        // 7 
        ["L", x3, y3 + r],
        // 8 
        ["A", r, r, 0, 0, 1, x3 + r, y3],
        // 9 
        ["Z"]
      ];
      var revertPositionMap = { top: 4, right: 6, bottom: 0, left: 2 };
      var index3 = revertPositionMap[position];
      var newPath = this.createCorner([pathArray[index3].slice(-2), pathArray[index3 + 1].slice(-2)]);
      pathArray.splice.apply(pathArray, __spreadArray([index3 + 1, 1], __read(newPath), false));
      pathArray[0][0] = "M";
      return pathArray;
    };
    Indicator2.prototype.createCorner = function(edge, size5) {
      if (size5 === void 0) {
        size5 = 10;
      }
      var cornerScale = 0.8;
      var isH = isHorizontal.apply(void 0, __spreadArray([], __read(edge), false));
      var _a2 = __read(edge, 2), _b = __read(_a2[0], 2), x05 = _b[0], y05 = _b[1], _c = __read(_a2[1], 2), x12 = _c[0], y12 = _c[1];
      var _d = __read(isH ? [x12 - x05, [x05, x12]] : [y12 - y05, [y05, y12]], 2), len5 = _d[0], _e = __read(_d[1], 2), b0 = _e[0], b1 = _e[1];
      var hL = len5 / 2;
      var sign3 = len5 / Math.abs(len5);
      var cL = size5 * sign3;
      var hCL = cL / 2;
      var cS = cL * Math.sqrt(3) / 2 * cornerScale;
      var _f = __read([b0, b0 + hL - hCL, b0 + hL, b0 + hL + hCL, b1], 5), a0 = _f[0], a1 = _f[1], a22 = _f[2], a32 = _f[3], a4 = _f[4];
      if (isH) {
        this.point = [a22, y05 - cS];
        return [
          ["L", a0, y05],
          ["L", a1, y05],
          ["L", a22, y05 - cS],
          ["L", a32, y05],
          ["L", a4, y05]
        ];
      }
      this.point = [x05 + cS, a22];
      return [
        ["L", x05, a0],
        ["L", x05, a1],
        ["L", x05 + cS, a22],
        ["L", x05, a32],
        ["L", x05, a4]
      ];
    };
    Indicator2.prototype.applyVisibility = function() {
      var visibility2 = this.attributes.visibility;
      if (visibility2 === "hidden")
        hide(this);
      else
        show(this);
    };
    Indicator2.prototype.bindEvents = function() {
      this.label.on(ElementEvent.BOUNDS_CHANGED, this.renderBackground);
    };
    Indicator2.prototype.render = function() {
      this.renderLabel();
      this.renderBackground();
      this.adjustLayout();
      this.applyVisibility();
    };
    return Indicator2;
  }(Component)
);

// node_modules/@antv/component/esm/ui/legend/continuous/utils.js
function search(array2, value2) {
  for (var i = 1; i < array2.length; i += 1) {
    var st = array2[i - 1];
    var end = array2[i];
    if (value2 >= st && value2 <= end) {
      return [st, end];
    }
  }
  return [value2, value2];
}
function getBlockColor(partition3, color2, orientation) {
  var colors = Array.from(color2);
  var count4 = partition3.length;
  return new Array(count4).fill(0).reduce(function(r, v, idx) {
    var c5 = colors[idx % colors.length];
    return r += " ".concat(partition3[idx], ":").concat(c5).concat(idx < count4 - 1 ? " ".concat(partition3[idx + 1], ":").concat(c5) : "");
  }, "l(".concat(orientation === "horizontal" ? "0" : "270", ")"));
}
function getNextTickValue(ticks2, value2) {
  var _a2 = __read(search(ticks2, value2), 2), v1 = _a2[0], v2 = _a2[1];
  return { tick: value2 > (v1 + v2) / 2 ? v2 : v1, range: [v1, v2] };
}

// node_modules/@antv/component/esm/ui/legend/continuous/ribbon.js
var CLASS_NAMES12 = classNames({
  trackGroup: "background-group",
  track: "background",
  selectionGroup: "ribbon-group",
  selection: "ribbon",
  clipPath: "clip-path"
}, "ribbon");
function getShape(attr2) {
  var orientation = attr2.orientation, size5 = attr2.size, length5 = attr2.length;
  return ifHorizontal(orientation, [length5, size5], [size5, length5]);
}
function getTrackPath(attr2) {
  var type = attr2.type;
  var _a2 = __read(getShape(attr2), 2), cw2 = _a2[0], ch2 = _a2[1];
  if (type === "size") {
    return [["M", 0, ch2], ["L", 0 + cw2, 0], ["L", 0 + cw2, ch2], ["Z"]];
  }
  return [["M", 0, ch2], ["L", 0, 0], ["L", 0 + cw2, 0], ["L", 0 + cw2, ch2], ["Z"]];
}
function getSelectionPath(attr2) {
  return getTrackPath(attr2);
}
function getColor(attr2) {
  var orientation = attr2.orientation, color2 = attr2.color, block = attr2.block, partition3 = attr2.partition;
  var colors;
  if (is_function_default(color2)) {
    var len5 = 20;
    colors = new Array(len5).fill(0).map(function(_2, index3, arr) {
      return color2(index3 / (arr.length - 1));
    });
  } else
    colors = color2;
  var count4 = colors.length;
  var genericColor = colors.map(function(c5) {
    return parseColor(c5).toString();
  });
  if (!count4)
    return "";
  if (count4 === 1)
    return genericColor[0];
  if (block)
    return getBlockColor(partition3, genericColor, orientation);
  return genericColor.reduce(function(r, c5, idx) {
    return r += " ".concat(idx / (count4 - 1), ":").concat(c5);
  }, "l(".concat(ifHorizontal(orientation, "0", "270"), ")"));
}
function getClipPath(attr2) {
  var orientation = attr2.orientation, range4 = attr2.range;
  if (!range4)
    return [];
  var _a2 = __read(getShape(attr2), 2), width = _a2[0], height = _a2[1];
  var _b = __read(range4, 2), st = _b[0], et = _b[1];
  var x3 = ifHorizontal(orientation, st * width, 0);
  var y3 = ifHorizontal(orientation, 0, st * height);
  var w = ifHorizontal(orientation, et * width, width);
  var h = ifHorizontal(orientation, height, et * height);
  return [["M", x3, y3], ["L", x3, h], ["L", w, h], ["L", w, y3], ["Z"]];
}
function renderTrack(container, attr2) {
  var style = subStyleProps(attr2, "track");
  container.maybeAppendByClassName(CLASS_NAMES12.track, "path").styles(__assign({ path: getTrackPath(attr2) }, style));
}
function renderSelection(container, attr2) {
  var style = subStyleProps(attr2, "selection");
  var fill2 = getColor(attr2);
  var ribbon = container.maybeAppendByClassName(CLASS_NAMES12.selection, "path").styles(__assign({ path: getSelectionPath(attr2), fill: fill2 }, style));
  var clipPath = ribbon.maybeAppendByClassName(CLASS_NAMES12.clipPath, "path").styles({ path: getClipPath(attr2) }).node();
  ribbon.style("clip-path", clipPath);
}
var Ribbon = (
  /** @class */
  function(_super) {
    __extends(Ribbon3, _super);
    function Ribbon3(options) {
      return _super.call(this, options, {
        type: "color",
        orientation: "horizontal",
        size: 30,
        range: [0, 1],
        length: 200,
        block: false,
        partition: [],
        color: ["#fff", "#000"],
        trackFill: "#e5e5e5"
      }) || this;
    }
    Ribbon3.prototype.render = function(attribute, container) {
      var trackGroup = select2(container).maybeAppendByClassName(CLASS_NAMES12.trackGroup, "g");
      renderTrack(trackGroup, attribute);
      var ribbonGroup = select2(container).maybeAppendByClassName(CLASS_NAMES12.selectionGroup, "g");
      renderSelection(ribbonGroup, attribute);
    };
    return Ribbon3;
  }(Component)
);

// node_modules/@antv/component/esm/ui/legend/continuous.js
function getMinMax(data2) {
  return {
    min: Math.min.apply(Math, __spreadArray([], __read(data2.map(function(d2) {
      return d2.value;
    })), false)),
    max: Math.max.apply(Math, __spreadArray([], __read(data2.map(function(d2) {
      return d2.value;
    })), false))
  };
}
var Continuous2 = (
  /** @class */
  function(_super) {
    __extends(Continuous3, _super);
    function Continuous3(options) {
      var _this2 = _super.call(this, options, CONTINUOUS_DEFAULT_OPTIONS) || this;
      _this2.eventToOffsetScale = new Linear({});
      _this2.innerRibbonScale = new Linear({});
      _this2.cacheLabelBBox = null;
      _this2.cacheHandleBBox = null;
      _this2.onHovering = function(e) {
        var _a2 = _this2.attributes, data2 = _a2.data, block = _a2.block;
        e.stopPropagation();
        var value2 = _this2.getValueByCanvasPoint(e);
        if (block) {
          var range4 = getNextTickValue(data2.map(function(_a3) {
            var value3 = _a3.value;
            return value3;
          }), value2).range;
          _this2.showIndicator((range4[0] + range4[1]) / 2, "".concat(range4[0], "-").concat(range4[1]));
          _this2.dispatchIndicated(value2, range4);
        } else {
          var safetyValue = _this2.getTickValue(value2);
          _this2.showIndicator(safetyValue);
          _this2.dispatchIndicated(safetyValue);
        }
      };
      _this2.onDragStart = function(target) {
        return function(e) {
          e.stopPropagation();
          if (!_this2.attributes.slidable)
            return;
          _this2.target = target;
          _this2.prevValue = _this2.getTickValue(_this2.getValueByCanvasPoint(e));
          document.addEventListener("mousemove", _this2.onDragging);
          document.addEventListener("touchmove", _this2.onDragging);
          document.addEventListener("mouseleave", _this2.onDragEnd);
          document.addEventListener("mouseup", _this2.onDragEnd);
          document.addEventListener("mouseup", _this2.onDragEnd);
          document.addEventListener("touchend", _this2.onDragEnd);
        };
      };
      _this2.onDragging = function(e) {
        var target = _this2.target;
        _this2.updateMouse();
        var _a2 = __read(_this2.selection, 2), start = _a2[0], end = _a2[1];
        var currValue = _this2.getTickValue(_this2.getValueByCanvasPoint(e));
        var diffValue = currValue - _this2.prevValue;
        if (target === "start")
          start !== currValue && _this2.updateSelection(currValue, end);
        else if (target === "end")
          end !== currValue && _this2.updateSelection(start, currValue);
        else if (target === "ribbon" && diffValue !== 0) {
          _this2.prevValue = currValue;
          _this2.updateSelection(diffValue, diffValue, true);
        }
      };
      _this2.onDragEnd = function() {
        _this2.style.cursor = "pointer";
        document.removeEventListener("mousemove", _this2.onDragging);
        document.removeEventListener("touchmove", _this2.onDragging);
        document.removeEventListener("mouseup", _this2.onDragEnd);
        document.removeEventListener("touchend", _this2.onDragEnd);
      };
      return _this2;
    }
    Object.defineProperty(Continuous3.prototype, "handleOffsetRatio", {
      get: function() {
        return this.ifHorizontal(0.5, 0.5);
      },
      enumerable: false,
      configurable: true
    });
    Continuous3.prototype.getBBox = function() {
      var _a2 = this.attributes, width = _a2.width, height = _a2.height;
      return new BBox(0, 0, width, height);
    };
    Continuous3.prototype.render = function(attributes, container) {
      var _this2 = this;
      var showLabel = attributes.showLabel;
      this.renderTitle(select2(container));
      var _a2 = this.availableSpace, x3 = _a2.x, y3 = _a2.y;
      var contentGroup = select2(container).maybeAppendByClassName(CLASS_NAMES10.contentGroup, "g").styles({ x: x3, y: y3 });
      var labelGroup = contentGroup.maybeAppendByClassName(CLASS_NAMES10.labelGroup, "g").styles({ zIndex: 1 });
      ifShow(!!showLabel, labelGroup, function(group3) {
        _this2.renderLabel(group3);
      });
      var ribbonGroup = contentGroup.maybeAppendByClassName(CLASS_NAMES10.ribbonGroup, "g").styles({ zIndex: 0 });
      this.handlesGroup = contentGroup.maybeAppendByClassName(CLASS_NAMES10.handlesGroup, "g").styles({ zIndex: 2 });
      this.renderHandles();
      this.renderRibbon(ribbonGroup);
      this.renderIndicator(contentGroup);
      this.adjustLabel();
      this.adjustHandles();
    };
    Object.defineProperty(Continuous3.prototype, "range", {
      get: function() {
        var _a2 = this.attributes, data2 = _a2.data, domain = _a2.domain;
        return domain ? { min: domain[0], max: domain[1] } : getMinMax(data2);
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Continuous3.prototype, "ribbonScale", {
      get: function() {
        var _a2 = this.range, min11 = _a2.min, max11 = _a2.max;
        this.innerRibbonScale.update({
          domain: [min11, max11],
          range: [0, 1]
        });
        return this.innerRibbonScale;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Continuous3.prototype, "ribbonRange", {
      get: function() {
        var _a2 = __read(this.selection, 2), min11 = _a2[0], max11 = _a2[1];
        var scale10 = this.ribbonScale;
        return [scale10.map(min11), scale10.map(max11)];
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Continuous3.prototype, "selection", {
      get: function() {
        var _a2 = this.range, min11 = _a2.min, max11 = _a2.max;
        var _b = this.attributes.defaultValue, _c = _b === void 0 ? [min11, max11] : _b, _d = __read(_c, 2), start = _d[0], end = _d[1];
        return [start, end];
      },
      enumerable: false,
      configurable: true
    });
    Continuous3.prototype.ifHorizontal = function(a4, b) {
      return ifHorizontal(this.attributes.orientation, typeof a4 === "function" ? a4() : a4, typeof b === "function" ? b() : b);
    };
    Continuous3.prototype.renderTitle = function(container) {
      var _a2 = this.attributes, showTitle = _a2.showTitle, titleText = _a2.titleText, width = _a2.width, height = _a2.height;
      var style = subStyleProps(this.attributes, "title");
      var finalTitleStyle = __assign(__assign({}, style), { width, height, text: titleText });
      var that = this;
      container.selectAll(CLASS_NAMES10.title.class).data(showTitle ? [titleText] : []).join(function(enter) {
        return enter.append(function() {
          return new Title({ style: finalTitleStyle });
        }).attr("className", CLASS_NAMES10.title.name).each(function() {
          that.title = this;
        });
      }, function(update3) {
        return update3.update(finalTitleStyle);
      }, function(exit) {
        return exit.each(function() {
          that.title = void 0;
        }).remove();
      });
    };
    Object.defineProperty(Continuous3.prototype, "availableSpace", {
      get: function() {
        if (this.title)
          return this.title.getAvailableSpace();
        var _a2 = this.attributes, width = _a2.width, height = _a2.height;
        return new BBox(0, 0, width, height);
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Continuous3.prototype, "labelFixedSpacing", {
      get: function() {
        var showTick = this.attributes.showTick;
        return showTick ? 5 : 0;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Continuous3.prototype, "labelPosition", {
      get: function() {
        var _a2 = this.attributes, orientation = _a2.orientation, labelDirection = _a2.labelDirection;
        var positions = {
          vertical: { positive: "right", negative: "left" },
          horizontal: { positive: "bottom", negative: "top" }
        };
        return positions[orientation][labelDirection];
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Continuous3.prototype, "labelBBox", {
      get: function() {
        var _a2;
        var showLabel = this.attributes.showLabel;
        if (!showLabel)
          return new BBox(0, 0, 0, 0);
        if (this.cacheLabelBBox)
          return this.cacheLabelBBox;
        var _b = ((_a2 = this.label.querySelector(CLASS_NAMES3.labelGroup.class)) === null || _a2 === void 0 ? void 0 : _a2.children.slice(-1)[0]).getBBox(), width = _b.width, height = _b.height;
        this.cacheLabelBBox = new BBox(0, 0, width, height);
        return this.cacheLabelBBox;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Continuous3.prototype, "labelShape", {
      get: function() {
        var _a2 = this.attributes, showLabel = _a2.showLabel, _b = _a2.labelSpacing, labelSpacing = _b === void 0 ? 0 : _b;
        if (!showLabel)
          return { width: 0, height: 0, size: 0, length: 0 };
        var _c = this.labelBBox, width = _c.width, height = _c.height;
        var size5 = this.ifHorizontal(height, width) + labelSpacing + this.labelFixedSpacing;
        var length5 = this.ifHorizontal(width, height);
        return { width, height, size: size5, length: length5 };
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Continuous3.prototype, "ribbonBBox", {
      get: function() {
        var _a2 = this.attributes, showHandle = _a2.showHandle, userDefinedRibbonSize = _a2.ribbonSize;
        var _b = this.availableSpace, availableWidth = _b.width, availableHeight = _b.height;
        var _c = this.labelShape, labelSize = _c.size, labelLength = _c.length;
        var _d = __read(this.ifHorizontal([availableHeight, availableWidth], [availableWidth, availableHeight]), 2), availableSize = _d[0], availableLength = _d[1];
        var _e = showHandle ? this.handleShape : { size: 0, length: 0 }, handleSize = _e.size, handleLength = _e.length;
        var handleRatio = this.handleOffsetRatio;
        var ribbonSize = 0;
        var labelPosition = this.labelPosition;
        if (userDefinedRibbonSize) {
          ribbonSize = userDefinedRibbonSize;
        } else if (["bottom", "right"].includes(labelPosition)) {
          ribbonSize = Math.min(availableSize - labelSize, (availableSize - handleSize) / handleRatio);
        } else if (availableSize * (1 - handleRatio) > handleSize) {
          ribbonSize = Math.max(availableSize - labelSize, 0);
        } else
          ribbonSize = Math.max((availableSize - labelSize - handleSize) / handleRatio, 0);
        var edgeLength = Math.max(handleLength, labelLength);
        var ribbonLength = availableLength - edgeLength;
        var _f = __read(this.ifHorizontal([ribbonLength, ribbonSize], [ribbonSize, ribbonLength]), 2), width = _f[0], height = _f[1];
        var finalLabelOccupy = ["top", "left"].includes(labelPosition) ? labelSize : 0;
        var _g = __read(this.ifHorizontal([edgeLength / 2, finalLabelOccupy], [finalLabelOccupy, edgeLength / 2]), 2), x3 = _g[0], y3 = _g[1];
        return new BBox(x3, y3, width, height);
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Continuous3.prototype, "ribbonShape", {
      get: function() {
        var _a2 = this.ribbonBBox, width = _a2.width, height = _a2.height;
        return this.ifHorizontal({ size: height, length: width }, { size: width, length: height });
      },
      enumerable: false,
      configurable: true
    });
    Continuous3.prototype.renderRibbon = function(container) {
      var _a2 = this.attributes, data2 = _a2.data, type = _a2.type, orientation = _a2.orientation, color2 = _a2.color, block = _a2.block;
      var ribbonStyle = subStyleProps(this.attributes, "ribbon");
      var _b = this.range, min11 = _b.min, max11 = _b.max;
      var _c = this.ribbonBBox, x3 = _c.x, y3 = _c.y;
      var _d = this.ribbonShape, length5 = _d.length, size5 = _d.size;
      var style = deepAssign2({
        x: x3,
        y: y3,
        length: length5,
        size: size5,
        type,
        orientation,
        color: color2,
        block,
        partition: data2.map(function(d2) {
          return (d2.value - min11) / (max11 - min11);
        }),
        range: this.ribbonRange
      }, ribbonStyle);
      this.ribbon = container.maybeAppendByClassName(CLASS_NAMES10.ribbon, function() {
        return new Ribbon({ style });
      }).update(style);
    };
    Continuous3.prototype.getHandleClassName = function(type) {
      return "".concat(CLASS_NAMES10.prefix("".concat(type, "-handle")));
    };
    Continuous3.prototype.renderHandles = function() {
      var _a2 = this.attributes, showHandle = _a2.showHandle, orientation = _a2.orientation;
      var handleStyle = subStyleProps(this.attributes, "handle");
      var _b = __read(this.selection, 2), min11 = _b[0], max11 = _b[1];
      var style = __assign(__assign({}, handleStyle), { orientation });
      var _c = handleStyle.shape, shape23 = _c === void 0 ? "slider" : _c;
      var HandleCtor = shape23 === "basic" ? Handle2 : Handle;
      var that = this;
      this.handlesGroup.selectAll(CLASS_NAMES10.handle.class).data(showHandle ? [
        { value: min11, type: "start" },
        { value: max11, type: "end" }
      ] : [], function(d2) {
        return d2.type;
      }).join(function(enter) {
        return enter.append(function() {
          return new HandleCtor({ style });
        }).attr("className", function(_a3) {
          var type = _a3.type;
          return "".concat(CLASS_NAMES10.handle, " ").concat(that.getHandleClassName(type));
        }).each(function(_a3) {
          var type = _a3.type, labelText = _a3.value;
          this.update({ labelText });
          var name2 = "".concat(type, "Handle");
          that[name2] = this;
          this.addEventListener("pointerdown", that.onDragStart(type));
        });
      }, function(update3) {
        return update3.update(style).each(function(_a3) {
          var labelText = _a3.value;
          this.update({ labelText });
        });
      }, function(exit) {
        return exit.each(function(_a3) {
          var type = _a3.type;
          var name2 = "".concat(type, "Handle");
          that[name2] = void 0;
        }).remove();
      });
    };
    Continuous3.prototype.adjustHandles = function() {
      var _a2 = __read(this.selection, 2), min11 = _a2[0], max11 = _a2[1];
      this.setHandlePosition("start", min11);
      this.setHandlePosition("end", max11);
    };
    Continuous3.prototype.adjustTitle = function() {
      var _a2 = this.attributes, titlePosition = _a2.titlePosition, orientation = _a2.orientation;
      var _b = __read(this.getElementsByClassName(CLASS_NAMES10.title.name), 1), title = _b[0];
      var handle = this.handlesGroup.select(".".concat(this.getHandleClassName("start"))).node();
      if (!title || !handle)
        return;
      if (titlePosition !== "top-left" || orientation !== "horizontal")
        return;
      var _c = __read(handle.getLocalBounds().min, 1), handleX = _c[0];
      var _d = __read(title.getLocalBounds().min, 1), titleX = _d[0];
      var diffX = handleX - titleX;
      title.style.x = +(this.style.x || 0) + diffX;
    };
    Object.defineProperty(Continuous3.prototype, "handleBBox", {
      get: function() {
        if (this.cacheHandleBBox)
          return this.cacheHandleBBox;
        if (!this.attributes.showHandle)
          return new BBox(0, 0, 0, 0);
        var _a2 = this.startHandle.getBBox(), startHandleWidth = _a2.width, startHandleHeight = _a2.height;
        var _b = this.endHandle.getBBox(), endHandleWidth = _b.width, endHandleHeight = _b.height;
        var _c = __read([Math.max(startHandleWidth, endHandleWidth), Math.max(startHandleHeight, endHandleHeight)], 2), width = _c[0], height = _c[1];
        this.cacheHandleBBox = new BBox(0, 0, width, height);
        return this.cacheHandleBBox;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Continuous3.prototype, "handleShape", {
      /**
       *   handle label  handle bbox  bbox
       */
      get: function() {
        var _a2 = this.handleBBox, width = _a2.width, height = _a2.height;
        var _b = __read(this.ifHorizontal([height, width], [width, height]), 2), size5 = _b[0], length5 = _b[1];
        return { width, height, size: size5, length: length5 };
      },
      enumerable: false,
      configurable: true
    });
    Continuous3.prototype.setHandlePosition = function(type, value2) {
      var handleFormatter = this.attributes.handleFormatter;
      var _a2 = this.ribbonBBox, ribbonX = _a2.x, ribbonY = _a2.y;
      var ribbonSize = this.ribbonShape.size;
      var offset2 = this.getOffset(value2);
      var _b = __read(this.ifHorizontal([ribbonX + offset2, ribbonY + ribbonSize * this.handleOffsetRatio], [ribbonX + ribbonSize * this.handleOffsetRatio, ribbonY + offset2]), 2), x3 = _b[0], y3 = _b[1];
      var handle = this.handlesGroup.select(".".concat(this.getHandleClassName(type))).node();
      handle === null || handle === void 0 ? void 0 : handle.update({ x: x3, y: y3, formatter: handleFormatter });
    };
    Continuous3.prototype.renderIndicator = function(container) {
      var style = subStyleProps(this.attributes, "indicator");
      this.indicator = container.maybeAppendByClassName(CLASS_NAMES10.indicator, function() {
        return new Indicator({});
      }).update(style);
    };
    Object.defineProperty(Continuous3.prototype, "labelData", {
      get: function() {
        var _this2 = this;
        var data2 = this.attributes.data;
        return data2.reduce(function(acc, curr, index3, arr) {
          var _a2, _b;
          var id3 = (_a2 = curr === null || curr === void 0 ? void 0 : curr.id) !== null && _a2 !== void 0 ? _a2 : index3.toString();
          acc.push(__assign(__assign({}, curr), { id: id3, index: index3, type: "value", label: (_b = curr === null || curr === void 0 ? void 0 : curr.label) !== null && _b !== void 0 ? _b : curr.value.toString(), value: _this2.ribbonScale.map(curr.value) }));
          if (index3 < arr.length - 1) {
            var next = arr[index3 + 1];
            var _c = __read([curr.value, next.value], 2), cr = _c[0], nx = _c[1];
            var midVal = (cr + nx) / 2;
            acc.push(__assign(__assign({}, curr), { id: id3, index: index3, type: "range", range: [cr, nx], label: [cr, nx].join("~"), value: _this2.ribbonScale.map(midVal) }));
          }
          return acc;
        }, []);
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Continuous3.prototype, "labelStyle", {
      get: function() {
        var _a2 = __read(["center", "middle"], 2), labelTextAlign = _a2[0], labelTextBaseline = _a2[1];
        var labelPosition = this.labelPosition;
        if (labelPosition === "top")
          labelTextBaseline = "bottom";
        else if (labelPosition === "bottom")
          labelTextBaseline = "top";
        else if (labelPosition === "left")
          labelTextAlign = "end";
        else if (labelPosition === "right")
          labelTextAlign = "start";
        return {
          labelTextAlign,
          labelTextBaseline
        };
      },
      enumerable: false,
      configurable: true
    });
    Continuous3.prototype.renderLabel = function(container) {
      var _a2 = this.attributes, _b = _a2.showTick, showTick = _b === void 0 ? false : _b, labelFilter = _a2.labelFilter, labelFormatter2 = _a2.labelFormatter;
      var tickStyle = subStyleProps(this.attributes, "tick");
      var labelStyle = subStyleProps(this.attributes, "label");
      var align = labelStyle.align;
      var style = deepAssign2(__assign({ showLine: false, showGrid: false, showTick, type: "linear", startPos: [0, 0], endPos: [0, 0], tickDirection: "negative", labelTransform: "rotate(0)" }, this.labelStyle), superStyleProps(tickStyle, "tick"), superStyleProps(labelStyle, "label"), { data: this.labelData });
      var functionStyle = {
        tickFilter: function(datum, index3, data2) {
          if ((datum === null || datum === void 0 ? void 0 : datum.type) !== "value")
            return false;
          if (labelFilter)
            return labelFilter(datum, datum.index, data2.filter(function(d2) {
              return d2.type !== "value";
            }));
          return true;
        },
        labelFilter: function(datum, index3, data2) {
          if ((datum === null || datum === void 0 ? void 0 : datum.type) !== align)
            return false;
          if (labelFilter)
            return labelFilter(datum, datum.index, data2.filter(function(d2) {
              return d2.type === align;
            }));
          return true;
        },
        labelFormatter: labelFormatter2
      };
      var finalLabelStyle = __assign(__assign(__assign({}, style), functionStyle), { labelOverlap: [{ type: "hide" }] });
      this.label = container.maybeAppendByClassName(CLASS_NAMES10.label, function() {
        return new Axis({ style: finalLabelStyle });
      }).node();
      this.label.update(finalLabelStyle, false);
    };
    Object.defineProperty(Continuous3.prototype, "labelAxisStyle", {
      get: function() {
        var _a2 = this.attributes, showTick = _a2.showTick, labelDirection = _a2.labelDirection, labelSpacing = _a2.labelSpacing, definedTickLength = _a2.tickLength;
        var ribbonSize = this.ribbonShape.size;
        var labelPosition = this.labelPosition;
        var labelFixedSpacing = this.labelFixedSpacing;
        var _b = __read([0, 0, 0], 3), offset2 = _b[0], spacing = _b[1], tickLength = _b[2];
        var internalVal = definedTickLength !== null && definedTickLength !== void 0 ? definedTickLength : ribbonSize;
        if (showTick) {
          tickLength = internalVal;
          spacing = labelFixedSpacing;
          if (labelDirection === "positive") {
            if (labelPosition === "right") {
              offset2 = internalVal;
              tickLength = internalVal;
            } else if (labelPosition === "bottom")
              offset2 = tickLength;
          } else if (labelDirection === "negative") {
            if (labelPosition === "top")
              offset2 = ribbonSize;
            else if (labelPosition === "left")
              offset2 = ribbonSize;
          }
        } else if (labelDirection === "positive") {
          if (labelPosition === "right")
            spacing = internalVal;
          else if (labelPosition === "bottom") {
            offset2 = ribbonSize + labelFixedSpacing;
            spacing = labelSpacing;
          }
        } else if (labelDirection === "negative") {
          if (labelPosition === "left")
            spacing = labelSpacing;
          else if (labelPosition === "top")
            spacing = labelSpacing;
        }
        return { offset: offset2, spacing: labelSpacing, tickLength };
      },
      enumerable: false,
      configurable: true
    });
    Continuous3.prototype.adjustLabel = function() {
      var showLabel = this.attributes.showLabel;
      if (!showLabel)
        return;
      var _a2 = this.ribbonBBox, x3 = _a2.x, y3 = _a2.y, width = _a2.width, height = _a2.height;
      var _b = this.labelAxisStyle, axisOffset = _b.offset, axisSpacing = _b.spacing, axisTickLength = _b.tickLength;
      var _c = __read(this.ifHorizontal([
        [x3, y3 + axisOffset],
        [x3 + width, y3 + axisOffset]
      ], [
        [x3 + axisOffset, y3 + height],
        [x3 + axisOffset, y3]
      ]), 2), startPos = _c[0], endPos = _c[1];
      this.label.update({
        startPos,
        endPos,
        tickLength: axisTickLength,
        labelSpacing: axisSpacing
      }, false);
    };
    Continuous3.prototype.bindEvents = function() {
      this.style.cursor = "pointer";
      this.ribbon.on("pointerdown", this.onDragStart("ribbon"));
      this.ribbon.on("pointermove", this.onHovering);
      this.addEventListener("pointerout", this.hideIndicator);
    };
    Continuous3.prototype.showIndicator = function(value2, text) {
      if (text === void 0) {
        text = "".concat(value2);
      }
      var showIndicator = this.attributes.showIndicator;
      if (!showIndicator || typeof value2 !== "number") {
        this.hideIndicator();
        return;
      }
      var _a2 = this.range, min11 = _a2.min, max11 = _a2.max;
      var _b = this.ribbonBBox, x3 = _b.x, y3 = _b.y;
      var safeValue = clamp_default(value2, min11, max11);
      var offset2 = this.getOffset(safeValue);
      var pos = this.ifHorizontal([offset2 + x3, y3], [x3, offset2 + y3]);
      this.indicator.update({
        x: pos[0],
        y: pos[1],
        position: this.ifHorizontal("top", "left"),
        labelText: text
      });
      show(this.indicator.node());
    };
    Continuous3.prototype.hideIndicator = function() {
      hide(this.indicator.node());
    };
    Continuous3.prototype.updateMouse = function() {
      if (this.attributes.slidable)
        this.style.cursor = "grabbing";
    };
    Continuous3.prototype.setSelection = function(start, end) {
      this.updateSelection(start, end);
    };
    Continuous3.prototype.updateSelection = function(stVal, endVal, isOffset) {
      var _a2;
      if (isOffset === void 0) {
        isOffset = false;
      }
      var _b = __read(this.selection, 2), currSt = _b[0], currEnd = _b[1];
      var _c = __read([stVal, endVal], 2), start = _c[0], end = _c[1];
      if (isOffset) {
        start += currSt;
        end += currEnd;
      }
      var _d = this.range, min11 = _d.min, max11 = _d.max;
      _a2 = __read(getSafetySelections([min11, max11], [start, end], this.selection), 2), start = _a2[0], end = _a2[1];
      this.update({ defaultValue: [start, end] });
      this.dispatchSelection();
    };
    Object.defineProperty(Continuous3.prototype, "step", {
      get: function() {
        var _a2 = this.attributes.step, step2 = _a2 === void 0 ? 1 : _a2;
        var _b = this.range, min11 = _b.min, max11 = _b.max;
        if (is_undefined_default(step2))
          return toPrecision((max11 - min11) * STEP_RATIO, 0);
        return step2;
      },
      enumerable: false,
      configurable: true
    });
    Continuous3.prototype.getTickValue = function(value2) {
      var _a2 = this.attributes, data2 = _a2.data, block = _a2.block;
      var min11 = this.range.min;
      if (block)
        return getNextTickValue(data2.map(function(_a3) {
          var value3 = _a3.value;
          return value3;
        }), value2).tick;
      return getStepValueByValue(value2, this.step, min11);
    };
    Continuous3.prototype.getValueByCanvasPoint = function(e, limit) {
      if (limit === void 0) {
        limit = false;
      }
      var _a2 = this.range, min11 = _a2.min, max11 = _a2.max;
      var _b = __read(this.ribbon.node().getPosition(), 2), x3 = _b[0], y3 = _b[1];
      var startPos = this.ifHorizontal(x3, y3);
      var currValue = this.ifHorizontal.apply(this, __spreadArray([], __read(getEventPos(e)), false));
      var offset2 = currValue - startPos;
      var value2 = clamp_default(this.getOffset(offset2, true), min11, max11);
      return value2;
    };
    Continuous3.prototype.getOffset = function(value2, reverse3) {
      if (reverse3 === void 0) {
        reverse3 = false;
      }
      var _a2 = this.range, min11 = _a2.min, max11 = _a2.max;
      var ribbonLen = this.ribbonShape.length;
      var scale10 = this.eventToOffsetScale;
      scale10.update({ domain: [min11, max11], range: [0, ribbonLen] });
      if (reverse3)
        return scale10.invert(value2);
      return scale10.map(value2);
    };
    Continuous3.prototype.dispatchSelection = function() {
      var evt = new CustomEvent("valuechange", {
        detail: {
          value: this.selection
        }
      });
      this.dispatchEvent(evt);
    };
    Continuous3.prototype.dispatchIndicated = function(value2, range4) {
      var evt = new CustomEvent("indicate", {
        detail: { value: value2, range: range4 }
      });
      this.dispatchEvent(evt);
    };
    return Continuous3;
  }(Component)
);

// node_modules/@antv/component/esm/ui/tooltip/constant.js
function getClassNames(prefixCls) {
  if (prefixCls === void 0) {
    prefixCls = "";
  }
  return {
    CONTAINER: "".concat(prefixCls, "tooltip"),
    TITLE: "".concat(prefixCls, "tooltip-title"),
    LIST: "".concat(prefixCls, "tooltip-list"),
    LIST_ITEM: "".concat(prefixCls, "tooltip-list-item"),
    NAME: "".concat(prefixCls, "tooltip-list-item-name"),
    MARKER: "".concat(prefixCls, "tooltip-list-item-marker"),
    NAME_LABEL: "".concat(prefixCls, "tooltip-list-item-name-label"),
    VALUE: "".concat(prefixCls, "tooltip-list-item-value"),
    CROSSHAIR_X: "".concat(prefixCls, "tooltip-crosshair-x"),
    CROSSHAIR_Y: "".concat(prefixCls, "tooltip-crosshair-y")
  };
}
var TEXT_OVERFLOW_STYLE = {
  overflow: "hidden",
  "white-space": "nowrap",
  "text-overflow": "ellipsis"
};
function getDefaultTooltipStyle(prefixCls) {
  var _a2;
  if (prefixCls === void 0) {
    prefixCls = "";
  }
  var CLASS_NAME2 = getClassNames(prefixCls);
  return _a2 = {}, _a2[".".concat(CLASS_NAME2.CONTAINER)] = {
    position: "absolute",
    visibility: "visible",
    // 'white-space': 'nowrap',
    "z-index": 8,
    transition: "visibility 0.2s cubic-bezier(0.23, 1, 0.32, 1), left 0.4s cubic-bezier(0.23, 1, 0.32, 1), top 0.4s cubic-bezier(0.23, 1, 0.32, 1)",
    "background-color": "rgba(255, 255, 255, 0.96)",
    "box-shadow": "0 6px 12px 0 rgba(0, 0, 0, 0.12)",
    "border-radius": "4px",
    color: "rgba(0, 0, 0, 0.65)",
    "font-size": "12px",
    // 'font-family': ,
    "line-height": "20px",
    padding: "12px",
    "min-width": "120px",
    "max-width": "360px",
    "font-family": "Roboto-Regular"
  }, _a2[".".concat(CLASS_NAME2.TITLE)] = {
    color: "rgba(0, 0, 0, 0.45)"
  }, _a2[".".concat(CLASS_NAME2.LIST)] = {
    margin: "0px",
    "list-style-type": "none",
    padding: "0px"
  }, _a2[".".concat(CLASS_NAME2.LIST_ITEM)] = {
    "list-style-type": "none",
    display: "flex",
    "line-height": "2em",
    "align-items": "center",
    "justify-content": "space-between",
    "white-space": "nowrap"
  }, _a2[".".concat(CLASS_NAME2.MARKER)] = {
    width: "8px",
    height: "8px",
    "border-radius": "50%",
    display: "inline-block",
    "margin-right": "4px"
  }, _a2[".".concat(CLASS_NAME2.NAME)] = {
    display: "flex",
    "align-items": "center",
    "max-width": "216px"
  }, _a2[".".concat(CLASS_NAME2.NAME_LABEL)] = __assign({ flex: 1 }, TEXT_OVERFLOW_STYLE), _a2[".".concat(CLASS_NAME2.VALUE)] = __assign({ display: "inline-block", float: "right", flex: 1, "text-align": "right", "min-width": "28px", "margin-left": "30px", color: "rgba(0, 0, 0, 0.85)" }, TEXT_OVERFLOW_STYLE), _a2[".".concat(CLASS_NAME2.CROSSHAIR_X)] = {
    position: "absolute",
    width: "1px",
    "background-color": "rgba(0, 0, 0, 0.25)"
  }, _a2[".".concat(CLASS_NAME2.CROSSHAIR_Y)] = {
    position: "absolute",
    height: "1px",
    "background-color": "rgba(0, 0, 0, 0.25)"
  }, _a2;
}

// node_modules/@antv/component/esm/ui/tooltip/index.js
var Tooltip = (
  /** @class */
  function(_super) {
    __extends(Tooltip3, _super);
    function Tooltip3(options) {
      var _this2 = this;
      var _a2, _b;
      var prefixCls = (_b = (_a2 = options.style) === null || _a2 === void 0 ? void 0 : _a2.template) === null || _b === void 0 ? void 0 : _b.prefixCls;
      var CLASS_NAME2 = getClassNames(prefixCls);
      _this2 = _super.call(this, options, {
        data: [],
        x: 0,
        y: 0,
        visibility: "visible",
        title: "",
        position: "bottom-right",
        offset: [5, 5],
        enterable: false,
        container: {
          x: 0,
          y: 0
        },
        bounding: null,
        template: {
          prefixCls: "",
          container: '<div class="'.concat(CLASS_NAME2.CONTAINER, '"></div>'),
          title: '<div class="'.concat(CLASS_NAME2.TITLE, '"></div>'),
          item: '<li class="'.concat(CLASS_NAME2.LIST_ITEM, '" data-index={index}>\n        <span class="').concat(CLASS_NAME2.NAME, '">\n          <span class="').concat(CLASS_NAME2.MARKER, '" style="background:{color}"></span>\n          <span class="').concat(CLASS_NAME2.NAME_LABEL, '" title="{name}">{name}</span>\n        </span>\n        <span class="').concat(CLASS_NAME2.VALUE, '" title="{value}">{value}</span>\n      </li>')
        },
        style: getDefaultTooltipStyle(prefixCls)
      }) || this;
      _this2.timestamp = -1;
      _this2.prevCustomContentKey = _this2.attributes.contentKey;
      _this2.initShape();
      _this2.render(_this2.attributes, _this2);
      return _this2;
    }
    Object.defineProperty(Tooltip3.prototype, "HTMLTooltipElement", {
      get: function() {
        return this.element;
      },
      enumerable: false,
      configurable: true
    });
    Tooltip3.prototype.getContainer = function() {
      return this.element;
    };
    Object.defineProperty(Tooltip3.prototype, "elementSize", {
      get: function() {
        var width = this.element.offsetWidth;
        var height = this.element.offsetHeight;
        return { width, height };
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Tooltip3.prototype, "HTMLTooltipItemsElements", {
      get: function() {
        var _a2 = this.attributes, data2 = _a2.data, template2 = _a2.template;
        return data2.map(function(_a3, idx) {
          var _b = _a3.name, name2 = _b === void 0 ? "" : _b, _c = _a3.color, color2 = _c === void 0 ? "black" : _c, index3 = _a3.index, rest2 = __rest(_a3, ["name", "color", "index"]);
          var datum = __assign({ name: name2, color: color2, index: index3 !== null && index3 !== void 0 ? index3 : idx }, rest2);
          return createDOM(substitute_default(template2.item, datum));
        });
      },
      enumerable: false,
      configurable: true
    });
    Tooltip3.prototype.render = function(attributes, container) {
      this.renderHTMLTooltipElement();
      this.updatePosition();
    };
    Tooltip3.prototype.destroy = function() {
      var _a2;
      (_a2 = this.element) === null || _a2 === void 0 ? void 0 : _a2.remove();
      _super.prototype.destroy.call(this);
    };
    Tooltip3.prototype.show = function(x3, y3) {
      var _this2 = this;
      if (x3 !== void 0 && y3 !== void 0) {
        var isToggle = this.element.style.visibility === "hidden";
        var setPosition = function() {
          _this2.attributes.x = x3 !== null && x3 !== void 0 ? x3 : _this2.attributes.x;
          _this2.attributes.y = y3 !== null && y3 !== void 0 ? y3 : _this2.attributes.y;
          _this2.updatePosition();
        };
        isToggle ? this.closeTransition(setPosition) : setPosition();
      }
      this.element.style.visibility = "visible";
    };
    Tooltip3.prototype.hide = function(x3, y3) {
      if (x3 === void 0) {
        x3 = 0;
      }
      if (y3 === void 0) {
        y3 = 0;
      }
      var enterable = this.attributes.enterable;
      if (enterable && this.isCursorEntered(x3, y3))
        return;
      this.element.style.visibility = "hidden";
    };
    Tooltip3.prototype.initShape = function() {
      var template2 = this.attributes.template;
      this.element = createDOM(template2.container);
      if (this.id)
        this.element.setAttribute("id", this.id);
    };
    Tooltip3.prototype.renderCustomContent = function() {
      if (this.prevCustomContentKey !== void 0 && this.prevCustomContentKey === this.attributes.contentKey)
        return;
      this.prevCustomContentKey = this.attributes.contentKey;
      var content = this.attributes.content;
      if (!content)
        return;
      if (typeof content === "string")
        this.element.innerHTML = content;
      else
        this.element.replaceChildren(content);
    };
    Tooltip3.prototype.renderHTMLTooltipElement = function() {
      var _a2, _b;
      var _c = this.attributes, template2 = _c.template, title = _c.title, enterable = _c.enterable, style = _c.style, content = _c.content;
      var CLASS_NAME2 = getClassNames(template2.prefixCls);
      var container = this.element;
      this.element.style.pointerEvents = enterable ? "auto" : "none";
      if (content)
        this.renderCustomContent();
      else {
        if (title) {
          container.innerHTML = template2.title;
          container.getElementsByClassName(CLASS_NAME2.TITLE)[0].innerHTML = title;
        } else
          (_b = (_a2 = container.getElementsByClassName(CLASS_NAME2.TITLE)) === null || _a2 === void 0 ? void 0 : _a2[0]) === null || _b === void 0 ? void 0 : _b.remove();
        var itemsElements = this.HTMLTooltipItemsElements;
        var ul = document.createElement("ul");
        ul.className = CLASS_NAME2.LIST;
        ul.replaceChildren.apply(ul, __spreadArray([], __read(itemsElements), false));
        var list = this.element.querySelector(".".concat(CLASS_NAME2.LIST));
        if (list)
          list.replaceWith(ul);
        else
          container.appendChild(ul);
      }
      applyStyleSheet(container, style);
    };
    Tooltip3.prototype.getRelativeOffsetFromCursor = function(assignPosition) {
      var _a2 = this.attributes, position = _a2.position, offset2 = _a2.offset;
      var interPosition = assignPosition || position;
      var finalPosition = interPosition.split("-");
      var positionScore = { left: [-1, 0], right: [1, 0], top: [0, -1], bottom: [0, 1] };
      var _b = this.elementSize, width = _b.width, height = _b.height;
      var absolutelyOffset = [-width / 2, -height / 2];
      finalPosition.forEach(function(pos) {
        var _a3 = __read(absolutelyOffset, 2), abs1 = _a3[0], abs22 = _a3[1];
        var _b2 = __read(positionScore[pos], 2), pos1 = _b2[0], pos2 = _b2[1];
        absolutelyOffset = [abs1 + (width / 2 + offset2[0]) * pos1, abs22 + (height / 2 + offset2[1]) * pos2];
      });
      return absolutelyOffset;
    };
    Tooltip3.prototype.setOffsetPosition = function(_a2) {
      var _b = __read(_a2, 2), offsetX = _b[0], offsetY = _b[1];
      var _c = this.attributes, _d = _c.x, x3 = _d === void 0 ? 0 : _d, _e = _c.y, y3 = _e === void 0 ? 0 : _e, _f = _c.container, cx = _f.x, cy = _f.y;
      this.element.style.left = "".concat(+x3 + cx + offsetX, "px");
      this.element.style.top = "".concat(+y3 + cy + offsetY, "px");
    };
    Tooltip3.prototype.updatePosition = function() {
      var _a2 = this.attributes.showDelay, showDelay = _a2 === void 0 ? 60 : _a2;
      var currentTimestamp = Date.now();
      if (this.timestamp > 0 && currentTimestamp - this.timestamp < showDelay)
        return;
      this.timestamp = currentTimestamp;
      this.setOffsetPosition(this.autoPosition(this.getRelativeOffsetFromCursor()));
    };
    Tooltip3.prototype.autoPosition = function(_a2) {
      var _b = __read(_a2, 2), offsetX = _b[0], offsetY = _b[1];
      var _c = this.attributes, cursorX = _c.x, cursorY = _c.y, bounding = _c.bounding, position = _c.position;
      if (!bounding)
        return [offsetX, offsetY];
      var _d = this.element, offsetWidth = _d.offsetWidth, offsetHeight = _d.offsetHeight;
      var _e = __read([+cursorX + offsetX, +cursorY + offsetY], 2), expectLeft = _e[0], expectTop = _e[1];
      var inversion = {
        left: "right",
        right: "left",
        top: "bottom",
        bottom: "top"
      };
      var boundingX = bounding.x, boundingY = bounding.y, boundingWidth = bounding.width, boundingHeight = bounding.height;
      var edgeCompare = {
        left: expectLeft < boundingX,
        right: expectLeft + offsetWidth > boundingX + boundingWidth,
        top: expectTop < boundingY,
        bottom: expectTop + offsetHeight > boundingY + boundingHeight
      };
      var correctivePosition = [];
      position.split("-").forEach(function(pos) {
        if (edgeCompare[pos])
          correctivePosition.push(inversion[pos]);
        else
          correctivePosition.push(pos);
      });
      var correctedPositionString = correctivePosition.join("-");
      return this.getRelativeOffsetFromCursor(correctedPositionString);
    };
    Tooltip3.prototype.isCursorEntered = function(clientX, clientY) {
      if (this.element) {
        var _a2 = this.element.getBoundingClientRect(), x3 = _a2.x, y3 = _a2.y, width = _a2.width, height = _a2.height;
        return new BBox(x3, y3, width, height).isPointIn(clientX, clientY);
      }
      return false;
    };
    Tooltip3.prototype.closeTransition = function(callback) {
      var _this2 = this;
      var transition2 = this.element.style.transition;
      this.element.style.transition = "none";
      callback();
      setTimeout(function() {
        _this2.element.style.transition = transition2;
      }, 10);
    };
    Tooltip3.tag = "tooltip";
    return Tooltip3;
  }(Component)
);

// node_modules/@antv/component/esm/ui/switch/constant.js
var SIZE_STYLE2 = {
  default: {
    sizeStyle: {
      width: 44,
      height: 22,
      radius: 11
    },
    tagStyle: {
      textStyle: {
        fontSize: 12,
        lineHeight: 16,
        fill: "#fff"
      },
      padding: 0
    },
    markerStyle: {
      size: 11
    }
  },
  small: {
    sizeStyle: {
      width: 28,
      height: 16,
      radius: 8
    },
    tagStyle: {
      textStyle: {
        fontSize: 10,
        lineHeight: 14,
        fill: "#fff"
      },
      padding: 0
    },
    markerStyle: {
      size: 8
    }
  },
  mini: {
    sizeStyle: {
      width: 20,
      height: 14,
      radius: 7
    },
    tagStyle: {
      textStyle: {
        fontSize: 7,
        lineHeight: 10,
        fill: "#fff"
      },
      padding: 0
    },
    markerStyle: {
      size: 7
    }
  }
};

// node_modules/@antv/component/esm/ui/switch/index.js
var OPTION_COLOR = "#1890FF";
var CLOSE_COLOR = "#00000040";
function getHandleShapeStyle(shape23, spacing, checked) {
  if (spacing === void 0) {
    spacing = 0;
  }
  if (checked === void 0) {
    checked = true;
  }
  var size5 = Number(shape23.style.height) - spacing * 2;
  return {
    x: checked ? Number(shape23.style.width) + Number(shape23.style.x) - spacing - size5 : Number(shape23.style.x) + spacing,
    y: Number(shape23.style.y) + spacing,
    width: size5,
    height: size5,
    radius: size5 / 2
  };
}
function getTagShapeStyle(backgroundStyle, _a2, spacing, checked) {
  var width = _a2.width, height = _a2.height;
  if (spacing === void 0) {
    spacing = 0;
  }
  if (checked === void 0) {
    checked = true;
  }
  return {
    x: checked ? Number(backgroundStyle.x) + spacing : Number(backgroundStyle.width) + Number(backgroundStyle.x) - width,
    y: Number(backgroundStyle.y) + (Number(backgroundStyle.height) - height) / 2
  };
}
var Switch = (
  /** @class */
  function(_super) {
    __extends(Switch2, _super);
    function Switch2(options) {
      return _super.call(this, options, {
        x: 0,
        y: 0,
        size: "default",
        spacing: 2,
        checked: true,
        disabled: false
      }) || this;
    }
    Switch2.prototype.render = function(attributes, container) {
      var _this2 = this;
      var size5 = attributes.size, spacing = attributes.spacing, disabled = attributes.disabled, checked = attributes.checked, unCheckedChildren = attributes.unCheckedChildren, checkedChildren = attributes.checkedChildren;
      var group3 = select2(container).maybeAppendByClassName("switch-content", "g").node();
      var bounds = group3.getLocalBounds();
      var _a2 = get_default(SIZE_STYLE2, size5, SIZE_STYLE2.default), sizeStyle = _a2.sizeStyle, tagStyle = _a2.tagStyle;
      var cursor = disabled ? "no-drop" : "pointer";
      var color2 = checked ? OPTION_COLOR : CLOSE_COLOR;
      var backgroundStyle = sizeStyle;
      var tagCfg = checked ? checkedChildren : unCheckedChildren;
      if (checkedChildren || unCheckedChildren) {
        select2(group3).maybeAppendByClassName("switch-tag", function() {
          return new Tag({});
        }).call(function(selection) {
          var tagShape = selection.node();
          tagShape.update(__assign(__assign({ cursor, backgroundStyle: null, text: false, marker: false }, tagStyle), tagCfg));
          var _a3 = (tagShape === null || tagShape === void 0 ? void 0 : tagShape.getLocalBounds()) || {}, max11 = _a3.max, min11 = _a3.min;
          var width = max11[0] - min11[0] + sizeStyle.radius;
          var height = max11[1] - min11[1];
          var backgroundWidth = Math.max(width + sizeStyle.height + 2, sizeStyle.width);
          backgroundStyle = __assign(__assign({}, sizeStyle), { width: backgroundWidth });
          tagShape.update(getTagShapeStyle({
            x: bounds.min[0],
            y: bounds.min[1],
            width: backgroundWidth,
            height: backgroundStyle.height
          }, { width, height }, backgroundStyle.radius, checked));
        });
      }
      var backgroundShape = select2(group3).maybeAppendByClassName("switch-background", "rect").styles(__assign({ zIndex: (group3.style.zIndex || 0) - 1, x: bounds.min[0], y: bounds.min[1], fill: color2, cursor, fillOpacity: disabled ? 0.4 : 1 }, backgroundStyle)).node();
      var backgroundStrokeShape = select2(group3).maybeAppendByClassName("switch-background-stroke", "rect").styles(__assign({ zIndex: (group3.style.zIndex || 0) - 2, x: bounds.min[0], y: bounds.min[1], stroke: color2, lineWidth: 0 }, backgroundStyle)).node();
      select2(group3).maybeAppendByClassName("switch-handle", "rect").styles({
        fill: "#fff",
        cursor
      }).call(function(selection) {
        var _a3, _b;
        var handleShape = selection.node();
        var newHandleShapeStyle = getHandleShapeStyle(backgroundShape, spacing, checked);
        var oldHandleShapeStyle = getHandleShapeStyle(backgroundShape, spacing, !checked);
        if (handleShape.attr("x") && !is_equal_default(newHandleShapeStyle, oldHandleShapeStyle) && _this2.checked !== checked) {
          handleShape.attr(oldHandleShapeStyle);
          (_a3 = handleShape.getAnimations()[0]) === null || _a3 === void 0 ? void 0 : _a3.cancel();
          (_b = backgroundStrokeShape.getAnimations()[0]) === null || _b === void 0 ? void 0 : _b.cancel();
          handleShape.animate([{ x: oldHandleShapeStyle.x }, { x: newHandleShapeStyle.x }], {
            duration: 120,
            fill: "both"
          });
          backgroundStrokeShape.animate([
            { lineWidth: 0, strokeOpacity: 0.5 },
            { lineWidth: 14, strokeOpacity: 0 }
          ], {
            duration: 400,
            easing: "ease-on"
          });
        } else {
          handleShape.attr(newHandleShapeStyle);
        }
      });
      this.checked = !!checked;
    };
    Switch2.tag = "switch";
    return Switch2;
  }(Component)
);

// node_modules/@antv/component/esm/ui/crosshair/constant.js
var CROSSHAIR_BASE_DEFAULT_STYLE = {
  tagText: "",
  lineStroke: "#416180",
  lineStrokeOpacity: 0.45,
  lineLineWidth: 1,
  lineLineDash: [5, 5]
};
var LINE_CROSSHAIR_DEFAULT_STYLE = deepAssign2({}, CROSSHAIR_BASE_DEFAULT_STYLE, {
  type: "line",
  tagPosition: "start",
  tagAlign: "center",
  tagVerticalAlign: "bottom"
});
var CIRCLE_CROSSHAIR_DEFAULT_STYLE = deepAssign2({}, CROSSHAIR_BASE_DEFAULT_STYLE, {
  type: "circle",
  defaultRadius: 0
});
var POLYGON_CROSSHAIR_DEFAULT_STYLE = deepAssign2({}, CROSSHAIR_BASE_DEFAULT_STYLE, {
  type: "polygon",
  defaultRadius: 0,
  startAngle: 0
});

// node_modules/@antv/component/esm/ui/crosshair/base.js
var CrosshairBase = (
  /** @class */
  function(_super) {
    __extends(CrosshairBase2, _super);
    function CrosshairBase2(options) {
      return _super.call(this, options, CROSSHAIR_BASE_DEFAULT_STYLE) || this;
    }
    Object.defineProperty(CrosshairBase2.prototype, "localPointer", {
      /**
       *  pointer 
       */
      get: function() {
        var _a2 = __read(this.getPosition(), 2), bx = _a2[0], by = _a2[1];
        var _b = __read(this.pointer, 2), x3 = _b[0], y3 = _b[1];
        return [x3 - bx, y3 - by];
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(CrosshairBase2.prototype, "tagStyle", {
      get: function() {
        var style = subStyleProps(this.attributes, "tag");
        return style;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(CrosshairBase2.prototype, "crosshairStyle", {
      get: function() {
        var style = subStyleProps(this.attributes, "line");
        return __assign(__assign({}, style), { path: this.crosshairPath });
      },
      enumerable: false,
      configurable: true
    });
    CrosshairBase2.prototype.render = function(attributes, container) {
      var group3 = select2(container).maybeAppendByClassName(".crosshair-group", "g").node();
      this.shapesGroup = group3;
      var tagStyle = this.tagStyle;
      var crosshairStyle = this.crosshairStyle;
      this.tagShape = select2(group3).maybeAppendByClassName("crosshair-tag", function() {
        return new Tag({ style: tagStyle });
      }).styles(tagStyle).node();
      this.crosshairShape = select2(group3).maybeAppendByClassName(".crosshair-path", "path").styles(crosshairStyle).node();
      this.adjustLayout();
    };
    CrosshairBase2.prototype.setPointer = function(pointer) {
      this.pointer = pointer;
    };
    CrosshairBase2.tag = "crosshair-base";
    return CrosshairBase2;
  }(Component)
);

// node_modules/@antv/component/esm/ui/crosshair/line.js
var LineCrosshair = (
  /** @class */
  function(_super) {
    __extends(LineCrosshair2, _super);
    function LineCrosshair2(options) {
      return _super.call(this, deepAssign2({}, LineCrosshair2.defaultOptions, options)) || this;
    }
    Object.defineProperty(LineCrosshair2.prototype, "crosshairPath", {
      get: function() {
        var _a2 = this.attributes, _b = __read(_a2.startPos, 2), sx = _b[0], sy = _b[1], _c = __read(_a2.endPos, 2), ex = _c[0], ey = _c[1];
        var path2 = [["M", 0, 0], ["L", ex - sx, ey - sy], ["Z"]];
        return path2;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(LineCrosshair2.prototype, "localPointer", {
      /**
       *  pointer 
       */
      get: function() {
        if (!this.pointer)
          return this.attributes.startPos;
        var _a2 = __read(this.getPosition(), 2), bx = _a2[0], by = _a2[1];
        var _b = __read(this.pointer, 2), x3 = _b[0], y3 = _b[1];
        return [x3 - bx, y3 - by];
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(LineCrosshair2.prototype, "isVertical", {
      get: function() {
        var _a2 = this.attributes, _b = __read(_a2.startPos, 2), x12 = _b[0], y12 = _b[1], _c = __read(_a2.endPos, 2), x22 = _c[0], y22 = _c[1];
        return x12 === x22 && y12 !== y22;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(LineCrosshair2.prototype, "tagShapeSpace", {
      get: function() {
        var _a2 = getShapeSpace(this.tagShape), width = _a2.width, height = _a2.height;
        return { width, height };
      },
      enumerable: false,
      configurable: true
    });
    LineCrosshair2.prototype.update = function(cfg) {
      _super.prototype.update.call(this, cfg);
    };
    LineCrosshair2.prototype.setPointer = function(pointer) {
      _super.prototype.setPointer.call(this, pointer);
      this.adjustPosition();
    };
    LineCrosshair2.prototype.setText = function(text) {
      this.tagShape.update({ text });
      this.adjustTag();
    };
    LineCrosshair2.prototype.adjustLayout = function() {
      this.adjustPosition();
      this.adjustTag();
    };
    LineCrosshair2.prototype.adjustPosition = function() {
      var _a2 = __read(this.localPointer, 2), lx = _a2[0], ly = _a2[1];
      var _b = __read(this.attributes.startPos, 2), sx = _b[0], sy = _b[1];
      var targetPos = this.getOrientVal([sx, ly], [lx, sy]);
      this.shapesGroup.setLocalPosition(targetPos);
    };
    LineCrosshair2.prototype.adjustTag = function() {
      var _a2 = this.attributes, tagText = _a2.tagText, tagPosition = _a2.tagPosition, _b = __read(_a2.startPos, 2), x12 = _b[0], y12 = _b[1], _c = __read(_a2.endPos, 2), x22 = _c[0], y22 = _c[1];
      if (!tagText || tagText === "") {
        hide(this.tagShape);
        return;
      }
      show(this.tagShape);
      var _d = this.tagShapeSpace, width = _d.width, height = _d.height;
      var _e = __read(this.getOrientVal({
        start: [-width / 2, height / 2],
        end: [x22 - x12 + width / 2, height / 2]
      }, {
        start: [0, 0],
        end: [0, y22 - y12 + height]
      })[tagPosition], 2), xOffset = _e[0], yOffset = _e[1];
      this.tagShape.setLocalPosition(xOffset, yOffset);
    };
    LineCrosshair2.prototype.getOrientVal = function(v1, v2) {
      return this.isVertical ? v2 : v1;
    };
    LineCrosshair2.tag = "line-crosshair";
    LineCrosshair2.defaultOptions = {
      style: LINE_CROSSHAIR_DEFAULT_STYLE
    };
    return LineCrosshair2;
  }(CrosshairBase)
);

// node_modules/@antv/component/esm/ui/crosshair/circle.js
var CircleCrosshair = (
  /** @class */
  function(_super) {
    __extends(CircleCrosshair2, _super);
    function CircleCrosshair2(options) {
      return _super.call(this, deepAssign2({}, CircleCrosshair2.defaultOptions, options)) || this;
    }
    Object.defineProperty(CircleCrosshair2.prototype, "crosshairPath", {
      get: function() {
        return this.createCirclePath();
      },
      enumerable: false,
      configurable: true
    });
    CircleCrosshair2.prototype.update = function(cfg) {
      _super.prototype.update.call(this, cfg);
    };
    CircleCrosshair2.prototype.setPointer = function(_a2) {
      var _b = __read(_a2, 2), x3 = _b[0], y3 = _b[1];
      _super.prototype.setPointer.call(this, [x3, y3]);
      var _c = __read(this.localPointer, 2), lx = _c[0], ly = _c[1];
      var _d = __read(this.attributes.center, 2), cx = _d[0], cy = _d[1];
      var path2 = this.createCirclePath(Math.pow(Math.pow(lx - cx, 2) + Math.pow(ly - cy, 2), 0.5));
      this.crosshairShape.attr({ path: path2 });
    };
    CircleCrosshair2.prototype.adjustLayout = function() {
      hide(this.tagShape);
    };
    CircleCrosshair2.prototype.createCirclePath = function(radius) {
      var _a2 = this.attributes, _b = __read(_a2.center, 2), x3 = _b[0], y3 = _b[1], defaultRadius2 = _a2.defaultRadius;
      return circle(x3, y3, radius || defaultRadius2);
    };
    CircleCrosshair2.tag = "circle-crosshair";
    CircleCrosshair2.defaultOptions = {
      style: CIRCLE_CROSSHAIR_DEFAULT_STYLE
    };
    return CircleCrosshair2;
  }(CrosshairBase)
);

// node_modules/@antv/component/esm/ui/crosshair/polygon.js
var PolygonCrosshair = (
  /** @class */
  function(_super) {
    __extends(PolygonCrosshair2, _super);
    function PolygonCrosshair2(options) {
      return _super.call(this, deepAssign2({}, PolygonCrosshair2.defaultOptions, options)) || this;
    }
    Object.defineProperty(PolygonCrosshair2.prototype, "crosshairPath", {
      get: function() {
        return this.createPolygonPath();
      },
      enumerable: false,
      configurable: true
    });
    PolygonCrosshair2.prototype.update = function(cfg) {
      _super.prototype.update.call(this, cfg);
    };
    Object.defineProperty(PolygonCrosshair2.prototype, "points", {
      /**
       * 
       */
      get: function() {
        var _a2 = this.attributes, startAngle = _a2.startAngle, sides = _a2.sides;
        var a4 = Math.PI * 2 / sides;
        var unit = [1, 0];
        var points = [];
        for (var i = 0; i < sides; i += 1) {
          points.push(rotate4(unit, [0, 0], startAngle / 180 * Math.PI + a4 * i));
        }
        return points;
      },
      enumerable: false,
      configurable: true
    });
    PolygonCrosshair2.prototype.setPointer = function(_a2) {
      var _b = __read(_a2, 2), x3 = _b[0], y3 = _b[1];
      _super.prototype.setPointer.call(this, [x3, y3]);
      var _c = __read(this.localPointer, 2), lx = _c[0], ly = _c[1];
      var center2 = this.attributes.center;
      var _d = __read(this.intersection([lx, ly]), 2), ix = _d[0], iy = _d[1];
      if (!ix || !iy)
        return;
      var equivalentRadius = lineLen(center2, [lx, ly]) / lineLen(center2, [ix, iy]);
      var path2 = this.createPolygonPath(equivalentRadius);
      this.crosshairShape.attr({ path: path2 });
    };
    PolygonCrosshair2.prototype.adjustLayout = function() {
      hide(this.tagShape);
    };
    PolygonCrosshair2.prototype.createPolygonPath = function(radius) {
      var _a2 = this.attributes, defaultRadius2 = _a2.defaultRadius, _b = __read(_a2.center, 2), cx = _b[0], cy = _b[1];
      var path2 = this.points.map(function(_a3, index3) {
        var _b2 = __read(_a3, 2), x3 = _b2[0], y3 = _b2[1];
        var _c = __read(scale7([x3, y3], radius || defaultRadius2), 2), tx = _c[0], ty = _c[1];
        return [index3 === 0 ? "M" : "L", cx + tx, cy + ty];
      });
      path2.push(["Z"]);
      return path2;
    };
    PolygonCrosshair2.prototype.intersection = function(_a2) {
      var _b;
      var _c = __read(_a2, 2), x3 = _c[0], y3 = _c[1];
      var points = this.points;
      var _d = __read(this.attributes.center, 2), cx = _d[0], cy = _d[1];
      var ix;
      var iy;
      for (var i = 1; i <= points.length; i += 1) {
        var _e = __read(points[i - 1], 2), sx = _e[0], sy = _e[1];
        var _f = __read(points[i % points.length], 2), ex = _f[0], ey = _f[1];
        var inter = intersection2([x3, y3], [cx, cy], [sx + cx, sy + cy], [ex + cx, ey + cy]);
        if (inter.length !== 0) {
          _b = __read(inter, 2), ix = _b[0], iy = _b[1];
        }
      }
      return [ix, iy];
    };
    PolygonCrosshair2.tag = "polygon-crosshair";
    PolygonCrosshair2.defaultOptions = {
      style: POLYGON_CROSSHAIR_DEFAULT_STYLE
    };
    return PolygonCrosshair2;
  }(CrosshairBase)
);

// node_modules/@antv/component/esm/ui/checkbox/constant.js
var LABEL_TEXT_STYLE = superStyleProps({
  fill: "rgba(0,0,0,0.45)",
  fontSize: 10,
  textAlign: "start",
  textBaseline: "middle",
  overflow: "clip"
}, "label");
var CHECKBOX_RECT_STYLE = {
  default: {
    width: 12,
    height: 12,
    radius: 2,
    stroke: "#dadada",
    lineWidth: 1,
    fill: "#ffffff",
    cursor: "pointer"
  },
  selected: {
    width: 12,
    height: 12,
    radius: 2,
    stroke: "#3471F9",
    lineWidth: 1,
    fill: "#3471F9",
    cursor: "pointer"
  }
};
var CHECKED_SHAPE_PATH = [
  ["M", 3, 6],
  ["L", "5", "8.5"],
  ["L", "8.5", "4"]
];
var CHECKED_SHAPE_STYLE = {
  path: CHECKED_SHAPE_PATH,
  lineWidth: 1,
  cursor: "pointer"
};

// node_modules/@antv/component/esm/ui/checkbox/index.js
function getLablePosition(shape23, spacing) {
  var bounds = shape23.getLocalBounds();
  return {
    x: bounds.halfExtents[0] ? bounds.max[0] + (spacing || 0) : shape23.style.x,
    y: bounds.halfExtents[1] ? (bounds.min[1] + bounds.max[1]) / 2 : shape23.style.y
  };
}
var Checkbox = (
  /** @class */
  function(_super) {
    __extends(Checkbox2, _super);
    function Checkbox2(options) {
      return _super.call(this, options, __assign({ x: 0, y: 0, labelText: "", spacing: 4, checked: false }, LABEL_TEXT_STYLE)) || this;
    }
    Checkbox2.prototype.render = function(attributes, container) {
      var checked = attributes.checked, spacing = attributes.spacing;
      this.checked = !!checked;
      var group3 = maybeAppend(container, ".checkbox-content", "g").attr("className", "checkbox-content").node();
      var boxStyle = subStyleProps(attributes, "box");
      var checkedStyle = subStyleProps(attributes, "checked");
      var labelStyle = subStyleProps(attributes, "label");
      var checkboxStyle = __assign(__assign({}, this.checked ? CHECKBOX_RECT_STYLE.selected : CHECKBOX_RECT_STYLE.default), boxStyle);
      var checkboxBoxCheckedStyle = __assign(__assign({}, CHECKED_SHAPE_STYLE), checkedStyle);
      this.checkboxBoxShape = maybeAppend(group3, ".checkbox-box", "rect").styles(__assign({ className: "checkbox-box", zIndex: (group3.style.zIndex || 0) - 1 }, checkboxStyle)).node();
      maybeAppend(this.checkboxBoxShape, ".checkbox-checked", "path").styles(__assign({ className: "checkbox-box-checked", stroke: "#fff" }, checkboxBoxCheckedStyle));
      var _a2 = getLablePosition(this.checkboxBoxShape, Number(spacing)), x3 = _a2.x, y3 = _a2.y;
      maybeAppend(group3, ".checkbox-label", "text").styles(__assign({ className: "checkbox-label", x: x3, y: y3 }, labelStyle));
    };
    Checkbox2.tag = "checkbox";
    return Checkbox2;
  }(Component)
);

// node_modules/@antv/component/esm/ui/poptip/constant.js
var _a;
var POPTIP_ID = "component-poptip";
var CLASS_NAME = {
  CONTAINER: "component-poptip",
  ARROW: "component-poptip-arrow",
  TEXT: "component-poptip-text"
};
var POPTIP_STYLE = (_a = {}, //   style
_a[".".concat(CLASS_NAME.CONTAINER)] = {
  visibility: "visible",
  position: "absolute",
  "background-color": "rgba(0, 0, 0)",
  "box-shadow": "0px 0px 10px #aeaeae",
  "border-radius": "3px",
  color: "#fff",
  opacity: 0.8,
  "font-size": "12px",
  padding: "4px 6px",
  display: "flex",
  "justify-content": "center",
  "align-items": "center",
  "z-index": 8,
  transition: "visibility 50ms"
}, //   style
_a[".".concat(CLASS_NAME.TEXT)] = {
  "text-align": "center"
}, _a[".".concat(CLASS_NAME.CONTAINER, "[data-position='top']")] = {
  transform: "translate(-50%, -100%)"
}, _a[".".concat(CLASS_NAME.CONTAINER, "[data-position='left']")] = {
  transform: "translate(-100%, -50%)"
}, _a[".".concat(CLASS_NAME.CONTAINER, "[data-position='right']")] = {
  transform: "translate(0, -50%)"
}, _a[".".concat(CLASS_NAME.CONTAINER, "[data-position='bottom']")] = {
  transform: "translate(-50%, 0)"
}, _a[".".concat(CLASS_NAME.CONTAINER, "[data-position='top-left']")] = {
  transform: "translate(0,-100%)"
}, _a[".".concat(CLASS_NAME.CONTAINER, "[data-position='top-right']")] = {
  transform: "translate(-100%,-100%)"
}, _a[".".concat(CLASS_NAME.CONTAINER, "[data-position='left-top']")] = {
  transform: "translate(-100%, 0)"
}, _a[".".concat(CLASS_NAME.CONTAINER, "[data-position='left-bottom']")] = {
  transform: "translate(-100%, -100%)"
}, _a[".".concat(CLASS_NAME.CONTAINER, "[data-position='right-top']")] = {
  transform: "translate(0, 0)"
}, _a[".".concat(CLASS_NAME.CONTAINER, "[data-position='right-bottom']")] = {
  transform: "translate(0, -100%)"
}, _a[".".concat(CLASS_NAME.CONTAINER, "[data-position='bottom-left']")] = {
  transform: "translate(0, 0)"
}, _a[".".concat(CLASS_NAME.CONTAINER, "[data-position='bottom-right']")] = {
  transform: "translate(-100%, 0)"
}, _a[".".concat(CLASS_NAME.ARROW)] = {
  width: "4px",
  height: "4px",
  transform: "rotate(45deg)",
  "background-color": "rgba(0, 0, 0)",
  position: "absolute",
  "z-index": -1
}, _a[".".concat(CLASS_NAME.CONTAINER, "[data-position='top']")] = {
  transform: "translate(-50%, calc(-100% - 5px))"
}, _a["[data-position='top'] .".concat(CLASS_NAME.ARROW)] = {
  bottom: "-2px"
}, _a[".".concat(CLASS_NAME.CONTAINER, "[data-position='left']")] = {
  transform: "translate(calc(-100% - 5px), -50%)"
}, _a["[data-position='left'] .".concat(CLASS_NAME.ARROW)] = {
  right: "-2px"
}, _a[".".concat(CLASS_NAME.CONTAINER, "[data-position='right']")] = {
  transform: "translate(5px, -50%)"
}, _a["[data-position='right'] .".concat(CLASS_NAME.ARROW)] = {
  left: "-2px"
}, _a[".".concat(CLASS_NAME.CONTAINER, "[data-position='bottom']")] = {
  transform: "translate(-50%, 5px)"
}, _a["[data-position='bottom'] .".concat(CLASS_NAME.ARROW)] = {
  top: "-2px"
}, _a[".".concat(CLASS_NAME.CONTAINER, "[data-position='top-left']")] = {
  transform: "translate(0, calc(-100% - 5px))"
}, _a["[data-position='top-left'] .".concat(CLASS_NAME.ARROW)] = {
  left: "10px",
  bottom: "-2px"
}, _a[".".concat(CLASS_NAME.CONTAINER, "[data-position='top-right']")] = {
  transform: "translate(-100%, calc(-100% - 5px))"
}, _a["[data-position='top-right'] .".concat(CLASS_NAME.ARROW)] = {
  right: "10px",
  bottom: "-2px"
}, _a[".".concat(CLASS_NAME.CONTAINER, "[data-position='left-top']")] = {
  transform: "translate(calc(-100% - 5px), 0)"
}, _a["[data-position='left-top'] .".concat(CLASS_NAME.ARROW)] = {
  right: "-2px",
  top: "8px"
}, _a[".".concat(CLASS_NAME.CONTAINER, "[data-position='left-bottom']")] = {
  transform: "translate(calc(-100% - 5px), -100%)"
}, _a["[data-position='left-bottom'] .".concat(CLASS_NAME.ARROW)] = {
  right: "-2px",
  bottom: "8px"
}, _a[".".concat(CLASS_NAME.CONTAINER, "[data-position='right-top']")] = {
  transform: "translate(5px, 0)"
}, _a["[data-position='right-top'] .".concat(CLASS_NAME.ARROW)] = {
  left: "-2px",
  top: "8px"
}, _a[".".concat(CLASS_NAME.CONTAINER, "[data-position='right-bottom']")] = {
  transform: "translate(5px, -100%)"
}, _a["[data-position='right-bottom'] .".concat(CLASS_NAME.ARROW)] = {
  left: "-2px",
  bottom: "8px"
}, _a[".".concat(CLASS_NAME.CONTAINER, "[data-position='bottom-left']")] = {
  transform: "translate(0, 5px)"
}, _a["[data-position='bottom-left'] .".concat(CLASS_NAME.ARROW)] = {
  top: "-2px",
  left: "8px"
}, _a[".".concat(CLASS_NAME.CONTAINER, "[data-position='bottom-right']")] = {
  transform: "translate(-100%, 5px)"
}, _a["[data-position='bottom-right'] .".concat(CLASS_NAME.ARROW)] = {
  top: "-2px",
  right: "8px"
}, _a);

// node_modules/@antv/component/esm/ui/poptip/utils.js
var _this = void 0;
function getPositionXY(clientX, clientY, target, position, arrowPointAtCenter, follow) {
  if (arrowPointAtCenter === void 0) {
    arrowPointAtCenter = false;
  }
  if (follow === void 0) {
    follow = false;
  }
  if (follow)
    return [clientX, clientY];
  var _a2 = target.getBoundingClientRect(), x3 = _a2.x, y3 = _a2.y, width = _a2.width, height = _a2.height;
  switch (position) {
    case "top":
      return arrowPointAtCenter ? [x3 + width / 2, y3] : [clientX, y3];
    case "left":
      return arrowPointAtCenter ? [x3, y3 + height / 2] : [x3, clientY];
    case "bottom":
      return arrowPointAtCenter ? [x3 + width / 2, y3 + height] : [clientX, y3 + height];
    case "right":
      return arrowPointAtCenter ? [x3 + width, y3 + height / 2] : [x3 + width, clientY];
    case "top-right":
    case "right-top":
      return [x3 + width, y3];
    case "left-bottom":
    case "bottom-left":
      return [x3, y3 + height];
    case "right-bottom":
    case "bottom-right":
      return [x3 + width, y3 + height];
    case "top-left":
    case "left-top":
    default:
      return [x3, y3];
  }
}
var getSingleTon = function(fn) {
  var instance;
  return function() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    if (!instance)
      instance = fn.apply(_this, args);
    return instance;
  };
};
function createElement2(id3) {
  var div4 = id3 && document.getElementById(id3);
  if (!div4) {
    div4 = document.createElement("div");
    div4.setAttribute("id", id3);
    document.body.appendChild(div4);
  }
  return div4;
}
function getSingleTonElement(id3) {
  var element = getSingleTon(createElement2)(id3);
  return element;
}

// node_modules/@antv/component/esm/ui/poptip/index.js
var Poptip = (
  /** @class */
  function(_super) {
    __extends(Poptip3, _super);
    function Poptip3(options) {
      var _this2 = _super.call(this, deep_mix_default({ style: { id: POPTIP_ID } }, Poptip3.defaultOptions, options)) || this;
      _this2.visibility = "visible";
      _this2.map = /* @__PURE__ */ new Map();
      _this2.domStyles = "";
      _this2.initShape();
      _this2.render(_this2.attributes, _this2);
      return _this2;
    }
    Object.defineProperty(Poptip3.prototype, "visible", {
      get: function() {
        return this.visibility === "visible";
      },
      enumerable: false,
      configurable: true
    });
    Poptip3.prototype.render = function(attributes, container) {
      this.visibility = this.style.visibility;
      this.updatePoptipElement();
    };
    Poptip3.prototype.update = function(cfg) {
      this.attr(deep_mix_default({}, this.style, cfg));
      this.render(this.attributes, this);
    };
    Poptip3.prototype.bind = function(element, callback) {
      var _this2 = this;
      if (!element)
        return;
      var defaultText = this.style.text;
      var onmousemove = function(e) {
        var target = element;
        var options = _this2.style;
        var text = defaultText;
        if (callback) {
          var _a2 = typeof callback === "function" ? callback.call(null, e) : callback, html = _a2.html, ele = _a2.target, restOptions = __rest(_a2, ["html", "target"]);
          options = mix({}, _this2.style, restOptions);
          if (ele || ele === false)
            target = ele;
          if (typeof html === "string")
            text = html;
        }
        var position = options.position, arrowPointAtCenter = options.arrowPointAtCenter, follow = options.follow, offset2 = options.offset;
        if (target) {
          var _b = e, clientX = _b.clientX, clientY = _b.clientY;
          var _c = __read(getPositionXY(clientX, clientY, target, position, arrowPointAtCenter, follow), 2), x3 = _c[0], y3 = _c[1];
          _this2.showTip(x3, y3, { text, position, offset: offset2 });
        } else {
          _this2.hideTip();
        }
      };
      var onmouseleave = function() {
        _this2.hideTip();
      };
      element.addEventListener("mousemove", onmousemove);
      element.addEventListener("mouseleave", onmouseleave);
      this.map.set(element, [onmousemove, onmouseleave]);
    };
    Poptip3.prototype.unbind = function(element) {
      if (this.map.has(element)) {
        var _a2 = __read(this.map.get(element) || [], 2), listener1 = _a2[0], listener2 = _a2[1];
        listener1 && element.removeEventListener("mousemove", listener1);
        listener2 && element.removeEventListener("mouseleave", listener2);
        this.map.delete(element);
      }
    };
    Poptip3.prototype.clear = function() {
      this.container.innerHTML = "";
    };
    Poptip3.prototype.destroy = function() {
      var _this2 = this;
      var _a2;
      __spreadArray([], __read(this.map.keys()), false).forEach(function(ele) {
        return _this2.unbind(ele);
      });
      (_a2 = this.container) === null || _a2 === void 0 ? void 0 : _a2.remove();
      _super.prototype.destroy.call(this);
    };
    Poptip3.prototype.showTip = function(x3, y3, options) {
      var text = get_default(options, "text");
      if (text && typeof text !== "string")
        return;
      this.applyStyles();
      if (x3 && y3 && options) {
        var offset2 = options.offset, position = options.position;
        position && this.container.setAttribute("data-position", position);
        this.setOffsetPosition(x3, y3, offset2);
        if (typeof text === "string") {
          var textElement = this.container.querySelector(".".concat(CLASS_NAME.TEXT));
          if (textElement) {
            textElement.innerHTML = text;
          }
        }
        this.visibility = "visible";
        this.container.style.visibility = "visible";
      }
    };
    Poptip3.prototype.hideTip = function() {
      this.visibility = "hidden";
      this.container.style.visibility = "hidden";
    };
    Poptip3.prototype.getContainer = function() {
      return this.container;
    };
    Poptip3.prototype.getClassName = function() {
      var containerClassName = this.style.containerClassName;
      return "".concat(CLASS_NAME.CONTAINER).concat(containerClassName ? " ".concat(containerClassName) : "");
    };
    Poptip3.prototype.initShape = function() {
      var _this2 = this;
      var id3 = this.style.id;
      this.container = getSingleTonElement(id3);
      this.container.className = this.getClassName();
      this.container.addEventListener("mousemove", function() {
        return _this2.showTip();
      });
      this.container.addEventListener("mouseleave", function() {
        return _this2.hideTip();
      });
    };
    Poptip3.prototype.updatePoptipElement = function() {
      var container = this.container;
      this.clear();
      var _a2 = this.style, id3 = _a2.id, template2 = _a2.template, text = _a2.text;
      this.container.setAttribute("id", id3);
      this.container.className = this.getClassName();
      var arrowNode = '<span class="'.concat(CLASS_NAME.ARROW, '"></span>');
      container.innerHTML = arrowNode;
      if (is_string_default(template2)) {
        container.innerHTML += template2;
      } else if (template2 && is_element_default(template2)) {
        container.appendChild(template2);
      }
      if (text) {
        container.getElementsByClassName(CLASS_NAME.TEXT)[0].textContent = text;
      }
      this.applyStyles();
      this.container.style.visibility = this.visibility;
    };
    Poptip3.prototype.applyStyles = function() {
      var styles = deepAssign2({}, POPTIP_STYLE, this.style.domStyles);
      var styleStr = Object.entries(styles).reduce(function(r, _a2) {
        var _b = __read(_a2, 2), key = _b[0], value2 = _b[1];
        var styleStr2 = Object.entries(value2).reduce(function(r2, _a3) {
          var _b2 = __read(_a3, 2), k2 = _b2[0], v = _b2[1];
          return "".concat(r2).concat(k2, ": ").concat(v, ";");
        }, "");
        return "".concat(r).concat(key, "{").concat(styleStr2, "}");
      }, "");
      if (this.domStyles !== styleStr) {
        this.domStyles = styleStr;
        var styleDOM = this.container.querySelector("style");
        if (styleDOM)
          this.container.removeChild(styleDOM);
        styleDOM = document.createElement("style");
        styleDOM.innerHTML = styleStr;
        this.container.appendChild(styleDOM);
      }
    };
    Poptip3.prototype.setOffsetPosition = function(x3, y3, offset2) {
      if (offset2 === void 0) {
        offset2 = this.style.offset;
      }
      var _a2 = __read(offset2, 2), _b = _a2[0], offsetX = _b === void 0 ? 0 : _b, _c = _a2[1], offsetY = _c === void 0 ? 0 : _c;
      this.container.style.left = "".concat(x3 + offsetX, "px");
      this.container.style.top = "".concat(y3 + offsetY, "px");
    };
    Poptip3.tag = "poptip";
    Poptip3.defaultOptions = {
      style: {
        x: 0,
        y: 0,
        width: 0,
        height: 0,
        target: null,
        visibility: "hidden",
        text: "",
        position: "top",
        follow: false,
        offset: [0, 0],
        domStyles: POPTIP_STYLE,
        template: '<div class="'.concat(CLASS_NAME.TEXT, '"></div>')
      }
    };
    return Poptip3;
  }(Component)
);

// node_modules/@antv/component/esm/ui/layout/layout.js
var Layout = (
  /** @class */
  function(_super) {
    __extends(Layout2, _super);
    function Layout2(options) {
      var _this2 = _super.call(this, options) || this;
      _this2.layoutEvents = [ElementEvent.BOUNDS_CHANGED, ElementEvent.INSERTED, ElementEvent.REMOVED];
      _this2.$margin = parseSeriesAttr(0);
      _this2.$padding = parseSeriesAttr(0);
      var _a2 = options.style || {}, _b = _a2.margin, margin = _b === void 0 ? 0 : _b, _c = _a2.padding, padding = _c === void 0 ? 0 : _c;
      _this2.margin = margin;
      _this2.padding = padding;
      _this2.isMutationObserved = true;
      _this2.bindEvents();
      return _this2;
    }
    Object.defineProperty(Layout2.prototype, "margin", {
      get: function() {
        return this.$margin;
      },
      set: function(value2) {
        this.$margin = parseSeriesAttr(value2);
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Layout2.prototype, "padding", {
      get: function() {
        return this.$padding;
      },
      set: function(value2) {
        this.$padding = parseSeriesAttr(value2);
      },
      enumerable: false,
      configurable: true
    });
    Layout2.prototype.getBBox = function() {
      var _a2 = this.attributes, _b = _a2.x, x3 = _b === void 0 ? 0 : _b, _c = _a2.y, y3 = _c === void 0 ? 0 : _c, width = _a2.width, height = _a2.height;
      var _d = __read(this.$margin, 4), marginTop = _d[0], marginRight = _d[1], marginBottom = _d[2], marginLeft = _d[3];
      return new BBox(x3 - marginLeft, y3 - marginTop, width + marginLeft + marginRight, height + marginTop + marginBottom);
    };
    Layout2.prototype.appendChild = function(child, index3) {
      child.isMutationObserved = true;
      _super.prototype.appendChild.call(this, child, index3);
      return child;
    };
    Layout2.prototype.getAvailableSpace = function() {
      var _a2 = this.attributes, width = _a2.width, height = _a2.height;
      var _b = __read(this.$padding, 4), paddingTop = _b[0], paddingRight = _b[1], paddingBottom = _b[2], paddingLeft = _b[3];
      var _c = __read(this.$margin, 4), marginTop = _c[0], marginLeft = _c[3];
      return new BBox(paddingLeft + marginLeft, paddingTop + marginTop, width - paddingLeft - paddingRight, height - paddingTop - paddingBottom);
    };
    Layout2.prototype.layout = function() {
      if (!this.attributes.display || !this.isConnected)
        return;
      if (this.children.some(function(child) {
        return !child.isConnected;
      }))
        return;
      try {
        var bboxes_1 = executer_default(this.getAvailableSpace(), this.children.map(function(child) {
          return child.getBBox();
        }), this.attributes);
        this.children.forEach(function(child, index3) {
          var _a2 = bboxes_1[index3], x3 = _a2.x, y3 = _a2.y;
          child.attr({ x: x3, y: y3 });
        });
      } catch (e) {
      }
    };
    Layout2.prototype.bindEvents = function() {
      var _this2 = this;
      this.layoutEvents.forEach(function(event) {
        _this2.addEventListener(event, function(e) {
          e.target.isMutationObserved = true;
          _this2.layout();
        });
      });
    };
    Layout2.prototype.attributeChangedCallback = function(name2, oldValue, newValue) {
      if (name2 === "margin")
        this.margin = newValue;
      else if (name2 === "padding")
        this.padding = newValue;
      this.layout();
    };
    return Layout2;
  }(Group2)
);

// node_modules/@antv/component/esm/ui/select/option.js
var Option = (
  /** @class */
  function(_super) {
    __extends(Option2, _super);
    function Option2(options) {
      var _this2 = _super.call(this, deepAssign2({}, Option2.defaultOptions, options)) || this;
      _this2.hoverColor = "#f5f5f5";
      _this2.selectedColor = "#e6f7ff";
      _this2.background = _this2.appendChild(new Rect({}));
      _this2.label = _this2.background.appendChild(new Group2({}));
      return _this2;
    }
    Object.defineProperty(Option2.prototype, "padding", {
      get: function() {
        return parseSeriesAttr(this.style.padding);
      },
      enumerable: false,
      configurable: true
    });
    Option2.prototype.renderLabel = function() {
      var _a2 = this.style, label = _a2.label, value2 = _a2.value;
      var labelStyle = subStyleProps(this.attributes, "label");
      select2(this.label).maybeAppend(".label", function() {
        return renderExtDo(label);
      }).attr("className", "label").styles(labelStyle);
      this.label.attr("__data__", value2);
    };
    Option2.prototype.renderBackground = function() {
      var labelBBox = this.label.getBBox();
      var _a2 = __read(this.padding, 4), top = _a2[0], right2 = _a2[1], bottom = _a2[2], left2 = _a2[3];
      var labelWidth = labelBBox.width, labelHeight = labelBBox.height;
      var backgroundWidth = labelWidth + left2 + right2;
      var backgroundHeight = labelHeight + top + bottom;
      var backgroundStyle = subStyleProps(this.attributes, "background");
      var _b = this.style, _c = _b.width, styleWidth = _c === void 0 ? 0 : _c, _d = _b.height, styleHeight = _d === void 0 ? 0 : _d, selected = _b.selected;
      this.background.attr(__assign(__assign({}, backgroundStyle), { width: Math.max(backgroundWidth, styleWidth), height: Math.max(backgroundHeight, styleHeight), fill: selected ? this.selectedColor : "#fff" }));
      this.label.attr({ x: left2, y: (backgroundHeight - labelHeight) / 2 });
    };
    Option2.prototype.render = function() {
      this.renderLabel();
      this.renderBackground();
    };
    Option2.prototype.bindEvents = function() {
      var _this2 = this;
      this.addEventListener("pointerenter", function() {
        if (_this2.style.selected)
          return;
        _this2.background.attr("fill", _this2.hoverColor);
      });
      this.addEventListener("pointerleave", function() {
        if (_this2.style.selected)
          return;
        _this2.background.attr("fill", _this2.style.backgroundFill);
      });
      var item = this;
      this.addEventListener("click", function() {
        var _a2 = _this2.style, label = _a2.label, value2 = _a2.value, onClick = _a2.onClick;
        onClick === null || onClick === void 0 ? void 0 : onClick(value2, { label, value: value2 }, item);
      });
    };
    Option2.defaultOptions = {
      style: {
        value: "",
        label: "",
        cursor: "pointer"
      }
    };
    return Option2;
  }(Component)
);

// node_modules/@antv/component/esm/ui/select/select.js
var Select2 = (
  /** @class */
  function(_super) {
    __extends(Select3, _super);
    function Select3(options) {
      var _a2, _b;
      var _this2 = _super.call(this, deepAssign2({}, Select3.defaultOptions, options)) || this;
      _this2.currentValue = (_a2 = Select3.defaultOptions.style) === null || _a2 === void 0 ? void 0 : _a2.defaultValue;
      _this2.isPointerInSelect = false;
      _this2.select = _this2.appendChild(new Rect({
        className: "select",
        style: {
          cursor: "pointer",
          width: 0,
          height: 0
        }
      }));
      _this2.dropdown = _this2.appendChild(new Rect({
        className: "dropdown"
      }));
      var defaultValue = _this2.style.defaultValue;
      if (defaultValue && ((_b = _this2.style.options) === null || _b === void 0 ? void 0 : _b.some(function(option) {
        return option.value === defaultValue;
      }))) {
        _this2.currentValue = defaultValue;
      }
      return _this2;
    }
    Select3.prototype.setValue = function(value2) {
      this.currentValue = value2;
      this.render();
    };
    Select3.prototype.getValue = function() {
      return this.currentValue;
    };
    Object.defineProperty(Select3.prototype, "dropdownPadding", {
      get: function() {
        return parseSeriesAttr(this.style.dropdownPadding);
      },
      enumerable: false,
      configurable: true
    });
    Select3.prototype.renderSelect = function() {
      var _this2 = this;
      var _a2;
      var _b = this.style, width = _b.width, height = _b.height, bordered = _b.bordered, showDropdownIcon = _b.showDropdownIcon;
      var selectStyle = subStyleProps(this.attributes, "select");
      var placeholderStyle = subStyleProps(this.attributes, "placeholder");
      this.select.attr(__assign(__assign({ width, height }, selectStyle), { fill: "#fff", strokeWidth: bordered ? 1 : 0 }));
      var padding = this.dropdownPadding;
      var iconSize = 10;
      if (showDropdownIcon) {
        select2(this.select).maybeAppend(".dropdown-icon", "path").style("d", "M-5,-3.5 L0,3.5 L5,-3.5").style("transform", "translate(".concat(width - iconSize - padding[1] - padding[3], ", ").concat(height / 2, ")")).style("lineWidth", 1).style("stroke", this.select.style.stroke);
      }
      var currentOption = (_a2 = this.style.options) === null || _a2 === void 0 ? void 0 : _a2.find(function(option) {
        return option.value === _this2.currentValue;
      });
      var finalPlaceholderStyle = __assign({ x: padding[3] }, placeholderStyle);
      select2(this.select).selectAll(".placeholder").data(!currentOption ? [1] : []).join(function(enter) {
        return enter.append("text").attr("className", "placeholder").styles(finalPlaceholderStyle).style("y", function() {
          var bbox = this.getBBox();
          return (height - bbox.height) / 2;
        });
      }, function(update3) {
        return update3.styles(finalPlaceholderStyle);
      }, function(exit) {
        return exit.remove();
      });
      var labelStyle = subStyleProps(this.attributes, "optionLabel");
      var finalValueStyle = __assign({ x: padding[3] }, labelStyle);
      select2(this.select).selectAll(".value").data(currentOption ? [currentOption] : []).join(function(enter) {
        return enter.append(function(datum) {
          return renderExtDo(datum.label);
        }).attr("className", "value").styles(finalValueStyle).style("y", function() {
          var bbox = this.getBBox();
          return (height - bbox.height) / 2;
        });
      }, function(update3) {
        return update3.styles(finalValueStyle);
      }, function(exit) {
        return exit.remove();
      });
    };
    Select3.prototype.renderDropdown = function() {
      var _this2 = this;
      var _a2, _b;
      var _c = this.style, width = _c.width, height = _c.height, options = _c.options, onSelect = _c.onSelect, open = _c.open;
      var dropdownStyle = subStyleProps(this.attributes, "dropdown");
      var optionStyle = subStyleProps(this.attributes, "option");
      var padding = this.dropdownPadding;
      select2(this.dropdown).maybeAppend(".dropdown-container", "g").attr("className", "dropdown-container").selectAll(".dropdown-item").data(options, function(datum) {
        return datum.value;
      }).join(function(enter) {
        return enter.append(function(datum) {
          return new Option({
            className: "dropdown-item",
            style: __assign(__assign(__assign({}, datum), optionStyle), { width: width - padding[1] - padding[3], selected: datum.value === _this2.currentValue, onClick: function(value2, option, item) {
              _this2.setValue(value2);
              onSelect === null || onSelect === void 0 ? void 0 : onSelect(value2, option, item);
              _this2.dispatchEvent(new CustomEvent("change", { detail: { value: value2, option, item } }));
              hide(_this2.dropdown);
            } })
          });
        }).each(function(datum, i) {
          var _a3;
          var nodes = (_a3 = this.parentNode) === null || _a3 === void 0 ? void 0 : _a3.children;
          var accHeight = nodes.reduce(function(acc, curr, index3) {
            if (index3 < i) {
              acc += curr.getBBox().height;
            }
            return acc;
          }, 0);
          this.attr("transform", "translate(".concat(padding[3], ", ").concat(padding[0] + accHeight, ")"));
        });
      }, function(update3) {
        return update3.update(function(datum) {
          return { selected: datum.value === _this2.currentValue };
        });
      }, function(exit) {
        return exit.remove();
      });
      var bbox = (_b = (_a2 = this.dropdown.getElementsByClassName("dropdown-container")) === null || _a2 === void 0 ? void 0 : _a2[0]) === null || _b === void 0 ? void 0 : _b.getBBox();
      var spacing = dropdownStyle.spacing;
      this.dropdown.attr(__assign({ y: height + spacing, width: bbox.width + padding[1] + padding[3], height: bbox.height + padding[0] + padding[2] }, dropdownStyle));
      !open && hide(this.dropdown);
    };
    Select3.prototype.render = function() {
      this.renderSelect();
      this.renderDropdown();
    };
    Select3.prototype.bindEvents = function() {
      var _this2 = this;
      this.addEventListener("click", function(e) {
        e.stopPropagation();
      });
      this.select.addEventListener("click", function() {
        if (_this2.dropdown.style.visibility === "visible")
          hide(_this2.dropdown);
        else {
          show(_this2.dropdown);
        }
      });
      this.addEventListener("pointerenter", function() {
        _this2.isPointerInSelect = true;
      });
      this.addEventListener("pointerleave", function() {
        _this2.isPointerInSelect = false;
      });
      document === null || document === void 0 ? void 0 : document.addEventListener("click", function() {
        if (!_this2.isPointerInSelect) {
          hide(_this2.dropdown);
        }
      });
    };
    Select3.defaultOptions = {
      style: {
        width: 140,
        height: 32,
        options: [],
        bordered: true,
        defaultValue: "",
        selectRadius: 8,
        selectStroke: "#d9d9d9",
        showDropdownIcon: true,
        placeholderText: "",
        placeholderFontSize: 12,
        placeholderTextBaseline: "top",
        placeholderFill: "#c2c2c2",
        dropdownFill: "#fff",
        dropdownStroke: "#d9d9d9",
        dropdownRadius: 8,
        dropdownShadowBlur: 4,
        dropdownShadowColor: "rgba(0, 0, 0, 0.08)",
        dropdownPadding: 8,
        dropdownSpacing: 10,
        optionPadding: [8, 12],
        optionFontSize: 12,
        optionTextBaseline: "top",
        optionBackgroundFill: "#fff",
        optionBackgroundRadius: 4,
        optionLabelFontSize: 12,
        optionLabelTextBaseline: "top"
      }
    };
    return Select3;
  }(Component)
);

// node_modules/@antv/component/esm/ui/timebar/icons.js
var IconBase = (
  /** @class */
  function(_super) {
    __extends(IconBase2, _super);
    function IconBase2(options) {
      var _this2 = _super.call(this, deepAssign2({}, { style: { backgroundOpacity: IconBase2.backgroundOpacities.default } }, IconBase2.defaultOptions, options)) || this;
      _this2.showBackground = true;
      _this2.background = _this2.appendChild(new Rect({}));
      _this2.icon = _this2.appendChild(new Group2({}));
      return _this2;
    }
    Object.defineProperty(IconBase2.prototype, "label", {
      get: function() {
        return "BaseIcon";
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(IconBase2.prototype, "lineWidth", {
      get: function() {
        return Math.log10(this.attributes.size);
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(IconBase2.prototype, "padding", {
      get: function() {
        return parseSeriesAttr(this.attributes.size / 5);
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(IconBase2.prototype, "iconSize", {
      get: function() {
        var size5 = this.attributes.size;
        var _a2 = __read(this.padding, 4), top = _a2[0], right2 = _a2[1], bottom = _a2[2], left2 = _a2[3];
        return Math.max(size5 - Math.max(left2 + right2, top + bottom), this.lineWidth * 2 + 1);
      },
      enumerable: false,
      configurable: true
    });
    IconBase2.prototype.renderBackground = function() {
      var size5 = this.attributes.size;
      var halfSize = size5 / 2;
      var backgroundStyle = subStyleProps(this.attributes, "background");
      this.background.attr(__assign({ x: -halfSize, y: -halfSize, width: size5, height: size5 }, backgroundStyle));
    };
    IconBase2.prototype.showIndicator = function() {
      if (!this.label)
        return;
      var size5 = this.attributes.size;
      var _a2 = this.background.getBBox(), x3 = _a2.x, y3 = _a2.y;
      this.indicator.update({ x: x3 + size5 / 2, y: y3 - 5, labelText: this.label, visibility: "visible" });
    };
    IconBase2.prototype.hideIndicator = function() {
      this.indicator.update({ visibility: "hidden" });
    };
    IconBase2.prototype.connectedCallback = function() {
      var _a2;
      _super.prototype.connectedCallback.call(this);
      var size5 = this.attributes.size;
      var _b = this.background.getBBox(), x3 = _b.x, y3 = _b.y;
      var canvas = (_a2 = this.ownerDocument) === null || _a2 === void 0 ? void 0 : _a2.defaultView;
      if (canvas) {
        this.indicator = canvas.appendChild(new Indicator({
          style: {
            x: x3 + size5 / 2,
            y: y3 - size5 / 2,
            visibility: "hidden",
            position: "top",
            radius: 3,
            zIndex: 100
          }
        }));
      }
    };
    IconBase2.prototype.disconnectedCallback = function() {
      this.indicator.destroy();
    };
    IconBase2.prototype.render = function() {
      this.renderIcon();
      if (this.showBackground)
        this.renderBackground();
    };
    IconBase2.prototype.bindEvents = function() {
      var _this2 = this;
      var onClick = this.attributes.onClick;
      this.addEventListener("click", function() {
        onClick === null || onClick === void 0 ? void 0 : onClick(_this2);
      });
      if (this.showBackground) {
        var resetBackground_1 = function() {
          return _this2.background.attr({ opacity: IconBase2.backgroundOpacities.default });
        };
        var hoverBackground_1 = function() {
          return _this2.background.attr({ opacity: IconBase2.backgroundOpacities.hover });
        };
        var activeBackground_1 = function() {
          return _this2.background.attr({ opacity: IconBase2.backgroundOpacities.active });
        };
        this.addEventListener("pointerenter", function() {
          hoverBackground_1();
          _this2.showIndicator();
        });
        this.addEventListener("pointerleave", function() {
          resetBackground_1();
          _this2.hideIndicator();
        });
        this.addEventListener("pointerdown", function() {
          activeBackground_1();
        });
        this.addEventListener("pointerup", function() {
          resetBackground_1();
        });
      }
    };
    IconBase2.tag = "IconBase";
    IconBase2.defaultOptions = {
      style: {
        x: 0,
        y: 0,
        size: 10,
        color: "#565758",
        backgroundRadius: 4,
        backgroundFill: "#e2e2e2"
      }
    };
    IconBase2.backgroundOpacities = {
      default: 0,
      hover: 0.8,
      active: 1
    };
    return IconBase2;
  }(Component)
);
var arrow = function(size5, color2) {
  if (color2 === void 0) {
    color2 = "#565758";
  }
  return new Path2({
    style: {
      fill: color2,
      anchor: "0.5 0.5",
      path: "M ".concat(size5, ",").concat(size5, " L -").concat(size5, ",0 L ").concat(size5, ",-").concat(size5, " Z"),
      transformOrigin: "center"
    }
  });
};
var Reset = (
  /** @class */
  function(_super) {
    __extends(Reset2, _super);
    function Reset2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Reset2.prototype.arcPath = function(cx, cy, radius) {
      var _a2 = __read([radius, radius], 2), rx = _a2[0], ry = _a2[1];
      var getPosByAngle = function(angle4) {
        return [cx + radius * Math.cos(angle4), cy + radius * Math.sin(angle4)];
      };
      var _b = __read(getPosByAngle(-5 / 4 * Math.PI), 2), x12 = _b[0], y12 = _b[1];
      var _c = __read(getPosByAngle(1 / 4 * Math.PI), 2), x22 = _c[0], y22 = _c[1];
      return "M".concat(x12, ",").concat(y12, ",A").concat(rx, ",").concat(ry, ",0,1,1,").concat(x22, ",").concat(y22);
    };
    Object.defineProperty(Reset2.prototype, "label", {
      get: function() {
        return "";
      },
      enumerable: false,
      configurable: true
    });
    Reset2.prototype.renderIcon = function() {
      var color2 = this.attributes.color;
      var size5 = this.iconSize;
      var lineWidth = this.lineWidth;
      var arrowSize = lineWidth + 0.5;
      select2(this.icon).maybeAppend(".reset", "path").styles({
        stroke: color2,
        lineWidth,
        path: this.arcPath(0, 0, size5 / 2 - lineWidth),
        markerStart: arrow(arrowSize, color2)
      });
    };
    return Reset2;
  }(IconBase)
);
var Backward = (
  /** @class */
  function(_super) {
    __extends(Backward2, _super);
    function Backward2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(Backward2.prototype, "label", {
      get: function() {
        return "";
      },
      enumerable: false,
      configurable: true
    });
    Backward2.prototype.renderIcon = function() {
      var color2 = this.attributes.color;
      var size5 = this.iconSize;
      var deltaX = size5 / 2;
      var deltaY = size5 / 2 / Math.pow(3, 0.5);
      var points = [
        [0, 0],
        [0, -deltaY],
        [-deltaX, 0],
        [0, deltaY],
        [0, 0],
        [deltaX, -deltaY],
        [deltaX, deltaY],
        [0, 0]
      ];
      select2(this.icon).maybeAppend(".backward", "polygon").styles({
        points,
        fill: color2
      });
    };
    return Backward2;
  }(IconBase)
);
var Forward = (
  /** @class */
  function(_super) {
    __extends(Forward2, _super);
    function Forward2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(Forward2.prototype, "label", {
      get: function() {
        return "";
      },
      enumerable: false,
      configurable: true
    });
    Forward2.prototype.renderIcon = function() {
      var color2 = this.attributes.color;
      var size5 = this.iconSize;
      var deltaX = size5 / 2;
      var deltaY = size5 / 2 / Math.pow(3, 0.5);
      var points = [
        [0, 0],
        [0, -deltaY],
        [deltaX, 0],
        [0, deltaY],
        [0, 0],
        [-deltaX, -deltaY],
        [-deltaX, deltaY],
        [0, 0]
      ];
      select2(this.icon).maybeAppend(".forward", "polygon").styles({
        points,
        fill: color2
      });
    };
    return Forward2;
  }(IconBase)
);
var Play = (
  /** @class */
  function(_super) {
    __extends(Play2, _super);
    function Play2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(Play2.prototype, "label", {
      get: function() {
        return "";
      },
      enumerable: false,
      configurable: true
    });
    Play2.prototype.renderIcon = function() {
      var color2 = this.attributes.color;
      var size5 = this.iconSize;
      var deltaX = size5 / 3 * Math.pow(3, 0.5) * 0.8;
      var points = [
        [deltaX, 0],
        [-deltaX / 2, -(size5 / 2) * 0.8],
        [-deltaX / 2, size5 / 2 * 0.8],
        [deltaX, 0]
      ];
      select2(this.icon).maybeAppend(".play", "polygon").styles({
        points,
        fill: color2
      });
    };
    return Play2;
  }(IconBase)
);
var Pause = (
  /** @class */
  function(_super) {
    __extends(Pause2, _super);
    function Pause2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(Pause2.prototype, "label", {
      get: function() {
        return "";
      },
      enumerable: false,
      configurable: true
    });
    Pause2.prototype.renderIcon = function() {
      var color2 = this.attributes.color;
      var size5 = this.iconSize;
      var deltaX = size5 / 3;
      var points = [
        [-deltaX, -size5 / 2],
        [-deltaX, size5 / 2],
        [-deltaX / 2, size5 / 2],
        [-deltaX / 2, -size5 / 2],
        [-deltaX, -size5 / 2],
        [deltaX / 2, -size5 / 2],
        [deltaX / 2, size5 / 2],
        [deltaX, size5 / 2],
        [deltaX, -size5 / 2]
      ];
      select2(this.icon).maybeAppend(".pause", "polygon").styles({
        points,
        fill: color2
      });
    };
    return Pause2;
  }(IconBase)
);
var Range = (
  /** @class */
  function(_super) {
    __extends(Range3, _super);
    function Range3() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(Range3.prototype, "label", {
      get: function() {
        return "";
      },
      enumerable: false,
      configurable: true
    });
    Range3.prototype.renderIcon = function() {
      var color2 = this.attributes.color;
      var _a2 = this, size5 = _a2.iconSize, lineWidth = _a2.lineWidth;
      var gap = lineWidth;
      select2(this.icon).maybeAppend(".left-line", "line").styles({
        x1: -size5 / 2,
        y1: -size5 / 2,
        x2: -size5 / 2,
        y2: size5 / 2,
        stroke: color2,
        lineWidth
      });
      select2(this.icon).maybeAppend(".right-line", "line").styles({
        x1: size5 / 2,
        y1: -size5 / 2,
        x2: size5 / 2,
        y2: size5 / 2,
        stroke: color2,
        lineWidth
      });
      select2(this.icon).maybeAppend(".left-arrow", "line").styles({
        x1: 0,
        y1: 0,
        x2: -size5 / 2 + gap * 2,
        y2: 0,
        stroke: color2,
        lineWidth,
        markerEnd: arrow(lineWidth * 2, color2)
      });
      select2(this.icon).maybeAppend(".right-arrow", "line").styles({
        x1: 0,
        y1: 0,
        x2: size5 / 2 - gap * 2,
        y2: 0,
        stroke: color2,
        lineWidth,
        markerEnd: arrow(lineWidth * 2, color2)
      });
    };
    return Range3;
  }(IconBase)
);
var Value = (
  /** @class */
  function(_super) {
    __extends(Value2, _super);
    function Value2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(Value2.prototype, "label", {
      get: function() {
        return "";
      },
      enumerable: false,
      configurable: true
    });
    Value2.prototype.renderIcon = function() {
      var color2 = this.attributes.color;
      var _a2 = this, size5 = _a2.iconSize, lineWidth = _a2.lineWidth;
      select2(this.icon).maybeAppend(".line", "line").styles({
        x1: 0,
        y1: -size5 / 2,
        x2: 0,
        y2: size5 / 2,
        stroke: color2,
        lineWidth
      });
      var gap = lineWidth;
      select2(this.icon).maybeAppend(".left-arrow", "line").styles({
        x1: -size5 / 2 - gap * 2,
        y1: 0,
        x2: -gap * 2,
        y2: 0,
        stroke: color2,
        lineWidth,
        markerEnd: arrow(lineWidth * 2, color2)
      });
      select2(this.icon).maybeAppend(".right-arrow", "line").styles({
        x1: size5 / 2 + gap * 2,
        y1: 0,
        x2: gap * 2,
        y2: 0,
        stroke: color2,
        lineWidth,
        markerEnd: arrow(lineWidth * 2, color2)
      });
    };
    return Value2;
  }(IconBase)
);
var getCoordinatePoints = function(size5) {
  return [
    [-size5 / 2, -size5 / 2],
    [-size5 / 2, size5 / 2],
    [size5 / 2, size5 / 2]
  ];
};
var LineChart = (
  /** @class */
  function(_super) {
    __extends(LineChart3, _super);
    function LineChart3() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(LineChart3.prototype, "label", {
      get: function() {
        return "";
      },
      enumerable: false,
      configurable: true
    });
    LineChart3.prototype.renderIcon = function() {
      var color2 = this.attributes.color;
      var _a2 = this, size5 = _a2.iconSize, lineWidth = _a2.lineWidth;
      var gap = lineWidth;
      var deltaX = (size5 - gap * 2 - lineWidth) / 4;
      var deltaY = (size5 - gap * 2 - lineWidth) / 2;
      var _b = __read([-size5 / 2 + gap, size5 / 2 - gap * 2], 2), ox = _b[0], oy = _b[1];
      select2(this.icon).maybeAppend(".coordinate", "polyline").styles({
        points: getCoordinatePoints(size5),
        stroke: color2,
        lineWidth
      });
      select2(this.icon).maybeAppend(".line", "polyline").styles({
        points: [
          [ox, oy],
          [ox + deltaX, oy - deltaY],
          [ox + deltaX * 2, oy],
          [ox + deltaX * 4, oy - deltaY * 2]
        ],
        stroke: color2,
        lineWidth
      });
    };
    return LineChart3;
  }(IconBase)
);
var BarChart = (
  /** @class */
  function(_super) {
    __extends(BarChart3, _super);
    function BarChart3() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(BarChart3.prototype, "label", {
      get: function() {
        return "";
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(BarChart3.prototype, "data", {
      get: function() {
        return [1, 4, 2, 4, 3];
      },
      enumerable: false,
      configurable: true
    });
    BarChart3.prototype.renderIcon = function() {
      var data2 = this.data;
      var color2 = this.attributes.color;
      var _a2 = this, size5 = _a2.iconSize, lineWidth = _a2.lineWidth;
      var gap = lineWidth;
      var deltaX = (size5 - gap) / data2.length;
      var deltaY = (size5 - gap * 2) / 4;
      var _b = __read([-size5 / 2 + gap * 2, size5 / 2 - gap], 2), ox = _b[0], oy = _b[1];
      select2(this.icon).maybeAppend(".coordinate", "polyline").styles({
        points: getCoordinatePoints(size5),
        stroke: color2,
        lineWidth
      });
      select2(this.icon).maybeAppend(".bars", "g").selectAll(".column").data(this.data.map(function(value2, index3) {
        return { value: value2, index: index3 };
      })).join(function(enter) {
        return enter.append("line").attr("className", "column").style("x1", function(_a3) {
          var index3 = _a3.index;
          return ox + deltaX * index3;
        }).style("y1", oy).style("x2", function(_a3) {
          var index3 = _a3.index;
          return ox + deltaX * index3;
        }).style("y2", function(_a3) {
          var value2 = _a3.value;
          return oy - deltaY * value2;
        }).styles({
          y1: oy,
          stroke: color2,
          lineWidth
        });
      });
    };
    return BarChart3;
  }(IconBase)
);
var Split = (
  /** @class */
  function(_super) {
    __extends(Split2, _super);
    function Split2(options) {
      var _this2 = _super.call(this, deepAssign2({}, { style: { color: "#d8d9d9" } }, options)) || this;
      _this2.showBackground = false;
      return _this2;
    }
    Split2.prototype.renderIcon = function() {
      var color2 = this.attributes.color;
      var _a2 = this, size5 = _a2.iconSize, lineWidth = _a2.lineWidth;
      select2(this.icon).maybeAppend(".split", "line").styles({
        x1: 0,
        y1: -size5 / 2,
        x2: 0,
        y2: size5 / 2,
        stroke: color2,
        lineWidth
      });
    };
    return Split2;
  }(IconBase)
);
var SpeedSelect = (
  /** @class */
  function(_super) {
    __extends(SpeedSelect2, _super);
    function SpeedSelect2() {
      var _this2 = _super.apply(this, __spreadArray([], __read(arguments), false)) || this;
      _this2.showBackground = false;
      return _this2;
    }
    Object.defineProperty(SpeedSelect2.prototype, "padding", {
      get: function() {
        return parseSeriesAttr(0);
      },
      enumerable: false,
      configurable: true
    });
    SpeedSelect2.prototype.renderIcon = function() {
      var iconSize = this.iconSize;
      var _a2 = this.attributes.speed, speed = _a2 === void 0 ? 1 : _a2;
      var inheritStyle = omit_default(this.attributes, ["x", "y", "width", "height", "size", "color", "speed"]);
      var width = clamp_default(iconSize, 20, Infinity);
      var height = 20;
      var x3 = -width / 2;
      var y3 = -height / 2;
      var style = __assign(__assign({}, inheritStyle), { x: x3, y: y3, width, height, defaultValue: speed, bordered: false, showDropdownIcon: false, selectRadius: 2, dropdownPadding: this.padding, dropdownRadius: 2, dropdownSpacing: iconSize / 5, placeholderFontSize: iconSize / 2, optionPadding: 0, optionLabelFontSize: iconSize / 2, optionBackgroundRadius: 1, options: [
        { label: "1x", value: 1 },
        { label: "1.5x", value: 1.5 },
        { label: "2x", value: 2 }
      ] });
      select2(this.icon).maybeAppend(".speed", function() {
        return new Select2({ style });
      }).attr("className", "speed").each(function() {
        this.update(style);
      });
    };
    SpeedSelect2.tag = "SpeedSelect";
    return SpeedSelect2;
  }(IconBase)
);
var ToggleIcon = (
  /** @class */
  function(_super) {
    __extends(ToggleIcon2, _super);
    function ToggleIcon2(options) {
      var _this2 = _super.call(this, options) || this;
      _this2.icon = _this2.appendChild(new Group2({}));
      _this2.currentType = _this2.attributes.type;
      return _this2;
    }
    ToggleIcon2.prototype.getType = function() {
      return this.currentType;
    };
    ToggleIcon2.prototype.render = function() {
      var _this2 = this;
      var _a2 = this.attributes, x3 = _a2.x, y3 = _a2.y, onChange = _a2.onChange, restStyles = __rest(_a2, ["x", "y", "onChange"]);
      select2(this.icon).selectAll(".icon").data([this.currentType]).join(function(enter) {
        return enter.append(function(type) {
          var _a3;
          var Ctor = (_a3 = _this2.toggles.find(function(_a4) {
            var _b = __read(_a4, 1), key = _b[0];
            return key === type;
          })) === null || _a3 === void 0 ? void 0 : _a3[1];
          if (!Ctor)
            throw new Error("Invalid type: ".concat(type));
          return new Ctor({});
        }).attr("className", "icon").styles(restStyles, false).update({});
      }, function(update3) {
        return update3.styles({ restStyles }).update({});
      }, function(exit) {
        return exit.remove();
      });
    };
    ToggleIcon2.prototype.bindEvents = function() {
      var _this2 = this;
      var onChange = this.attributes.onChange;
      this.addEventListener("click", function(e) {
        e.preventDefault();
        e.stopPropagation();
        var nextIndex = (_this2.toggles.findIndex(function(_a2) {
          var _b = __read(_a2, 1), key = _b[0];
          return key === _this2.currentType;
        }) + 1) % _this2.toggles.length;
        var nextType = _this2.toggles[nextIndex][0];
        onChange === null || onChange === void 0 ? void 0 : onChange(_this2.currentType);
        _this2.currentType = nextType;
        _this2.render();
      });
    };
    ToggleIcon2.tag = "ToggleIcon";
    return ToggleIcon2;
  }(Component)
);
var PlayPause = (
  /** @class */
  function(_super) {
    __extends(PlayPause2, _super);
    function PlayPause2(options) {
      var _this2 = _super.call(this, deepAssign2({}, { style: { type: "play" } }, options)) || this;
      _this2.toggles = [
        ["play", Play],
        ["pause", Pause]
      ];
      return _this2;
    }
    return PlayPause2;
  }(ToggleIcon)
);
var SelectionType = (
  /** @class */
  function(_super) {
    __extends(SelectionType2, _super);
    function SelectionType2(options) {
      var _this2 = _super.call(this, deepAssign2({}, { style: { type: "range" } }, options)) || this;
      _this2.toggles = [
        ["range", Range],
        ["value", Value]
      ];
      return _this2;
    }
    return SelectionType2;
  }(ToggleIcon)
);
var ChartType = (
  /** @class */
  function(_super) {
    __extends(ChartType2, _super);
    function ChartType2(options) {
      var _this2 = _super.call(this, deepAssign2({}, { style: { type: "column" } }, options)) || this;
      _this2.toggles = [
        ["line", LineChart],
        ["column", BarChart]
      ];
      return _this2;
    }
    return ChartType2;
  }(ToggleIcon)
);

// node_modules/@antv/component/esm/ui/timebar/controller.js
var componentsMap = {
  reset: Reset,
  speed: SpeedSelect,
  backward: Backward,
  playPause: PlayPause,
  forward: Forward,
  selectionType: SelectionType,
  chartType: ChartType,
  split: Split
};
var Controller = (
  /** @class */
  function(_super) {
    __extends(Controller3, _super);
    function Controller3(options) {
      var _this2 = _super.call(this, deepAssign2({}, Controller3.defaultOptions, options)) || this;
      _this2.background = _this2.appendChild(new Rect({}));
      _this2.functions = _this2.appendChild(new Group2({}));
      return _this2;
    }
    Object.defineProperty(Controller3.prototype, "padding", {
      get: function() {
        return parseSeriesAttr(this.attributes.padding);
      },
      enumerable: false,
      configurable: true
    });
    Controller3.prototype.renderBackground = function() {
      var _a2 = this.style, width = _a2.width, height = _a2.height;
      var backgroundStyle = subStyleProps(this.attributes, "background");
      this.background.attr(__assign({ width, height }, backgroundStyle));
    };
    Controller3.prototype.renderFunctions = function() {
      var _this2 = this;
      var _a2;
      var _b = this.attributes, functions2 = _b.functions, iconSize = _b.iconSize, iconSpacing = _b.iconSpacing, width = _b.width, height = _b.height, align = _b.align;
      var _c = __read(this.padding, 4), right2 = _c[1], left2 = _c[3];
      var components = functions2.reduce(function(prev, curr) {
        if (prev.length && curr.length) {
          return prev.concat.apply(prev, __spreadArray(["split"], __read(curr), false));
        }
        return prev.concat.apply(prev, __spreadArray([], __read(curr), false));
      }, []);
      var componentsWidth = components.length * (iconSize + iconSpacing) - iconSpacing;
      var xOffset = {
        left: left2 + iconSize / 2,
        center: (width - componentsWidth) / 2 + iconSize / 2,
        right: width - componentsWidth - left2 - right2 + iconSize / 2
      }[align] || 0;
      (_a2 = this.speedSelect) === null || _a2 === void 0 ? void 0 : _a2.destroy();
      this.functions.removeChildren();
      components.forEach(function(name2, index3) {
        var _a3;
        var Ctor = componentsMap[name2];
        var style = {
          x: index3 * (iconSize + iconSpacing) + xOffset,
          y: height / 2,
          size: iconSize
        };
        if (Ctor === SpeedSelect) {
          style.speed = _this2.attributes.speed;
          style.onSelect = function(value2) {
            return _this2.handleFunctionChange(name2, { value: value2 });
          };
        } else if ([PlayPause, SelectionType, ChartType].includes(Ctor)) {
          style.onChange = function(value2) {
            return _this2.handleFunctionChange(name2, { value: value2 });
          };
          if (Ctor === PlayPause)
            style.type = _this2.attributes.state === "play" ? "pause" : "play";
          if (Ctor === SelectionType)
            style.type = _this2.attributes.selectionType === "range" ? "value" : "range";
          if (Ctor === ChartType)
            style.type = _this2.attributes.chartType === "line" ? "column" : "line";
        } else {
          style.onClick = function() {
            return _this2.handleFunctionChange(name2, { value: name2 });
          };
        }
        if (Ctor === SpeedSelect) {
          var _b2 = _this2.getBBox(), baseX = _b2.x, baseY = _b2.y;
          var x3 = style.x, y3 = style.y;
          var canvas = (_a3 = _this2.ownerDocument) === null || _a3 === void 0 ? void 0 : _a3.defaultView;
          if (canvas) {
            _this2.speedSelect = new Ctor({ style: __assign(__assign({}, style), { zIndex: 100, x: baseX + x3, y: baseY + y3 }) });
            canvas.appendChild(_this2.speedSelect);
          }
        } else {
          _this2.functions.appendChild(new Ctor({ style }));
        }
      });
    };
    Controller3.prototype.disconnectedCallback = function() {
      var _a2;
      _super.prototype.disconnectedCallback.call(this);
      (_a2 = this.speedSelect) === null || _a2 === void 0 ? void 0 : _a2.destroy();
    };
    Controller3.prototype.render = function() {
      this.renderBackground();
      this.renderFunctions();
    };
    Controller3.prototype.handleFunctionChange = function(name2, value2) {
      var onChange = this.attributes.onChange;
      onChange === null || onChange === void 0 ? void 0 : onChange(name2, value2);
    };
    Controller3.defaultOptions = {
      style: {
        width: 300,
        height: 40,
        padding: 0,
        align: "center",
        iconSize: 25,
        iconSpacing: 0,
        speed: 1,
        state: "pause",
        chartType: "line",
        selectionType: "range",
        backgroundFill: "#fbfdff",
        backgroundStroke: "#ebedf0",
        functions: [
          ["reset", "speed"],
          ["backward", "playPause", "forward"],
          ["selectionType", "chartType"]
        ]
      }
    };
    return Controller3;
  }(Component)
);

// node_modules/@antv/component/esm/ui/timebar/handle.js
var TimeModeHandle = (
  /** @class */
  function(_super) {
    __extends(TimeModeHandle2, _super);
    function TimeModeHandle2(options) {
      var _this2 = _super.call(this, deepAssign2({}, TimeModeHandle2.defaultOptions, options)) || this;
      _this2.bindEvents();
      return _this2;
    }
    TimeModeHandle2.prototype.bindEvents = function() {
      var _this2 = this;
      this.addEventListener("mouseenter", function() {
        _this2.attr("lineWidth", Math.ceil(+(_this2.style.r || 0) / 2));
      });
      this.addEventListener("mouseleave", function() {
        _this2.attr("lineWidth", 0);
      });
    };
    TimeModeHandle2.defaultOptions = {
      style: {
        r: 5,
        fill: "#3f7cf7",
        lineWidth: 0,
        stroke: "#3f7cf7",
        strokeOpacity: 0.5,
        cursor: "pointer"
      }
    };
    return TimeModeHandle2;
  }(Circle)
);
var ChartModeHandle = (
  /** @class */
  function(_super) {
    __extends(ChartModeHandle2, _super);
    function ChartModeHandle2(options) {
      return _super.call(this, deepAssign2({}, ChartModeHandle2.defaultOptions, options)) || this;
    }
    ChartModeHandle2.prototype.renderBackground = function() {
      var _a2 = this.attributes, width = _a2.width, height = _a2.height;
      var style = subStyleProps(this.attributes, "background");
      select2(this).maybeAppend("background", "rect").attr("className", "background").styles(__assign({ x: -width / 2, y: -height / 2, width, height }, style));
    };
    ChartModeHandle2.prototype.renderIcon = function() {
      var iconSize = this.attributes.iconSize;
      var style = subStyleProps(this.attributes, "icon");
      var diffX = 1;
      var diffY = iconSize / 2;
      select2(this).maybeAppend("icon-left-line", "line").attr("className", "icon-left-line").styles(__assign({ x1: -diffX, y1: -diffY, x2: -diffX, y2: diffY }, style));
      select2(this).maybeAppend("icon-right-line", "line").attr("className", "icon-right-line").styles(__assign({ x1: diffX, y1: -diffY, x2: diffX, y2: diffY }, style));
    };
    ChartModeHandle2.prototype.renderBorder = function() {
      var _a2 = this.attributes, width = _a2.width, height = _a2.height, type = _a2.type;
      var style = subStyleProps(this.attributes, "border");
      var x3 = type === "start" ? +width / 2 : -width / 2;
      select2(this).maybeAppend("border", "line").attr("className", "border").styles(__assign({ x1: x3, y1: -height / 2, x2: x3, y2: +height / 2 }, style));
    };
    ChartModeHandle2.prototype.render = function() {
      this.renderBackground();
      this.renderIcon();
      this.renderBorder();
    };
    ChartModeHandle2.defaultOptions = {
      style: {
        width: 10,
        height: 50,
        iconSize: 10,
        type: "start",
        backgroundFill: "#fff",
        backgroundFillOpacity: 0.5,
        iconStroke: "#9a9a9a",
        iconLineWidth: 1,
        borderStroke: "#e8e8e8",
        borderLineWidth: 1
      }
    };
    return ChartModeHandle2;
  }(Component)
);

// node_modules/@antv/component/esm/ui/timebar/utils.js
function labelFormatter(time, interval2) {
  if (typeof time === "number") {
    return parseBySeries(time);
  }
  return parseByTime(time, interval2);
}
function parseByTime(time, interval2) {
  var date = new Date(time);
  switch (interval2) {
    case "half-hour":
    case "hour":
    case "four-hour":
      if ([0, 6, 12, 18].includes(date.getHours()) && date.getMinutes() === 0) {
        return formatTime(date, "HH:mm\nYYYY-MM-DD");
      }
      return formatTime(date, "HH:mm");
    case "half-day":
      if (date.getHours() < 12) {
        return "AM\n".concat(formatTime(date, "YYYY-MM-DD"));
      }
      return "PM";
    case "day":
      if ([1, 10, 20].includes(date.getDate())) {
        return formatTime(date, "DD\nYYYY-MM");
      }
      return formatTime(date, "DD");
    case "week":
      if (date.getDate() <= 7) {
        return formatTime(date, "DD\nYYYY-MM");
      }
      return formatTime(date, "DD");
    case "month":
      if ([0, 6].includes(date.getMonth())) {
        return formatTime(date, "MM\nYYYY");
      }
      return formatTime(date, "MM");
    case "season":
      if ([0].includes(date.getMonth())) {
        return formatTime(date, "MM\nYYYY");
      }
      return formatTime(date, "MM");
    case "year":
      return formatTime(date, "YYYY");
    default:
      return formatTime(date, "YYYY-MM-DD HH:mm");
  }
}
function parseBySeries(time) {
  var hours = String(Math.floor(time / 3600)).padStart(2, "0");
  var minutes = String(Math.floor(time % 3600 / 60)).padStart(2, "0");
  var seconds = String(Math.floor(time % 60)).padStart(2, "0");
  if (time < 3600) {
    return "".concat(minutes, ":").concat(seconds);
  }
  return "".concat(hours, ":").concat(minutes, ":").concat(seconds);
}

// node_modules/@antv/component/esm/ui/timebar/timebar.js
var Timebar = (
  /** @class */
  function(_super) {
    __extends(Timebar2, _super);
    function Timebar2(options) {
      var _this2 = _super.call(this, deepAssign2({}, Timebar2.defaultOptions, options)) || this;
      _this2.axis = _this2.appendChild(new Axis({
        style: { type: "linear", startPos: [0, 0], endPos: [0, 0], data: [], showArrow: false, animate: false }
      }));
      _this2.timeline = _this2.appendChild(new Slider({
        style: {
          onChange: function(values5) {
            _this2.handleSliderChange(values5);
          }
        }
      }));
      _this2.controller = _this2.appendChild(new Controller({}));
      _this2.states = {};
      _this2.handleSliderChange = function(values5) {
        var prevValues = function() {
          var val = _this2.states.values;
          if (Array.isArray(val))
            return __spreadArray([], __read(val), false);
          return val;
        }();
        _this2.setBySliderValues(values5);
        _this2.dispatchOnChange(prevValues);
      };
      var _a2 = _this2.attributes, selectionType = _a2.selectionType, chartType = _a2.chartType, speed = _a2.speed, state = _a2.state, playMode = _a2.playMode, values4 = _a2.values;
      _this2.states = { chartType, playMode, selectionType, speed, state };
      _this2.setByTimebarValues(values4);
      return _this2;
    }
    Object.defineProperty(Timebar2.prototype, "data", {
      get: function() {
        var data2 = this.attributes.data;
        var compareFn = function(a4, b) {
          if (a4.time < b.time)
            return -1;
          if (a4.time > b.time)
            return 1;
          return 0;
        };
        return data2.sort(compareFn);
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Timebar2.prototype, "space", {
      /**  */
      get: function() {
        var _a2 = this.attributes, width = _a2.width, height = _a2.height, type = _a2.type, controllerHeight = _a2.controllerHeight;
        var availableTimelineHeight = clamp_default(+height - controllerHeight, 0, +height);
        var controllerBBox = new BBox(0, +height - controllerHeight, +width, controllerHeight);
        var axisBBox;
        var axisHeight = 0;
        if (type === "chart") {
          axisHeight = 35;
          axisBBox = new BBox(0, availableTimelineHeight - axisHeight, +width, axisHeight);
        } else
          axisBBox = new BBox();
        var timelineHeight = type === "time" ? 10 : availableTimelineHeight;
        var timelineBBox = new BBox(0, type === "time" ? availableTimelineHeight : availableTimelineHeight - timelineHeight, +width, timelineHeight - axisHeight);
        return { axisBBox, controllerBBox, timelineBBox };
      },
      enumerable: false,
      configurable: true
    });
    Timebar2.prototype.setBySliderValues = function(val) {
      var _a2, _b;
      var data2 = this.data;
      var _c = __read(Array.isArray(val) ? val : [0, val], 2), startRatio = _c[0], endRatio = _c[1];
      var length5 = data2.length;
      var startDatum = data2[Math.floor(startRatio * length5)];
      var endDatum = data2[Math.ceil(endRatio * length5) - (Array.isArray(val) ? 0 : 1)];
      this.states.values = [(_a2 = startDatum === null || startDatum === void 0 ? void 0 : startDatum.time) !== null && _a2 !== void 0 ? _a2 : data2[0].time, (_b = endDatum === null || endDatum === void 0 ? void 0 : endDatum.time) !== null && _b !== void 0 ? _b : Infinity];
    };
    Timebar2.prototype.setByTimebarValues = function(val) {
      var _a2, _b, _c;
      var data2 = this.data;
      var _d = __read(Array.isArray(val) ? val : [void 0, val], 2), start = _d[0], end = _d[1];
      var startDatum = data2.find(function(_a3) {
        var time = _a3.time;
        return time === start;
      });
      var endDatum = data2.find(function(_a3) {
        var time = _a3.time;
        return time === end;
      });
      this.states.values = [(_a2 = startDatum === null || startDatum === void 0 ? void 0 : startDatum.time) !== null && _a2 !== void 0 ? _a2 : (_b = data2[0]) === null || _b === void 0 ? void 0 : _b.time, (_c = endDatum === null || endDatum === void 0 ? void 0 : endDatum.time) !== null && _c !== void 0 ? _c : Infinity];
    };
    Timebar2.prototype.setByIndex = function(index3) {
      var _a2, _b, _c, _d;
      var data2 = this.data;
      var _e = __read(index3, 2), startIndex = _e[0], endIndex = _e[1];
      this.states.values = [(_b = (_a2 = data2[startIndex]) === null || _a2 === void 0 ? void 0 : _a2.time) !== null && _b !== void 0 ? _b : data2[0].time, (_d = (_c = this.data[endIndex]) === null || _c === void 0 ? void 0 : _c.time) !== null && _d !== void 0 ? _d : Infinity];
    };
    Object.defineProperty(Timebar2.prototype, "sliderValues", {
      /**
       *  timebar  values
       */
      get: function() {
        var _a2 = this.states, values4 = _a2.values, selectionType = _a2.selectionType;
        var _b = __read(Array.isArray(values4) ? values4 : [void 0, values4], 2), start = _b[0], end = _b[1];
        var data2 = this.data;
        var length5 = data2.length;
        var isValue = selectionType === "value";
        var getStartValue = function() {
          var startDatumIndex = data2.findIndex(function(_a3) {
            var time = _a3.time;
            return time === start;
          });
          if (isValue)
            return 0;
          if (startDatumIndex > -1)
            return startDatumIndex / length5;
          return 0;
        };
        var getEndValue = function() {
          if (end === Infinity)
            return 1;
          var endDatumIndex = data2.findIndex(function(_a3) {
            var time = _a3.time;
            return time === end;
          });
          if (endDatumIndex > -1)
            return endDatumIndex / length5;
          if (isValue)
            return 0.5;
          return 1;
        };
        return [getStartValue(), getEndValue()];
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Timebar2.prototype, "values", {
      get: function() {
        var _a2 = this.states, values4 = _a2.values, selectionType = _a2.selectionType;
        var _b = __read(Array.isArray(values4) ? values4 : [this.data[0].time, values4], 2), start = _b[0], end = _b[1];
        if (selectionType === "value")
          return end;
        return [start, end];
      },
      enumerable: false,
      configurable: true
    });
    Timebar2.prototype.getDatumByRatio = function(ratio) {
      var data2 = this.data;
      var length5 = data2.length;
      var index3 = Math.floor(ratio * (length5 - 1));
      return data2[index3];
    };
    Object.defineProperty(Timebar2.prototype, "chartHandleIconShape", {
      get: function() {
        var selectionType = this.states.selectionType;
        var height = this.space.timelineBBox.height;
        if (selectionType === "range")
          return function(type) {
            return new ChartModeHandle({ style: { type, height, iconSize: height / 6 } });
          };
        return function() {
          return new Line({ style: { x1: 0, y1: -height / 2, x2: 0, y2: height / 2, lineWidth: 2, stroke: "#c8c8c8" } });
        };
      },
      enumerable: false,
      configurable: true
    });
    Timebar2.prototype.getChartStyle = function(bbox) {
      var _this2 = this;
      var x3 = bbox.x, y3 = bbox.y, width = bbox.width, height = bbox.height;
      var _a2 = this.states, selectionType = _a2.selectionType, chartType = _a2.chartType;
      var data2 = this.data;
      var _b = this.attributes, type = _b.type, userDefinedLabelFormatter = _b.labelFormatter;
      var _c = subStyleProps(this.attributes, "chart"), ignoreType = _c.type, userDefinedChartStyle = __rest(_c, ["type"]);
      var isRange = selectionType === "range";
      if (type === "time") {
        return __assign({ handleIconShape: function() {
          return new TimeModeHandle({});
        }, selectionFill: "#2e7ff8", selectionFillOpacity: 1, showLabelOnInteraction: true, handleLabelDy: isRange ? -15 : 0, autoFitLabel: isRange, handleSpacing: isRange ? -15 : 0, trackFill: "#edeeef", trackLength: width, trackOpacity: 0.5, trackRadius: height / 2, trackSize: height / 2, type: selectionType, values: this.sliderValues, formatter: function(value2) {
          if (userDefinedLabelFormatter)
            return userDefinedLabelFormatter(value2);
          var time = _this2.getDatumByRatio(value2).time;
          if (typeof time === "number")
            return parseBySeries(time);
          return formatTime(time, "YYYY-MM-DD HH:mm:ss");
        }, x: x3, y: y3, zIndex: 1 }, userDefinedChartStyle);
      }
      var handleIconOffset = selectionType === "range" ? 5 : 0;
      var sparklineData = data2.map(function(_a3) {
        var value2 = _a3.value;
        return value2;
      });
      return __assign({ handleIconOffset, handleIconShape: this.chartHandleIconShape, selectionFill: "#fff", selectionFillOpacity: 0.5, selectionType: "invert", sparklineSpacing: 0.1, sparklineColumnLineWidth: 0, sparklineColor: "#d4e5fd", sparklineAreaOpacity: 1, sparklineAreaLineWidth: 0, sparklineData, sparklineType: chartType, sparklineScale: 0.8, trackLength: width, trackSize: height, type: selectionType, values: this.sliderValues, x: x3, y: y3, zIndex: 1 }, userDefinedChartStyle);
    };
    Timebar2.prototype.renderChart = function(bbox) {
      if (bbox === void 0) {
        bbox = this.space.timelineBBox;
      }
      this.timeline.update(this.getChartStyle(bbox));
    };
    Timebar2.prototype.updateSelection = function() {
      this.timeline.setValues(this.sliderValues, true);
      this.handleSliderChange(this.sliderValues);
    };
    Timebar2.prototype.getAxisStyle = function(bbox) {
      var data2 = this.data;
      var _a2 = this.attributes, interval2 = _a2.interval, userDefinedLabelFormatter = _a2.labelFormatter;
      var userDefinedAxisStyle = subStyleProps(this.attributes, "axis");
      var x3 = bbox.x, y3 = bbox.y, width = bbox.width;
      var axisData = __spreadArray(__spreadArray([], __read(data2), false), [{ time: 0 }], false).map(function(_a3, index3, arr) {
        var time = _a3.time;
        return {
          label: "".concat(time),
          value: index3 / (arr.length - 1),
          time
        };
      });
      var style = __assign({
        startPos: [x3, y3],
        endPos: [x3 + width, y3],
        data: axisData,
        // hide last label
        labelFilter: function(_datum, index3) {
          return index3 < axisData.length - 1;
        },
        labelFormatter: function(_a3) {
          var time = _a3.time;
          return userDefinedLabelFormatter ? userDefinedLabelFormatter(time) : labelFormatter(time, interval2);
        }
      }, userDefinedAxisStyle);
      return style;
    };
    Timebar2.prototype.renderAxis = function(bbox) {
      if (bbox === void 0) {
        bbox = this.space.axisBBox;
      }
      var type = this.attributes.type;
      if (type !== "chart")
        return;
      this.axis.update(this.getAxisStyle(bbox));
    };
    Timebar2.prototype.renderController = function(bbox) {
      if (bbox === void 0) {
        bbox = this.space.controllerBBox;
      }
      var type = this.attributes.type;
      var _a2 = this.states, state = _a2.state, speed = _a2.speed, selectionType = _a2.selectionType, chartType = _a2.chartType;
      var userDefinedControllerStyle = subStyleProps(this.attributes, "controller");
      var that = this;
      var style = __assign(__assign(__assign({}, bbox), { iconSize: 20, speed, state, selectionType, chartType, onChange: function(type2, _a3) {
        var value2 = _a3.value;
        switch (type2) {
          case "reset":
            that.internalReset();
            break;
          case "speed":
            that.handleSpeedChange(value2);
            break;
          case "backward":
            that.internalBackward();
            break;
          case "playPause":
            if (value2 === "play")
              that.internalPlay();
            else
              that.internalPause();
            break;
          case "forward":
            that.internalForward();
            break;
          case "selectionType":
            that.handleSelectionTypeChange(value2);
            break;
          case "chartType":
            that.handleChartTypeChange(value2);
            break;
          default:
            break;
        }
      } }), userDefinedControllerStyle);
      if (type === "time") {
        style.functions = [["reset", "speed"], ["backward", "playPause", "forward"], ["selectionType"]];
      }
      this.controller.update(style);
    };
    Timebar2.prototype.dispatchOnChange = function(prevValues) {
      var data2 = this.data;
      var onChange = this.attributes.onChange;
      var _a2 = this.states, values4 = _a2.values, selectionType = _a2.selectionType;
      var _b = __read(values4, 2), start = _b[0], end = _b[1];
      var endTime = end === Infinity ? data2.at(-1).time : end;
      var newValues = selectionType === "range" ? [start, endTime] : endTime;
      var isEqual3 = function(val1, val2) {
        if (Array.isArray(val1)) {
          if (!Array.isArray(val2))
            return false;
          if (val1[0] === val2[0]) {
            if (val1[1] === val2[1])
              return true;
            if (val1[1] === Infinity || val2[1] === Infinity)
              return true;
          }
          return false;
        }
        if (Array.isArray(val2))
          return false;
        return val1 === val2;
      };
      if (!prevValues || !isEqual3(prevValues, newValues)) {
        onChange === null || onChange === void 0 ? void 0 : onChange(selectionType === "range" ? [start, endTime] : endTime);
      }
    };
    Timebar2.prototype.internalReset = function(preventEvent) {
      var _a2, _b;
      var selectionType = this.states.selectionType;
      this.internalPause();
      this.setBySliderValues(selectionType === "range" ? [0, 1] : [0, 0]);
      this.renderController();
      this.updateSelection();
      if (!preventEvent) {
        (_b = (_a2 = this.attributes) === null || _a2 === void 0 ? void 0 : _a2.onReset) === null || _b === void 0 ? void 0 : _b.call(_a2);
        this.dispatchOnChange();
      }
    };
    Timebar2.prototype.reset = function() {
      this.internalReset();
    };
    Timebar2.prototype.moveSelection = function(direction3, preventEvent) {
      var data2 = this.data;
      var length5 = data2.length;
      var _a2 = this.states, values4 = _a2.values, selectionType = _a2.selectionType, playMode = _a2.playMode;
      var _b = __read(values4, 2), startTime = _b[0], endTime = _b[1];
      var startIndex = data2.findIndex(function(_a3) {
        var time = _a3.time;
        return time === startTime;
      });
      var endIndex = data2.findIndex(function(_a3) {
        var time = _a3.time;
        return time === endTime;
      });
      if (endIndex === -1)
        endIndex = length5;
      var diff = direction3 === "backward" ? -1 : 1;
      var currentIndexes;
      if (selectionType === "range") {
        if (playMode === "acc") {
          currentIndexes = [startIndex, endIndex + diff];
          if (diff === -1 && startIndex === endIndex) {
            currentIndexes = [startIndex, length5];
          }
        } else
          currentIndexes = [startIndex + diff, endIndex + diff];
      } else
        currentIndexes = [startIndex, endIndex + diff];
      var normalizeIndexes = function(indexes2) {
        var _a3 = __read(indexes2.sort(function(a4, b) {
          return a4 - b;
        }), 2), start = _a3[0], end = _a3[1];
        var clampIndex = function(index3) {
          return clamp_default(index3, 0, length5);
        };
        if (end > length5) {
          if (selectionType === "value")
            return [0, 0];
          if (playMode === "acc")
            return [clampIndex(start), clampIndex(start)];
          return [0, clampIndex(end - start)];
        }
        if (start < 0) {
          if (playMode === "acc")
            return [0, clampIndex(end)];
          return [clampIndex(start + length5 - end), length5];
        }
        return [clampIndex(start), clampIndex(end)];
      };
      var normalizedIndexes = normalizeIndexes(currentIndexes);
      this.setByIndex(normalizedIndexes);
      this.updateSelection();
      return normalizedIndexes;
    };
    Timebar2.prototype.internalBackward = function(preventEvent) {
      var _a2, _b;
      var indexes2 = this.moveSelection("backward", preventEvent);
      if (!preventEvent) {
        (_b = (_a2 = this.attributes) === null || _a2 === void 0 ? void 0 : _a2.onBackward) === null || _b === void 0 ? void 0 : _b.call(_a2);
        this.dispatchOnChange();
      }
      return indexes2;
    };
    Timebar2.prototype.backward = function() {
      this.internalBackward();
    };
    Timebar2.prototype.internalPlay = function(preventEvent) {
      var _this2 = this;
      var _a2, _b;
      var data2 = this.data;
      var loop = this.attributes.loop;
      var _c = this.states.speed, speed = _c === void 0 ? 1 : _c;
      this.playInterval = window.setInterval(function() {
        var indexes2 = _this2.internalForward();
        if (indexes2[1] === data2.length && !loop) {
          _this2.internalPause();
          _this2.renderController();
        }
      }, 1e3 / speed);
      this.states.state = "play";
      !preventEvent && ((_b = (_a2 = this.attributes) === null || _a2 === void 0 ? void 0 : _a2.onPlay) === null || _b === void 0 ? void 0 : _b.call(_a2));
    };
    Timebar2.prototype.play = function() {
      this.internalPlay();
    };
    Timebar2.prototype.internalPause = function(preventEvent) {
      var _a2, _b;
      clearInterval(this.playInterval);
      this.states.state = "pause";
      !preventEvent && ((_b = (_a2 = this.attributes) === null || _a2 === void 0 ? void 0 : _a2.onPause) === null || _b === void 0 ? void 0 : _b.call(_a2));
    };
    Timebar2.prototype.pause = function() {
      this.internalPause();
    };
    Timebar2.prototype.internalForward = function(preventEvent) {
      var _a2, _b;
      var indexes2 = this.moveSelection("forward", preventEvent);
      if (!preventEvent) {
        (_b = (_a2 = this.attributes) === null || _a2 === void 0 ? void 0 : _a2.onForward) === null || _b === void 0 ? void 0 : _b.call(_a2);
        this.dispatchOnChange();
      }
      return indexes2;
    };
    Timebar2.prototype.forward = function() {
      this.internalForward();
    };
    Timebar2.prototype.handleSpeedChange = function(value2) {
      var _a2, _b;
      this.states.speed = value2;
      var state = this.states.state;
      if (state === "play") {
        this.internalPause(true);
        this.internalPlay(true);
      }
      (_b = (_a2 = this.attributes) === null || _a2 === void 0 ? void 0 : _a2.onSpeedChange) === null || _b === void 0 ? void 0 : _b.call(_a2, value2);
    };
    Timebar2.prototype.handleSelectionTypeChange = function(type) {
      var _a2, _b;
      this.states.selectionType = type;
      this.renderChart();
      (_b = (_a2 = this.attributes) === null || _a2 === void 0 ? void 0 : _a2.onSelectionTypeChange) === null || _b === void 0 ? void 0 : _b.call(_a2, type);
    };
    Timebar2.prototype.handleChartTypeChange = function(type) {
      var _a2, _b;
      this.states.chartType = type;
      this.renderChart();
      (_b = (_a2 = this.attributes) === null || _a2 === void 0 ? void 0 : _a2.onChartTypeChange) === null || _b === void 0 ? void 0 : _b.call(_a2, type);
    };
    Timebar2.prototype.render = function() {
      var _a2 = this.space, axisBBox = _a2.axisBBox, controllerBBox = _a2.controllerBBox, timelineBBox = _a2.timelineBBox;
      this.renderController(controllerBBox);
      this.renderAxis(axisBBox);
      this.renderChart(timelineBBox);
      if (this.states.state === "play")
        this.internalPlay();
    };
    Timebar2.prototype.destroy = function() {
      _super.prototype.destroy.call(this);
      this.internalPause(true);
    };
    Timebar2.defaultOptions = {
      style: {
        axisLabelFill: "#6e6e6e",
        axisLabelTextAlign: "left",
        axisLabelTextBaseline: "top",
        axisLabelTransform: "translate(5, -12)",
        axisLineLineWidth: 1,
        axisLineStroke: "#cacdd1",
        axisTickLength: 15,
        axisTickLineWidth: 1,
        axisTickStroke: "#cacdd1",
        chartShowLabel: false,
        chartType: "line",
        controllerAlign: "center",
        controllerHeight: 40,
        data: [],
        interval: "day",
        loop: false,
        playMode: "acc",
        selectionType: "range",
        type: "time"
      }
    };
    return Timebar2;
  }(Component)
);

// node_modules/@antv/component/esm/index.js
runtime.enableCSSParsing = false;

// node_modules/@antv/g2/esm/shape/text/advance.js
var __rest21 = function(s2, e) {
  var t = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
      t[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t[p2[i]] = s2[p2[i]];
    }
  return t;
};
function getConnectorPoint(shape23) {
  const { min: [x05, y05], max: [x12, y12] } = shape23.getLocalBounds();
  let x3 = 0;
  let y3 = 0;
  if (x05 > 0)
    x3 = x05;
  if (x12 < 0)
    x3 = x12;
  if (y05 > 0)
    y3 = y05;
  if (y12 < 0)
    y3 = y12;
  return [x3, y3];
}
function inferBackgroundBounds(textShape, padding = []) {
  const [top = 0, right2 = 0, bottom = top, left2 = right2] = padding;
  const container = textShape.parentNode;
  const angle4 = container.getEulerAngles();
  container.setEulerAngles(0);
  const { min: min11, halfExtents } = textShape.getLocalBounds();
  const [x3, y3] = min11;
  const [hw, hh] = halfExtents;
  container.setEulerAngles(angle4);
  return {
    x: x3 - left2,
    y: y3 - top,
    width: hw * 2 + left2 + right2,
    height: hh * 2 + top + bottom
  };
}
var cos2 = (p0, p1, p2) => {
  const a4 = dist4(p0, p1);
  const b = dist4(p1, p2);
  const c5 = dist4(p2, p0);
  return (Math.pow(a4, 2) + Math.pow(b, 2) - Math.pow(c5, 2)) / (2 * a4 * b);
};
function inferConnectorPath(shape23, points, controlPoints2, coordCenter) {
  const [[x05, y05], [x12, y12]] = points;
  const [x3, y3] = getConnectorPoint(shape23);
  if (x05 === x12 && y05 === y12) {
    return line_default()([
      [0, 0],
      [x3, y3]
    ]);
  }
  const P = [[x05 - x12, y05 - y12]].concat(controlPoints2.length ? controlPoints2 : [[0, 0]]);
  const p0 = [coordCenter[0] - x12, coordCenter[1] - y12];
  const [p1, p2] = P;
  if (cos2(p0, p1, p2) > 0) {
    const x22 = (() => {
      const { min: min11, max: max11 } = shape23.getLocalBounds();
      const vx = p1[0] + (p1[1] - p0[1]) * (p1[1] - 0) / (p1[0] - p0[0]);
      if (max11[0] < p0[0])
        return Math.min(max11[0], vx);
      return Math.max(min11[0], vx);
    })();
    P.splice(1, 1, [x22, 0]);
  }
  return line_default()(P);
}
var Advance = createElement((g) => {
  const _a2 = g.attributes, {
    className: className2,
    // Do not pass className
    class: _c,
    transform: transform3,
    rotate: rotate6,
    labelTransform,
    labelTransformOrigin,
    x: x3,
    y: y3,
    x0: x05 = x3,
    y0: y05 = y3,
    text,
    background,
    connector,
    startMarker,
    endMarker,
    coordCenter,
    innerHTML
  } = _a2, rest2 = __rest21(_a2, ["className", "class", "transform", "rotate", "labelTransform", "labelTransformOrigin", "x", "y", "x0", "y0", "text", "background", "connector", "startMarker", "endMarker", "coordCenter", "innerHTML"]);
  if ([x3, y3, x05, y05].some((v) => !is_number_default(v))) {
    g.children.forEach((d2) => d2.remove());
    return;
  }
  const _b = subObject(rest2, "background"), { padding } = _b, backgroundStyle = __rest21(_b, ["padding"]);
  const _d = subObject(rest2, "connector"), { points = [] } = _d, connectorStyle = __rest21(_d, ["points"]);
  const endPoints = [
    [+x05, +y05],
    [+x3, +y3]
  ];
  let textShape;
  if (innerHTML) {
    textShape = select(g).maybeAppend("html", "html", className2).style("zIndex", 0).style("innerHTML", innerHTML).call(applyStyle, Object.assign({ transform: labelTransform, transformOrigin: labelTransformOrigin }, rest2)).node();
  } else {
    textShape = select(g).maybeAppend("text", "text").style("zIndex", 0).style("text", text).call(applyStyle, Object.assign({ textBaseline: "middle", transform: labelTransform, transformOrigin: labelTransformOrigin }, rest2)).node();
  }
  const rect4 = select(g).maybeAppend("background", "rect").style("zIndex", -1).call(applyStyle, inferBackgroundBounds(textShape, padding)).call(applyStyle, background ? backgroundStyle : {}).node();
  const connectorPath = inferConnectorPath(rect4, endPoints, points, coordCenter);
  const markerStart = startMarker && new Marker({
    id: "startMarker",
    style: Object.assign({ x: 0, y: 0 }, subObject(rest2, "startMarker"))
  });
  const markerEnd = endMarker && new Marker({
    id: "endMarker",
    style: Object.assign({ x: 0, y: 0 }, subObject(rest2, "endMarker"))
  });
  select(g).maybeAppend("connector", "path").style("zIndex", 0).style("path", connectorPath).style("markerStart", markerStart).style("markerEnd", markerEnd).call(applyStyle, connector ? connectorStyle : {});
});

// node_modules/@antv/g2/esm/shape/text/text.js
var Text3 = (options, context) => {
  const { coordinate: coordinate2 } = context;
  return (points, value2, defaults5) => {
    const { color: color2, text = "", fontSize, rotate: rotate6 = 0, transform: transform3 = "" } = value2;
    const textStyle = {
      text: String(text),
      stroke: color2,
      fill: color2,
      fontSize
    };
    const [[x05, y05]] = points;
    return select(new Advance()).style("x", x05).style("y", y05).call(applyStyle, defaults5).style("transform", `${transform3}rotate(${+rotate6})`).style("coordCenter", coordinate2.getCenter()).call(applyStyle, textStyle).call(applyStyle, options).node();
  };
};
Text3.props = {
  defaultMarker: "point",
  defaultEnterAnimation: "fadeIn",
  defaultUpdateAnimation: "morphing",
  defaultExitAnimation: "fadeOut"
};

// node_modules/@antv/g2/esm/shape/text/badge.js
var __rest22 = function(s2, e) {
  var t = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
      t[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t[p2[i]] = s2[p2[i]];
    }
  return t;
};
function getPath(r) {
  const offset2 = r / Math.sqrt(2);
  const dy = r * Math.sqrt(2);
  const [p0x, p0y] = [-offset2, offset2 - dy];
  const [p1x, p1y] = [0, 0];
  const [p2x, p2y] = [offset2, offset2 - dy];
  return [
    ["M", p0x, p0y],
    ["A", r, r, 0, 1, 1, p2x, p2y],
    ["L", p1x, p1y],
    ["Z"]
  ];
}
function inferTextPosition(shape23) {
  const { min: min11, max: max11 } = shape23.getLocalBounds();
  return [(min11[0] + max11[0]) * 0.5, (min11[1] + max11[1]) * 0.5];
}
var BadgeShape = createElement((g) => {
  const _a2 = g.attributes, { class: className2, x: x05, y: y05 } = _a2, rest2 = __rest22(_a2, ["class", "x", "y"]);
  const markerStyle = subObject(rest2, "marker");
  const { size: size5 = 24 } = markerStyle;
  const symbol = () => getPath(size5 / 2);
  const bgShape = select(g).maybeAppend("marker", () => new Marker({})).call((selection) => selection.node().update(Object.assign({ symbol }, markerStyle))).node();
  const [x3, y3] = inferTextPosition(bgShape);
  select(g).maybeAppend("text", "text").style("x", x3).style("y", y3).call(applyStyle, rest2);
});
var Badge = (options, context) => {
  const style = __rest22(options, []);
  return (points, value2, defaults5) => {
    const { color: defaultColor } = defaults5, rest2 = __rest22(defaults5, ["color"]);
    const { color: color2 = defaultColor, text = "" } = value2;
    const textStyle = {
      text: String(text),
      stroke: color2,
      fill: color2
    };
    const [[x05, y05]] = points;
    return select(new BadgeShape()).call(applyStyle, rest2).style("x", x05).style("y", y05).call(applyStyle, textStyle).call(applyStyle, style).node();
  };
};
Badge.props = {
  defaultMarker: "point",
  defaultEnterAnimation: "fadeIn",
  defaultUpdateAnimation: "morphing",
  defaultExitAnimation: "fadeOut"
};

// node_modules/@antv/g2/esm/shape/area/curve.js
var __rest23 = function(s2, e) {
  var t = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
      t[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t[p2[i]] = s2[p2[i]];
    }
  return t;
};
function segmentation2(points, defined4) {
  const definedPointsY1 = [];
  const definedPointsY0 = [];
  const segments = [];
  let m3 = false;
  let dp = null;
  const mid2 = points.length / 2;
  for (let i = 0; i < mid2; i++) {
    const y12 = points[i];
    const y05 = points[i + mid2];
    if ([...y12, ...y05].some((v) => !defined4(v)))
      m3 = true;
    else {
      definedPointsY1.push(y12);
      definedPointsY0.push(y05);
      if (m3 && dp) {
        m3 = false;
        const [dpy1, dpy0] = dp;
        segments.push([dpy1, y12, dpy0, y05]);
      }
      dp = [y12, y05];
    }
  }
  return [definedPointsY1.concat(definedPointsY0), segments];
}
var DoubleArea = createElement((g) => {
  const { areaPath, connectPath, areaStyle, connectStyle } = g.attributes;
  const document2 = g.ownerDocument;
  select(g).maybeAppend("connect-path", () => document2.createElement("path", {})).style("d", connectPath).call(applyStyle, connectStyle);
  select(g).maybeAppend("area-path", () => document2.createElement("path", {})).style("d", areaPath).call(applyStyle, areaStyle);
});
var Curve2 = (options, context) => {
  const { curve, gradient: gradient2 = false, defined: defined4 = (d2) => !Number.isNaN(d2) && d2 !== void 0 && d2 !== null, connect: connectNulls = false } = options, style = __rest23(options, ["curve", "gradient", "defined", "connect"]);
  const { coordinate: coordinate2, document: document2 } = context;
  return (P, value2, defaults5) => {
    const { color: defaultColor } = defaults5;
    const { color: color2 = defaultColor, seriesColor: sc, seriesX: sx, seriesY: sy } = value2;
    const tpShape = isTranspose(coordinate2);
    const transform3 = getTransform(coordinate2, value2);
    const fill2 = gradient2 && sc ? computeGradient(sc, sx, sy, gradient2, void 0, tpShape) : color2;
    const finalStyle = Object.assign(Object.assign(Object.assign(Object.assign({}, defaults5), { stroke: fill2, fill: fill2 }), transform3 && { transform: transform3 }), style);
    const [DP, MS] = segmentation2(P, defined4);
    const connectStyle = subObject(finalStyle, "connect");
    const missing = !!MS.length;
    const getPathNode = (path2) => {
      return select(document2.createElement("path", {})).style("d", path2 || "").call(applyStyle, finalStyle).node();
    };
    if (!isPolar(coordinate2)) {
      const areaPath = (points) => {
        const Y12 = points.slice(0, points.length / 2);
        const Y02 = points.slice(points.length / 2);
        return tpShape ? area_default().y((_2, idx) => Y12[idx][1]).x1((_2, idx) => Y12[idx][0]).x0((_2, idx) => Y02[idx][0]).defined((_2, idx) => [...Y12[idx], ...Y02[idx]].every(defined4)).curve(curve)(Y12) : area_default().x((_2, idx) => Y12[idx][0]).y1((_2, idx) => Y12[idx][1]).y0((_2, idx) => Y02[idx][1]).defined((_2, idx) => [...Y12[idx], ...Y02[idx]].every(defined4)).curve(curve)(Y12);
      };
      if (!missing || connectNulls && !Object.keys(connectStyle).length) {
        return getPathNode(areaPath(DP));
      }
      if (missing && !connectNulls) {
        return getPathNode(areaPath(P));
      }
      return select(new DoubleArea()).style("areaStyle", finalStyle).style("connectStyle", Object.assign(Object.assign({}, connectStyle), style)).style("areaPath", areaPath(P)).style("connectPath", MS.map(areaPath).join("")).node();
    } else {
      const areaRadialPath = (points) => {
        const center2 = coordinate2.getCenter();
        const Y12 = points.slice(0, points.length / 2);
        const Y02 = points.slice(points.length / 2);
        return areaRadial_default().angle((_2, idx) => angleWithQuadrant(sub6(Y12[idx], center2))).outerRadius((_2, idx) => dist4(Y12[idx], center2)).innerRadius((_2, idx) => dist4(Y02[idx], center2)).defined((_2, idx) => [...Y12[idx], ...Y02[idx]].every(defined4)).curve(curve)(Y02);
      };
      if (!missing || connectNulls && !Object.keys(connectStyle).length) {
        return getPathNode(areaRadialPath(DP));
      }
      if (missing && !connectNulls) {
        return getPathNode(areaRadialPath(P));
      }
      return select(new DoubleArea()).style("areaStyle", finalStyle).style("connectStyle", Object.assign(Object.assign({}, connectStyle), style)).style("areaPath", areaRadialPath(P)).style("connectPath", MS.map(areaRadialPath).join("")).node();
    }
  };
};
Curve2.props = {
  defaultMarker: "smooth",
  defaultEnterAnimation: "fadeIn",
  defaultUpdateAnimation: "morphing",
  defaultExitAnimation: "fadeOut"
};

// node_modules/@antv/g2/esm/shape/area/area.js
var Area = (options, context) => {
  const { coordinate: coordinate2 } = context;
  return (...params) => {
    const curve = isPolar(coordinate2) ? linearClosed_default : linear_default;
    return Curve2(Object.assign({ curve }, options), context)(...params);
  };
};
Area.props = Object.assign(Object.assign({}, Curve2.props), { defaultMarker: "square" });

// node_modules/@antv/g2/esm/shape/area/smooth.js
var __rest24 = function(s2, e) {
  var t = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
      t[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t[p2[i]] = s2[p2[i]];
    }
  return t;
};
var Smooth2 = (options, context) => {
  const rest2 = __rest24(options, []);
  const { coordinate: coordinate2 } = context;
  return (...params) => {
    const curve = isPolar(coordinate2) ? catmullRomClosed_default : isTranspose(coordinate2) ? monotoneY : monotoneX;
    return Curve2(Object.assign({ curve }, rest2), context)(...params);
  };
};
Smooth2.props = Object.assign(Object.assign({}, Curve2.props), { defaultMarker: "smooth" });

// node_modules/@antv/g2/esm/shape/area/hvh.js
var HVH2 = (options, context) => {
  return (...params) => {
    return Curve2(Object.assign({ curve: step_default }, options), context)(...params);
  };
};
HVH2.props = Object.assign(Object.assign({}, Curve2.props), { defaultMarker: "hvh" });

// node_modules/@antv/g2/esm/shape/area/vh.js
var VH2 = (options, context) => {
  return (...params) => {
    return Curve2(Object.assign({ curve: stepBefore }, options), context)(...params);
  };
};
VH2.props = Object.assign(Object.assign({}, Curve2.props), { defaultMarker: "vh" });

// node_modules/@antv/g2/esm/shape/area/hv.js
var HV2 = (options, context) => {
  return (...params) => {
    return Curve2(Object.assign({ curve: stepAfter }, options), context)(...params);
  };
};
HV2.props = Object.assign(Object.assign({}, Curve2.props), { defaultMarker: "hv" });

// node_modules/@antv/g2/esm/shape/link/link.js
var Link = (options, context) => {
  const { arrow: arrow2 = false } = options;
  return (...params) => {
    return Vector(Object.assign(Object.assign({}, options), { arrow: arrow2 }), context)(...params);
  };
};
Link.props = {
  defaultMarker: "line",
  defaultEnterAnimation: "fadeIn",
  defaultUpdateAnimation: "morphing",
  defaultExitAnimation: "fadeOut"
};

// node_modules/@antv/g2/esm/shape/link/smooth.js
var __rest25 = function(s2, e) {
  var t = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
      t[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t[p2[i]] = s2[p2[i]];
    }
  return t;
};
var Smooth3 = (options, context) => {
  const style = __rest25(options, []);
  const { document: document2 } = context;
  return (points, value2, defaults5) => {
    const { color: defaultColor } = defaults5, rest2 = __rest25(defaults5, ["color"]);
    const { color: color2 = defaultColor, transform: transform3 } = value2;
    const [from, to] = points;
    const path2 = path();
    path2.moveTo(from[0], from[1]);
    path2.bezierCurveTo(from[0] / 2 + to[0] / 2, from[1], from[0] / 2 + to[0] / 2, to[1], to[0], to[1]);
    return select(document2.createElement("path", {})).call(applyStyle, rest2).style("d", path2.toString()).style("stroke", color2).style("transform", transform3).call(applyStyle, style).node();
  };
};
Smooth3.props = {
  defaultMarker: "smooth",
  defaultEnterAnimation: "fadeIn",
  defaultUpdateAnimation: "morphing",
  defaultExitAnimation: "fadeOut"
};

// node_modules/@antv/g2/esm/shape/link/vhv.js
var __rest26 = function(s2, e) {
  var t = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
      t[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t[p2[i]] = s2[p2[i]];
    }
  return t;
};
function getVHVPath(from, to, coordinate2, ratio) {
  const path2 = path();
  if (isPolar(coordinate2)) {
    const center2 = coordinate2.getCenter();
    const a4 = dist4(from, center2);
    const b = dist4(to, center2);
    const radius = (b - a4) * ratio + a4;
    path2.moveTo(from[0], from[1]);
    appendArc(path2, from, to, center2, radius);
    path2.lineTo(to[0], to[1]);
    return path2;
  }
  if (isTranspose(coordinate2)) {
    path2.moveTo(from[0], from[1]);
    path2.lineTo(from[0] + (to[0] - from[0]) * ratio, from[1]);
    path2.lineTo(from[0] + (to[0] - from[0]) * ratio, to[1]);
    path2.lineTo(to[0], to[1]);
    return path2;
  }
  path2.moveTo(from[0], from[1]);
  path2.lineTo(from[0], from[1] + (to[1] - from[1]) * ratio);
  path2.lineTo(to[0], from[1] + (to[1] - from[1]) * ratio);
  path2.lineTo(to[0], to[1]);
  return path2;
}
var VHV = (options, context) => {
  const { cornerRatio = 1 / 3 } = options, style = __rest26(options, ["cornerRatio"]);
  const { coordinate: coordinate2, document: document2 } = context;
  return (points, value2, defaults5) => {
    const { defaultColor } = defaults5, rest2 = __rest26(defaults5, ["defaultColor"]);
    const { color: color2 = defaultColor, transform: transform3 } = value2;
    const [from, to] = points;
    const path2 = getVHVPath(from, to, coordinate2, cornerRatio);
    return select(document2.createElement("path", {})).call(applyStyle, rest2).style("d", path2.toString()).style("stroke", color2).style("transform", transform3).call(applyStyle, style).node();
  };
};
VHV.props = {
  defaultMarker: "vhv",
  defaultEnterAnimation: "fadeIn",
  defaultUpdateAnimation: "morphing",
  defaultExitAnimation: "fadeOut"
};

// node_modules/@antv/g2/esm/shape/link/arc.js
var __rest27 = function(s2, e) {
  var t = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
      t[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t[p2[i]] = s2[p2[i]];
    }
  return t;
};
var Arc = (options, context) => {
  const style = __rest27(options, []);
  const { coordinate: coordinate2, document: document2 } = context;
  return (points, value2, defaults5) => {
    const { color: defaultColor } = defaults5, rest2 = __rest27(defaults5, ["color"]);
    const { color: color2 = defaultColor, transform: transform3 } = value2;
    const [from, to] = points;
    const path2 = path();
    path2.moveTo(from[0], from[1]);
    if (isPolar(coordinate2)) {
      const center2 = coordinate2.getCenter();
      path2.quadraticCurveTo(center2[0], center2[1], to[0], to[1]);
    } else {
      const center2 = mid(from, to);
      const raduis = dist4(from, to) / 2;
      appendArc(path2, from, to, center2, raduis);
    }
    return select(document2.createElement("path", {})).call(applyStyle, rest2).style("d", path2.toString()).style("stroke", color2).style("transform", transform3).call(applyStyle, style).node();
  };
};
Arc.props = {
  defaultMarker: "smooth",
  defaultEnterAnimation: "fadeIn",
  defaultUpdateAnimation: "morphing",
  defaultExitAnimation: "fadeOut"
};

// node_modules/d3-hierarchy/src/cluster.js
function defaultSeparation(a4, b) {
  return a4.parent === b.parent ? 1 : 2;
}
function meanX(children) {
  return children.reduce(meanXReduce, 0) / children.length;
}
function meanXReduce(x3, c5) {
  return x3 + c5.x;
}
function maxY(children) {
  return 1 + children.reduce(maxYReduce, 0);
}
function maxYReduce(y3, c5) {
  return Math.max(y3, c5.y);
}
function leafLeft(node) {
  var children;
  while (children = node.children)
    node = children[0];
  return node;
}
function leafRight(node) {
  var children;
  while (children = node.children)
    node = children[children.length - 1];
  return node;
}
function cluster_default() {
  var separation = defaultSeparation, dx = 1, dy = 1, nodeSize = false;
  function cluster(root3) {
    var previousNode, x3 = 0;
    root3.eachAfter(function(node) {
      var children = node.children;
      if (children) {
        node.x = meanX(children);
        node.y = maxY(children);
      } else {
        node.x = previousNode ? x3 += separation(node, previousNode) : 0;
        node.y = 0;
        previousNode = node;
      }
    });
    var left2 = leafLeft(root3), right2 = leafRight(root3), x05 = left2.x - separation(left2, right2) / 2, x12 = right2.x + separation(right2, left2) / 2;
    return root3.eachAfter(nodeSize ? function(node) {
      node.x = (node.x - root3.x) * dx;
      node.y = (root3.y - node.y) * dy;
    } : function(node) {
      node.x = (node.x - x05) / (x12 - x05) * dx;
      node.y = (1 - (root3.y ? node.y / root3.y : 1)) * dy;
    });
  }
  cluster.separation = function(x3) {
    return arguments.length ? (separation = x3, cluster) : separation;
  };
  cluster.size = function(x3) {
    return arguments.length ? (nodeSize = false, dx = +x3[0], dy = +x3[1], cluster) : nodeSize ? null : [dx, dy];
  };
  cluster.nodeSize = function(x3) {
    return arguments.length ? (nodeSize = true, dx = +x3[0], dy = +x3[1], cluster) : nodeSize ? [dx, dy] : null;
  };
  return cluster;
}

// node_modules/d3-hierarchy/src/hierarchy/count.js
function count3(node) {
  var sum5 = 0, children = node.children, i = children && children.length;
  if (!i)
    sum5 = 1;
  else
    while (--i >= 0)
      sum5 += children[i].value;
  node.value = sum5;
}
function count_default() {
  return this.eachAfter(count3);
}

// node_modules/d3-hierarchy/src/hierarchy/each.js
function each_default3(callback, that) {
  let index3 = -1;
  for (const node of this) {
    callback.call(that, node, ++index3, this);
  }
  return this;
}

// node_modules/d3-hierarchy/src/hierarchy/eachBefore.js
function eachBefore_default(callback, that) {
  var node = this, nodes = [node], children, i, index3 = -1;
  while (node = nodes.pop()) {
    callback.call(that, node, ++index3, this);
    if (children = node.children) {
      for (i = children.length - 1; i >= 0; --i) {
        nodes.push(children[i]);
      }
    }
  }
  return this;
}

// node_modules/d3-hierarchy/src/hierarchy/eachAfter.js
function eachAfter_default(callback, that) {
  var node = this, nodes = [node], next = [], children, i, n, index3 = -1;
  while (node = nodes.pop()) {
    next.push(node);
    if (children = node.children) {
      for (i = 0, n = children.length; i < n; ++i) {
        nodes.push(children[i]);
      }
    }
  }
  while (node = next.pop()) {
    callback.call(that, node, ++index3, this);
  }
  return this;
}

// node_modules/d3-hierarchy/src/hierarchy/find.js
function find_default3(callback, that) {
  let index3 = -1;
  for (const node of this) {
    if (callback.call(that, node, ++index3, this)) {
      return node;
    }
  }
}

// node_modules/d3-hierarchy/src/hierarchy/sum.js
function sum_default(value2) {
  return this.eachAfter(function(node) {
    var sum5 = +value2(node.data) || 0, children = node.children, i = children && children.length;
    while (--i >= 0)
      sum5 += children[i].value;
    node.value = sum5;
  });
}

// node_modules/d3-hierarchy/src/hierarchy/sort.js
function sort_default(compare) {
  return this.eachBefore(function(node) {
    if (node.children) {
      node.children.sort(compare);
    }
  });
}

// node_modules/d3-hierarchy/src/hierarchy/path.js
function path_default(end) {
  var start = this, ancestor = leastCommonAncestor(start, end), nodes = [start];
  while (start !== ancestor) {
    start = start.parent;
    nodes.push(start);
  }
  var k2 = nodes.length;
  while (end !== ancestor) {
    nodes.splice(k2, 0, end);
    end = end.parent;
  }
  return nodes;
}
function leastCommonAncestor(a4, b) {
  if (a4 === b)
    return a4;
  var aNodes = a4.ancestors(), bNodes = b.ancestors(), c5 = null;
  a4 = aNodes.pop();
  b = bNodes.pop();
  while (a4 === b) {
    c5 = a4;
    a4 = aNodes.pop();
    b = bNodes.pop();
  }
  return c5;
}

// node_modules/d3-hierarchy/src/hierarchy/ancestors.js
function ancestors_default() {
  var node = this, nodes = [node];
  while (node = node.parent) {
    nodes.push(node);
  }
  return nodes;
}

// node_modules/d3-hierarchy/src/hierarchy/descendants.js
function descendants_default() {
  return Array.from(this);
}

// node_modules/d3-hierarchy/src/hierarchy/leaves.js
function leaves_default() {
  var leaves = [];
  this.eachBefore(function(node) {
    if (!node.children) {
      leaves.push(node);
    }
  });
  return leaves;
}

// node_modules/d3-hierarchy/src/hierarchy/links.js
function links_default() {
  var root3 = this, links = [];
  root3.each(function(node) {
    if (node !== root3) {
      links.push({ source: node.parent, target: node });
    }
  });
  return links;
}

// node_modules/d3-hierarchy/src/hierarchy/iterator.js
function* iterator_default() {
  var node = this, current, next = [node], children, i, n;
  do {
    current = next.reverse(), next = [];
    while (node = current.pop()) {
      yield node;
      if (children = node.children) {
        for (i = 0, n = children.length; i < n; ++i) {
          next.push(children[i]);
        }
      }
    }
  } while (next.length);
}

// node_modules/d3-hierarchy/src/hierarchy/index.js
function hierarchy(data2, children) {
  if (data2 instanceof Map) {
    data2 = [void 0, data2];
    if (children === void 0)
      children = mapChildren;
  } else if (children === void 0) {
    children = objectChildren;
  }
  var root3 = new Node2(data2), node, nodes = [root3], child, childs, i, n;
  while (node = nodes.pop()) {
    if ((childs = children(node.data)) && (n = (childs = Array.from(childs)).length)) {
      node.children = childs;
      for (i = n - 1; i >= 0; --i) {
        nodes.push(child = childs[i] = new Node2(childs[i]));
        child.parent = node;
        child.depth = node.depth + 1;
      }
    }
  }
  return root3.eachBefore(computeHeight);
}
function node_copy() {
  return hierarchy(this).eachBefore(copyData);
}
function objectChildren(d2) {
  return d2.children;
}
function mapChildren(d2) {
  return Array.isArray(d2) ? d2[1] : null;
}
function copyData(node) {
  if (node.data.value !== void 0)
    node.value = node.data.value;
  node.data = node.data.data;
}
function computeHeight(node) {
  var height = 0;
  do
    node.height = height;
  while ((node = node.parent) && node.height < ++height);
}
function Node2(data2) {
  this.data = data2;
  this.depth = this.height = 0;
  this.parent = null;
}
Node2.prototype = hierarchy.prototype = {
  constructor: Node2,
  count: count_default,
  each: each_default3,
  eachAfter: eachAfter_default,
  eachBefore: eachBefore_default,
  find: find_default3,
  sum: sum_default,
  sort: sort_default,
  path: path_default,
  ancestors: ancestors_default,
  descendants: descendants_default,
  leaves: leaves_default,
  links: links_default,
  copy: node_copy,
  [Symbol.iterator]: iterator_default
};

// node_modules/d3-hierarchy/src/accessors.js
function optional(f) {
  return f == null ? null : required(f);
}
function required(f) {
  if (typeof f !== "function")
    throw new Error();
  return f;
}

// node_modules/d3-hierarchy/src/constant.js
function constantZero() {
  return 0;
}
function constant_default2(x3) {
  return function() {
    return x3;
  };
}

// node_modules/d3-hierarchy/src/lcg.js
var a2 = 1664525;
var c = 1013904223;
var m = 4294967296;
function lcg_default() {
  let s2 = 1;
  return () => (s2 = (a2 * s2 + c) % m) / m;
}

// node_modules/d3-hierarchy/src/array.js
function array_default2(x3) {
  return typeof x3 === "object" && "length" in x3 ? x3 : Array.from(x3);
}
function shuffle(array2, random6) {
  let m3 = array2.length, t, i;
  while (m3) {
    i = random6() * m3-- | 0;
    t = array2[m3];
    array2[m3] = array2[i];
    array2[i] = t;
  }
  return array2;
}

// node_modules/d3-hierarchy/src/pack/enclose.js
function packEncloseRandom(circles, random6) {
  var i = 0, n = (circles = shuffle(Array.from(circles), random6)).length, B3 = [], p2, e;
  while (i < n) {
    p2 = circles[i];
    if (e && enclosesWeak(e, p2))
      ++i;
    else
      e = encloseBasis(B3 = extendBasis(B3, p2)), i = 0;
  }
  return e;
}
function extendBasis(B3, p2) {
  var i, j;
  if (enclosesWeakAll(p2, B3))
    return [p2];
  for (i = 0; i < B3.length; ++i) {
    if (enclosesNot(p2, B3[i]) && enclosesWeakAll(encloseBasis2(B3[i], p2), B3)) {
      return [B3[i], p2];
    }
  }
  for (i = 0; i < B3.length - 1; ++i) {
    for (j = i + 1; j < B3.length; ++j) {
      if (enclosesNot(encloseBasis2(B3[i], B3[j]), p2) && enclosesNot(encloseBasis2(B3[i], p2), B3[j]) && enclosesNot(encloseBasis2(B3[j], p2), B3[i]) && enclosesWeakAll(encloseBasis3(B3[i], B3[j], p2), B3)) {
        return [B3[i], B3[j], p2];
      }
    }
  }
  throw new Error();
}
function enclosesNot(a4, b) {
  var dr = a4.r - b.r, dx = b.x - a4.x, dy = b.y - a4.y;
  return dr < 0 || dr * dr < dx * dx + dy * dy;
}
function enclosesWeak(a4, b) {
  var dr = a4.r - b.r + Math.max(a4.r, b.r, 1) * 1e-9, dx = b.x - a4.x, dy = b.y - a4.y;
  return dr > 0 && dr * dr > dx * dx + dy * dy;
}
function enclosesWeakAll(a4, B3) {
  for (var i = 0; i < B3.length; ++i) {
    if (!enclosesWeak(a4, B3[i])) {
      return false;
    }
  }
  return true;
}
function encloseBasis(B3) {
  switch (B3.length) {
    case 1:
      return encloseBasis1(B3[0]);
    case 2:
      return encloseBasis2(B3[0], B3[1]);
    case 3:
      return encloseBasis3(B3[0], B3[1], B3[2]);
  }
}
function encloseBasis1(a4) {
  return {
    x: a4.x,
    y: a4.y,
    r: a4.r
  };
}
function encloseBasis2(a4, b) {
  var x12 = a4.x, y12 = a4.y, r1 = a4.r, x22 = b.x, y22 = b.y, r2 = b.r, x21 = x22 - x12, y21 = y22 - y12, r21 = r2 - r1, l = Math.sqrt(x21 * x21 + y21 * y21);
  return {
    x: (x12 + x22 + x21 / l * r21) / 2,
    y: (y12 + y22 + y21 / l * r21) / 2,
    r: (l + r1 + r2) / 2
  };
}
function encloseBasis3(a4, b, c5) {
  var x12 = a4.x, y12 = a4.y, r1 = a4.r, x22 = b.x, y22 = b.y, r2 = b.r, x3 = c5.x, y3 = c5.y, r3 = c5.r, a22 = x12 - x22, a32 = x12 - x3, b2 = y12 - y22, b3 = y12 - y3, c22 = r2 - r1, c32 = r3 - r1, d1 = x12 * x12 + y12 * y12 - r1 * r1, d2 = d1 - x22 * x22 - y22 * y22 + r2 * r2, d3 = d1 - x3 * x3 - y3 * y3 + r3 * r3, ab = a32 * b2 - a22 * b3, xa = (b2 * d3 - b3 * d2) / (ab * 2) - x12, xb = (b3 * c22 - b2 * c32) / ab, ya = (a32 * d2 - a22 * d3) / (ab * 2) - y12, yb = (a22 * c32 - a32 * c22) / ab, A5 = xb * xb + yb * yb - 1, B3 = 2 * (r1 + xa * xb + ya * yb), C3 = xa * xa + ya * ya - r1 * r1, r = -(Math.abs(A5) > 1e-6 ? (B3 + Math.sqrt(B3 * B3 - 4 * A5 * C3)) / (2 * A5) : C3 / B3);
  return {
    x: x12 + xa + xb * r,
    y: y12 + ya + yb * r,
    r
  };
}

// node_modules/d3-hierarchy/src/pack/siblings.js
function place(b, a4, c5) {
  var dx = b.x - a4.x, x3, a22, dy = b.y - a4.y, y3, b2, d2 = dx * dx + dy * dy;
  if (d2) {
    a22 = a4.r + c5.r, a22 *= a22;
    b2 = b.r + c5.r, b2 *= b2;
    if (a22 > b2) {
      x3 = (d2 + b2 - a22) / (2 * d2);
      y3 = Math.sqrt(Math.max(0, b2 / d2 - x3 * x3));
      c5.x = b.x - x3 * dx - y3 * dy;
      c5.y = b.y - x3 * dy + y3 * dx;
    } else {
      x3 = (d2 + a22 - b2) / (2 * d2);
      y3 = Math.sqrt(Math.max(0, a22 / d2 - x3 * x3));
      c5.x = a4.x + x3 * dx - y3 * dy;
      c5.y = a4.y + x3 * dy + y3 * dx;
    }
  } else {
    c5.x = a4.x + c5.r;
    c5.y = a4.y;
  }
}
function intersects(a4, b) {
  var dr = a4.r + b.r - 1e-6, dx = b.x - a4.x, dy = b.y - a4.y;
  return dr > 0 && dr * dr > dx * dx + dy * dy;
}
function score(node) {
  var a4 = node._, b = node.next._, ab = a4.r + b.r, dx = (a4.x * b.r + b.x * a4.r) / ab, dy = (a4.y * b.r + b.y * a4.r) / ab;
  return dx * dx + dy * dy;
}
function Node3(circle3) {
  this._ = circle3;
  this.next = null;
  this.previous = null;
}
function packSiblingsRandom(circles, random6) {
  if (!(n = (circles = array_default2(circles)).length))
    return 0;
  var a4, b, c5, n, aa, ca, i, j, k2, sj, sk;
  a4 = circles[0], a4.x = 0, a4.y = 0;
  if (!(n > 1))
    return a4.r;
  b = circles[1], a4.x = -b.r, b.x = a4.r, b.y = 0;
  if (!(n > 2))
    return a4.r + b.r;
  place(b, a4, c5 = circles[2]);
  a4 = new Node3(a4), b = new Node3(b), c5 = new Node3(c5);
  a4.next = c5.previous = b;
  b.next = a4.previous = c5;
  c5.next = b.previous = a4;
  pack:
    for (i = 3; i < n; ++i) {
      place(a4._, b._, c5 = circles[i]), c5 = new Node3(c5);
      j = b.next, k2 = a4.previous, sj = b._.r, sk = a4._.r;
      do {
        if (sj <= sk) {
          if (intersects(j._, c5._)) {
            b = j, a4.next = b, b.previous = a4, --i;
            continue pack;
          }
          sj += j._.r, j = j.next;
        } else {
          if (intersects(k2._, c5._)) {
            a4 = k2, a4.next = b, b.previous = a4, --i;
            continue pack;
          }
          sk += k2._.r, k2 = k2.previous;
        }
      } while (j !== k2.next);
      c5.previous = a4, c5.next = b, a4.next = b.previous = b = c5;
      aa = score(a4);
      while ((c5 = c5.next) !== b) {
        if ((ca = score(c5)) < aa) {
          a4 = c5, aa = ca;
        }
      }
      b = a4.next;
    }
  a4 = [b._], c5 = b;
  while ((c5 = c5.next) !== b)
    a4.push(c5._);
  c5 = packEncloseRandom(a4, random6);
  for (i = 0; i < n; ++i)
    a4 = circles[i], a4.x -= c5.x, a4.y -= c5.y;
  return c5.r;
}

// node_modules/d3-hierarchy/src/pack/index.js
function defaultRadius(d2) {
  return Math.sqrt(d2.value);
}
function pack_default() {
  var radius = null, dx = 1, dy = 1, padding = constantZero;
  function pack3(root3) {
    const random6 = lcg_default();
    root3.x = dx / 2, root3.y = dy / 2;
    if (radius) {
      root3.eachBefore(radiusLeaf(radius)).eachAfter(packChildrenRandom(padding, 0.5, random6)).eachBefore(translateChild(1));
    } else {
      root3.eachBefore(radiusLeaf(defaultRadius)).eachAfter(packChildrenRandom(constantZero, 1, random6)).eachAfter(packChildrenRandom(padding, root3.r / Math.min(dx, dy), random6)).eachBefore(translateChild(Math.min(dx, dy) / (2 * root3.r)));
    }
    return root3;
  }
  pack3.radius = function(x3) {
    return arguments.length ? (radius = optional(x3), pack3) : radius;
  };
  pack3.size = function(x3) {
    return arguments.length ? (dx = +x3[0], dy = +x3[1], pack3) : [dx, dy];
  };
  pack3.padding = function(x3) {
    return arguments.length ? (padding = typeof x3 === "function" ? x3 : constant_default2(+x3), pack3) : padding;
  };
  return pack3;
}
function radiusLeaf(radius) {
  return function(node) {
    if (!node.children) {
      node.r = Math.max(0, +radius(node) || 0);
    }
  };
}
function packChildrenRandom(padding, k2, random6) {
  return function(node) {
    if (children = node.children) {
      var children, i, n = children.length, r = padding(node) * k2 || 0, e;
      if (r)
        for (i = 0; i < n; ++i)
          children[i].r += r;
      e = packSiblingsRandom(children, random6);
      if (r)
        for (i = 0; i < n; ++i)
          children[i].r -= r;
      node.r = e + r;
    }
  };
}
function translateChild(k2) {
  return function(node) {
    var parent2 = node.parent;
    node.r *= k2;
    if (parent2) {
      node.x = parent2.x + k2 * node.x;
      node.y = parent2.y + k2 * node.y;
    }
  };
}

// node_modules/d3-hierarchy/src/treemap/round.js
function round_default(node) {
  node.x0 = Math.round(node.x0);
  node.y0 = Math.round(node.y0);
  node.x1 = Math.round(node.x1);
  node.y1 = Math.round(node.y1);
}

// node_modules/d3-hierarchy/src/treemap/dice.js
function dice_default(parent2, x05, y05, x12, y12) {
  var nodes = parent2.children, node, i = -1, n = nodes.length, k2 = parent2.value && (x12 - x05) / parent2.value;
  while (++i < n) {
    node = nodes[i], node.y0 = y05, node.y1 = y12;
    node.x0 = x05, node.x1 = x05 += node.value * k2;
  }
}

// node_modules/d3-hierarchy/src/partition.js
function partition_default() {
  var dx = 1, dy = 1, padding = 0, round6 = false;
  function partition3(root3) {
    var n = root3.height + 1;
    root3.x0 = root3.y0 = padding;
    root3.x1 = dx;
    root3.y1 = dy / n;
    root3.eachBefore(positionNode(dy, n));
    if (round6)
      root3.eachBefore(round_default);
    return root3;
  }
  function positionNode(dy2, n) {
    return function(node) {
      if (node.children) {
        dice_default(node, node.x0, dy2 * (node.depth + 1) / n, node.x1, dy2 * (node.depth + 2) / n);
      }
      var x05 = node.x0, y05 = node.y0, x12 = node.x1 - padding, y12 = node.y1 - padding;
      if (x12 < x05)
        x05 = x12 = (x05 + x12) / 2;
      if (y12 < y05)
        y05 = y12 = (y05 + y12) / 2;
      node.x0 = x05;
      node.y0 = y05;
      node.x1 = x12;
      node.y1 = y12;
    };
  }
  partition3.round = function(x3) {
    return arguments.length ? (round6 = !!x3, partition3) : round6;
  };
  partition3.size = function(x3) {
    return arguments.length ? (dx = +x3[0], dy = +x3[1], partition3) : [dx, dy];
  };
  partition3.padding = function(x3) {
    return arguments.length ? (padding = +x3, partition3) : padding;
  };
  return partition3;
}

// node_modules/d3-hierarchy/src/stratify.js
var preroot = { depth: -1 };
var ambiguous = {};
var imputed = {};
function defaultId(d2) {
  return d2.id;
}
function defaultParentId(d2) {
  return d2.parentId;
}
function stratify_default() {
  var id3 = defaultId, parentId = defaultParentId, path2;
  function stratify(data2) {
    var nodes = Array.from(data2), currentId = id3, currentParentId = parentId, n, d2, i, root3, parent2, node, nodeId, nodeKey, nodeByKey = /* @__PURE__ */ new Map();
    if (path2 != null) {
      const I = nodes.map((d3, i2) => normalize8(path2(d3, i2, data2)));
      const P = I.map(parentof);
      const S = new Set(I).add("");
      for (const i2 of P) {
        if (!S.has(i2)) {
          S.add(i2);
          I.push(i2);
          P.push(parentof(i2));
          nodes.push(imputed);
        }
      }
      currentId = (_2, i2) => I[i2];
      currentParentId = (_2, i2) => P[i2];
    }
    for (i = 0, n = nodes.length; i < n; ++i) {
      d2 = nodes[i], node = nodes[i] = new Node2(d2);
      if ((nodeId = currentId(d2, i, data2)) != null && (nodeId += "")) {
        nodeKey = node.id = nodeId;
        nodeByKey.set(nodeKey, nodeByKey.has(nodeKey) ? ambiguous : node);
      }
      if ((nodeId = currentParentId(d2, i, data2)) != null && (nodeId += "")) {
        node.parent = nodeId;
      }
    }
    for (i = 0; i < n; ++i) {
      node = nodes[i];
      if (nodeId = node.parent) {
        parent2 = nodeByKey.get(nodeId);
        if (!parent2)
          throw new Error("missing: " + nodeId);
        if (parent2 === ambiguous)
          throw new Error("ambiguous: " + nodeId);
        if (parent2.children)
          parent2.children.push(node);
        else
          parent2.children = [node];
        node.parent = parent2;
      } else {
        if (root3)
          throw new Error("multiple roots");
        root3 = node;
      }
    }
    if (!root3)
      throw new Error("no root");
    if (path2 != null) {
      while (root3.data === imputed && root3.children.length === 1) {
        root3 = root3.children[0], --n;
      }
      for (let i2 = nodes.length - 1; i2 >= 0; --i2) {
        node = nodes[i2];
        if (node.data !== imputed)
          break;
        node.data = null;
      }
    }
    root3.parent = preroot;
    root3.eachBefore(function(node2) {
      node2.depth = node2.parent.depth + 1;
      --n;
    }).eachBefore(computeHeight);
    root3.parent = null;
    if (n > 0)
      throw new Error("cycle");
    return root3;
  }
  stratify.id = function(x3) {
    return arguments.length ? (id3 = optional(x3), stratify) : id3;
  };
  stratify.parentId = function(x3) {
    return arguments.length ? (parentId = optional(x3), stratify) : parentId;
  };
  stratify.path = function(x3) {
    return arguments.length ? (path2 = optional(x3), stratify) : path2;
  };
  return stratify;
}
function normalize8(path2) {
  path2 = `${path2}`;
  let i = path2.length;
  if (slash(path2, i - 1) && !slash(path2, i - 2))
    path2 = path2.slice(0, -1);
  return path2[0] === "/" ? path2 : `/${path2}`;
}
function parentof(path2) {
  let i = path2.length;
  if (i < 2)
    return "";
  while (--i > 1)
    if (slash(path2, i))
      break;
  return path2.slice(0, i);
}
function slash(path2, i) {
  if (path2[i] === "/") {
    let k2 = 0;
    while (i > 0 && path2[--i] === "\\")
      ++k2;
    if ((k2 & 1) === 0)
      return true;
  }
  return false;
}

// node_modules/d3-hierarchy/src/tree.js
function defaultSeparation2(a4, b) {
  return a4.parent === b.parent ? 1 : 2;
}
function nextLeft(v) {
  var children = v.children;
  return children ? children[0] : v.t;
}
function nextRight(v) {
  var children = v.children;
  return children ? children[children.length - 1] : v.t;
}
function moveSubtree(wm, wp, shift) {
  var change = shift / (wp.i - wm.i);
  wp.c -= change;
  wp.s += shift;
  wm.c += change;
  wp.z += shift;
  wp.m += shift;
}
function executeShifts(v) {
  var shift = 0, change = 0, children = v.children, i = children.length, w;
  while (--i >= 0) {
    w = children[i];
    w.z += shift;
    w.m += shift;
    shift += w.s + (change += w.c);
  }
}
function nextAncestor(vim, v, ancestor) {
  return vim.a.parent === v.parent ? vim.a : ancestor;
}
function TreeNode(node, i) {
  this._ = node;
  this.parent = null;
  this.children = null;
  this.A = null;
  this.a = this;
  this.z = 0;
  this.m = 0;
  this.c = 0;
  this.s = 0;
  this.t = null;
  this.i = i;
}
TreeNode.prototype = Object.create(Node2.prototype);
function treeRoot(root3) {
  var tree = new TreeNode(root3, 0), node, nodes = [tree], child, children, i, n;
  while (node = nodes.pop()) {
    if (children = node._.children) {
      node.children = new Array(n = children.length);
      for (i = n - 1; i >= 0; --i) {
        nodes.push(child = node.children[i] = new TreeNode(children[i], i));
        child.parent = node;
      }
    }
  }
  (tree.parent = new TreeNode(null, 0)).children = [tree];
  return tree;
}
function tree_default() {
  var separation = defaultSeparation2, dx = 1, dy = 1, nodeSize = null;
  function tree(root3) {
    var t = treeRoot(root3);
    t.eachAfter(firstWalk), t.parent.m = -t.z;
    t.eachBefore(secondWalk);
    if (nodeSize)
      root3.eachBefore(sizeNode);
    else {
      var left2 = root3, right2 = root3, bottom = root3;
      root3.eachBefore(function(node) {
        if (node.x < left2.x)
          left2 = node;
        if (node.x > right2.x)
          right2 = node;
        if (node.depth > bottom.depth)
          bottom = node;
      });
      var s2 = left2 === right2 ? 1 : separation(left2, right2) / 2, tx = s2 - left2.x, kx2 = dx / (right2.x + s2 + tx), ky2 = dy / (bottom.depth || 1);
      root3.eachBefore(function(node) {
        node.x = (node.x + tx) * kx2;
        node.y = node.depth * ky2;
      });
    }
    return root3;
  }
  function firstWalk(v) {
    var children = v.children, siblings = v.parent.children, w = v.i ? siblings[v.i - 1] : null;
    if (children) {
      executeShifts(v);
      var midpoint = (children[0].z + children[children.length - 1].z) / 2;
      if (w) {
        v.z = w.z + separation(v._, w._);
        v.m = v.z - midpoint;
      } else {
        v.z = midpoint;
      }
    } else if (w) {
      v.z = w.z + separation(v._, w._);
    }
    v.parent.A = apportion(v, w, v.parent.A || siblings[0]);
  }
  function secondWalk(v) {
    v._.x = v.z + v.parent.m;
    v.m += v.parent.m;
  }
  function apportion(v, w, ancestor) {
    if (w) {
      var vip = v, vop = v, vim = w, vom = vip.parent.children[0], sip = vip.m, sop = vop.m, sim = vim.m, som = vom.m, shift;
      while (vim = nextRight(vim), vip = nextLeft(vip), vim && vip) {
        vom = nextLeft(vom);
        vop = nextRight(vop);
        vop.a = v;
        shift = vim.z + sim - vip.z - sip + separation(vim._, vip._);
        if (shift > 0) {
          moveSubtree(nextAncestor(vim, v, ancestor), v, shift);
          sip += shift;
          sop += shift;
        }
        sim += vim.m;
        sip += vip.m;
        som += vom.m;
        sop += vop.m;
      }
      if (vim && !nextRight(vop)) {
        vop.t = vim;
        vop.m += sim - sop;
      }
      if (vip && !nextLeft(vom)) {
        vom.t = vip;
        vom.m += sip - som;
        ancestor = v;
      }
    }
    return ancestor;
  }
  function sizeNode(node) {
    node.x *= dx;
    node.y = node.depth * dy;
  }
  tree.separation = function(x3) {
    return arguments.length ? (separation = x3, tree) : separation;
  };
  tree.size = function(x3) {
    return arguments.length ? (nodeSize = false, dx = +x3[0], dy = +x3[1], tree) : nodeSize ? null : [dx, dy];
  };
  tree.nodeSize = function(x3) {
    return arguments.length ? (nodeSize = true, dx = +x3[0], dy = +x3[1], tree) : nodeSize ? [dx, dy] : null;
  };
  return tree;
}

// node_modules/d3-hierarchy/src/treemap/slice.js
function slice_default(parent2, x05, y05, x12, y12) {
  var nodes = parent2.children, node, i = -1, n = nodes.length, k2 = parent2.value && (y12 - y05) / parent2.value;
  while (++i < n) {
    node = nodes[i], node.x0 = x05, node.x1 = x12;
    node.y0 = y05, node.y1 = y05 += node.value * k2;
  }
}

// node_modules/d3-hierarchy/src/treemap/squarify.js
var phi = (1 + Math.sqrt(5)) / 2;
function squarifyRatio(ratio, parent2, x05, y05, x12, y12) {
  var rows = [], nodes = parent2.children, row2, nodeValue, i0 = 0, i1 = 0, n = nodes.length, dx, dy, value2 = parent2.value, sumValue, minValue, maxValue, newRatio, minRatio, alpha, beta;
  while (i0 < n) {
    dx = x12 - x05, dy = y12 - y05;
    do
      sumValue = nodes[i1++].value;
    while (!sumValue && i1 < n);
    minValue = maxValue = sumValue;
    alpha = Math.max(dy / dx, dx / dy) / (value2 * ratio);
    beta = sumValue * sumValue * alpha;
    minRatio = Math.max(maxValue / beta, beta / minValue);
    for (; i1 < n; ++i1) {
      sumValue += nodeValue = nodes[i1].value;
      if (nodeValue < minValue)
        minValue = nodeValue;
      if (nodeValue > maxValue)
        maxValue = nodeValue;
      beta = sumValue * sumValue * alpha;
      newRatio = Math.max(maxValue / beta, beta / minValue);
      if (newRatio > minRatio) {
        sumValue -= nodeValue;
        break;
      }
      minRatio = newRatio;
    }
    rows.push(row2 = { value: sumValue, dice: dx < dy, children: nodes.slice(i0, i1) });
    if (row2.dice)
      dice_default(row2, x05, y05, x12, value2 ? y05 += dy * sumValue / value2 : y12);
    else
      slice_default(row2, x05, y05, value2 ? x05 += dx * sumValue / value2 : x12, y12);
    value2 -= sumValue, i0 = i1;
  }
  return rows;
}
var squarify_default = function custom8(ratio) {
  function squarify(parent2, x05, y05, x12, y12) {
    squarifyRatio(ratio, parent2, x05, y05, x12, y12);
  }
  squarify.ratio = function(x3) {
    return custom8((x3 = +x3) > 1 ? x3 : 1);
  };
  return squarify;
}(phi);

// node_modules/d3-hierarchy/src/treemap/index.js
function treemap_default() {
  var tile = squarify_default, round6 = false, dx = 1, dy = 1, paddingStack = [0], paddingInner = constantZero, paddingTop = constantZero, paddingRight = constantZero, paddingBottom = constantZero, paddingLeft = constantZero;
  function treemap(root3) {
    root3.x0 = root3.y0 = 0;
    root3.x1 = dx;
    root3.y1 = dy;
    root3.eachBefore(positionNode);
    paddingStack = [0];
    if (round6)
      root3.eachBefore(round_default);
    return root3;
  }
  function positionNode(node) {
    var p2 = paddingStack[node.depth], x05 = node.x0 + p2, y05 = node.y0 + p2, x12 = node.x1 - p2, y12 = node.y1 - p2;
    if (x12 < x05)
      x05 = x12 = (x05 + x12) / 2;
    if (y12 < y05)
      y05 = y12 = (y05 + y12) / 2;
    node.x0 = x05;
    node.y0 = y05;
    node.x1 = x12;
    node.y1 = y12;
    if (node.children) {
      p2 = paddingStack[node.depth + 1] = paddingInner(node) / 2;
      x05 += paddingLeft(node) - p2;
      y05 += paddingTop(node) - p2;
      x12 -= paddingRight(node) - p2;
      y12 -= paddingBottom(node) - p2;
      if (x12 < x05)
        x05 = x12 = (x05 + x12) / 2;
      if (y12 < y05)
        y05 = y12 = (y05 + y12) / 2;
      tile(node, x05, y05, x12, y12);
    }
  }
  treemap.round = function(x3) {
    return arguments.length ? (round6 = !!x3, treemap) : round6;
  };
  treemap.size = function(x3) {
    return arguments.length ? (dx = +x3[0], dy = +x3[1], treemap) : [dx, dy];
  };
  treemap.tile = function(x3) {
    return arguments.length ? (tile = required(x3), treemap) : tile;
  };
  treemap.padding = function(x3) {
    return arguments.length ? treemap.paddingInner(x3).paddingOuter(x3) : treemap.paddingInner();
  };
  treemap.paddingInner = function(x3) {
    return arguments.length ? (paddingInner = typeof x3 === "function" ? x3 : constant_default2(+x3), treemap) : paddingInner;
  };
  treemap.paddingOuter = function(x3) {
    return arguments.length ? treemap.paddingTop(x3).paddingRight(x3).paddingBottom(x3).paddingLeft(x3) : treemap.paddingTop();
  };
  treemap.paddingTop = function(x3) {
    return arguments.length ? (paddingTop = typeof x3 === "function" ? x3 : constant_default2(+x3), treemap) : paddingTop;
  };
  treemap.paddingRight = function(x3) {
    return arguments.length ? (paddingRight = typeof x3 === "function" ? x3 : constant_default2(+x3), treemap) : paddingRight;
  };
  treemap.paddingBottom = function(x3) {
    return arguments.length ? (paddingBottom = typeof x3 === "function" ? x3 : constant_default2(+x3), treemap) : paddingBottom;
  };
  treemap.paddingLeft = function(x3) {
    return arguments.length ? (paddingLeft = typeof x3 === "function" ? x3 : constant_default2(+x3), treemap) : paddingLeft;
  };
  return treemap;
}

// node_modules/d3-hierarchy/src/treemap/binary.js
function binary_default(parent2, x05, y05, x12, y12) {
  var nodes = parent2.children, i, n = nodes.length, sum5, sums = new Array(n + 1);
  for (sums[0] = sum5 = i = 0; i < n; ++i) {
    sums[i + 1] = sum5 += nodes[i].value;
  }
  partition3(0, n, parent2.value, x05, y05, x12, y12);
  function partition3(i2, j, value2, x06, y06, x13, y13) {
    if (i2 >= j - 1) {
      var node = nodes[i2];
      node.x0 = x06, node.y0 = y06;
      node.x1 = x13, node.y1 = y13;
      return;
    }
    var valueOffset = sums[i2], valueTarget = value2 / 2 + valueOffset, k2 = i2 + 1, hi = j - 1;
    while (k2 < hi) {
      var mid2 = k2 + hi >>> 1;
      if (sums[mid2] < valueTarget)
        k2 = mid2 + 1;
      else
        hi = mid2;
    }
    if (valueTarget - sums[k2 - 1] < sums[k2] - valueTarget && i2 + 1 < k2)
      --k2;
    var valueLeft = sums[k2] - valueOffset, valueRight = value2 - valueLeft;
    if (x13 - x06 > y13 - y06) {
      var xk = value2 ? (x06 * valueRight + x13 * valueLeft) / value2 : x13;
      partition3(i2, k2, valueLeft, x06, y06, xk, y13);
      partition3(k2, j, valueRight, xk, y06, x13, y13);
    } else {
      var yk = value2 ? (y06 * valueRight + y13 * valueLeft) / value2 : y13;
      partition3(i2, k2, valueLeft, x06, y06, x13, yk);
      partition3(k2, j, valueRight, x06, yk, x13, y13);
    }
  }
}

// node_modules/d3-hierarchy/src/treemap/sliceDice.js
function sliceDice_default(parent2, x05, y05, x12, y12) {
  (parent2.depth & 1 ? slice_default : dice_default)(parent2, x05, y05, x12, y12);
}

// node_modules/d3-hierarchy/src/treemap/resquarify.js
var resquarify_default = function custom9(ratio) {
  function resquarify(parent2, x05, y05, x12, y12) {
    if ((rows = parent2._squarify) && rows.ratio === ratio) {
      var rows, row2, nodes, i, j = -1, n, m3 = rows.length, value2 = parent2.value;
      while (++j < m3) {
        row2 = rows[j], nodes = row2.children;
        for (i = row2.value = 0, n = nodes.length; i < n; ++i)
          row2.value += nodes[i].value;
        if (row2.dice)
          dice_default(row2, x05, y05, x12, value2 ? y05 += (y12 - y05) * row2.value / value2 : y12);
        else
          slice_default(row2, x05, y05, value2 ? x05 += (x12 - x05) * row2.value / value2 : x12, y12);
        value2 -= row2.value;
      }
    } else {
      parent2._squarify = rows = squarifyRatio(ratio, parent2, x05, y05, x12, y12);
      rows.ratio = ratio;
    }
  }
  resquarify.ratio = function(x3) {
    return custom9((x3 = +x3) > 1 ? x3 : 1);
  };
  return resquarify;
}(phi);

// node_modules/@antv/g2/esm/mark/utils.js
function baseChannels(options = {}) {
  const { shapes } = options;
  return [
    { name: "color" },
    { name: "opacity" },
    { name: "shape", range: shapes },
    { name: "enterType" },
    { name: "enterDelay", scaleKey: "enter" },
    { name: "enterDuration", scaleKey: "enter" },
    { name: "enterEasing" },
    { name: "key", scale: "identity" },
    { name: "groupKey", scale: "identity" },
    { name: "label", scale: "identity" }
  ];
}
function baseGeometryChannels(options = {}) {
  return [...baseChannels(options), { name: "title", scale: "identity" }];
}
function tooltip2d() {
  return [
    { type: MaybeTitle, channel: "color" },
    { type: MaybeTooltip, channel: ["x", "y"] }
  ];
}
function tooltip1d() {
  return [
    { type: MaybeTitle, channel: "x" },
    { type: MaybeTooltip, channel: ["y"] }
  ];
}
function tooltipXd() {
  return [
    { type: MaybeTitle, channel: "color" },
    { type: MaybeTooltip, channel: ["position"] }
  ];
}
function baseAnnotationChannels(options = {}) {
  return baseChannels(options);
}
function basePreInference() {
  return [{ type: MaybeKey }];
}
function basePostInference() {
  return [];
}
function bandWidth(scale10, x3) {
  return scale10.getBandWidth(scale10.invert(x3));
}
function createBandOffset(scale10, value2, options = {}) {
  const { x: X, y: Y, series: S } = value2;
  const { x: x3, y: y3, series } = scale10;
  const { style: { bandOffset = series ? 0 : 0.5, bandOffsetX = bandOffset, bandOffsetY = bandOffset } = {} } = options;
  const isBandX = !!(x3 === null || x3 === void 0 ? void 0 : x3.getBandWidth);
  const isBandY = !!(y3 === null || y3 === void 0 ? void 0 : y3.getBandWidth);
  const isSeries = !!(series === null || series === void 0 ? void 0 : series.getBandWidth);
  if (!isBandX && !isBandY)
    return (d2) => d2;
  return (d2, i) => {
    const widthX = isBandX ? bandWidth(x3, X[i]) : 0;
    const widthY = isBandY ? bandWidth(y3, Y[i]) : 0;
    const f = () => (bandWidth(series, S[i]) / 2 + +S[i]) * widthX;
    const offset2 = isSeries && S ? f() : 0;
    const [x05, y05] = d2;
    return [x05 + bandOffsetX * widthX + offset2, y05 + bandOffsetY * widthY];
  };
}
function p(d2) {
  return parseFloat(d2) / 100;
}
function visualMark(index3, scale10, value2, coordinate2) {
  const { x: X, y: Y } = value2;
  const { innerWidth, innerHeight } = coordinate2.getOptions();
  const P = Array.from(index3, (i) => {
    const x05 = X[i];
    const y05 = Y[i];
    const x3 = typeof x05 === "string" ? p(x05) * innerWidth : +x05;
    const y3 = typeof y05 === "string" ? p(y05) * innerHeight : +y05;
    return [[x3, y3]];
  });
  return [index3, P];
}
function field(encode) {
  return typeof encode === "function" ? encode : (d2) => d2[encode];
}
function valueof(data2, encode) {
  return Array.from(data2, field(encode));
}
function initializeData(data2, encode) {
  const { source = (d2) => d2.source, target = (d2) => d2.target, value: value2 = (d2) => d2.value } = encode;
  const { links, nodes } = data2;
  const LS = valueof(links, source);
  const LT = valueof(links, target);
  const LV = valueof(links, value2);
  return {
    links: links.map((_2, i) => ({
      target: LT[i],
      source: LS[i],
      value: LV[i]
    })),
    nodes: nodes || Array.from(/* @__PURE__ */ new Set([...LS, ...LT]), (key) => ({ key }))
  };
}
function generateHierarchyRoot(data2, path2) {
  if (Array.isArray(data2)) {
    return typeof path2 === "function" ? stratify_default().path(path2)(data2) : stratify_default()(data2);
  }
  return hierarchy(data2);
}

// node_modules/@antv/g2/esm/shape/image/image.js
var __rest28 = function(s2, e) {
  var t = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
      t[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t[p2[i]] = s2[p2[i]];
    }
  return t;
};
var Image3 = (options, context) => {
  const { coordinate: coordinate2, document: document2 } = context;
  return (points, value2, defaults5) => {
    const { color: defaultColor } = defaults5, rest2 = __rest28(defaults5, ["color"]);
    const { color: color2 = defaultColor, src = "", size: size5 = 32, transform: transform3 = "" } = value2;
    let { width = size5, height = size5 } = options;
    const [[x05, y05]] = points;
    const [w, h] = coordinate2.getSize();
    width = typeof width === "string" ? p(width) * w : width;
    height = typeof height === "string" ? p(height) * h : height;
    const x3 = x05 - Number(width) / 2;
    const y3 = y05 - Number(height) / 2;
    return select(document2.createElement("image", {})).call(applyStyle, rest2).style("x", x3).style("y", y3).style("img", src).style("stroke", color2).style("transform", transform3).call(applyStyle, options).style("width", width).style("height", height).node();
  };
};
Image3.props = {
  defaultEnterAnimation: "fadeIn",
  defaultUpdateAnimation: "morphing",
  defaultExitAnimation: "fadeOut"
};

// node_modules/@antv/g2/esm/shape/polygon/polygon.js
var __rest29 = function(s2, e) {
  var t = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
      t[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t[p2[i]] = s2[p2[i]];
    }
  return t;
};
function getPolygonPath(points, coordinate2) {
  const path2 = path();
  if (isPolar(coordinate2)) {
    const center2 = coordinate2.getCenter();
    const closedPoints = [...points, points[0]];
    const dists = closedPoints.map((p2) => dist4(p2, center2));
    closedPoints.forEach((curr, idx) => {
      if (idx === 0) {
        path2.moveTo(curr[0], curr[1]);
        return;
      }
      const currDist = dists[idx];
      const prev = points[idx - 1];
      const prevDist = dists[idx - 1];
      if (prevDist !== void 0 && Math.abs(currDist - prevDist) < 1e-10) {
        appendArc(path2, prev, curr, center2, currDist);
      } else {
        path2.lineTo(curr[0], curr[1]);
      }
    });
    path2.closePath();
    return path2;
  }
  return appendPolygon(path2, points);
}
var Polygon2 = (options, context) => {
  const { coordinate: coordinate2, document: document2 } = context;
  return (points, value2, defaults5) => {
    const { color: defaultColor } = defaults5, rest2 = __rest29(defaults5, ["color"]);
    const { color: color2 = defaultColor, transform: transform3 } = value2;
    const path2 = getPolygonPath(points, coordinate2);
    return select(document2.createElement("path", {})).call(applyStyle, rest2).style("d", path2.toString()).style("stroke", color2).style("fill", color2).style("transform", transform3).call(applyStyle, options).node();
  };
};
Polygon2.props = {
  defaultMarker: "square",
  defaultEnterAnimation: "fadeIn",
  defaultUpdateAnimation: "morphing",
  defaultExitAnimation: "fadeOut"
};

// node_modules/@antv/g2/esm/shape/polygon/ribbon.js
var __rest30 = function(s2, e) {
  var t = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
      t[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t[p2[i]] = s2[p2[i]];
    }
  return t;
};
function getRibbonPath(points, coordinate2) {
  const [p0, p1, p2, p3] = points;
  const path2 = path();
  if (isPolar(coordinate2)) {
    const center2 = coordinate2.getCenter();
    const radius = dist4(center2, p0);
    path2.moveTo(p0[0], p0[1]);
    path2.quadraticCurveTo(center2[0], center2[1], p2[0], p2[1]);
    appendArc(path2, p2, p3, center2, radius);
    path2.quadraticCurveTo(center2[0], center2[1], p1[0], p1[1]);
    appendArc(path2, p1, p0, center2, radius);
    path2.closePath();
    return path2;
  }
  path2.moveTo(p0[0], p0[1]);
  path2.bezierCurveTo(p0[0] / 2 + p2[0] / 2, p0[1], p0[0] / 2 + p2[0] / 2, p2[1], p2[0], p2[1]);
  path2.lineTo(p3[0], p3[1]);
  path2.bezierCurveTo(p3[0] / 2 + p1[0] / 2, p3[1], p3[0] / 2 + p1[0] / 2, p1[1], p1[0], p1[1]);
  path2.lineTo(p0[0], p0[1]);
  path2.closePath();
  return path2;
}
var Ribbon2 = (options, context) => {
  const style = __rest30(options, []);
  const { coordinate: coordinate2, document: document2 } = context;
  return (points, value2, defaults5) => {
    const { color: defaultColor } = defaults5, rest2 = __rest30(defaults5, ["color"]);
    const { color: color2 = defaultColor, transform: transform3 } = value2;
    const path2 = getRibbonPath(points, coordinate2);
    return select(document2.createElement("path", {})).call(applyStyle, rest2).style("d", path2.toString()).style("fill", color2 || defaultColor).style("stroke", color2 || defaultColor).style("transform", transform3).call(applyStyle, style).node();
  };
};
Ribbon2.props = {
  defaultMarker: "square",
  defaultEnterAnimation: "fadeIn",
  defaultUpdateAnimation: "morphing",
  defaultExitAnimation: "fadeOut"
};

// node_modules/@antv/g2/esm/shape/box/box.js
var __rest31 = function(s2, e) {
  var t = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
      t[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t[p2[i]] = s2[p2[i]];
    }
  return t;
};
function getPath2(points, coordinate2) {
  const path2 = path();
  if (!isPolar(coordinate2)) {
    path2.moveTo(...points[0]);
    path2.lineTo(...points[1]);
    path2.moveTo(...points[2]);
    path2.lineTo(...points[3]);
    path2.moveTo(...points[4]);
    path2.lineTo(...points[5]);
    path2.lineTo(...points[6]);
    path2.lineTo(...points[7]);
    path2.closePath();
    path2.moveTo(...points[8]);
    path2.lineTo(...points[9]);
    path2.moveTo(...points[10]);
    path2.lineTo(...points[11]);
    path2.moveTo(...points[12]);
    path2.lineTo(...points[13]);
  } else {
    const center2 = coordinate2.getCenter();
    const [x3, y3] = center2;
    const startAngle = angle3(sub6(points[0], center2));
    const endAngle = angle3(sub6(points[1], center2));
    const radiusHigh = dist4(center2, points[2]);
    const radiusQ3 = dist4(center2, points[3]);
    const radiusMedian = dist4(center2, points[8]);
    const radiusQ1 = dist4(center2, points[10]);
    const radiusLow = dist4(center2, points[11]);
    path2.moveTo(...points[0]);
    path2.arc(x3, y3, radiusHigh, startAngle, endAngle);
    path2.arc(x3, y3, radiusHigh, endAngle, startAngle, true);
    path2.moveTo(...points[2]);
    path2.lineTo(...points[3]);
    path2.moveTo(...points[4]);
    path2.arc(x3, y3, radiusQ3, startAngle, endAngle);
    path2.lineTo(...points[6]);
    path2.arc(x3, y3, radiusQ1, endAngle, startAngle, true);
    path2.closePath();
    path2.moveTo(...points[8]);
    path2.arc(x3, y3, radiusMedian, startAngle, endAngle);
    path2.arc(x3, y3, radiusMedian, endAngle, startAngle, true);
    path2.moveTo(...points[10]);
    path2.lineTo(...points[11]);
    path2.moveTo(...points[12]);
    path2.arc(x3, y3, radiusLow, startAngle, endAngle);
    path2.arc(x3, y3, radiusLow, endAngle, startAngle, true);
  }
  return path2;
}
var Box = (options, context) => {
  const { coordinate: coordinate2, document: document2 } = context;
  return (points, value2, defaults5) => {
    const { color: color2, transform: transform3 } = value2;
    const { color: defaultColor, fill: fill2 = defaultColor, stroke: stroke2 = defaultColor } = defaults5, rest2 = __rest31(defaults5, ["color", "fill", "stroke"]);
    const path2 = getPath2(points, coordinate2);
    return select(document2.createElement("path", {})).call(applyStyle, rest2).style("d", path2.toString()).style("stroke", stroke2).style("fill", color2 || fill2).style("transform", transform3).call(applyStyle, options).node();
  };
};
Box.props = {
  defaultMarker: "point",
  defaultEnterAnimation: "fadeIn",
  defaultUpdateAnimation: "morphing",
  defaultExitAnimation: "fadeOut"
};

// node_modules/@antv/g2/esm/shape/box/violin.js
var __rest32 = function(s2, e) {
  var t = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
      t[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t[p2[i]] = s2[p2[i]];
    }
  return t;
};
function getPath3(p2, coordinate2, size5 = 4) {
  const path2 = path();
  if (!isPolar(coordinate2)) {
    path2.moveTo(...p2[2]);
    path2.lineTo(...p2[3]);
    path2.lineTo(p2[3][0] - size5, p2[3][1]);
    path2.lineTo(p2[10][0] - size5, p2[10][1]);
    path2.lineTo(p2[10][0] + size5, p2[10][1]);
    path2.lineTo(p2[3][0] + size5, p2[3][1]);
    path2.lineTo(...p2[3]);
    path2.closePath();
    path2.moveTo(...p2[10]);
    path2.lineTo(...p2[11]);
    path2.moveTo(p2[3][0] + size5 / 2, p2[8][1]);
    path2.arc(p2[3][0], p2[8][1], size5 / 2, 0, Math.PI * 2);
    path2.closePath();
    return path2;
  }
  const center2 = coordinate2.getCenter();
  const [x3, y3] = center2;
  const radiusQ3 = dist4(center2, p2[3]);
  const radiusMedian = dist4(center2, p2[8]);
  const radiusQ1 = dist4(center2, p2[10]);
  const middleAngle = angle3(sub6(p2[2], center2));
  const rectAngle = Math.asin(size5 / radiusMedian);
  const startAngle = middleAngle - rectAngle;
  const endAngle = middleAngle + rectAngle;
  path2.moveTo(...p2[2]);
  path2.lineTo(...p2[3]);
  path2.moveTo(Math.cos(startAngle) * radiusQ3 + x3, Math.sin(startAngle) * radiusQ3 + y3);
  path2.arc(x3, y3, radiusQ3, startAngle, endAngle);
  path2.lineTo(Math.cos(endAngle) * radiusQ1 + x3, Math.sin(endAngle) * radiusQ1 + y3);
  path2.arc(x3, y3, radiusQ1, endAngle, startAngle, true);
  path2.lineTo(Math.cos(startAngle) * radiusQ3 + x3, Math.sin(startAngle) * radiusQ3 + y3);
  path2.closePath();
  path2.moveTo(...p2[10]);
  path2.lineTo(...p2[11]);
  const a4 = (startAngle + endAngle) / 2;
  path2.moveTo(Math.cos(a4) * (radiusMedian + size5 / 2) + x3, Math.sin(a4) * (radiusMedian + size5 / 2) + y3);
  path2.arc(Math.cos(a4) * radiusMedian + x3, Math.sin(a4) * radiusMedian + y3, size5 / 2, a4, Math.PI * 2 + a4);
  path2.closePath();
  return path2;
}
var Violin = (options, context) => {
  const { coordinate: coordinate2, document: document2 } = context;
  return (points, value2, defaults5) => {
    const { color: color2, transform: transform3 } = value2;
    const size5 = 4;
    const { color: defaultColor, fill: fill2 = defaultColor, stroke: stroke2 = defaultColor } = defaults5, rest2 = __rest32(defaults5, ["color", "fill", "stroke"]);
    const path2 = getPath3(points, coordinate2, size5);
    return select(document2.createElement("path", {})).call(applyStyle, rest2).style("d", path2.toString()).style("stroke", stroke2).style("fill", color2 || fill2).style("transform", transform3).call(applyStyle, options).node();
  };
};
Violin.props = {
  defaultMarker: "point",
  defaultEnterAnimation: "fadeIn",
  defaultUpdateAnimation: "morphing",
  defaultExitAnimation: "fadeOut"
};

// node_modules/@antv/g2/esm/shape/lineXY/line.js
var __rest33 = function(s2, e) {
  var t = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
      t[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t[p2[i]] = s2[p2[i]];
    }
  return t;
};
function getArrowMarker(document2, arrowSize, arrowStyle) {
  const arrowMarker = document2.createElement("path", {
    style: Object.assign({ path: `M ${arrowSize},${arrowSize} L -${arrowSize},0 L ${arrowSize},-${arrowSize} L 0,0 Z`, anchor: "0.5 0.5", transformOrigin: "center" }, arrowStyle)
  });
  return arrowMarker;
}
function getPath4(points, coordinate2) {
  if (!isPolar(coordinate2))
    return line_default().x((d2) => d2[0]).y((d2) => d2[1])(points);
  const center2 = coordinate2.getCenter();
  return arc_default()({
    startAngle: 0,
    endAngle: Math.PI * 2,
    outerRadius: dist4(points[0], center2),
    innerRadius: dist4(points[1], center2)
  });
}
function getTransform2(coordinate2, transform3) {
  if (!isPolar(coordinate2))
    return transform3;
  const [cx, cy] = coordinate2.getCenter();
  return `translate(${cx}, ${cy}) ${transform3 || ""}`;
}
var Line4 = (options, context) => {
  const { arrow: arrow2, arrowSize = 4 } = options, style = __rest33(options, ["arrow", "arrowSize"]);
  const { coordinate: coordinate2, document: document2 } = context;
  return (points, value2, defaults5) => {
    const { color: defaultColor, lineWidth } = defaults5, shapeTheme = __rest33(defaults5, ["color", "lineWidth"]);
    const { color: color2 = defaultColor, size: size5 = lineWidth } = value2;
    const arrowMarker = arrow2 ? getArrowMarker(document2, arrowSize, Object.assign({ fill: style.stroke || color2, stroke: style.stroke || color2 }, subObject(style, "arrow"))) : null;
    const path2 = getPath4(points, coordinate2);
    const transform3 = getTransform2(coordinate2, value2.transform);
    return select(document2.createElement("path", {})).call(applyStyle, shapeTheme).style("d", path2).style("stroke", color2).style("lineWidth", size5).style("transform", transform3).style("markerEnd", arrowMarker).call(applyStyle, style).node();
  };
};
Line4.props = {
  defaultMarker: "line",
  defaultEnterAnimation: "fadeIn",
  defaultUpdateAnimation: "morphing",
  defaultExitAnimation: "fadeOut"
};

// node_modules/@antv/g2/esm/shape/connector/connector.js
var __rest34 = function(s2, e) {
  var t = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
      t[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t[p2[i]] = s2[p2[i]];
    }
  return t;
};
function inferSymbol(x3, y3, r) {
  return [["M", x3, y3], ["L", x3 + 2 * r, y3 - r], ["L", x3 + 2 * r, y3 + r], ["Z"]];
}
function inferConnectorPath2(points) {
  return line_default().x((d2) => d2[0]).y((d2) => d2[1])(points);
}
function getPoints(coordinate2, points, offset1, offset2, length1 = 0) {
  const [[x05, y05], [x12, y12]] = points;
  if (isTranspose(coordinate2)) {
    const X02 = x05 + offset1;
    const X12 = x12 + offset2;
    const X = X02 + length1;
    return [
      [X02, y05],
      [X, y05],
      [X, y12],
      [X12, y12]
    ];
  }
  const Y02 = y05 - offset1;
  const Y12 = y12 - offset2;
  const Y = Y02 - length1;
  return [
    [x05, Y02],
    [x05, Y],
    [x12, Y],
    [x12, Y12]
  ];
}
var Connector = (options, context) => {
  const { offset: offset2 = 0, offset1 = offset2, offset2: offset22 = offset2, connectLength1: length1, endMarker = true } = options, style = __rest34(options, ["offset", "offset1", "offset2", "connectLength1", "endMarker"]);
  const { coordinate: coordinate2 } = context;
  return (points, value2, defaults5) => {
    const { color: defaultColor, connectLength1 } = defaults5, rest2 = __rest34(defaults5, ["color", "connectLength1"]);
    const { color: color2, transform: transform3 } = value2;
    const P = getPoints(coordinate2, points, offset1, offset22, length1 !== null && length1 !== void 0 ? length1 : connectLength1);
    const makerStyle = subObject(Object.assign(Object.assign({}, style), defaults5), "endMarker");
    return select(new Path2()).call(applyStyle, rest2).style("path", inferConnectorPath2(P)).style("stroke", color2 || defaultColor).style("transform", transform3).style("markerEnd", endMarker ? new Marker({
      className: "marker",
      style: Object.assign(Object.assign({}, makerStyle), { symbol: inferSymbol })
    }) : null).call(applyStyle, style).node();
  };
};
Connector.props = {
  defaultMarker: "line",
  defaultEnterAnimation: "fadeIn",
  defaultUpdateAnimation: "morphing",
  defaultExitAnimation: "fadeOut"
};

// node_modules/@antv/g2/esm/utils/string.js
function camelCase2(s2) {
  return s2.replace(/-(\w)/g, function(_2, letter) {
    return letter.toUpperCase();
  });
}
function kebabCase(s2) {
  return s2.replace(/([A-Z])/g, "-$1").toLowerCase();
}

// node_modules/@antv/g2/esm/shape/label/position/index.js
var position_exports = {};
__export(position_exports, {
  area: () => area,
  bottom: () => getDefaultStyle,
  bottomLeft: () => getDefaultStyle,
  bottomRight: () => getDefaultStyle,
  inside: () => getDefaultStyle,
  left: () => getDefaultStyle,
  outside: () => outside,
  right: () => getDefaultStyle,
  spider: () => spider,
  surround: () => surround,
  top: () => getDefaultStyle,
  topLeft: () => getDefaultStyle,
  topRight: () => getDefaultStyle
});

// node_modules/@antv/g2/esm/shape/label/position/area.js
function area(position, points, value2, coordinate2) {
  const l = points.length / 2;
  const Y12 = points.slice(0, l);
  const Y02 = points.slice(l);
  let idx = maxIndex(Y12, (p2, i) => Math.abs(p2[1] - Y02[i][1]));
  idx = Math.max(Math.min(idx, l - 2), 1);
  const mid2 = (i) => [Y12[i][0], (Y12[i][1] + Y02[i][1]) / 2];
  const point7 = mid2(idx);
  const prev = mid2(idx - 1);
  const next = mid2(idx + 1);
  const rotate6 = angle3(sub6(next, prev)) / Math.PI * 180;
  return {
    x: point7[0],
    y: point7[1],
    transform: `rotate(${rotate6})`,
    textAlign: "center",
    textBaseline: "middle"
  };
}

// node_modules/@antv/g2/esm/shape/label/position/default.js
function inferNonCircularStyle(position, points, value2, coordinate2) {
  const { bounds } = value2;
  const [[x05, y05], [x12, y12]] = bounds;
  const w = x12 - x05;
  const h = y12 - y05;
  const xy = (options) => {
    const { x: ox, y: oy } = options;
    const px = maybePercentage(value2.x, w);
    const py = maybePercentage(value2.y, h);
    return Object.assign(Object.assign({}, options), { x: (px || ox) + x05, y: (py || oy) + y05 });
  };
  if (position === "left")
    return xy({ x: 0, y: h / 2, textAnchor: "start", textBaseline: "middle" });
  if (position === "right")
    return xy({ x: w, y: h / 2, textAnchor: "end", textBaseline: "middle" });
  if (position === "top")
    return xy({ x: w / 2, y: 0, textAnchor: "center", textBaseline: "top" });
  if (position === "bottom")
    return xy({ x: w / 2, y: h, textAnchor: "center", textBaseline: "bottom" });
  if (position === "top-left")
    return xy({ x: 0, y: 0, textAnchor: "start", textBaseline: "top" });
  if (position === "top-right")
    return xy({ x: w, y: 0, textAnchor: "end", textBaseline: "top" });
  if (position === "bottom-left")
    return xy({ x: 0, y: h, textAnchor: "start", textBaseline: "bottom" });
  if (position === "bottom-right")
    return xy({ x: w, y: h, textAnchor: "end", textBaseline: "bottom" });
  return xy({
    x: w / 2,
    y: h / 2,
    textAnchor: "center",
    textBaseline: "middle"
  });
}
function inferRadialStyle(position, points, value2, coordinate2) {
  const { y: y3, y1: y12, autoRotate, rotateToAlignArc } = value2;
  const center2 = coordinate2.getCenter();
  const arcObject = getArcObject(coordinate2, points, [y3, y12]);
  const { innerRadius, outerRadius, startAngle, endAngle } = arcObject;
  const angle4 = position === "inside" ? (startAngle + endAngle) / 2 : endAngle;
  const rotate6 = inferRotation(angle4, autoRotate, rotateToAlignArc);
  const point7 = (() => {
    const [p0, p1] = points;
    const radius = innerRadius + (outerRadius - innerRadius) * 0.5;
    const [x3, y4] = position === "inside" ? pointOfArc(center2, angle4, radius) : mid(p0, p1);
    return { x: x3, y: y4 };
  })();
  return Object.assign(Object.assign({}, point7), { textAlign: position === "inside" ? "center" : "start", textBaseline: "middle", rotate: rotate6 });
}
function pointOfArc(center2, angle4, radius) {
  return [
    center2[0] + Math.sin(angle4) * radius,
    center2[1] - Math.cos(angle4) * radius
  ];
}
function inferRotation(angle4, autoRotate, rotateToAlignArc) {
  if (!autoRotate)
    return 0;
  const append3 = rotateToAlignArc ? 0 : Math.sin(angle4) < 0 ? 90 : -90;
  return angle4 / Math.PI * 180 + append3;
}
function inferInnerCircularStyle(position, points, value2, coordinate2) {
  const { y: y3, y1: y12, autoRotate, rotateToAlignArc, radius: radiusRatio = 0.5, offset: offset2 = 0 } = value2;
  const arcObject = getArcObject(coordinate2, points, [y3, y12]);
  const { startAngle, endAngle } = arcObject;
  const center2 = coordinate2.getCenter();
  const angle4 = (startAngle + endAngle) / 2;
  const rotate6 = inferRotation(angle4, autoRotate, rotateToAlignArc);
  const textStyle = { textAlign: "center", textBaseline: "middle", rotate: rotate6 };
  const { innerRadius, outerRadius } = arcObject;
  const r0 = innerRadius + (outerRadius - innerRadius) * radiusRatio;
  const r1 = r0 + offset2;
  const [x05, y05] = pointOfArc(center2, angle4, r1);
  return Object.assign({ x: x05, y: y05 }, textStyle);
}
function maybeUndefined(d2) {
  return d2 === void 0 ? null : d2;
}
function inferIdentityStyle(position, points, value2, coordinate2) {
  const { bounds } = value2;
  const [p2] = bounds;
  return {
    x: maybeUndefined(p2[0]),
    y: maybeUndefined(p2[1])
  };
}
function getDefaultStyle(position, points, value2, coordinate2) {
  const { bounds } = value2;
  if (bounds.length === 1) {
    return inferIdentityStyle(position, points, value2, coordinate2);
  }
  const inferDefaultStyle2 = isRadial(coordinate2) ? inferRadialStyle : isCircular(coordinate2) ? inferInnerCircularStyle : inferNonCircularStyle;
  return inferDefaultStyle2(position, points, value2, coordinate2);
}

// node_modules/@antv/g2/esm/shape/label/position/outside.js
function linePoints(center2, angle4, radius, radius1, offsetX) {
  const [x05, y05] = pointOfArc(center2, angle4, radius);
  const [x12, y12] = pointOfArc(center2, angle4, radius1);
  const sign3 = Math.sin(angle4) > 0 ? 1 : -1;
  return [
    [x05, y05],
    [x12, y12],
    [x12 + sign3 * offsetX, y12]
  ];
}
function radiusOf2(points, value2, coordinate2) {
  const arcObject = getArcObject(coordinate2, points, [value2.y, value2.y1]);
  const { innerRadius, outerRadius } = arcObject;
  return innerRadius + (outerRadius - innerRadius);
}
function angleOf2(points, value2, coordinate2) {
  const arcObject = getArcObject(coordinate2, points, [value2.y, value2.y1]);
  const { startAngle, endAngle } = arcObject;
  return (startAngle + endAngle) / 2;
}
function inferOutsideCircularStyle(position, points, value2, coordinate2) {
  const { autoRotate, rotateToAlignArc, offset: offset2 = 0, connector = true, connectorLength = offset2, connectorLength2 = 0, connectorDistance = 0 } = value2;
  const center2 = coordinate2.getCenter();
  const angle4 = angleOf2(points, value2, coordinate2);
  const sign3 = Math.sin(angle4) > 0 ? 1 : -1;
  const rotate6 = inferRotation(angle4, autoRotate, rotateToAlignArc);
  const textStyle = {
    textAlign: sign3 > 0 || isRadial(coordinate2) ? "start" : "end",
    textBaseline: "middle",
    rotate: rotate6
  };
  const radius = radiusOf2(points, value2, coordinate2);
  const radius1 = radius + (connector ? connectorLength : offset2);
  const [[x05, y05], [x12, y12], [x22, y22]] = linePoints(center2, angle4, radius, radius1, connector ? connectorLength2 : 0);
  const dx = connector ? +connectorDistance * sign3 : 0;
  const x3 = x22 + dx;
  const y3 = y22;
  const connectorStyle = {
    connector,
    connectorPoints: [
      [x12 - x3, y12 - y3],
      [x22 - x3, y22 - y3]
    ]
  };
  return Object.assign(Object.assign({
    x0: x05,
    y0: y05,
    x: x22 + dx,
    y: y22
  }, textStyle), connectorStyle);
}
function outside(position, points, value2, coordinate2) {
  const { bounds } = value2;
  if (bounds.length === 1) {
    return inferIdentityStyle(position, points, value2, coordinate2);
  }
  const inferDefaultStyle2 = isRadial(coordinate2) ? inferRadialStyle : isCircular(coordinate2) ? inferOutsideCircularStyle : inferNonCircularStyle;
  return inferDefaultStyle2(position, points, value2, coordinate2);
}

// node_modules/@antv/g2/esm/shape/label/position/spider.js
var __rest35 = function(s2, e) {
  var t = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
      t[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t[p2[i]] = s2[p2[i]];
    }
  return t;
};
function spider(position, points, value2, coordinate2) {
  if (!isCircular(coordinate2))
    return {};
  const { connectorLength, connectorLength2, connectorDistance } = value2;
  const style = __rest35(inferOutsideCircularStyle("outside", points, value2, coordinate2), []);
  const center2 = coordinate2.getCenter();
  const radius = radiusOf2(points, value2, coordinate2);
  const angle4 = angleOf2(points, value2, coordinate2);
  const radius1 = radius + connectorLength + connectorLength2;
  const sign3 = Math.sin(angle4) > 0 ? 1 : -1;
  const newX = center2[0] + (radius1 + +connectorDistance) * sign3;
  const { x: originX } = style;
  const dx = newX - originX;
  style.x += dx;
  style.connectorPoints[0][0] -= dx;
  return style;
}

// node_modules/@antv/g2/esm/shape/label/position/surround.js
var __rest36 = function(s2, e) {
  var t = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
      t[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t[p2[i]] = s2[p2[i]];
    }
  return t;
};
function surround(position, points, value2, coordinate2) {
  if (!isCircular(coordinate2))
    return {};
  const { connectorLength, connectorLength2, connectorDistance } = value2;
  const style = __rest36(inferOutsideCircularStyle("outside", points, value2, coordinate2), []);
  const { x0: x05, y0: y05 } = style;
  const center2 = coordinate2.getCenter();
  const radius = getRadius(coordinate2);
  const radius1 = radius + connectorLength;
  const angle4 = angleWithQuadrant([x05 - center2[0], y05 - center2[1]]);
  const sign3 = Math.sin(angle4) > 0 ? 1 : -1;
  const [newX, newY] = pointOfArc(center2, angle4, radius1);
  style.x = newX + (connectorLength2 + connectorDistance) * sign3;
  style.y = newY;
  return style;
}

// node_modules/@antv/g2/esm/shape/label/label.js
var __rest37 = function(s2, e) {
  var t = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
      t[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t[p2[i]] = s2[p2[i]];
    }
  return t;
};
function inferPosition(position, coordinate2) {
  if (position !== void 0)
    return position;
  if (isCircular(coordinate2))
    return "inside";
  if (isTranspose(coordinate2))
    return "right";
  return "top";
}
function getDefaultStyle2(points, value2, coordinate2, theme, options) {
  const { position } = value2;
  const { render: render3 } = options;
  const p2 = inferPosition(position, coordinate2);
  const labelType = render3 ? "htmlLabel" : p2 === "inside" ? "innerLabel" : "label";
  const t = theme[labelType];
  const v = Object.assign({}, t, value2);
  const processor = position_exports[camelCase2(p2)];
  if (!processor) {
    throw new Error(`Unknown position: ${p2}`);
  }
  return Object.assign(Object.assign({}, t), processor(p2, points, v, coordinate2, options));
}
var Label = (options, context) => {
  const { coordinate: coordinate2, theme } = context;
  const { render: render3 } = options;
  return (points, value2) => {
    const { text, x: x3, y: y3, transform: specifiedTS = "", transformOrigin, className: className2 = "" } = value2, overrideStyle = __rest37(value2, ["text", "x", "y", "transform", "transformOrigin", "className"]);
    const _a2 = getDefaultStyle2(points, value2, coordinate2, theme, options), { rotate: rotate6 = 0, transform: transform3 = "" } = _a2, defaultStyle2 = __rest37(_a2, ["rotate", "transform"]);
    return select(new Advance()).call(applyStyle, defaultStyle2).style("text", `${text}`).style("className", `${className2} g2-label`).style("innerHTML", render3 ? render3(text, value2.datum, value2.index) : void 0).style("labelTransform", `${transform3} rotate(${+rotate6}) ${specifiedTS}`.trim()).style("labelTransformOrigin", transformOrigin).style("coordCenter", coordinate2.getCenter()).call(applyStyle, overrideStyle).node();
  };
};
Label.props = {
  defaultMarker: "point"
};

// node_modules/@antv/g2/esm/shape/path/color.js
var __rest38 = function(s2, e) {
  var t = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
      t[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t[p2[i]] = s2[p2[i]];
    }
  return t;
};
var Color4 = (options, context) => {
  const { arrow: arrow2, colorAttribute } = options, style = __rest38(options, ["arrow", "colorAttribute"]);
  const { coordinate: coordinate2, document: document2 } = context;
  return (points, value2, defaults5) => {
    const { color: defaultColor, stroke: stroke2 } = defaults5, rest2 = __rest38(defaults5, ["color", "stroke"]);
    const { d: d2, color: color2 = defaultColor } = value2;
    const [width, height] = coordinate2.getSize();
    return select(document2.createElement("path", {})).call(applyStyle, rest2).style("d", typeof d2 === "function" ? d2({ width, height }) : d2).style(colorAttribute, color2).call(applyStyle, style).node();
  };
};
Color4.props = {
  defaultEnterAnimation: "fadeIn",
  defaultUpdateAnimation: "morphing",
  defaultExitAnimation: "fadeOut"
};

// node_modules/@antv/g2/esm/shape/path/path.js
var Path3 = (options, context) => {
  return Color4(Object.assign({ colorAttribute: "fill" }, options), context);
};
Path3.props = {
  defaultMarker: "hvh",
  defaultEnterAnimation: "fadeIn",
  defaultUpdateAnimation: "morphing",
  defaultExitAnimation: "fadeOut"
};

// node_modules/@antv/g2/esm/shape/path/hollow.js
var Hollow2 = (options, context) => {
  return Color4(Object.assign({ fill: "none", colorAttribute: "stroke" }, options), context);
};
Hollow2.props = {
  defaultMarker: "hvh",
  defaultEnterAnimation: "fadeIn",
  defaultUpdateAnimation: "morphing",
  defaultExitAnimation: "fadeOut"
};

// node_modules/@antv/g2/esm/shape/density/density.js
var __rest39 = function(s2, e) {
  var t = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
      t[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t[p2[i]] = s2[p2[i]];
    }
  return t;
};
var Density = (options, context) => {
  const { document: document2 } = context;
  return (points, value2, defaults5) => {
    const { transform: transform3 } = value2;
    const { color: defaultColor } = defaults5, rest2 = __rest39(defaults5, ["color"]);
    const { color: color2 = defaultColor } = value2;
    const [first3, ...p2] = points;
    const path2 = path();
    path2.moveTo(...first3);
    p2.forEach(([x3, y3]) => {
      path2.lineTo(x3, y3);
    });
    path2.closePath();
    return select(document2.createElement("path", {})).call(applyStyle, rest2).style("d", path2.toString()).style("stroke", color2 || defaultColor).style("fill", color2 || defaultColor).style("fillOpacity", 0.4).style("transform", transform3).call(applyStyle, options).node();
  };
};
Density.props = {
  defaultMarker: "square",
  defaultEnterAnimation: "fadeIn",
  defaultUpdateAnimation: "morphing",
  defaultExitAnimation: "fadeOut"
};

// node_modules/@antv/g2/esm/utils/lru.js
var cache = flru_default(3);
function lru(fn, keyFn = (...args) => `${args[0]}`, maxSize = 16) {
  const cache2 = flru_default(maxSize);
  return (...args) => {
    const key = keyFn(...args);
    let v = cache2.get(key);
    if (cache2.has(key))
      return cache2.get(key);
    v = fn(...args);
    cache2.set(key, v);
    return v;
  };
}

// node_modules/@antv/g2/esm/shape/heatmap/renderer/gradient.js
function parseGradient2(gradient2) {
  if (typeof gradient2 === "string") {
    return gradient2.split(" ").map((stop) => {
      const [r, c5] = stop.split(":");
      return [+r, c5];
    });
  }
  return gradient2;
}

// node_modules/@antv/g2/esm/shape/heatmap/renderer/index.js
function newCanvas(createCanvas, width, height) {
  const c5 = createCanvas ? createCanvas() : document.createElement("canvas");
  c5.width = width;
  c5.height = height;
  return c5;
}
var getPointTemplate = lru((radius, blurFactor, createCanvas) => {
  const tplCanvas = newCanvas(createCanvas, radius * 2, radius * 2);
  const tplCtx = tplCanvas.getContext("2d");
  const x3 = radius;
  const y3 = radius;
  if (blurFactor === 1) {
    tplCtx.beginPath();
    tplCtx.arc(x3, y3, radius, 0, 2 * Math.PI, false);
    tplCtx.fillStyle = "rgba(0,0,0,1)";
    tplCtx.fill();
  } else {
    const gradient2 = tplCtx.createRadialGradient(x3, y3, radius * blurFactor, x3, y3, radius);
    gradient2.addColorStop(0, "rgba(0,0,0,1)");
    gradient2.addColorStop(1, "rgba(0,0,0,0)");
    tplCtx.fillStyle = gradient2;
    tplCtx.fillRect(0, 0, 2 * radius, 2 * radius);
  }
  return tplCanvas;
}, (radius) => `${radius}`);
function getColorPalette(gradientConfig, createCanvas) {
  const paletteCanvas = newCanvas(createCanvas, 256, 1);
  const paletteCtx = paletteCanvas.getContext("2d");
  const gradient2 = paletteCtx.createLinearGradient(0, 0, 256, 1);
  parseGradient2(gradientConfig).forEach(([r, c5]) => {
    gradient2.addColorStop(r, c5);
  });
  paletteCtx.fillStyle = gradient2;
  paletteCtx.fillRect(0, 0, 256, 1);
  return paletteCtx.getImageData(0, 0, 256, 1).data;
}
function drawAlpha(shadowCtx, min11, max11, data2, options, createCanvas) {
  const { blur: blur3 } = options;
  let len5 = data2.length;
  while (len5--) {
    const { x: x3, y: y3, value: v, radius } = data2[len5];
    const value2 = Math.min(v, max11);
    const rectX = x3 - radius;
    const rectY = y3 - radius;
    const tpl = getPointTemplate(radius, 1 - blur3, createCanvas);
    const templateAlpha = (value2 - min11) / (max11 - min11);
    shadowCtx.globalAlpha = Math.max(templateAlpha, 1e-3);
    shadowCtx.drawImage(tpl, rectX, rectY);
  }
  return shadowCtx;
}
function colorize(shadowCtx, maxWidth, maxHeight, palette, options) {
  const { minOpacity, opacity, maxOpacity, useGradientOpacity } = options;
  const x3 = 0;
  const y3 = 0;
  const width = maxWidth;
  const height = maxHeight;
  const img = shadowCtx.getImageData(x3, y3, width, height);
  const imgData = img.data;
  const len5 = imgData.length;
  for (let i = 3; i < len5; i += 4) {
    const alpha = imgData[i];
    const offset2 = alpha * 4;
    if (!offset2) {
      continue;
    }
    const finalAlpha = opacity || Math.max(0, Math.min(maxOpacity, Math.max(minOpacity, alpha)));
    imgData[i - 3] = palette[offset2];
    imgData[i - 2] = palette[offset2 + 1];
    imgData[i - 1] = palette[offset2 + 2];
    imgData[i] = useGradientOpacity ? palette[offset2 + 3] : finalAlpha;
  }
  return img;
}
function HeatmapRenderer(width, height, min11, max11, data2, options, createCanvas) {
  const opts = Object.assign({ blur: 0.85, minOpacity: 0, opacity: 0.6, maxOpacity: 1, gradient: [
    [0.25, "rgb(0,0,255)"],
    [0.55, "rgb(0,255,0)"],
    [0.85, "yellow"],
    [1, "rgb(255,0,0)"]
  ] }, options);
  opts.minOpacity *= 255;
  opts.opacity *= 255;
  opts.maxOpacity *= 255;
  const shadowCanvas = newCanvas(createCanvas, width, height);
  const shadowCtx = shadowCanvas.getContext("2d");
  const palette = getColorPalette(opts.gradient, createCanvas);
  shadowCtx.clearRect(0, 0, width, height);
  drawAlpha(shadowCtx, min11, max11, data2, opts, createCanvas);
  const img = colorize(shadowCtx, width, height, palette, opts);
  const canvas = newCanvas(createCanvas, width, height);
  const ctx4 = canvas.getContext("2d");
  ctx4.putImageData(img, 0, 0);
  return ctx4;
}

// node_modules/@antv/g2/esm/shape/heatmap/heatmap.js
var __rest40 = function(s2, e) {
  var t = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
      t[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t[p2[i]] = s2[p2[i]];
    }
  return t;
};
function deleteKey(obj, fn) {
  return Object.keys(obj).reduce((r, k2) => {
    const v = obj[k2];
    if (!fn(v, k2))
      r[k2] = v;
    return r;
  }, {});
}
var Heatmap = (options, context) => {
  const { gradient: gradient2, opacity, maxOpacity, minOpacity, blur: blur3, useGradientOpacity } = options, style = __rest40(options, ["gradient", "opacity", "maxOpacity", "minOpacity", "blur", "useGradientOpacity"]);
  const { coordinate: coordinate2, createCanvas, document: document2 } = context;
  return (points, value2, defaults5) => {
    const { transform: transform3 } = value2;
    const [width, height] = coordinate2.getSize();
    const data2 = points.map((p2) => ({
      x: p2[0],
      y: p2[1],
      value: p2[2],
      radius: p2[3]
    }));
    const min11 = min4(points, (p2) => p2[2]);
    const max11 = max4(points, (p2) => p2[2]);
    const options2 = {
      gradient: gradient2,
      opacity,
      minOpacity,
      maxOpacity,
      blur: blur3,
      useGradientOpacity
    };
    const ctx4 = width && height ? HeatmapRenderer(width, height, min11, max11, data2, deleteKey(options2, (v) => v === void 0), createCanvas) : { canvas: null };
    return select(document2.createElement("image", {})).call(applyStyle, defaults5).style("x", 0).style("y", 0).style("width", width).style("height", height).style("src", ctx4.canvas).style("transform", transform3).call(applyStyle, style).node();
  };
};
Heatmap.props = {
  defaultMarker: "point",
  defaultEnterAnimation: "fadeIn",
  defaultUpdateAnimation: "morphing",
  defaultExitAnimation: "fadeOut"
};

// node_modules/@antv/g2/esm/shape/shape/shape.js
var __rest41 = function(s2, e) {
  var t = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
      t[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t[p2[i]] = s2[p2[i]];
    }
  return t;
};
var Shape2 = (options, context) => {
  const { render: render3 } = options, rest2 = __rest41(options, ["render"]);
  return (points) => {
    const [[x05, y05]] = points;
    return render3(Object.assign(Object.assign({}, rest2), { x: x05, y: y05 }), context);
  };
};
Shape2.props = {
  defaultMarker: "point",
  defaultEnterAnimation: "fadeIn",
  defaultUpdateAnimation: "morphing",
  defaultExitAnimation: "fadeOut"
};

// node_modules/@antv/g2/esm/shape/liquid/wave.js
var DURATION = 5e3;
function lerp5(min11, max11, factor) {
  return min11 + (max11 - min11) * factor;
}
function getWaterWavePositions(x3, stage, waveLength, amplitude) {
  if (stage === 0) {
    return [
      [x3 + 1 / 2 * waveLength / Math.PI / 2, amplitude / 2],
      [x3 + 1 / 2 * waveLength / Math.PI, amplitude],
      [x3 + waveLength / 4, amplitude]
    ];
  }
  if (stage === 1) {
    return [
      [x3 + 1 / 2 * waveLength / Math.PI / 2 * (Math.PI - 2), amplitude],
      [
        x3 + 1 / 2 * waveLength / Math.PI / 2 * (Math.PI - 1),
        amplitude / 2
      ],
      [x3 + waveLength / 4, 0]
    ];
  }
  if (stage === 2) {
    return [
      [x3 + 1 / 2 * waveLength / Math.PI / 2, -amplitude / 2],
      [x3 + 1 / 2 * waveLength / Math.PI, -amplitude],
      [x3 + waveLength / 4, -amplitude]
    ];
  }
  return [
    [x3 + 1 / 2 * waveLength / Math.PI / 2 * (Math.PI - 2), -amplitude],
    [
      x3 + 1 / 2 * waveLength / Math.PI / 2 * (Math.PI - 1),
      -amplitude / 2
    ],
    [x3 + waveLength / 4, 0]
  ];
}
function getWaterWavePath(radius, waterLevel, waveLength, phase, amplitude, cx, cy) {
  const curves = Math.ceil(2 * radius / waveLength * 4) * 4;
  const path2 = [];
  let _phase = phase;
  while (_phase < -Math.PI * 2) {
    _phase += Math.PI * 2;
  }
  while (_phase > 0) {
    _phase -= Math.PI * 2;
  }
  _phase = _phase / Math.PI / 2 * waveLength;
  const left2 = cx - radius + _phase - radius * 2;
  path2.push(["M", left2, waterLevel]);
  let waveRight = 0;
  for (let c5 = 0; c5 < curves; ++c5) {
    const stage = c5 % 4;
    const pos = getWaterWavePositions(c5 * waveLength / 4, stage, waveLength, amplitude);
    path2.push([
      "C",
      pos[0][0] + left2,
      -pos[0][1] + waterLevel,
      pos[1][0] + left2,
      -pos[1][1] + waterLevel,
      pos[2][0] + left2,
      -pos[2][1] + waterLevel
    ]);
    if (c5 === curves - 1) {
      waveRight = pos[2][0];
    }
  }
  path2.push(["L", waveRight + left2, cy + radius]);
  path2.push(["L", left2, cy + radius]);
  path2.push(["Z"]);
  return path2;
}
function addWave(x3, y3, level, waveCount, waveAttrs, group3, minY, radius, waveLength, animation, document2) {
  const { fill: fill2, fillOpacity, opacity } = waveAttrs;
  for (let idx = 0; idx < waveCount; idx++) {
    const factor = waveCount <= 1 ? 1 : idx / (waveCount - 1);
    const path2 = getWaterWavePath(
      radius,
      minY + radius * level,
      waveLength,
      0,
      // Amplitude height.
      radius / 40,
      x3,
      y3
    );
    const wave = document2.createElement("path", {
      style: {
        path: path2,
        fill: fill2,
        opacity: lerp5(0.2, 0.9, factor) * Number(opacity || fillOpacity)
      }
    });
    group3.appendChild(wave);
    try {
      if (animation === false)
        return;
      const keyframes = [
        {
          transform: "translate(0, 0)"
        },
        {
          transform: `translate(${waveLength * 2}px, 0)`
        }
      ];
      wave.animate(keyframes, {
        duration: lerp5(0.5 * DURATION, DURATION, factor) * 2,
        iterations: Infinity
      });
    } catch (e) {
      console.warn("off-screen group animate error!");
    }
  }
}

// node_modules/@antv/g2/esm/shape/liquid/shapes.js
function circle2(x3, y3, r) {
  return `
      M ${x3} ${y3 - r} 
      a ${r} ${r} 0 1 0 0 ${r * 2}
      a ${r} ${r} 0 1 0 0 ${-r * 2}
      Z
    `;
}
function rect3(x3, y3, r) {
  const GOLDEN_SECTION_RATIO = 0.618;
  const w = r * GOLDEN_SECTION_RATIO;
  return `
      M ${x3 - w} ${y3 - r}
      L ${x3 + w} ${y3 - r}
      L ${x3 + w} ${y3 + r}
      L ${x3 - w} ${y3 + r}
      Z
    `;
}
function diamond3(x3, y3, r) {
  return `
      M ${x3} ${y3 - r}
      L ${x3 + r} ${y3}
      L ${x3} ${y3 + r}
      L ${x3 - r} ${y3}
      Z
    `;
}
function triangle3(x3, y3, r) {
  return `
      M ${x3} ${y3 - r}
      L ${x3 + r} ${y3 + r}
      L ${x3 - r} ${y3 + r}
      Z
    `;
}
function pin(x3, y3, radius) {
  const w = radius * 4 / 3;
  const h = Math.max(w, radius * 2);
  const r = w / 2;
  const cx = x3;
  const cy = r + y3 - h / 2;
  const theta = Math.asin(r / ((h - r) * 0.85));
  const dy = Math.sin(theta) * r;
  const dx = Math.cos(theta) * r;
  const x05 = cx - dx;
  const y05 = cy + dy;
  const cpX = x3;
  const cpY = cy + r / Math.sin(theta);
  return `
      M ${x05} ${y05}
      A ${r} ${r} 0 1 1 ${x05 + dx * 2} ${y05}
      Q ${cpX} ${cpY} ${x3} ${y3 + h / 2}
      Q ${cpX} ${cpY} ${x05} ${y05}
      Z 
    `;
}
var LiquidShapesPath = {
  pin,
  rect: rect3,
  circle: circle2,
  diamond: diamond3,
  triangle: triangle3
};

// node_modules/@antv/g2/esm/shape/liquid/liquid.js
var __rest42 = function(s2, e) {
  var t = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
      t[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t[p2[i]] = s2[p2[i]];
    }
  return t;
};
var getLiquidShape = (shape23 = "circle") => LiquidShapesPath[shape23] || LiquidShapesPath.circle;
var Liquid = (options, context) => {
  if (!context)
    return;
  const { coordinate: coordinate2 } = context;
  const { liquidOptions, styleOptions } = options;
  const { liquidShape, percent } = liquidOptions;
  const { background: backgroundStyle, outline = {}, wave = {} } = styleOptions, attr2 = __rest42(styleOptions, ["background", "outline", "wave"]);
  const { border = 2, distance: distance7 = 0 } = outline, outlineStyle = __rest42(outline, ["border", "distance"]);
  const { length: length5 = 192, count: count4 = 3 } = wave;
  return (points, cfg, defaultAttr) => {
    const { document: document2 } = context.canvas;
    const { color: color2, fillOpacity } = defaultAttr;
    const attrs = Object.assign(Object.assign({ fill: color2 }, defaultAttr), attr2);
    const g = document2.createElement("g", {});
    const [centerX, centerY] = coordinate2.getCenter();
    const size5 = coordinate2.getSize();
    const radius = Math.min(...size5) / 2;
    const buildPath = is_function_default(liquidShape) ? liquidShape : getLiquidShape(liquidShape);
    const shapePath = buildPath(centerX, centerY, radius, ...size5);
    if (Object.keys(backgroundStyle).length) {
      const backgroundShape = document2.createElement("path", {
        style: Object.assign({ path: shapePath, fill: "#fff" }, backgroundStyle)
      });
      g.appendChild(backgroundShape);
    }
    if (percent > 0) {
      const clipShape = document2.createElement("path", {
        style: {
          path: shapePath
        }
      });
      g.appendChild(clipShape);
      g.style.clipPath = clipShape;
      addWave(centerX, centerY, 1 - percent, count4, attrs, g, clipShape.getBBox().y, radius * 2, length5, true, document2);
    }
    const distanceShape = document2.createElement("path", {
      style: {
        path: shapePath,
        fill: "transparent",
        lineWidth: border + 2 * distance7,
        stroke: "#fff"
      }
    });
    const borderShape = document2.createElement("path", {
      style: Object.assign(Object.assign(Object.assign({ path: shapePath, stroke: color2, strokeOpacity: fillOpacity, lineWidth: border }, attrs), outlineStyle), { fill: "transparent" })
    });
    g.appendChild(distanceShape);
    g.appendChild(borderShape);
    return g;
  };
};
Liquid.props = {};

// node_modules/@antv/g2/esm/mark/interval.js
function bandWidth2(scale10, x3) {
  return scale10.getBandWidth(scale10.invert(x3));
}
var shape = {
  rect: Rect2,
  hollow: Hollow,
  funnel: Funnel,
  pyramid: Pyramid
};
var Interval = () => {
  return (index3, scale10, value2, coordinate2) => {
    const { x: X, y: Y, y1: Y12, series: S, size: SZ } = value2;
    const x3 = scale10.x;
    const series = scale10.series;
    const [width] = coordinate2.getSize();
    const NSZ = SZ ? SZ.map((d2) => +d2 / width) : null;
    const x1x2 = !SZ ? (x4, w, i) => [x4, x4 + w] : (x4, w, i) => {
      const mx = x4 + w / 2;
      const s2 = NSZ[i];
      return [mx - s2 / 2, mx + s2 / 2];
    };
    const P = Array.from(index3, (i) => {
      const groupWidth = bandWidth2(x3, X[i]);
      const ratio = series ? bandWidth2(series, S === null || S === void 0 ? void 0 : S[i]) : 1;
      const width2 = groupWidth * ratio;
      const offset2 = (+(S === null || S === void 0 ? void 0 : S[i]) || 0) * groupWidth;
      const x05 = +X[i] + offset2;
      const [x12, x22] = x1x2(x05, width2, i);
      const y12 = +Y[i];
      const y22 = +Y12[i];
      const p1 = [x12, y12];
      const p2 = [x22, y12];
      const p3 = [x22, y22];
      const p4 = [x12, y22];
      return [p1, p2, p3, p4].map((d2) => coordinate2.map(d2));
    });
    return [index3, P];
  };
};
Interval.props = {
  defaultShape: "rect",
  defaultLabelShape: "label",
  composite: false,
  shape,
  channels: [
    ...baseGeometryChannels({ shapes: Object.keys(shape) }),
    { name: "x", scale: "band", required: true },
    { name: "y", required: true },
    { name: "series", scale: "band" },
    { name: "size" }
  ],
  preInference: [
    ...basePreInference(),
    { type: MaybeZeroY1 },
    { type: MaybeZeroX }
  ],
  postInference: [...basePostInference(), ...tooltip1d()],
  interaction: { shareTooltip: true }
};

// node_modules/@antv/g2/esm/mark/rect.js
var shape2 = {
  rect: Rect2,
  hollow: Hollow
};
var Rect3 = () => {
  return (index3, scale10, value2, coordinate2) => {
    const { x: X, x1: X12, y: Y, y1: Y12 } = value2;
    const P = Array.from(index3, (i) => {
      const p1 = [+X[i], +Y[i]];
      const p2 = [+X12[i], +Y[i]];
      const p3 = [+X12[i], +Y12[i]];
      const p4 = [+X[i], +Y12[i]];
      return [p1, p2, p3, p4].map((d2) => coordinate2.map(d2));
    });
    return [index3, P];
  };
};
Rect3.props = {
  defaultShape: "rect",
  defaultLabelShape: "label",
  composite: false,
  shape: shape2,
  channels: [
    ...baseGeometryChannels({ shapes: Object.keys(shape2) }),
    { name: "x", required: true },
    { name: "y", required: true }
  ],
  preInference: [...basePreInference(), { type: MaybeZeroY1 }],
  postInference: [...basePostInference(), ...tooltip1d()],
  interaction: {
    shareTooltip: true
  }
};

// node_modules/@antv/g2/esm/mark/line.js
var shape3 = {
  line: Line2,
  smooth: Smooth,
  hv: HV,
  vh: VH,
  hvh: HVH,
  trail: Trail
};
var line3 = (index3, scale10, value2, coordinate2) => {
  var _a2, _b;
  const { series: S, x: X, y: Y } = value2;
  const { x: x3, y: y3 } = scale10;
  if (X === void 0 || Y === void 0) {
    throw new Error("Missing encode for x or y channel.");
  }
  const series = S ? Array.from(group(index3, (i) => S[i]).values()) : [index3];
  const I = series.map((group3) => group3[0]).filter((i) => i !== void 0);
  const xoffset = (((_a2 = x3 === null || x3 === void 0 ? void 0 : x3.getBandWidth) === null || _a2 === void 0 ? void 0 : _a2.call(x3)) || 0) / 2;
  const yoffset = (((_b = y3 === null || y3 === void 0 ? void 0 : y3.getBandWidth) === null || _b === void 0 ? void 0 : _b.call(y3)) || 0) / 2;
  const P = Array.from(series, (I2) => {
    return I2.map((i) => coordinate2.map([+X[i] + xoffset, +Y[i] + yoffset]));
  });
  return [I, P, series];
};
var parallel = (index3, scale10, value2, coordinate2) => {
  const PV = Object.entries(value2).filter(([key]) => key.startsWith("position")).map(([, value3]) => value3);
  if (PV.length === 0) {
    throw new Error("Missing encode for position channel.");
  }
  const P = Array.from(index3, (i) => {
    const vector = PV.map((pv) => +pv[i]);
    const vectors = coordinate2.map(vector);
    const points = [];
    for (let i2 = 0; i2 < vectors.length; i2 += 2) {
      points.push([vectors[i2], vectors[i2 + 1]]);
    }
    return points;
  });
  return [index3, P];
};
var Line5 = () => {
  return (index3, scale10, value2, coordinate2) => {
    const mark2 = isParallel(coordinate2) ? parallel : line3;
    return mark2(index3, scale10, value2, coordinate2);
  };
};
Line5.props = {
  defaultShape: "line",
  defaultLabelShape: "label",
  composite: false,
  shape: shape3,
  channels: [
    ...baseGeometryChannels({ shapes: Object.keys(shape3) }),
    { name: "x" },
    { name: "y" },
    { name: "position", independent: true },
    { name: "size" },
    { name: "series", scale: "band" }
  ],
  preInference: [
    ...basePreInference(),
    // !!!Note This order is very important.
    { type: MaybeGradient },
    { type: MaybeSeries }
  ],
  postInference: [...basePostInference(), ...tooltip1d(), ...tooltipXd()],
  interaction: {
    shareTooltip: true,
    seriesTooltip: true,
    crosshairs: true
  }
};

// node_modules/@antv/g2/esm/mark/point.js
var shape4 = {
  hollow: HollowPoint,
  hollowDiamond: HollowDiamond,
  hollowHexagon: HollowHexagon,
  hollowSquare: HollowSquare,
  hollowTriangleDown: HollowTriangleDown,
  hollowTriangle: HollowTriangle,
  hollowBowtie: HollowBowtie,
  point: Point3,
  plus: Plus,
  diamond: Diamond,
  square: Square,
  triangle: Triangle,
  hexagon: Hexagon,
  cross: Cross,
  bowtie: Bowtie,
  hyphen: Hyphen,
  line: Line3,
  tick: Tick,
  triangleDown: TriangleDown
};
var Point4 = (options) => {
  return (index3, scale10, value2, coordinate2) => {
    const { x: X, y: Y, x1: X12, y1: Y12, size: S, dx: DX, dy: DY } = value2;
    const [width, height] = coordinate2.getSize();
    const offset2 = createBandOffset(scale10, value2, options);
    const xy = (i) => {
      const dx = +((DX === null || DX === void 0 ? void 0 : DX[i]) || 0);
      const dy = +((DY === null || DY === void 0 ? void 0 : DY[i]) || 0);
      const x3 = X12 ? (+X[i] + +X12[i]) / 2 : +X[i];
      const y3 = Y12 ? (+Y[i] + +Y12[i]) / 2 : +Y[i];
      const cx = x3 + dx;
      const cy = y3 + dy;
      return [cx, cy];
    };
    const P = S ? Array.from(index3, (i) => {
      const [cx, cy] = xy(i);
      const r = +S[i];
      const a4 = r / width;
      const b = r / height;
      const p1 = [cx - a4, cy - b];
      const p2 = [cx + a4, cy + b];
      return [
        coordinate2.map(offset2(p1, i)),
        coordinate2.map(offset2(p2, i))
      ];
    }) : Array.from(index3, (i) => [coordinate2.map(offset2(xy(i), i))]);
    return [index3, P];
  };
};
Point4.props = {
  defaultShape: "hollow",
  defaultLabelShape: "label",
  composite: false,
  shape: shape4,
  channels: [
    ...baseGeometryChannels({ shapes: Object.keys(shape4) }),
    { name: "x", required: true },
    { name: "y", required: true },
    { name: "series", scale: "band" },
    { name: "size", quantitative: "sqrt" },
    { name: "dx", scale: "identity" },
    { name: "dy", scale: "identity" }
  ],
  preInference: [
    ...basePreInference(),
    { type: MaybeZeroX },
    { type: MaybeZeroY }
  ],
  postInference: [...basePostInference(), { type: MaybeSize }, ...tooltip2d()]
};

// node_modules/@antv/g2/esm/mark/text.js
var shape5 = {
  text: Text3,
  badge: Badge
};
var Text4 = (options) => {
  const { cartesian: cartesian3 = false } = options;
  if (cartesian3)
    return visualMark;
  return (index3, scale10, value2, coordinate2) => {
    const { x: X, y: Y } = value2;
    const offset2 = createBandOffset(scale10, value2, options);
    const P = Array.from(index3, (i) => {
      const p2 = [+X[i], +Y[i]];
      return [coordinate2.map(offset2(p2, i))];
    });
    return [index3, P];
  };
};
Text4.props = {
  defaultShape: "text",
  defaultLabelShape: "label",
  composite: false,
  shape: shape5,
  channels: [
    ...baseGeometryChannels({ shapes: Object.keys(shape5) }),
    { name: "x", required: true },
    { name: "y", required: true },
    { name: "text", scale: "identity" },
    { name: "fontSize" },
    { name: "rotate" }
  ],
  preInference: [
    ...basePreInference(),
    { type: MaybeTuple },
    { type: MaybeVisualPosition }
  ],
  postInference: [...basePostInference(), ...tooltip2d()]
};

// node_modules/@antv/g2/esm/mark/cell.js
var shape6 = {
  cell: Rect2,
  hollow: Hollow
};
var Cell = () => {
  return (index3, scale10, value2, coordinate2) => {
    const { x: X, y: Y } = value2;
    const x3 = scale10.x;
    const y3 = scale10.y;
    const P = Array.from(index3, (i) => {
      const width = x3.getBandWidth(x3.invert(+X[i]));
      const height = y3.getBandWidth(y3.invert(+Y[i]));
      const x12 = +X[i];
      const y12 = +Y[i];
      const p1 = [x12, y12];
      const p2 = [x12 + width, y12];
      const p3 = [x12 + width, y12 + height];
      const p4 = [x12, y12 + height];
      return [p1, p2, p3, p4].map((d2) => coordinate2.map(d2));
    });
    return [index3, P];
  };
};
Cell.props = {
  defaultShape: "cell",
  defaultLabelShape: "label",
  shape: shape6,
  composite: false,
  channels: [
    ...baseGeometryChannels({ shapes: Object.keys(shape6) }),
    { name: "x", required: true, scale: "band" },
    { name: "y", required: true, scale: "band" }
  ],
  preInference: [
    ...basePreInference(),
    { type: MaybeZeroX },
    { type: MaybeZeroY },
    { type: MaybeZeroPadding }
  ],
  postInference: [...basePostInference(), ...tooltip2d()]
};

// node_modules/@antv/g2/esm/mark/area.js
var shape7 = {
  area: Area,
  smooth: Smooth2,
  hvh: HVH2,
  vh: VH2,
  hv: HV2
};
var Area2 = () => {
  return (index3, scale10, value2, coordinate2) => {
    var _a2, _b;
    const { x: X, y: Y, y1: Y12, series: S } = value2;
    const { x: x3, y: y3 } = scale10;
    const series = S ? Array.from(group(index3, (i) => S[i]).values()) : [index3];
    const I = series.map((group3) => group3[0]).filter((i) => i !== void 0);
    const xoffset = (((_a2 = x3 === null || x3 === void 0 ? void 0 : x3.getBandWidth) === null || _a2 === void 0 ? void 0 : _a2.call(x3)) || 0) / 2;
    const yoffset = (((_b = y3 === null || y3 === void 0 ? void 0 : y3.getBandWidth) === null || _b === void 0 ? void 0 : _b.call(y3)) || 0) / 2;
    const P = Array.from(series, (SI) => {
      const l = SI.length;
      const points = new Array(l * 2);
      for (let idx = 0; idx < SI.length; idx++) {
        const i = SI[idx];
        points[idx] = coordinate2.map([+X[i] + xoffset, +Y[i] + yoffset]);
        points[l + idx] = coordinate2.map([+X[i] + xoffset, +Y12[i] + yoffset]);
      }
      return points;
    });
    return [I, P, series];
  };
};
Area2.props = {
  defaultShape: "area",
  defaultLabelShape: "label",
  composite: false,
  shape: shape7,
  channels: [
    ...baseGeometryChannels({ shapes: Object.keys(shape7) }),
    { name: "x", required: true },
    { name: "y", required: true },
    { name: "size" },
    { name: "series", scale: "band" }
  ],
  preInference: [
    ...basePreInference(),
    { type: MaybeSeries },
    { type: MaybeZeroY1 },
    { type: MaybeZeroPadding }
  ],
  postInference: [...basePostInference(), ...tooltip1d()],
  interaction: {
    shareTooltip: true,
    seriesTooltip: true,
    crosshairs: true
  }
};

// node_modules/@antv/g2/esm/mark/link.js
var shape8 = {
  link: Link,
  arc: Arc,
  smooth: Smooth3,
  vhv: VHV
};
var Link2 = (options) => {
  return (index3, scale10, value2, coordinate2) => {
    const { x: X, y: Y, x1: X12 = X, y1: Y12 = Y } = value2;
    const offset2 = createBandOffset(scale10, value2, options);
    const P = index3.map((i) => [
      coordinate2.map(offset2([+X[i], +Y[i]], i)),
      coordinate2.map(offset2([+X12[i], +Y12[i]], i))
    ]);
    return [index3, P];
  };
};
Link2.props = {
  defaultShape: "link",
  defaultLabelShape: "label",
  composite: false,
  shape: shape8,
  channels: [
    ...baseGeometryChannels({ shapes: Object.keys(shape8) }),
    { name: "x", required: true },
    { name: "y", required: true }
  ],
  preInference: [
    ...basePreInference(),
    { type: MaybeIdentityY },
    { type: MaybeIdentityX }
  ],
  postInference: [...basePostInference(), ...tooltip2d()]
};

// node_modules/@antv/g2/esm/mark/image.js
var shape9 = {
  image: Image3
};
var Image4 = (options) => {
  const { cartesian: cartesian3 } = options;
  if (cartesian3)
    return visualMark;
  return (index3, scale10, value2, coordinate2) => {
    const { x: X, y: Y } = value2;
    const offset2 = createBandOffset(scale10, value2, options);
    const P = Array.from(index3, (i) => {
      const p2 = [+X[i], +Y[i]];
      return [coordinate2.map(offset2(p2, i))];
    });
    return [index3, P];
  };
};
Image4.props = {
  defaultShape: "image",
  defaultLabelShape: "label",
  composite: false,
  shape: shape9,
  channels: [
    ...baseGeometryChannels({ shapes: Object.keys(shape9) }),
    { name: "x", required: true },
    { name: "y", required: true },
    { name: "src", scale: "identity" },
    { name: "size" }
  ],
  preInference: [
    ...basePreInference(),
    { type: MaybeTuple },
    { type: MaybeVisualPosition }
  ],
  postInference: [...basePostInference(), ...tooltip2d()]
};

// node_modules/@antv/g2/esm/mark/polygon.js
var shape10 = {
  polygon: Polygon2,
  ribbon: Ribbon2
};
var Polygon3 = () => {
  return (index3, scale10, value2, coordinate2) => {
    const Xn2 = Object.entries(value2).filter(([key]) => key.startsWith("x")).map(([, value3]) => value3);
    const Yn2 = Object.entries(value2).filter(([key]) => key.startsWith("y")).map(([, value3]) => value3);
    const P = index3.map((i) => {
      const Pn = [];
      for (let j = 0; j < Xn2.length; j++) {
        const x3 = Xn2[j][i];
        if (x3 === void 0)
          break;
        const y3 = Yn2[j][i];
        Pn.push(coordinate2.map([+x3, +y3]));
      }
      return Pn;
    });
    return [index3, P];
  };
};
Polygon3.props = {
  defaultShape: "polygon",
  defaultLabelShape: "label",
  composite: false,
  shape: shape10,
  channels: [
    ...baseGeometryChannels({ shapes: Object.keys(shape10) }),
    { name: "x", required: true },
    { name: "y", required: true }
  ],
  preInference: [...basePreInference()],
  postInference: [...basePostInference(), ...tooltip2d()]
};

// node_modules/@antv/g2/esm/mark/box.js
var shape11 = {
  box: Box,
  violin: Violin
};
var Box2 = () => {
  return (index3, scale10, value2, coordinate2) => {
    const { x: X, y: Y, y1: Y12, y2: Y22, y3: Y3, y4: Y4, series: S } = value2;
    const xScale = scale10.x;
    const series = scale10.series;
    const P = Array.from(index3, (i) => {
      const groupWidth = xScale.getBandWidth(xScale.invert(+X[i]));
      const ratio = series ? series.getBandWidth(series.invert(+(S === null || S === void 0 ? void 0 : S[i]))) : 1;
      const width = groupWidth * ratio;
      const offset2 = (+(S === null || S === void 0 ? void 0 : S[i]) || 0) * groupWidth;
      const x3 = +X[i] + offset2 + width / 2;
      const [low, q12, median3, q32, high] = [
        +Y[i],
        +Y12[i],
        +Y22[i],
        +Y3[i],
        +Y4[i]
      ];
      const P13 = [
        [x3 - width / 2, high],
        [x3 + width / 2, high],
        [x3, high],
        [x3, q32],
        [x3 - width / 2, q32],
        [x3 + width / 2, q32],
        [x3 + width / 2, q12],
        [x3 - width / 2, q12],
        [x3 - width / 2, median3],
        [x3 + width / 2, median3],
        [x3, q12],
        [x3, low],
        [x3 - width / 2, low],
        [x3 + width / 2, low]
      ];
      return P13.map((d2) => coordinate2.map(d2));
    });
    return [index3, P];
  };
};
Box2.props = {
  defaultShape: "box",
  defaultLabelShape: "label",
  composite: false,
  shape: shape11,
  channels: [
    ...baseGeometryChannels({ shapes: Object.keys(shape11) }),
    { name: "x", scale: "band", required: true },
    { name: "y", required: true },
    { name: "series", scale: "band" }
  ],
  preInference: [...basePreInference(), { type: MaybeZeroX }],
  postInference: [...basePostInference(), ...tooltip1d()],
  interaction: {
    shareTooltip: true
  }
};

// node_modules/@antv/g2/esm/mark/vector.js
var shape12 = {
  vector: Vector
};
var Vector2 = () => {
  return (index3, scale10, value2, coordinate2) => {
    const { x: X, y: Y, size: S, rotate: R } = value2;
    const [width, height] = coordinate2.getSize();
    const P = index3.map((i) => {
      const angle4 = +R[i] / 180 * Math.PI;
      const s2 = +S[i];
      const a4 = s2 / width;
      const b = s2 / height;
      const vx = a4 * Math.cos(angle4);
      const vy = -b * Math.sin(angle4);
      return [
        coordinate2.map([+X[i] - vx / 2, +Y[i] - vy / 2]),
        coordinate2.map([+X[i] + vx / 2, +Y[i] + vy / 2])
      ];
    });
    return [index3, P];
  };
};
Vector2.props = {
  defaultShape: "vector",
  defaultLabelShape: "label",
  composite: false,
  shape: shape12,
  channels: [
    ...baseGeometryChannels({ shapes: Object.keys(shape12) }),
    { name: "x", required: true },
    { name: "y", required: true },
    { name: "rotate", required: true, scale: "identity" },
    { name: "size", required: true }
  ],
  preInference: [...basePreInference()],
  postInference: [...basePostInference(), ...tooltip2d()]
};

// node_modules/@antv/g2/esm/mark/lineY.js
var shape13 = {
  line: Line4
};
var LineY = (options) => {
  return (index3, scale10, value2, coordinate2) => {
    const { y: Y } = value2;
    const offset2 = createBandOffset(scale10, value2, deep_mix_default({ style: { bandOffset: 0 } }, options));
    const P = Array.from(index3, (i) => {
      const p1 = [0, Y[i]];
      const p2 = [1, Y[i]];
      return [p1, p2].map((d2) => coordinate2.map(offset2(d2, i)));
    });
    return [index3, P];
  };
};
LineY.props = {
  defaultShape: "line",
  defaultLabelShape: "label",
  composite: false,
  shape: shape13,
  channels: [
    ...baseAnnotationChannels({ shapes: Object.keys(shape13) }),
    { name: "y", required: true }
  ],
  preInference: [...basePreInference(), { type: MaybeTupleY }],
  postInference: [...basePostInference()]
};

// node_modules/@antv/g2/esm/mark/lineX.js
var shape14 = {
  line: Line4
};
var LineX = (options) => {
  return (index3, scale10, value2, coordinate2) => {
    const { x: X } = value2;
    const offset2 = createBandOffset(scale10, value2, deep_mix_default({ style: { bandOffset: 0 } }, options));
    const P = Array.from(index3, (i) => {
      const p1 = [X[i], 1];
      const p2 = [X[i], 0];
      return [p1, p2].map((d2) => coordinate2.map(offset2(d2, i)));
    });
    return [index3, P];
  };
};
LineX.props = {
  defaultShape: "line",
  defaultLabelShape: "label",
  composite: false,
  shape: shape14,
  channels: [
    ...baseAnnotationChannels({ shapes: Object.keys(shape14) }),
    { name: "x", required: true }
  ],
  preInference: [...basePreInference(), { type: MaybeTupleX }],
  postInference: [...basePostInference()]
};

// node_modules/@antv/g2/esm/mark/connector.js
var shape15 = {
  connector: Connector
};
var Connector2 = (...args) => {
  return Link2(...args);
};
Connector2.props = {
  defaultShape: "connector",
  defaultLabelShape: "label",
  composite: false,
  shape: shape15,
  channels: [
    ...baseAnnotationChannels({ shapes: Object.keys(shape15) }),
    { name: "x", required: true },
    { name: "y", required: true }
  ],
  preInference: [...basePreInference()],
  postInference: [...basePostInference()]
};

// node_modules/@antv/g2/esm/mark/range.js
function extend2(channel, extended, value2, scale10) {
  if (extended)
    return () => [0, 1];
  const { [channel]: C3, [`${channel}1`]: C1 } = value2;
  return (i) => {
    var _a2;
    const offset2 = ((_a2 = scale10.getBandWidth) === null || _a2 === void 0 ? void 0 : _a2.call(scale10, scale10.invert(+C1[i]))) || 0;
    return [C3[i], C1[i] + offset2];
  };
}
function AbstractRange(options = {}) {
  const { extendX = false, extendY = false } = options;
  return (index3, scale10, value2, coordinate2) => {
    const x3 = extend2("x", extendX, value2, scale10.x);
    const y3 = extend2("y", extendY, value2, scale10.y);
    const P = Array.from(index3, (i) => {
      const [x12, x22] = x3(i);
      const [y12, y22] = y3(i);
      const p1 = [x12, y12];
      const p2 = [x22, y12];
      const p3 = [x22, y22];
      const p4 = [x12, y22];
      return [p1, p2, p3, p4].map((d2) => coordinate2.map(d2));
    });
    return [index3, P];
  };
}
var shape16 = { range: Rect2 };
var Range2 = () => {
  return AbstractRange();
};
Range2.props = {
  defaultShape: "range",
  defaultLabelShape: "label",
  composite: false,
  shape: shape16,
  channels: [
    ...baseAnnotationChannels({ shapes: Object.keys(shape16) }),
    { name: "x", required: true },
    { name: "y", required: true }
  ],
  preInference: [...basePreInference()],
  postInference: [...basePostInference()]
};

// node_modules/@antv/g2/esm/mark/rangeX.js
var shape17 = {
  range: Rect2
};
var RangeX = () => {
  return AbstractRange({ extendY: true });
};
RangeX.props = {
  defaultShape: "range",
  defaultLabelShape: "label",
  composite: false,
  shape: shape17,
  channels: [
    ...baseAnnotationChannels({ shapes: Object.keys(shape17) }),
    { name: "x", required: true }
  ],
  preInference: [...basePreInference(), { type: MaybeDefaultX }],
  postInference: [...basePostInference()]
};

// node_modules/@antv/g2/esm/mark/rangeY.js
var shape18 = {
  range: Rect2
};
var RangeY = () => {
  return AbstractRange({ extendX: true });
};
RangeY.props = {
  defaultShape: "range",
  defaultLabelShape: "label",
  composite: false,
  shape: shape18,
  channels: [
    ...baseAnnotationChannels({ shapes: Object.keys(shape18) }),
    { name: "y", required: true }
  ],
  preInference: [...basePreInference(), { type: MaybeDefaultY }],
  postInference: [...basePostInference()]
};

// node_modules/@antv/g2/esm/data/utils/d3-sankey/align.js
function targetDepth(d2) {
  return d2.target.depth;
}
function left(node) {
  return node.depth;
}
function right(node, n) {
  return n - 1 - node.height;
}
function justify(node, n) {
  return node.sourceLinks.length ? node.depth : n - 1;
}
function center(node) {
  return node.targetLinks.length ? node.depth : node.sourceLinks.length ? min4(node.sourceLinks, targetDepth) - 1 : 0;
}

// node_modules/@antv/g2/esm/data/utils/d3-sankey/constant.js
function constant3(x3) {
  return function() {
    return x3;
  };
}

// node_modules/@antv/g2/esm/data/utils/d3-sankey/sankey.js
function ascendingSourceBreadth(a4, b) {
  return ascendingBreadth(a4.source, b.source) || a4.index - b.index;
}
function ascendingTargetBreadth(a4, b) {
  return ascendingBreadth(a4.target, b.target) || a4.index - b.index;
}
function ascendingBreadth(a4, b) {
  return a4.y0 - b.y0;
}
function value(d2) {
  return d2.value;
}
function defaultId2(d2) {
  return d2.index;
}
function defaultNodes(graph) {
  return graph.nodes;
}
function defaultLinks(graph) {
  return graph.links;
}
function find2(nodeById, id3) {
  const node = nodeById.get(id3);
  if (!node)
    throw new Error("missing: " + id3);
  return node;
}
function computeLinkBreadths({ nodes }) {
  for (const node of nodes) {
    let y05 = node.y0;
    let y12 = y05;
    for (const link3 of node.sourceLinks) {
      link3.y0 = y05 + link3.width / 2;
      y05 += link3.width;
    }
    for (const link3 of node.targetLinks) {
      link3.y1 = y12 + link3.width / 2;
      y12 += link3.width;
    }
  }
}
function Sankey() {
  let x05 = 0, y05 = 0, x12 = 1, y12 = 1;
  let dx = 24;
  let dy = 8, py;
  let id3 = defaultId2;
  let align = justify;
  let depth;
  let sort2;
  let linkSort;
  let nodes = defaultNodes;
  let links = defaultLinks;
  let iterations2 = 6;
  function sankey(arg) {
    const graph = {
      nodes: nodes(arg),
      links: links(arg)
    };
    computeNodeLinks(graph);
    computeNodeValues(graph);
    computeNodeDepths(graph);
    computeNodeHeights(graph);
    computeNodeBreadths(graph);
    computeLinkBreadths(graph);
    return graph;
  }
  sankey.update = function(graph) {
    computeLinkBreadths(graph);
    return graph;
  };
  sankey.nodeId = function(_2) {
    return arguments.length ? (id3 = typeof _2 === "function" ? _2 : constant3(_2), sankey) : id3;
  };
  sankey.nodeAlign = function(_2) {
    return arguments.length ? (align = typeof _2 === "function" ? _2 : constant3(_2), sankey) : align;
  };
  sankey.nodeDepth = function(_2) {
    return arguments.length ? (depth = typeof _2 === "function" ? _2 : _2, sankey) : depth;
  };
  sankey.nodeSort = function(_2) {
    return arguments.length ? (sort2 = _2, sankey) : sort2;
  };
  sankey.nodeWidth = function(_2) {
    return arguments.length ? (dx = +_2, sankey) : dx;
  };
  sankey.nodePadding = function(_2) {
    return arguments.length ? (dy = py = +_2, sankey) : dy;
  };
  sankey.nodes = function(_2) {
    return arguments.length ? (nodes = typeof _2 === "function" ? _2 : constant3(_2), sankey) : nodes;
  };
  sankey.links = function(_2) {
    return arguments.length ? (links = typeof _2 === "function" ? _2 : constant3(_2), sankey) : links;
  };
  sankey.linkSort = function(_2) {
    return arguments.length ? (linkSort = _2, sankey) : linkSort;
  };
  sankey.size = function(_2) {
    return arguments.length ? (x05 = y05 = 0, x12 = +_2[0], y12 = +_2[1], sankey) : [x12 - x05, y12 - y05];
  };
  sankey.extent = function(_2) {
    return arguments.length ? (x05 = +_2[0][0], x12 = +_2[1][0], y05 = +_2[0][1], y12 = +_2[1][1], sankey) : [
      [x05, y05],
      [x12, y12]
    ];
  };
  sankey.iterations = function(_2) {
    return arguments.length ? (iterations2 = +_2, sankey) : iterations2;
  };
  function computeNodeLinks({ nodes: nodes2, links: links2 }) {
    nodes2.forEach((node, idx) => {
      node.index = idx;
      node.sourceLinks = [];
      node.targetLinks = [];
    });
    const nodeById = new Map(nodes2.map((d2) => [id3(d2), d2]));
    links2.forEach((link3, idx) => {
      link3.index = idx;
      let { source, target } = link3;
      if (typeof source !== "object")
        source = link3.source = find2(nodeById, source);
      if (typeof target !== "object")
        target = link3.target = find2(nodeById, target);
      source.sourceLinks.push(link3);
      target.targetLinks.push(link3);
    });
    if (linkSort != null) {
      for (const { sourceLinks, targetLinks } of nodes2) {
        sourceLinks.sort(linkSort);
        targetLinks.sort(linkSort);
      }
    }
  }
  function computeNodeValues({ nodes: nodes2 }) {
    for (const node of nodes2) {
      node.value = node.fixedValue === void 0 ? Math.max(sum(node.sourceLinks, value), sum(node.targetLinks, value)) : node.fixedValue;
    }
  }
  function computeNodeDepths({ nodes: nodes2 }) {
    const n = nodes2.length;
    let current = new Set(nodes2);
    let next = /* @__PURE__ */ new Set();
    let x3 = 0;
    while (current.size) {
      current.forEach((node) => {
        node.depth = x3;
        for (const { target } of node.sourceLinks) {
          next.add(target);
        }
      });
      if (++x3 > n)
        throw new Error("circular link");
      current = next;
      next = /* @__PURE__ */ new Set();
    }
    if (depth) {
      const maxDepth2 = Math.max(max4(nodes2, (d2) => d2.depth) + 1, 0);
      let node;
      for (let i = 0; i < nodes2.length; i++) {
        node = nodes2[i];
        node.depth = depth.call(null, node, maxDepth2);
      }
    }
  }
  function computeNodeHeights({ nodes: nodes2 }) {
    const n = nodes2.length;
    let current = new Set(nodes2);
    let next = /* @__PURE__ */ new Set();
    let x3 = 0;
    while (current.size) {
      current.forEach((node) => {
        node.height = x3;
        for (const { source } of node.targetLinks) {
          next.add(source);
        }
      });
      if (++x3 > n)
        throw new Error("circular link");
      current = next;
      next = /* @__PURE__ */ new Set();
    }
  }
  function computeNodeLayers({ nodes: nodes2 }) {
    const x3 = Math.max(max4(nodes2, (d2) => d2.depth) + 1, 0);
    const kx2 = (x12 - x05 - dx) / (x3 - 1);
    const columns = new Array(x3).fill(0).map(() => []);
    for (const node of nodes2) {
      const i = Math.max(0, Math.min(x3 - 1, Math.floor(align.call(null, node, x3))));
      node.layer = i;
      node.x0 = x05 + i * kx2;
      node.x1 = node.x0 + dx;
      if (columns[i])
        columns[i].push(node);
      else
        columns[i] = [node];
    }
    if (sort2)
      for (const column2 of columns) {
        column2.sort(sort2);
      }
    return columns;
  }
  function initializeNodeBreadths(columns) {
    const ky2 = min4(columns, (c5) => (y12 - y05 - (c5.length - 1) * py) / sum(c5, value));
    for (const nodes2 of columns) {
      let y3 = y05;
      for (const node of nodes2) {
        node.y0 = y3;
        node.y1 = y3 + node.value * ky2;
        y3 = node.y1 + py;
        for (const link3 of node.sourceLinks) {
          link3.width = link3.value * ky2;
        }
      }
      y3 = (y12 - y3 + py) / (nodes2.length + 1);
      for (let i = 0; i < nodes2.length; ++i) {
        const node = nodes2[i];
        node.y0 += y3 * (i + 1);
        node.y1 += y3 * (i + 1);
      }
      reorderLinks(nodes2);
    }
  }
  function computeNodeBreadths(graph) {
    const columns = computeNodeLayers(graph);
    py = Math.min(dy, (y12 - y05) / (max4(columns, (c5) => c5.length) - 1));
    initializeNodeBreadths(columns);
    for (let i = 0; i < iterations2; ++i) {
      const alpha = Math.pow(0.99, i);
      const beta = Math.max(1 - alpha, (i + 1) / iterations2);
      relaxRightToLeft(columns, alpha, beta);
      relaxLeftToRight(columns, alpha, beta);
    }
  }
  function relaxLeftToRight(columns, alpha, beta) {
    for (let i = 1, n = columns.length; i < n; ++i) {
      const column2 = columns[i];
      for (const target of column2) {
        let y3 = 0;
        let w = 0;
        for (const { source, value: value2 } of target.targetLinks) {
          const v = value2 * (target.layer - source.layer);
          y3 += targetTop(source, target) * v;
          w += v;
        }
        if (!(w > 0))
          continue;
        const dy2 = (y3 / w - target.y0) * alpha;
        target.y0 += dy2;
        target.y1 += dy2;
        reorderNodeLinks(target);
      }
      if (sort2 === void 0)
        column2.sort(ascendingBreadth);
      if (column2.length)
        resolveCollisions(column2, beta);
    }
  }
  function relaxRightToLeft(columns, alpha, beta) {
    for (let n = columns.length, i = n - 2; i >= 0; --i) {
      const column2 = columns[i];
      for (const source of column2) {
        let y3 = 0;
        let w = 0;
        for (const { target, value: value2 } of source.sourceLinks) {
          const v = value2 * (target.layer - source.layer);
          y3 += sourceTop(source, target) * v;
          w += v;
        }
        if (!(w > 0))
          continue;
        const dy2 = (y3 / w - source.y0) * alpha;
        source.y0 += dy2;
        source.y1 += dy2;
        reorderNodeLinks(source);
      }
      if (sort2 === void 0)
        column2.sort(ascendingBreadth);
      if (column2.length)
        resolveCollisions(column2, beta);
    }
  }
  function resolveCollisions(nodes2, alpha) {
    const i = nodes2.length >> 1;
    const subject = nodes2[i];
    resolveCollisionsBottomToTop(nodes2, subject.y0 - py, i - 1, alpha);
    resolveCollisionsTopToBottom(nodes2, subject.y1 + py, i + 1, alpha);
    resolveCollisionsBottomToTop(nodes2, y12, nodes2.length - 1, alpha);
    resolveCollisionsTopToBottom(nodes2, y05, 0, alpha);
  }
  function resolveCollisionsTopToBottom(nodes2, y3, i, alpha) {
    for (; i < nodes2.length; ++i) {
      const node = nodes2[i];
      const dy2 = (y3 - node.y0) * alpha;
      if (dy2 > 1e-6)
        node.y0 += dy2, node.y1 += dy2;
      y3 = node.y1 + py;
    }
  }
  function resolveCollisionsBottomToTop(nodes2, y3, i, alpha) {
    for (; i >= 0; --i) {
      const node = nodes2[i];
      const dy2 = (node.y1 - y3) * alpha;
      if (dy2 > 1e-6)
        node.y0 -= dy2, node.y1 -= dy2;
      y3 = node.y0 - py;
    }
  }
  function reorderNodeLinks({ sourceLinks, targetLinks }) {
    if (linkSort === void 0) {
      for (const { source: { sourceLinks: sourceLinks2 } } of targetLinks) {
        sourceLinks2.sort(ascendingTargetBreadth);
      }
      for (const { target: { targetLinks: targetLinks2 } } of sourceLinks) {
        targetLinks2.sort(ascendingSourceBreadth);
      }
    }
  }
  function reorderLinks(nodes2) {
    if (linkSort === void 0) {
      for (const { sourceLinks, targetLinks } of nodes2) {
        sourceLinks.sort(ascendingTargetBreadth);
        targetLinks.sort(ascendingSourceBreadth);
      }
    }
  }
  function targetTop(source, target) {
    let y3 = source.y0 - (source.sourceLinks.length - 1) * py / 2;
    for (const { target: node, width } of source.sourceLinks) {
      if (node === target)
        break;
      y3 += width + py;
    }
    for (const { source: node, width } of target.targetLinks) {
      if (node === source)
        break;
      y3 -= width;
    }
    return y3;
  }
  function sourceTop(source, target) {
    let y3 = target.y0 - (target.targetLinks.length - 1) * py / 2;
    for (const { source: node, width } of target.targetLinks) {
      if (node === source)
        break;
      y3 += width + py;
    }
    for (const { target: node, width } of source.sourceLinks) {
      if (node === target)
        break;
      y3 -= width;
    }
    return y3;
  }
  return sankey;
}

// node_modules/@antv/g2/esm/data/sankey.js
var DEFAULT_OPTIONS = {
  nodeAlign: "justify",
  nodeWidth: 8e-3,
  nodePadding: 0.03,
  nodes: (graph) => graph.nodes,
  links: (graph) => graph.links,
  nodeSort: void 0,
  linkSort: void 0,
  iterations: 6
};
var ALIGN_METHOD = {
  left,
  right,
  center,
  justify
};
function getNodeAlignFunction(nodeAlign) {
  const type = typeof nodeAlign;
  if (type === "string")
    return ALIGN_METHOD[nodeAlign] || justify;
  if (type === "function")
    return nodeAlign;
  return justify;
}
var Sankey2 = (options) => {
  return (data2) => {
    const { nodeId, nodeSort, nodeAlign, nodeWidth, nodePadding, nodeDepth, nodes: nodeNodes, links: nodeLinks, linkSort, iterations: iterations2 } = Object.assign({}, DEFAULT_OPTIONS, options);
    const sankeyProcessor = Sankey().nodeSort(nodeSort).linkSort(linkSort).links(nodeLinks).nodes(nodeNodes).nodeWidth(nodeWidth).nodePadding(nodePadding).nodeDepth(nodeDepth).nodeAlign(getNodeAlignFunction(nodeAlign)).iterations(iterations2).extent([
      [0, 0],
      [1, 1]
    ]);
    if (typeof nodeId === "function") {
      sankeyProcessor.nodeId(nodeId);
    }
    const layoutData = sankeyProcessor(data2);
    const { nodes: N, links: L } = layoutData;
    const nodes = N.map((node) => {
      const { x0: x05, x1: x12, y0: y05, y1: y12 } = node;
      return Object.assign(Object.assign({}, node), { x: [x05, x12, x12, x05], y: [y05, y05, y12, y12] });
    });
    const links = L.map((edge) => {
      const { source, target } = edge;
      const sx = source.x1;
      const tx = target.x0;
      const offset2 = edge.width / 2;
      return Object.assign(Object.assign({}, edge), { x: [sx, sx, tx, tx], y: [
        edge.y0 + offset2,
        edge.y0 - offset2,
        edge.y1 + offset2,
        edge.y1 - offset2
      ] });
    });
    return { nodes, links };
  };
};
Sankey2.props = {};

// node_modules/@antv/g2/esm/utils/mark.js
function subTooltip(tooltip2, name2, defaults5 = {}, main = false) {
  if (isUnset(tooltip2))
    return tooltip2;
  if (Array.isArray(tooltip2) && main)
    return tooltip2;
  const sub8 = subObject(tooltip2, name2);
  return deep_mix_default(defaults5, sub8);
}
function maybeTooltip(tooltip2, defaults5 = {}) {
  if (isUnset(tooltip2))
    return tooltip2;
  if (Array.isArray(tooltip2))
    return tooltip2;
  if (!isFullTooltip(tooltip2))
    return tooltip2;
  return deep_mix_default(defaults5, tooltip2);
}
function isFullTooltip(tooltip2) {
  if (Object.keys(tooltip2).length === 0)
    return true;
  const { title, items } = tooltip2;
  return title !== void 0 || items !== void 0;
}
function maybeAnimation(animate2, sub8) {
  return typeof animate2 === "object" ? subObject(animate2, sub8) : animate2;
}

// node_modules/@antv/g2/esm/mark/sankey.js
var __rest43 = function(s2, e) {
  var t = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
      t[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t[p2[i]] = s2[p2[i]];
    }
  return t;
};
var DEFAULT_LAYOUT_OPTIONS = {
  nodeId: (d2) => d2.key,
  nodeWidth: 0.02,
  nodePadding: 0.02
};
var DEFAULT_NODE_OPTIONS = {
  type: "polygon",
  axis: false,
  legend: false,
  encode: {
    shape: "polygon",
    x: "x",
    y: "y"
  },
  scale: {
    x: { type: "identity" },
    y: { type: "identity" }
  },
  style: {
    stroke: "#000"
  }
};
var DEFAULT_LINK_OPTIONS = {
  type: "polygon",
  axis: false,
  legend: false,
  encode: {
    shape: "ribbon",
    x: "x",
    y: "y"
  },
  style: {
    fillOpacity: 0.5,
    stroke: void 0
  }
};
var DEFAULT_LABEL_OPTIONS = {
  textAlign: (d2) => d2.x[0] < 0.5 ? "start" : "end",
  position: (d2) => d2.x[0] < 0.5 ? "right" : "left",
  fontSize: 10
};
var Sankey3 = (options) => {
  const { data: data2, encode = {}, scale: scale10, style = {}, layout = {}, nodeLabels = [], linkLabels = [], animate: animate2 = {}, tooltip: tooltip2 = {} } = options;
  const { links, nodes } = initializeData(data2, encode);
  const nodeEncode = subObject(encode, "node");
  const linkEncode = subObject(encode, "link");
  const { key: nodeKey = (d2) => d2.key, color: color2 = nodeKey } = nodeEncode;
  const { links: linkData, nodes: nodeData } = Sankey2(Object.assign(Object.assign(Object.assign({}, DEFAULT_LAYOUT_OPTIONS), { nodeId: field(nodeKey) }), layout))({ links, nodes });
  const _a2 = subObject(style, "label"), { text = nodeKey, spacing = 5 } = _a2, labelStyle = __rest43(_a2, ["text", "spacing"]);
  const key1 = field(nodeKey);
  const nodeTooltip = subTooltip(tooltip2, "node", {
    title: key1,
    items: [{ field: "value" }]
  }, true);
  const linkTooltip = subTooltip(tooltip2, "link", {
    title: "",
    items: [
      (d2) => ({ name: "source", value: key1(d2.source) }),
      (d2) => ({ name: "target", value: key1(d2.target) })
    ]
  });
  return [
    deep_mix_default({}, DEFAULT_NODE_OPTIONS, {
      data: nodeData,
      encode: Object.assign(Object.assign({}, nodeEncode), { color: color2 }),
      scale: scale10,
      style: subObject(style, "node"),
      labels: [
        Object.assign(Object.assign(Object.assign({}, DEFAULT_LABEL_OPTIONS), { text, dx: (d2) => d2.x[0] < 0.5 ? spacing : -spacing }), labelStyle),
        ...nodeLabels
      ],
      tooltip: nodeTooltip,
      animate: maybeAnimation(animate2, "node"),
      axis: false
    }),
    deep_mix_default({}, DEFAULT_LINK_OPTIONS, {
      data: linkData,
      encode: linkEncode,
      labels: linkLabels,
      style: Object.assign({ fill: linkEncode.color ? void 0 : "#aaa", strokeWidth: 0 }, subObject(style, "link")),
      tooltip: linkTooltip,
      animate: maybeAnimation(animate2, "link")
    })
  ];
};
Sankey3.props = {};

// node_modules/@antv/g2/esm/data/utils/arc/sort.js
var sort_exports = {};
__export(sort_exports, {
  frequency: () => frequency,
  id: () => id2,
  name: () => name,
  weight: () => weight
});
function weight(a4, b) {
  return b.value - a4.value;
}
function frequency(a4, b) {
  return b.frequency - a4.frequency;
}
function id2(a4, b) {
  return `${a4.id}`.localeCompare(`${b.id}`);
}
function name(a4, b) {
  return `${a4.name}`.localeCompare(`${b.name}`);
}

// node_modules/@antv/g2/esm/data/utils/arc/arc.js
var DEFAULT_OPTIONS2 = {
  y: 0,
  thickness: 0.05,
  weight: false,
  marginRatio: 0.1,
  id: (node) => node.id,
  source: (edge) => edge.source,
  target: (edge) => edge.target,
  sourceWeight: (edge) => edge.value || 1,
  targetWeight: (edge) => edge.value || 1,
  sortBy: null
};
function Arc2(options) {
  const { y: y3, thickness, weight: weight2, marginRatio, id: id3, source, target, sourceWeight, targetWeight, sortBy: sortBy2 } = Object.assign(Object.assign({}, DEFAULT_OPTIONS2), options);
  function arc(data2) {
    const nodes = data2.nodes.map((n) => Object.assign({}, n));
    const edges = data2.edges.map((n) => Object.assign({}, n));
    preprocess(nodes, edges);
    sortNodes(nodes, edges);
    layoutNodes(nodes, edges);
    layoutEdges(nodes, edges);
    return { nodes, edges };
  }
  function preprocess(nodes, edges) {
    edges.forEach((edge) => {
      edge.source = source(edge);
      edge.target = target(edge);
      edge.sourceWeight = sourceWeight(edge);
      edge.targetWeight = targetWeight(edge);
    });
    const edgesBySource = group(edges, (e) => e.source);
    const edgesByTarget = group(edges, (e) => e.target);
    nodes.forEach((node) => {
      node.id = id3(node);
      const sources = edgesBySource.has(node.id) ? edgesBySource.get(node.id) : [];
      const targets = edgesByTarget.has(node.id) ? edgesByTarget.get(node.id) : [];
      node.frequency = sources.length + targets.length;
      node.value = sum(sources, (d2) => d2.sourceWeight) + sum(targets, (d2) => d2.targetWeight);
    });
    return { nodes, edges };
  }
  function sortNodes(nodes, edges) {
    const method2 = typeof sortBy2 === "function" ? sortBy2 : sort_exports[sortBy2];
    if (method2) {
      nodes.sort(method2);
    }
  }
  function layoutNodes(nodes, edges) {
    const size5 = nodes.length;
    if (!size5) {
      throw error("Invalid nodes: it's empty!");
    }
    if (!weight2) {
      const deltaX = 1 / size5;
      nodes.forEach((node, i) => {
        node.x = (i + 0.5) * deltaX;
        node.y = y3;
      });
      return { nodes, edges };
    }
    const margin = marginRatio / (2 * size5);
    const total = nodes.reduce((prev, node) => prev += node.value, 0);
    nodes.reduce((deltaX, node) => {
      node.weight = node.value / total;
      node.width = node.weight * (1 - marginRatio);
      node.height = thickness;
      const minX = margin + deltaX;
      const maxX = minX + node.width;
      const minY = y3 - thickness / 2;
      const maxY2 = minY + thickness;
      node.x = [minX, maxX, maxX, minX];
      node.y = [minY, minY, maxY2, maxY2];
      return deltaX + node.width + 2 * margin;
    }, 0);
    return {
      nodes,
      edges
    };
  }
  function layoutEdges(nodes, edges) {
    const nodesMap = new Map(nodes.map((d2) => [d2.id, d2]));
    if (!weight2) {
      edges.forEach((edge) => {
        const sourceId = source(edge);
        const targetId = target(edge);
        const sourceNode = nodesMap.get(sourceId);
        const targetNode = nodesMap.get(targetId);
        if (sourceNode && targetNode) {
          edge.x = [sourceNode.x, targetNode.x];
          edge.y = [sourceNode.y, targetNode.y];
        }
      });
      return { nodes, edges };
    }
    edges.forEach((edge) => {
      edge.x = [0, 0, 0, 0];
      edge.y = [y3, y3, y3, y3];
    });
    const edgesBySource = group(edges, (e) => e.source);
    const edgesByTarget = group(edges, (e) => e.target);
    nodes.forEach((node) => {
      const { edges: edges2, width, x: x3, y: y4, value: value2, id: id4 } = node;
      const sourceEdges = edgesBySource.get(id4) || [];
      const targetEdges = edgesByTarget.get(id4) || [];
      let offset2 = 0;
      sourceEdges.map((edge) => {
        const w = edge.sourceWeight / value2 * width;
        edge.x[0] = x3[0] + offset2;
        edge.x[1] = x3[0] + offset2 + w;
        offset2 += w;
      });
      targetEdges.forEach((edge) => {
        const w = edge.targetWeight / value2 * width;
        edge.x[3] = x3[0] + offset2;
        edge.x[2] = x3[0] + offset2 + w;
        offset2 += w;
      });
    });
  }
  return arc;
}

// node_modules/@antv/g2/esm/data/arc.js
var Arc3 = (options) => {
  return (data2) => {
    return Arc2(options)(data2);
  };
};
Arc3.props = {};

// node_modules/@antv/g2/esm/mark/chord.js
var __rest44 = function(s2, e) {
  var t = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
      t[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t[p2[i]] = s2[p2[i]];
    }
  return t;
};
var DEFAULT_LAYOUT_OPTIONS2 = {
  y: 0,
  thickness: 0.05,
  marginRatio: 0.1,
  id: (node) => node.key,
  source: (edge) => edge.source,
  target: (edge) => edge.target,
  sourceWeight: (edge) => edge.value || 1,
  targetWeight: (edge) => edge.value || 1,
  sortBy: null
  // optional, id | weight | frequency | {function}
};
var DEFAULT_NODE_OPTIONS2 = {
  type: "polygon",
  axis: false,
  legend: false,
  encode: {
    shape: "polygon",
    x: "x",
    y: "y"
  },
  scale: {
    x: { type: "identity" },
    y: { type: "identity" }
  },
  style: {
    opacity: 1,
    fillOpacity: 1,
    lineWidth: 1
  }
};
var DEFAULT_LINK_OPTIONS2 = {
  type: "polygon",
  axis: false,
  legend: false,
  encode: {
    shape: "ribbon",
    x: "x",
    y: "y"
  },
  style: {
    opacity: 0.5,
    lineWidth: 1,
    strokeWidth: 1
  }
};
var DEFAULT_LABEL_OPTIONS2 = {
  position: "outside",
  fontSize: 10
};
var Chord = (options, context) => {
  const { data: data2, encode = {}, scale: scale10, style = {}, layout = {}, nodeLabels = [], linkLabels = [], animate: animate2 = {}, tooltip: tooltip2 = {} } = options;
  const { nodes, links } = initializeData(data2, encode);
  const nodeEncode = subObject(encode, "node");
  const linkEncode = subObject(encode, "link");
  const { key: nodeKey = (d2) => d2.key, color: color2 = nodeKey } = nodeEncode;
  const { linkEncodeColor = (d2) => d2.source } = linkEncode;
  const { nodeWidthRatio = DEFAULT_LAYOUT_OPTIONS2.thickness, nodePaddingRatio = DEFAULT_LAYOUT_OPTIONS2.marginRatio } = layout, restLayout = __rest44(layout, ["nodeWidthRatio", "nodePaddingRatio"]);
  const { nodes: nodeData, edges: linkData } = Arc3(Object.assign(Object.assign(Object.assign(Object.assign({}, DEFAULT_LAYOUT_OPTIONS2), { id: field(nodeKey), thickness: nodeWidthRatio, marginRatio: nodePaddingRatio }), restLayout), { weight: true }))({ nodes, edges: links });
  const _a2 = subObject(style, "label"), { text = nodeKey } = _a2, labelStyle = __rest44(_a2, ["text"]);
  const nodeTooltip = subTooltip(tooltip2, "node", {
    title: "",
    items: [(d2) => ({ name: d2.key, value: d2.value })]
  }, true);
  const linkTooltip = subTooltip(tooltip2, "link", {
    title: "",
    items: [(d2) => ({ name: `${d2.source} -> ${d2.target}`, value: d2.value })]
  });
  const { height, width } = context;
  const minimumLen = Math.min(height, width);
  return [
    deep_mix_default({}, DEFAULT_LINK_OPTIONS2, {
      data: linkData,
      encode: Object.assign(Object.assign({}, linkEncode), { color: linkEncodeColor }),
      labels: linkLabels,
      style: Object.assign({ fill: linkEncodeColor ? void 0 : "#aaa" }, subObject(style, "link")),
      tooltip: linkTooltip,
      animate: maybeAnimation(animate2, "link")
    }),
    deep_mix_default({}, DEFAULT_NODE_OPTIONS2, {
      data: nodeData,
      encode: Object.assign(Object.assign({}, nodeEncode), { color: color2 }),
      scale: scale10,
      style: subObject(style, "node"),
      coordinate: {
        type: "polar",
        // Leave enough rendering space for the label.
        outerRadius: (minimumLen - 20) / minimumLen,
        startAngle: -Math.PI * 2,
        endAngle: 0
      },
      labels: [
        Object.assign(Object.assign(Object.assign({}, DEFAULT_LABEL_OPTIONS2), { text }), labelStyle),
        ...nodeLabels
      ],
      tooltip: nodeTooltip,
      animate: maybeAnimation(animate2, "node"),
      axis: false
    })
  ];
};
Chord.props = {};

// node_modules/@antv/g2/esm/mark/path.js
var shape19 = {
  path: Path3,
  hollow: Hollow2
};
var Path4 = (options) => {
  return (index3, scale10, value2, coordinate2) => {
    return [index3, index3.map(() => [[0, 0]])];
  };
};
Path4.props = {
  defaultShape: "path",
  defaultLabelShape: "label",
  shape: shape19,
  composite: false,
  channels: [
    ...baseGeometryChannels({ shapes: Object.keys(shape19) }),
    { name: "d", scale: "identity" }
  ],
  preInference: [...basePreInference()],
  postInference: [...basePostInference()]
};

// node_modules/@antv/g2/esm/mark/treemap.js
var __rest45 = function(s2, e) {
  var t = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
      t[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t[p2[i]] = s2[p2[i]];
    }
  return t;
};
function getTileMethod(tile, ratio) {
  const tiles = {
    treemapBinary: binary_default,
    treemapDice: dice_default,
    treemapSlice: slice_default,
    treemapSliceDice: sliceDice_default,
    treemapSquarify: squarify_default,
    treemapResquarify: resquarify_default
  };
  const tileMethod = tile === "treemapSquarify" ? tiles[tile].ratio(ratio) : tiles[tile];
  if (!tileMethod) {
    throw new TypeError("Invalid tile method!");
  }
  return tileMethod;
}
function dataTransform(data2, layout, encode) {
  const { value: value2 } = encode;
  const tileMethod = getTileMethod(layout.tile, layout.ratio);
  const root3 = generateHierarchyRoot(data2, layout.path);
  value2 ? root3.sum((d2) => layout.ignoreParentValue && d2.children ? 0 : field(value2)(d2)).sort(layout.sort) : root3.count();
  treemap_default().tile(tileMethod).size(layout.size).round(layout.round).paddingInner(layout.paddingInner).paddingOuter(layout.paddingOuter).paddingTop(layout.paddingTop).paddingRight(layout.paddingRight).paddingBottom(layout.paddingBottom).paddingLeft(layout.paddingLeft)(root3);
  return root3.descendants().map((d2) => Object.assign(d2, {
    x: [d2.x0, d2.x1],
    y: [d2.y0, d2.y1]
  })).filter(typeof layout.layer === "function" ? layout.layer : (d2) => d2.height === layout.layer);
}
var GET_DEFAULT_LAYOUT_OPTIONS = (width, height) => ({
  tile: "treemapSquarify",
  ratio: 0.5 * (1 + Math.sqrt(5)),
  size: [width, height],
  round: false,
  ignoreParentValue: true,
  padding: 0,
  paddingInner: 0,
  paddingOuter: 0,
  paddingTop: 0,
  paddingRight: 0,
  paddingBottom: 0,
  paddingLeft: 0,
  sort: (a4, b) => b.value - a4.value,
  layer: 0
});
var GET_DEFAULT_OPTIONS = (width, height) => ({
  type: "rect",
  axis: false,
  encode: {
    x: "x",
    y: "y",
    color: (d2) => d2.data.parent.name
  },
  scale: {
    x: { domain: [0, width], range: [0, 1] },
    y: { domain: [0, height], range: [0, 1] }
  },
  style: {
    stroke: "#fff"
  }
});
var DEFAULT_LABEL_OPTIONS3 = {
  fontSize: 10,
  text: (d2) => d2.data.name,
  position: "inside",
  fill: "#000",
  textOverflow: "clip",
  wordWrap: true,
  maxLines: 1,
  wordWrapWidth: (d2) => d2.x1 - d2.x0
};
var DEFAULT_TOOLTIP_OPTIONS = {
  title: (d2) => d2.data.name,
  items: [{ field: "value" }]
};
var Treemap = (options, context) => {
  const { width, height } = context;
  const { data: data2, encode = {}, scale: scale10, style = {}, layout = {}, labels = [], tooltip: tooltip2 = {} } = options, resOptions = __rest45(options, ["data", "encode", "scale", "style", "layout", "labels", "tooltip"]);
  const transformedData = dataTransform(data2, deep_mix_default({}, GET_DEFAULT_LAYOUT_OPTIONS(width, height), layout), encode);
  const labelStyle = subObject(style, "label");
  return deep_mix_default({}, GET_DEFAULT_OPTIONS(width, height), Object.assign(Object.assign({
    data: transformedData,
    encode,
    scale: scale10,
    style,
    labels: [
      Object.assign(Object.assign({}, DEFAULT_LABEL_OPTIONS3), labelStyle),
      ...labels
    ]
  }, resOptions), { tooltip: maybeTooltip(tooltip2, DEFAULT_TOOLTIP_OPTIONS), axis: false }));
};
Treemap.props = {};

// node_modules/@antv/g2/esm/mark/pack.js
var __rest46 = function(s2, e) {
  var t = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
      t[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t[p2[i]] = s2[p2[i]];
    }
  return t;
};
var GET_DEFAULT_LAYOUT_OPTIONS2 = (width, height) => ({
  size: [width, height],
  padding: 0,
  sort: (a4, b) => b.value - a4.value
});
var GET_DEFAULT_OPTIONS2 = (width, height, encode) => ({
  type: "point",
  axis: false,
  legend: false,
  scale: {
    x: { domain: [0, width] },
    y: { domain: [0, height] },
    size: { type: "identity" }
  },
  encode: {
    x: "x",
    y: "y",
    size: "r",
    shape: "point"
  },
  style: {
    fill: !encode.color ? (d2) => d2.height === 0 ? "#ddd" : "#fff" : void 0,
    stroke: !encode.color ? (d2) => d2.height === 0 ? "" : "#000" : void 0
  }
});
var DEFAULT_LABEL_OPTIONS4 = {
  text: "",
  position: "inside",
  textOverflow: "clip",
  wordWrap: true,
  maxLines: 1,
  wordWrapWidth: (d2) => d2.r * 2
};
var DEFAULT_TOOLTIP_OPTIONS2 = {
  title: (d2) => d2.data.name,
  items: [{ field: "value" }]
};
var dataTransform2 = (data2, layout, encode) => {
  const { value: value2 } = encode;
  const root3 = is_array_default(data2) ? stratify_default().path(layout.path)(data2) : hierarchy(data2);
  value2 ? root3.sum((d2) => field(value2)(d2)).sort(layout.sort) : root3.count();
  pack_default().size(layout.size).padding(layout.padding)(root3);
  return root3.descendants();
};
var Pack2 = (markOptions, context) => {
  const { width, height } = context;
  const { data: data2, encode = {}, scale: scale10 = {}, style = {}, layout = {}, labels = [], tooltip: tooltip2 = {} } = markOptions, resOptions = __rest46(markOptions, ["data", "encode", "scale", "style", "layout", "labels", "tooltip"]);
  const DEFAULT_OPTIONS8 = GET_DEFAULT_OPTIONS2(width, height, encode);
  const transformedData = dataTransform2(data2, deep_mix_default({}, GET_DEFAULT_LAYOUT_OPTIONS2(width, height), layout), deep_mix_default({}, DEFAULT_OPTIONS8["encode"], encode));
  const labelStyle = subObject(style, "label");
  return deep_mix_default({}, DEFAULT_OPTIONS8, Object.assign(Object.assign({
    data: transformedData,
    encode,
    scale: scale10,
    style,
    labels: [
      Object.assign(Object.assign({}, DEFAULT_LABEL_OPTIONS4), labelStyle),
      ...labels
    ]
  }, resOptions), { tooltip: maybeTooltip(tooltip2, DEFAULT_TOOLTIP_OPTIONS2), axis: false }));
};
Pack2.props = {};

// node_modules/@antv/g2/esm/mark/boxplot.js
var __rest47 = function(s2, e) {
  var t = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
      t[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t[p2[i]] = s2[p2[i]];
    }
  return t;
};
function min9(I, V) {
  return min4(I, (i) => V[i]);
}
function max9(I, V) {
  return max4(I, (i) => V[i]);
}
function lower(I, V) {
  const lo = q1(I, V) * 2.5 - q3(I, V) * 1.5;
  return min4(I, (i) => V[i] >= lo ? V[i] : NaN);
}
function q1(I, V) {
  return quantile(I, 0.25, (i) => V[i]);
}
function q2(I, V) {
  return quantile(I, 0.5, (i) => V[i]);
}
function q3(I, V) {
  return quantile(I, 0.75, (i) => V[i]);
}
function upper(I, V) {
  const hi = q3(I, V) * 2.5 - q1(I, V) * 1.5;
  return max4(I, (i) => V[i] <= hi ? V[i] : NaN);
}
function OutlierY() {
  return (I, mark2) => {
    const { encode } = mark2;
    const { y: y3, x: x3 } = encode;
    const { value: V } = y3;
    const { value: X } = x3;
    const GI = Array.from(group(I, (i) => X[+i]).values());
    const FI = GI.flatMap((I2) => {
      const lo = lower(I2, V);
      const hi = upper(I2, V);
      return I2.filter((i) => V[i] < lo || V[i] > hi);
    });
    return [FI, mark2];
  };
}
var Boxplot = (options) => {
  const { data: data2, encode, style = {}, tooltip: tooltip2 = {}, transform: transform3, animate: animate2 } = options, rest2 = __rest47(options, ["data", "encode", "style", "tooltip", "transform", "animate"]);
  const { point: point7 = true } = style, restStyle = __rest47(style, ["point"]);
  const { y: y3 } = encode;
  const encodeY = { y: y3, y1: y3, y2: y3, y3, y4: y3 };
  const qy = { y1: q1, y2: q2, y3: q3 };
  const boxTooltip = subTooltip(tooltip2, "box", {
    items: [
      { channel: "y", name: "min" },
      { channel: "y1", name: "q1" },
      { channel: "y2", name: "q2" },
      { channel: "y3", name: "q3" },
      { channel: "y4", name: "max" }
    ]
  }, true);
  const pointTooltip = subTooltip(tooltip2, "point", {
    title: { channel: "x" },
    items: [{ name: "outlier", channel: "y" }]
  });
  if (!point7) {
    return Object.assign({ type: "box", data: data2, transform: [
      Object.assign(Object.assign({ type: "groupX", y: min9 }, qy), { y4: max9 })
    ], encode: Object.assign(Object.assign({}, encode), encodeY), style: restStyle, tooltip: boxTooltip }, rest2);
  }
  const boxStyle = subObject(restStyle, "box");
  const pointStyle = subObject(restStyle, "point");
  return [
    Object.assign({ type: "box", data: data2, transform: [
      Object.assign(Object.assign({ type: "groupX", y: lower }, qy), { y4: upper })
    ], encode: Object.assign(Object.assign({}, encode), encodeY), style: boxStyle, tooltip: boxTooltip, animate: maybeAnimation(animate2, "box") }, rest2),
    // Draw outliers.
    {
      type: "point",
      data: data2,
      transform: [{ type: OutlierY }],
      encode,
      style: Object.assign({}, pointStyle),
      tooltip: pointTooltip,
      animate: maybeAnimation(animate2, "point")
    }
  ];
};
Boxplot.props = {};

// node_modules/@antv/g2/esm/mark/shape.js
var shape20 = {
  shape: Shape2
};
var Shape3 = (options) => {
  const { cartesian: cartesian3 } = options;
  if (cartesian3)
    return visualMark;
  return (index3, scale10, value2, coordinate2) => {
    const { x: X, y: Y } = value2;
    const offset2 = createBandOffset(scale10, value2, options);
    const P = Array.from(index3, (i) => {
      const p2 = [+X[i], +Y[i]];
      return [coordinate2.map(offset2(p2, i))];
    });
    return [index3, P];
  };
};
Shape3.props = {
  defaultShape: "shape",
  defaultLabelShape: "label",
  composite: false,
  shape: shape20,
  channels: [
    { name: "x", required: true },
    { name: "y", required: true }
  ],
  preInference: [
    ...basePreInference(),
    { type: MaybeTuple },
    { type: MaybeVisualPosition },
    { type: MaybeFunctionAttribute }
  ]
};

// node_modules/d3-force/src/center.js
function center_default(x3, y3) {
  var nodes, strength = 1;
  if (x3 == null)
    x3 = 0;
  if (y3 == null)
    y3 = 0;
  function force() {
    var i, n = nodes.length, node, sx = 0, sy = 0;
    for (i = 0; i < n; ++i) {
      node = nodes[i], sx += node.x, sy += node.y;
    }
    for (sx = (sx / n - x3) * strength, sy = (sy / n - y3) * strength, i = 0; i < n; ++i) {
      node = nodes[i], node.x -= sx, node.y -= sy;
    }
  }
  force.initialize = function(_2) {
    nodes = _2;
  };
  force.x = function(_2) {
    return arguments.length ? (x3 = +_2, force) : x3;
  };
  force.y = function(_2) {
    return arguments.length ? (y3 = +_2, force) : y3;
  };
  force.strength = function(_2) {
    return arguments.length ? (strength = +_2, force) : strength;
  };
  return force;
}

// node_modules/d3-quadtree/src/add.js
function add_default(d2) {
  const x3 = +this._x.call(null, d2), y3 = +this._y.call(null, d2);
  return add9(this.cover(x3, y3), x3, y3, d2);
}
function add9(tree, x3, y3, d2) {
  if (isNaN(x3) || isNaN(y3))
    return tree;
  var parent2, node = tree._root, leaf = { data: d2 }, x05 = tree._x0, y05 = tree._y0, x12 = tree._x1, y12 = tree._y1, xm, ym, xp, yp, right2, bottom, i, j;
  if (!node)
    return tree._root = leaf, tree;
  while (node.length) {
    if (right2 = x3 >= (xm = (x05 + x12) / 2))
      x05 = xm;
    else
      x12 = xm;
    if (bottom = y3 >= (ym = (y05 + y12) / 2))
      y05 = ym;
    else
      y12 = ym;
    if (parent2 = node, !(node = node[i = bottom << 1 | right2]))
      return parent2[i] = leaf, tree;
  }
  xp = +tree._x.call(null, node.data);
  yp = +tree._y.call(null, node.data);
  if (x3 === xp && y3 === yp)
    return leaf.next = node, parent2 ? parent2[i] = leaf : tree._root = leaf, tree;
  do {
    parent2 = parent2 ? parent2[i] = new Array(4) : tree._root = new Array(4);
    if (right2 = x3 >= (xm = (x05 + x12) / 2))
      x05 = xm;
    else
      x12 = xm;
    if (bottom = y3 >= (ym = (y05 + y12) / 2))
      y05 = ym;
    else
      y12 = ym;
  } while ((i = bottom << 1 | right2) === (j = (yp >= ym) << 1 | xp >= xm));
  return parent2[j] = node, parent2[i] = leaf, tree;
}
function addAll(data2) {
  var d2, i, n = data2.length, x3, y3, xz = new Array(n), yz = new Array(n), x05 = Infinity, y05 = Infinity, x12 = -Infinity, y12 = -Infinity;
  for (i = 0; i < n; ++i) {
    if (isNaN(x3 = +this._x.call(null, d2 = data2[i])) || isNaN(y3 = +this._y.call(null, d2)))
      continue;
    xz[i] = x3;
    yz[i] = y3;
    if (x3 < x05)
      x05 = x3;
    if (x3 > x12)
      x12 = x3;
    if (y3 < y05)
      y05 = y3;
    if (y3 > y12)
      y12 = y3;
  }
  if (x05 > x12 || y05 > y12)
    return this;
  this.cover(x05, y05).cover(x12, y12);
  for (i = 0; i < n; ++i) {
    add9(this, xz[i], yz[i], data2[i]);
  }
  return this;
}

// node_modules/d3-quadtree/src/cover.js
function cover_default(x3, y3) {
  if (isNaN(x3 = +x3) || isNaN(y3 = +y3))
    return this;
  var x05 = this._x0, y05 = this._y0, x12 = this._x1, y12 = this._y1;
  if (isNaN(x05)) {
    x12 = (x05 = Math.floor(x3)) + 1;
    y12 = (y05 = Math.floor(y3)) + 1;
  } else {
    var z = x12 - x05 || 1, node = this._root, parent2, i;
    while (x05 > x3 || x3 >= x12 || y05 > y3 || y3 >= y12) {
      i = (y3 < y05) << 1 | x3 < x05;
      parent2 = new Array(4), parent2[i] = node, node = parent2, z *= 2;
      switch (i) {
        case 0:
          x12 = x05 + z, y12 = y05 + z;
          break;
        case 1:
          x05 = x12 - z, y12 = y05 + z;
          break;
        case 2:
          x12 = x05 + z, y05 = y12 - z;
          break;
        case 3:
          x05 = x12 - z, y05 = y12 - z;
          break;
      }
    }
    if (this._root && this._root.length)
      this._root = node;
  }
  this._x0 = x05;
  this._y0 = y05;
  this._x1 = x12;
  this._y1 = y12;
  return this;
}

// node_modules/d3-quadtree/src/data.js
function data_default() {
  var data2 = [];
  this.visit(function(node) {
    if (!node.length)
      do
        data2.push(node.data);
      while (node = node.next);
  });
  return data2;
}

// node_modules/d3-quadtree/src/extent.js
function extent_default(_2) {
  return arguments.length ? this.cover(+_2[0][0], +_2[0][1]).cover(+_2[1][0], +_2[1][1]) : isNaN(this._x0) ? void 0 : [[this._x0, this._y0], [this._x1, this._y1]];
}

// node_modules/d3-quadtree/src/quad.js
function quad_default(node, x05, y05, x12, y12) {
  this.node = node;
  this.x0 = x05;
  this.y0 = y05;
  this.x1 = x12;
  this.y1 = y12;
}

// node_modules/d3-quadtree/src/find.js
function find_default4(x3, y3, radius) {
  var data2, x05 = this._x0, y05 = this._y0, x12, y12, x22, y22, x32 = this._x1, y32 = this._y1, quads = [], node = this._root, q, i;
  if (node)
    quads.push(new quad_default(node, x05, y05, x32, y32));
  if (radius == null)
    radius = Infinity;
  else {
    x05 = x3 - radius, y05 = y3 - radius;
    x32 = x3 + radius, y32 = y3 + radius;
    radius *= radius;
  }
  while (q = quads.pop()) {
    if (!(node = q.node) || (x12 = q.x0) > x32 || (y12 = q.y0) > y32 || (x22 = q.x1) < x05 || (y22 = q.y1) < y05)
      continue;
    if (node.length) {
      var xm = (x12 + x22) / 2, ym = (y12 + y22) / 2;
      quads.push(
        new quad_default(node[3], xm, ym, x22, y22),
        new quad_default(node[2], x12, ym, xm, y22),
        new quad_default(node[1], xm, y12, x22, ym),
        new quad_default(node[0], x12, y12, xm, ym)
      );
      if (i = (y3 >= ym) << 1 | x3 >= xm) {
        q = quads[quads.length - 1];
        quads[quads.length - 1] = quads[quads.length - 1 - i];
        quads[quads.length - 1 - i] = q;
      }
    } else {
      var dx = x3 - +this._x.call(null, node.data), dy = y3 - +this._y.call(null, node.data), d2 = dx * dx + dy * dy;
      if (d2 < radius) {
        var d3 = Math.sqrt(radius = d2);
        x05 = x3 - d3, y05 = y3 - d3;
        x32 = x3 + d3, y32 = y3 + d3;
        data2 = node.data;
      }
    }
  }
  return data2;
}

// node_modules/d3-quadtree/src/remove.js
function remove_default3(d2) {
  if (isNaN(x3 = +this._x.call(null, d2)) || isNaN(y3 = +this._y.call(null, d2)))
    return this;
  var parent2, node = this._root, retainer, previous, next, x05 = this._x0, y05 = this._y0, x12 = this._x1, y12 = this._y1, x3, y3, xm, ym, right2, bottom, i, j;
  if (!node)
    return this;
  if (node.length)
    while (true) {
      if (right2 = x3 >= (xm = (x05 + x12) / 2))
        x05 = xm;
      else
        x12 = xm;
      if (bottom = y3 >= (ym = (y05 + y12) / 2))
        y05 = ym;
      else
        y12 = ym;
      if (!(parent2 = node, node = node[i = bottom << 1 | right2]))
        return this;
      if (!node.length)
        break;
      if (parent2[i + 1 & 3] || parent2[i + 2 & 3] || parent2[i + 3 & 3])
        retainer = parent2, j = i;
    }
  while (node.data !== d2)
    if (!(previous = node, node = node.next))
      return this;
  if (next = node.next)
    delete node.next;
  if (previous)
    return next ? previous.next = next : delete previous.next, this;
  if (!parent2)
    return this._root = next, this;
  next ? parent2[i] = next : delete parent2[i];
  if ((node = parent2[0] || parent2[1] || parent2[2] || parent2[3]) && node === (parent2[3] || parent2[2] || parent2[1] || parent2[0]) && !node.length) {
    if (retainer)
      retainer[j] = node;
    else
      this._root = node;
  }
  return this;
}
function removeAll(data2) {
  for (var i = 0, n = data2.length; i < n; ++i)
    this.remove(data2[i]);
  return this;
}

// node_modules/d3-quadtree/src/root.js
function root_default() {
  return this._root;
}

// node_modules/d3-quadtree/src/size.js
function size_default() {
  var size5 = 0;
  this.visit(function(node) {
    if (!node.length)
      do
        ++size5;
      while (node = node.next);
  });
  return size5;
}

// node_modules/d3-quadtree/src/visit.js
function visit_default(callback) {
  var quads = [], q, node = this._root, child, x05, y05, x12, y12;
  if (node)
    quads.push(new quad_default(node, this._x0, this._y0, this._x1, this._y1));
  while (q = quads.pop()) {
    if (!callback(node = q.node, x05 = q.x0, y05 = q.y0, x12 = q.x1, y12 = q.y1) && node.length) {
      var xm = (x05 + x12) / 2, ym = (y05 + y12) / 2;
      if (child = node[3])
        quads.push(new quad_default(child, xm, ym, x12, y12));
      if (child = node[2])
        quads.push(new quad_default(child, x05, ym, xm, y12));
      if (child = node[1])
        quads.push(new quad_default(child, xm, y05, x12, ym));
      if (child = node[0])
        quads.push(new quad_default(child, x05, y05, xm, ym));
    }
  }
  return this;
}

// node_modules/d3-quadtree/src/visitAfter.js
function visitAfter_default(callback) {
  var quads = [], next = [], q;
  if (this._root)
    quads.push(new quad_default(this._root, this._x0, this._y0, this._x1, this._y1));
  while (q = quads.pop()) {
    var node = q.node;
    if (node.length) {
      var child, x05 = q.x0, y05 = q.y0, x12 = q.x1, y12 = q.y1, xm = (x05 + x12) / 2, ym = (y05 + y12) / 2;
      if (child = node[0])
        quads.push(new quad_default(child, x05, y05, xm, ym));
      if (child = node[1])
        quads.push(new quad_default(child, xm, y05, x12, ym));
      if (child = node[2])
        quads.push(new quad_default(child, x05, ym, xm, y12));
      if (child = node[3])
        quads.push(new quad_default(child, xm, ym, x12, y12));
    }
    next.push(q);
  }
  while (q = next.pop()) {
    callback(q.node, q.x0, q.y0, q.x1, q.y1);
  }
  return this;
}

// node_modules/d3-quadtree/src/x.js
function defaultX(d2) {
  return d2[0];
}
function x_default(_2) {
  return arguments.length ? (this._x = _2, this) : this._x;
}

// node_modules/d3-quadtree/src/y.js
function defaultY(d2) {
  return d2[1];
}
function y_default(_2) {
  return arguments.length ? (this._y = _2, this) : this._y;
}

// node_modules/d3-quadtree/src/quadtree.js
function quadtree(nodes, x3, y3) {
  var tree = new Quadtree(x3 == null ? defaultX : x3, y3 == null ? defaultY : y3, NaN, NaN, NaN, NaN);
  return nodes == null ? tree : tree.addAll(nodes);
}
function Quadtree(x3, y3, x05, y05, x12, y12) {
  this._x = x3;
  this._y = y3;
  this._x0 = x05;
  this._y0 = y05;
  this._x1 = x12;
  this._y1 = y12;
  this._root = void 0;
}
function leaf_copy(leaf) {
  var copy7 = { data: leaf.data }, next = copy7;
  while (leaf = leaf.next)
    next = next.next = { data: leaf.data };
  return copy7;
}
var treeProto = quadtree.prototype = Quadtree.prototype;
treeProto.copy = function() {
  var copy7 = new Quadtree(this._x, this._y, this._x0, this._y0, this._x1, this._y1), node = this._root, nodes, child;
  if (!node)
    return copy7;
  if (!node.length)
    return copy7._root = leaf_copy(node), copy7;
  nodes = [{ source: node, target: copy7._root = new Array(4) }];
  while (node = nodes.pop()) {
    for (var i = 0; i < 4; ++i) {
      if (child = node.source[i]) {
        if (child.length)
          nodes.push({ source: child, target: node.target[i] = new Array(4) });
        else
          node.target[i] = leaf_copy(child);
      }
    }
  }
  return copy7;
};
treeProto.add = add_default;
treeProto.addAll = addAll;
treeProto.cover = cover_default;
treeProto.data = data_default;
treeProto.extent = extent_default;
treeProto.find = find_default4;
treeProto.remove = remove_default3;
treeProto.removeAll = removeAll;
treeProto.root = root_default;
treeProto.size = size_default;
treeProto.visit = visit_default;
treeProto.visitAfter = visitAfter_default;
treeProto.x = x_default;
treeProto.y = y_default;

// node_modules/d3-force/src/constant.js
function constant_default3(x3) {
  return function() {
    return x3;
  };
}

// node_modules/d3-force/src/jiggle.js
function jiggle_default(random6) {
  return (random6() - 0.5) * 1e-6;
}

// node_modules/d3-force/src/link.js
function index2(d2) {
  return d2.index;
}
function find3(nodeById, nodeId) {
  var node = nodeById.get(nodeId);
  if (!node)
    throw new Error("node not found: " + nodeId);
  return node;
}
function link_default(links) {
  var id3 = index2, strength = defaultStrength, strengths, distance7 = constant_default3(30), distances, nodes, count4, bias, random6, iterations2 = 1;
  if (links == null)
    links = [];
  function defaultStrength(link3) {
    return 1 / Math.min(count4[link3.source.index], count4[link3.target.index]);
  }
  function force(alpha) {
    for (var k2 = 0, n = links.length; k2 < iterations2; ++k2) {
      for (var i = 0, link3, source, target, x3, y3, l, b; i < n; ++i) {
        link3 = links[i], source = link3.source, target = link3.target;
        x3 = target.x + target.vx - source.x - source.vx || jiggle_default(random6);
        y3 = target.y + target.vy - source.y - source.vy || jiggle_default(random6);
        l = Math.sqrt(x3 * x3 + y3 * y3);
        l = (l - distances[i]) / l * alpha * strengths[i];
        x3 *= l, y3 *= l;
        target.vx -= x3 * (b = bias[i]);
        target.vy -= y3 * b;
        source.vx += x3 * (b = 1 - b);
        source.vy += y3 * b;
      }
    }
  }
  function initialize() {
    if (!nodes)
      return;
    var i, n = nodes.length, m3 = links.length, nodeById = new Map(nodes.map((d2, i2) => [id3(d2, i2, nodes), d2])), link3;
    for (i = 0, count4 = new Array(n); i < m3; ++i) {
      link3 = links[i], link3.index = i;
      if (typeof link3.source !== "object")
        link3.source = find3(nodeById, link3.source);
      if (typeof link3.target !== "object")
        link3.target = find3(nodeById, link3.target);
      count4[link3.source.index] = (count4[link3.source.index] || 0) + 1;
      count4[link3.target.index] = (count4[link3.target.index] || 0) + 1;
    }
    for (i = 0, bias = new Array(m3); i < m3; ++i) {
      link3 = links[i], bias[i] = count4[link3.source.index] / (count4[link3.source.index] + count4[link3.target.index]);
    }
    strengths = new Array(m3), initializeStrength();
    distances = new Array(m3), initializeDistance();
  }
  function initializeStrength() {
    if (!nodes)
      return;
    for (var i = 0, n = links.length; i < n; ++i) {
      strengths[i] = +strength(links[i], i, links);
    }
  }
  function initializeDistance() {
    if (!nodes)
      return;
    for (var i = 0, n = links.length; i < n; ++i) {
      distances[i] = +distance7(links[i], i, links);
    }
  }
  force.initialize = function(_nodes, _random) {
    nodes = _nodes;
    random6 = _random;
    initialize();
  };
  force.links = function(_2) {
    return arguments.length ? (links = _2, initialize(), force) : links;
  };
  force.id = function(_2) {
    return arguments.length ? (id3 = _2, force) : id3;
  };
  force.iterations = function(_2) {
    return arguments.length ? (iterations2 = +_2, force) : iterations2;
  };
  force.strength = function(_2) {
    return arguments.length ? (strength = typeof _2 === "function" ? _2 : constant_default3(+_2), initializeStrength(), force) : strength;
  };
  force.distance = function(_2) {
    return arguments.length ? (distance7 = typeof _2 === "function" ? _2 : constant_default3(+_2), initializeDistance(), force) : distance7;
  };
  return force;
}

// node_modules/d3-dispatch/src/dispatch.js
var noop = { value: () => {
} };
function dispatch() {
  for (var i = 0, n = arguments.length, _2 = {}, t; i < n; ++i) {
    if (!(t = arguments[i] + "") || t in _2 || /[\s.]/.test(t))
      throw new Error("illegal type: " + t);
    _2[t] = [];
  }
  return new Dispatch(_2);
}
function Dispatch(_2) {
  this._ = _2;
}
function parseTypenames(typenames, types) {
  return typenames.trim().split(/^|\s+/).map(function(t) {
    var name2 = "", i = t.indexOf(".");
    if (i >= 0)
      name2 = t.slice(i + 1), t = t.slice(0, i);
    if (t && !types.hasOwnProperty(t))
      throw new Error("unknown type: " + t);
    return { type: t, name: name2 };
  });
}
Dispatch.prototype = dispatch.prototype = {
  constructor: Dispatch,
  on: function(typename, callback) {
    var _2 = this._, T = parseTypenames(typename + "", _2), t, i = -1, n = T.length;
    if (arguments.length < 2) {
      while (++i < n)
        if ((t = (typename = T[i]).type) && (t = get(_2[t], typename.name)))
          return t;
      return;
    }
    if (callback != null && typeof callback !== "function")
      throw new Error("invalid callback: " + callback);
    while (++i < n) {
      if (t = (typename = T[i]).type)
        _2[t] = set7(_2[t], typename.name, callback);
      else if (callback == null)
        for (t in _2)
          _2[t] = set7(_2[t], typename.name, null);
    }
    return this;
  },
  copy: function() {
    var copy7 = {}, _2 = this._;
    for (var t in _2)
      copy7[t] = _2[t].slice();
    return new Dispatch(copy7);
  },
  call: function(type, that) {
    if ((n = arguments.length - 2) > 0)
      for (var args = new Array(n), i = 0, n, t; i < n; ++i)
        args[i] = arguments[i + 2];
    if (!this._.hasOwnProperty(type))
      throw new Error("unknown type: " + type);
    for (t = this._[type], i = 0, n = t.length; i < n; ++i)
      t[i].value.apply(that, args);
  },
  apply: function(type, that, args) {
    if (!this._.hasOwnProperty(type))
      throw new Error("unknown type: " + type);
    for (var t = this._[type], i = 0, n = t.length; i < n; ++i)
      t[i].value.apply(that, args);
  }
};
function get(type, name2) {
  for (var i = 0, n = type.length, c5; i < n; ++i) {
    if ((c5 = type[i]).name === name2) {
      return c5.value;
    }
  }
}
function set7(type, name2, callback) {
  for (var i = 0, n = type.length; i < n; ++i) {
    if (type[i].name === name2) {
      type[i] = noop, type = type.slice(0, i).concat(type.slice(i + 1));
      break;
    }
  }
  if (callback != null)
    type.push({ name: name2, value: callback });
  return type;
}
var dispatch_default = dispatch;

// node_modules/d3-timer/src/timer.js
var frame = 0;
var timeout = 0;
var interval = 0;
var pokeDelay = 1e3;
var taskHead;
var taskTail;
var clockLast = 0;
var clockNow = 0;
var clockSkew = 0;
var clock2 = typeof performance === "object" && performance.now ? performance : Date;
var setFrame = typeof window === "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(f) {
  setTimeout(f, 17);
};
function now() {
  return clockNow || (setFrame(clearNow), clockNow = clock2.now() + clockSkew);
}
function clearNow() {
  clockNow = 0;
}
function Timer() {
  this._call = this._time = this._next = null;
}
Timer.prototype = timer.prototype = {
  constructor: Timer,
  restart: function(callback, delay2, time) {
    if (typeof callback !== "function")
      throw new TypeError("callback is not a function");
    time = (time == null ? now() : +time) + (delay2 == null ? 0 : +delay2);
    if (!this._next && taskTail !== this) {
      if (taskTail)
        taskTail._next = this;
      else
        taskHead = this;
      taskTail = this;
    }
    this._call = callback;
    this._time = time;
    sleep();
  },
  stop: function() {
    if (this._call) {
      this._call = null;
      this._time = Infinity;
      sleep();
    }
  }
};
function timer(callback, delay2, time) {
  var t = new Timer();
  t.restart(callback, delay2, time);
  return t;
}
function timerFlush() {
  now();
  ++frame;
  var t = taskHead, e;
  while (t) {
    if ((e = clockNow - t._time) >= 0)
      t._call.call(void 0, e);
    t = t._next;
  }
  --frame;
}
function wake() {
  clockNow = (clockLast = clock2.now()) + clockSkew;
  frame = timeout = 0;
  try {
    timerFlush();
  } finally {
    frame = 0;
    nap();
    clockNow = 0;
  }
}
function poke() {
  var now3 = clock2.now(), delay2 = now3 - clockLast;
  if (delay2 > pokeDelay)
    clockSkew -= delay2, clockLast = now3;
}
function nap() {
  var t02, t12 = taskHead, t22, time = Infinity;
  while (t12) {
    if (t12._call) {
      if (time > t12._time)
        time = t12._time;
      t02 = t12, t12 = t12._next;
    } else {
      t22 = t12._next, t12._next = null;
      t12 = t02 ? t02._next = t22 : taskHead = t22;
    }
  }
  taskTail = t02;
  sleep(time);
}
function sleep(time) {
  if (frame)
    return;
  if (timeout)
    timeout = clearTimeout(timeout);
  var delay2 = time - clockNow;
  if (delay2 > 24) {
    if (time < Infinity)
      timeout = setTimeout(wake, time - clock2.now() - clockSkew);
    if (interval)
      interval = clearInterval(interval);
  } else {
    if (!interval)
      clockLast = clock2.now(), interval = setInterval(poke, pokeDelay);
    frame = 1, setFrame(wake);
  }
}

// node_modules/d3-force/src/lcg.js
var a3 = 1664525;
var c2 = 1013904223;
var m2 = 4294967296;
function lcg_default2() {
  let s2 = 1;
  return () => (s2 = (a3 * s2 + c2) % m2) / m2;
}

// node_modules/d3-force/src/simulation.js
function x2(d2) {
  return d2.x;
}
function y2(d2) {
  return d2.y;
}
var initialRadius = 10;
var initialAngle = Math.PI * (3 - Math.sqrt(5));
function simulation_default(nodes) {
  var simulation, alpha = 1, alphaMin = 1e-3, alphaDecay = 1 - Math.pow(alphaMin, 1 / 300), alphaTarget = 0, velocityDecay = 0.6, forces = /* @__PURE__ */ new Map(), stepper = timer(step2), event = dispatch_default("tick", "end"), random6 = lcg_default2();
  if (nodes == null)
    nodes = [];
  function step2() {
    tick3();
    event.call("tick", simulation);
    if (alpha < alphaMin) {
      stepper.stop();
      event.call("end", simulation);
    }
  }
  function tick3(iterations2) {
    var i, n = nodes.length, node;
    if (iterations2 === void 0)
      iterations2 = 1;
    for (var k2 = 0; k2 < iterations2; ++k2) {
      alpha += (alphaTarget - alpha) * alphaDecay;
      forces.forEach(function(force) {
        force(alpha);
      });
      for (i = 0; i < n; ++i) {
        node = nodes[i];
        if (node.fx == null)
          node.x += node.vx *= velocityDecay;
        else
          node.x = node.fx, node.vx = 0;
        if (node.fy == null)
          node.y += node.vy *= velocityDecay;
        else
          node.y = node.fy, node.vy = 0;
      }
    }
    return simulation;
  }
  function initializeNodes() {
    for (var i = 0, n = nodes.length, node; i < n; ++i) {
      node = nodes[i], node.index = i;
      if (node.fx != null)
        node.x = node.fx;
      if (node.fy != null)
        node.y = node.fy;
      if (isNaN(node.x) || isNaN(node.y)) {
        var radius = initialRadius * Math.sqrt(0.5 + i), angle4 = i * initialAngle;
        node.x = radius * Math.cos(angle4);
        node.y = radius * Math.sin(angle4);
      }
      if (isNaN(node.vx) || isNaN(node.vy)) {
        node.vx = node.vy = 0;
      }
    }
  }
  function initializeForce(force) {
    if (force.initialize)
      force.initialize(nodes, random6);
    return force;
  }
  initializeNodes();
  return simulation = {
    tick: tick3,
    restart: function() {
      return stepper.restart(step2), simulation;
    },
    stop: function() {
      return stepper.stop(), simulation;
    },
    nodes: function(_2) {
      return arguments.length ? (nodes = _2, initializeNodes(), forces.forEach(initializeForce), simulation) : nodes;
    },
    alpha: function(_2) {
      return arguments.length ? (alpha = +_2, simulation) : alpha;
    },
    alphaMin: function(_2) {
      return arguments.length ? (alphaMin = +_2, simulation) : alphaMin;
    },
    alphaDecay: function(_2) {
      return arguments.length ? (alphaDecay = +_2, simulation) : +alphaDecay;
    },
    alphaTarget: function(_2) {
      return arguments.length ? (alphaTarget = +_2, simulation) : alphaTarget;
    },
    velocityDecay: function(_2) {
      return arguments.length ? (velocityDecay = 1 - _2, simulation) : 1 - velocityDecay;
    },
    randomSource: function(_2) {
      return arguments.length ? (random6 = _2, forces.forEach(initializeForce), simulation) : random6;
    },
    force: function(name2, _2) {
      return arguments.length > 1 ? (_2 == null ? forces.delete(name2) : forces.set(name2, initializeForce(_2)), simulation) : forces.get(name2);
    },
    find: function(x3, y3, radius) {
      var i = 0, n = nodes.length, dx, dy, d2, node, closest;
      if (radius == null)
        radius = Infinity;
      else
        radius *= radius;
      for (i = 0; i < n; ++i) {
        node = nodes[i];
        dx = x3 - node.x;
        dy = y3 - node.y;
        d2 = dx * dx + dy * dy;
        if (d2 < radius)
          closest = node, radius = d2;
      }
      return closest;
    },
    on: function(name2, _2) {
      return arguments.length > 1 ? (event.on(name2, _2), simulation) : event.on(name2);
    }
  };
}

// node_modules/d3-force/src/manyBody.js
function manyBody_default() {
  var nodes, node, random6, alpha, strength = constant_default3(-30), strengths, distanceMin2 = 1, distanceMax2 = Infinity, theta2 = 0.81;
  function force(_2) {
    var i, n = nodes.length, tree = quadtree(nodes, x2, y2).visitAfter(accumulate);
    for (alpha = _2, i = 0; i < n; ++i)
      node = nodes[i], tree.visit(apply2);
  }
  function initialize() {
    if (!nodes)
      return;
    var i, n = nodes.length, node2;
    strengths = new Array(n);
    for (i = 0; i < n; ++i)
      node2 = nodes[i], strengths[node2.index] = +strength(node2, i, nodes);
  }
  function accumulate(quad) {
    var strength2 = 0, q, c5, weight2 = 0, x3, y3, i;
    if (quad.length) {
      for (x3 = y3 = i = 0; i < 4; ++i) {
        if ((q = quad[i]) && (c5 = Math.abs(q.value))) {
          strength2 += q.value, weight2 += c5, x3 += c5 * q.x, y3 += c5 * q.y;
        }
      }
      quad.x = x3 / weight2;
      quad.y = y3 / weight2;
    } else {
      q = quad;
      q.x = q.data.x;
      q.y = q.data.y;
      do
        strength2 += strengths[q.data.index];
      while (q = q.next);
    }
    quad.value = strength2;
  }
  function apply2(quad, x12, _2, x22) {
    if (!quad.value)
      return true;
    var x3 = quad.x - node.x, y3 = quad.y - node.y, w = x22 - x12, l = x3 * x3 + y3 * y3;
    if (w * w / theta2 < l) {
      if (l < distanceMax2) {
        if (x3 === 0)
          x3 = jiggle_default(random6), l += x3 * x3;
        if (y3 === 0)
          y3 = jiggle_default(random6), l += y3 * y3;
        if (l < distanceMin2)
          l = Math.sqrt(distanceMin2 * l);
        node.vx += x3 * quad.value * alpha / l;
        node.vy += y3 * quad.value * alpha / l;
      }
      return true;
    } else if (quad.length || l >= distanceMax2)
      return;
    if (quad.data !== node || quad.next) {
      if (x3 === 0)
        x3 = jiggle_default(random6), l += x3 * x3;
      if (y3 === 0)
        y3 = jiggle_default(random6), l += y3 * y3;
      if (l < distanceMin2)
        l = Math.sqrt(distanceMin2 * l);
    }
    do
      if (quad.data !== node) {
        w = strengths[quad.data.index] * alpha / l;
        node.vx += x3 * w;
        node.vy += y3 * w;
      }
    while (quad = quad.next);
  }
  force.initialize = function(_nodes, _random) {
    nodes = _nodes;
    random6 = _random;
    initialize();
  };
  force.strength = function(_2) {
    return arguments.length ? (strength = typeof _2 === "function" ? _2 : constant_default3(+_2), initialize(), force) : strength;
  };
  force.distanceMin = function(_2) {
    return arguments.length ? (distanceMin2 = _2 * _2, force) : Math.sqrt(distanceMin2);
  };
  force.distanceMax = function(_2) {
    return arguments.length ? (distanceMax2 = _2 * _2, force) : Math.sqrt(distanceMax2);
  };
  force.theta = function(_2) {
    return arguments.length ? (theta2 = _2 * _2, force) : Math.sqrt(theta2);
  };
  return force;
}

// node_modules/d3-force/src/x.js
function x_default2(x3) {
  var strength = constant_default3(0.1), nodes, strengths, xz;
  if (typeof x3 !== "function")
    x3 = constant_default3(x3 == null ? 0 : +x3);
  function force(alpha) {
    for (var i = 0, n = nodes.length, node; i < n; ++i) {
      node = nodes[i], node.vx += (xz[i] - node.x) * strengths[i] * alpha;
    }
  }
  function initialize() {
    if (!nodes)
      return;
    var i, n = nodes.length;
    strengths = new Array(n);
    xz = new Array(n);
    for (i = 0; i < n; ++i) {
      strengths[i] = isNaN(xz[i] = +x3(nodes[i], i, nodes)) ? 0 : +strength(nodes[i], i, nodes);
    }
  }
  force.initialize = function(_2) {
    nodes = _2;
    initialize();
  };
  force.strength = function(_2) {
    return arguments.length ? (strength = typeof _2 === "function" ? _2 : constant_default3(+_2), initialize(), force) : strength;
  };
  force.x = function(_2) {
    return arguments.length ? (x3 = typeof _2 === "function" ? _2 : constant_default3(+_2), initialize(), force) : x3;
  };
  return force;
}

// node_modules/d3-force/src/y.js
function y_default2(y3) {
  var strength = constant_default3(0.1), nodes, strengths, yz;
  if (typeof y3 !== "function")
    y3 = constant_default3(y3 == null ? 0 : +y3);
  function force(alpha) {
    for (var i = 0, n = nodes.length, node; i < n; ++i) {
      node = nodes[i], node.vy += (yz[i] - node.y) * strengths[i] * alpha;
    }
  }
  function initialize() {
    if (!nodes)
      return;
    var i, n = nodes.length;
    strengths = new Array(n);
    yz = new Array(n);
    for (i = 0; i < n; ++i) {
      strengths[i] = isNaN(yz[i] = +y3(nodes[i], i, nodes)) ? 0 : +strength(nodes[i], i, nodes);
    }
  }
  force.initialize = function(_2) {
    nodes = _2;
    initialize();
  };
  force.strength = function(_2) {
    return arguments.length ? (strength = typeof _2 === "function" ? _2 : constant_default3(+_2), initialize(), force) : strength;
  };
  force.y = function(_2) {
    return arguments.length ? (y3 = typeof _2 === "function" ? _2 : constant_default3(+_2), initialize(), force) : y3;
  };
  return force;
}

// node_modules/@antv/g2/esm/mark/forceGraph.js
var __rest48 = function(s2, e) {
  var t = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
      t[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t[p2[i]] = s2[p2[i]];
    }
  return t;
};
var DEFAULT_LAYOUT_OPTIONS3 = {
  joint: true
};
var DEFAULT_LINK_OPTIONS3 = {
  type: "link",
  axis: false,
  legend: false,
  encode: {
    x: [(d2) => d2.source.x, (d2) => d2.target.x],
    y: [(d2) => d2.source.y, (d2) => d2.target.y]
  },
  style: {
    stroke: "#999",
    strokeOpacity: 0.6
  }
};
var DEFAULT_NODE_OPTIONS3 = {
  type: "point",
  axis: false,
  legend: false,
  encode: {
    x: "x",
    y: "y",
    size: 5,
    color: "group",
    shape: "point"
  },
  style: {
    stroke: "#fff"
  }
};
var DEFAULT_LABEL_OPTIONS5 = {
  text: ""
};
function dataTransform3(data2, layout, encode) {
  const { nodes, links } = data2;
  const { joint, nodeStrength, linkStrength } = layout;
  const { nodeKey = (d2) => d2.id, linkKey = (d2) => d2.id } = encode;
  const nodeForce = manyBody_default();
  const linkForce = link_default(links).id(field(linkKey));
  typeof nodeStrength === "function" && nodeForce.strength(nodeStrength);
  typeof linkStrength === "function" && linkForce.strength(linkStrength);
  const simulation = simulation_default(nodes).force("link", linkForce).force("charge", nodeForce);
  joint ? simulation.force("center", center_default()) : simulation.force("x", x_default2()).force("y", y_default2());
  simulation.stop();
  const n = Math.ceil(Math.log(simulation.alphaMin()) / Math.log(1 - simulation.alphaDecay()));
  for (let i = 0; i < n; i++)
    simulation.tick();
  return {
    nodesData: nodes,
    linksData: links
  };
}
var ForceGraph = (options) => {
  const { data: data2, encode: e = {}, scale: scale10, style = {}, layout = {}, nodeLabels = [], linkLabels = [], animate: animate2 = {}, tooltip: tooltip2 = {} } = options;
  const { nodeKey = (d2) => d2.id, linkKey = (d2) => d2.id } = e, restEncode = __rest48(e, ["nodeKey", "linkKey"]);
  const encode = Object.assign({ nodeKey, linkKey }, restEncode);
  const nodeEncode = subObject(encode, "node");
  const linkEncode = subObject(encode, "link");
  const { links, nodes } = initializeData(data2, encode);
  const { nodesData, linksData } = dataTransform3({ links, nodes }, deep_mix_default({}, DEFAULT_LAYOUT_OPTIONS3, layout), encode);
  const linkTooltip = subTooltip(tooltip2, "link", {
    items: [
      (d2) => ({ name: "source", value: field(linkKey)(d2.source) }),
      (d2) => ({ name: "target", value: field(linkKey)(d2.target) })
    ]
  });
  const nodeTooltip = subTooltip(tooltip2, "node", {
    items: [(d2) => ({ name: "key", value: field(nodeKey)(d2) })]
  }, true);
  return [
    deep_mix_default({}, DEFAULT_LINK_OPTIONS3, {
      data: linksData,
      encode: linkEncode,
      labels: linkLabels,
      style: subObject(style, "link"),
      tooltip: linkTooltip,
      animate: maybeAnimation(animate2, "link")
    }),
    deep_mix_default({}, DEFAULT_NODE_OPTIONS3, {
      data: nodesData,
      encode: Object.assign({}, nodeEncode),
      scale: scale10,
      style: subObject(style, "node"),
      tooltip: nodeTooltip,
      labels: [
        Object.assign(Object.assign({}, DEFAULT_LABEL_OPTIONS5), subObject(style, "label")),
        ...nodeLabels
      ],
      animate: maybeAnimation(animate2, "link")
    })
  ];
};
ForceGraph.props = {};

// node_modules/@antv/g2/esm/data/cluster.js
var hierarchyFunction = (layoutFunction) => (options) => {
  return (data2) => {
    const { field: field3 = "value", nodeSize, separation, sortBy: sortBy2, as = ["x", "y"] } = options;
    const [x3, y3] = as;
    const root3 = hierarchy(data2, (d2) => d2.children).sum((d2) => d2[field3]).sort(sortBy2);
    const c5 = layoutFunction();
    c5.size([1, 1]);
    if (nodeSize)
      c5.nodeSize(nodeSize);
    if (separation)
      c5.separation(separation);
    c5(root3);
    const nodes = [];
    root3.each((node) => {
      node[x3] = node.x;
      node[y3] = node.y;
      node.name = node.data.name;
      nodes.push(node);
    });
    const edges = root3.links();
    edges.forEach((edge) => {
      edge[x3] = [edge.source[x3], edge.target[x3]];
      edge[y3] = [edge.source[y3], edge.target[y3]];
    });
    return { nodes, edges };
  };
};
var Cluster = (options) => {
  return hierarchyFunction(cluster_default)(options);
};
Cluster.props = {};

// node_modules/@antv/g2/esm/data/tree.js
var Tree = (options) => {
  return hierarchyFunction(tree_default)(options);
};
Tree.props = {};

// node_modules/@antv/g2/esm/mark/tree.js
var DEFAULT_LAYOUT_OPTIONS4 = {
  sortBy: (a4, b) => b.value - a4.value
};
var DEFAULT_NODE_OPTIONS4 = {
  axis: false,
  legend: false,
  type: "point",
  encode: {
    x: "x",
    y: "y",
    size: 2,
    shape: "point"
  }
};
var DEFAULT_LINK_OPTIONS4 = {
  type: "link",
  encode: {
    x: "x",
    y: "y",
    shape: "smooth"
  }
};
var DEFAULT_LABEL_OPTIONS6 = {
  text: "",
  fontSize: 10
};
var Tree2 = (options) => {
  const { data: data2, encode = {}, scale: scale10 = {}, style = {}, layout = {}, nodeLabels = [], linkLabels = [], animate: animate2 = {}, tooltip: tooltip2 = {} } = options;
  const valueEncode = encode === null || encode === void 0 ? void 0 : encode.value;
  const { nodes, edges } = Tree(Object.assign(Object.assign(Object.assign({}, DEFAULT_LAYOUT_OPTIONS4), layout), { field: valueEncode }))(data2);
  const nodeTooltip = subTooltip(tooltip2, "node", {
    title: "name",
    items: ["value"]
  }, true);
  const linkTooltip = subTooltip(tooltip2, "link", {
    title: "",
    items: [
      (d2) => ({ name: "source", value: d2.source.name }),
      (d2) => ({ name: "target", value: d2.target.name })
    ]
  });
  return [
    deep_mix_default({}, DEFAULT_LINK_OPTIONS4, {
      data: edges,
      encode: subObject(encode, "link"),
      scale: subObject(scale10, "link"),
      labels: linkLabels,
      style: Object.assign({ stroke: "#999" }, subObject(style, "link")),
      tooltip: linkTooltip,
      animate: maybeAnimation(animate2, "link")
    }),
    deep_mix_default({}, DEFAULT_NODE_OPTIONS4, {
      data: nodes,
      scale: subObject(scale10, "node"),
      encode: subObject(encode, "node"),
      labels: [
        Object.assign(Object.assign({}, DEFAULT_LABEL_OPTIONS6), subObject(style, "label")),
        ...nodeLabels
      ],
      style: Object.assign({}, subObject(style, "node")),
      tooltip: nodeTooltip,
      animate: maybeAnimation(animate2, "node")
    })
  ];
};
Tree2.props = {};

// node_modules/d3-dsv/src/dsv.js
var EOL = {};
var EOF = {};
var QUOTE = 34;
var NEWLINE = 10;
var RETURN = 13;
function objectConverter(columns) {
  return new Function("d", "return {" + columns.map(function(name2, i) {
    return JSON.stringify(name2) + ": d[" + i + '] || ""';
  }).join(",") + "}");
}
function customConverter(columns, f) {
  var object = objectConverter(columns);
  return function(row2, i) {
    return f(object(row2), i, columns);
  };
}
function inferColumns(rows) {
  var columnSet = /* @__PURE__ */ Object.create(null), columns = [];
  rows.forEach(function(row2) {
    for (var column2 in row2) {
      if (!(column2 in columnSet)) {
        columns.push(columnSet[column2] = column2);
      }
    }
  });
  return columns;
}
function pad2(value2, width) {
  var s2 = value2 + "", length5 = s2.length;
  return length5 < width ? new Array(width - length5 + 1).join(0) + s2 : s2;
}
function formatYear(year2) {
  return year2 < 0 ? "-" + pad2(-year2, 6) : year2 > 9999 ? "+" + pad2(year2, 6) : pad2(year2, 4);
}
function formatDate(date) {
  var hours = date.getUTCHours(), minutes = date.getUTCMinutes(), seconds = date.getUTCSeconds(), milliseconds = date.getUTCMilliseconds();
  return isNaN(date) ? "Invalid Date" : formatYear(date.getUTCFullYear(), 4) + "-" + pad2(date.getUTCMonth() + 1, 2) + "-" + pad2(date.getUTCDate(), 2) + (milliseconds ? "T" + pad2(hours, 2) + ":" + pad2(minutes, 2) + ":" + pad2(seconds, 2) + "." + pad2(milliseconds, 3) + "Z" : seconds ? "T" + pad2(hours, 2) + ":" + pad2(minutes, 2) + ":" + pad2(seconds, 2) + "Z" : minutes || hours ? "T" + pad2(hours, 2) + ":" + pad2(minutes, 2) + "Z" : "");
}
function dsv_default(delimiter) {
  var reFormat = new RegExp('["' + delimiter + "\n\r]"), DELIMITER = delimiter.charCodeAt(0);
  function parse(text, f) {
    var convert, columns, rows = parseRows(text, function(row2, i) {
      if (convert)
        return convert(row2, i - 1);
      columns = row2, convert = f ? customConverter(row2, f) : objectConverter(row2);
    });
    rows.columns = columns || [];
    return rows;
  }
  function parseRows(text, f) {
    var rows = [], N = text.length, I = 0, n = 0, t, eof = N <= 0, eol = false;
    if (text.charCodeAt(N - 1) === NEWLINE)
      --N;
    if (text.charCodeAt(N - 1) === RETURN)
      --N;
    function token2() {
      if (eof)
        return EOF;
      if (eol)
        return eol = false, EOL;
      var i, j = I, c5;
      if (text.charCodeAt(j) === QUOTE) {
        while (I++ < N && text.charCodeAt(I) !== QUOTE || text.charCodeAt(++I) === QUOTE)
          ;
        if ((i = I) >= N)
          eof = true;
        else if ((c5 = text.charCodeAt(I++)) === NEWLINE)
          eol = true;
        else if (c5 === RETURN) {
          eol = true;
          if (text.charCodeAt(I) === NEWLINE)
            ++I;
        }
        return text.slice(j + 1, i - 1).replace(/""/g, '"');
      }
      while (I < N) {
        if ((c5 = text.charCodeAt(i = I++)) === NEWLINE)
          eol = true;
        else if (c5 === RETURN) {
          eol = true;
          if (text.charCodeAt(I) === NEWLINE)
            ++I;
        } else if (c5 !== DELIMITER)
          continue;
        return text.slice(j, i);
      }
      return eof = true, text.slice(j, N);
    }
    while ((t = token2()) !== EOF) {
      var row2 = [];
      while (t !== EOL && t !== EOF)
        row2.push(t), t = token2();
      if (f && (row2 = f(row2, n++)) == null)
        continue;
      rows.push(row2);
    }
    return rows;
  }
  function preformatBody(rows, columns) {
    return rows.map(function(row2) {
      return columns.map(function(column2) {
        return formatValue(row2[column2]);
      }).join(delimiter);
    });
  }
  function format3(rows, columns) {
    if (columns == null)
      columns = inferColumns(rows);
    return [columns.map(formatValue).join(delimiter)].concat(preformatBody(rows, columns)).join("\n");
  }
  function formatBody(rows, columns) {
    if (columns == null)
      columns = inferColumns(rows);
    return preformatBody(rows, columns).join("\n");
  }
  function formatRows(rows) {
    return rows.map(formatRow).join("\n");
  }
  function formatRow(row2) {
    return row2.map(formatValue).join(delimiter);
  }
  function formatValue(value2) {
    return value2 == null ? "" : value2 instanceof Date ? formatDate(value2) : reFormat.test(value2 += "") ? '"' + value2.replace(/"/g, '""') + '"' : value2;
  }
  return {
    parse,
    parseRows,
    format: format3,
    formatBody,
    formatRows,
    formatRow,
    formatValue
  };
}

// node_modules/d3-dsv/src/csv.js
var csv = dsv_default(",");
var csvParse = csv.parse;
var csvParseRows = csv.parseRows;
var csvFormat = csv.format;
var csvFormatBody = csv.formatBody;
var csvFormatRows = csv.formatRows;
var csvFormatRow = csv.formatRow;
var csvFormatValue = csv.formatValue;

// node_modules/d3-dsv/src/tsv.js
var tsv = dsv_default("	");
var tsvParse = tsv.parse;
var tsvParseRows = tsv.parseRows;
var tsvFormat = tsv.format;
var tsvFormatBody = tsv.formatBody;
var tsvFormatRows = tsv.formatRows;
var tsvFormatRow = tsv.formatRow;
var tsvFormatValue = tsv.formatValue;

// node_modules/d3-dsv/src/autoType.js
function autoType(object) {
  for (var key in object) {
    var value2 = object[key].trim(), number2, m3;
    if (!value2)
      value2 = null;
    else if (value2 === "true")
      value2 = true;
    else if (value2 === "false")
      value2 = false;
    else if (value2 === "NaN")
      value2 = NaN;
    else if (!isNaN(number2 = +value2))
      value2 = number2;
    else if (m3 = value2.match(/^([-+]\d{2})?\d{4}(-\d{2}(-\d{2})?)?(T\d{2}:\d{2}(:\d{2}(\.\d{3})?)?(Z|[-+]\d{2}:\d{2})?)?$/)) {
      if (fixtz && !!m3[4] && !m3[7])
        value2 = value2.replace(/-/g, "/").replace(/T/, " ");
      value2 = new Date(value2);
    } else
      continue;
    object[key] = value2;
  }
  return object;
}
var fixtz = (/* @__PURE__ */ new Date("2019-01-01T00:00")).getHours() || (/* @__PURE__ */ new Date("2019-07-01T00:00")).getHours();

// node_modules/@antv/g2/esm/data/fetch.js
var __awaiter3 = function(thisArg, _arguments, P, generator) {
  function adopt(value2) {
    return value2 instanceof P ? value2 : new P(function(resolve) {
      resolve(value2);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject2) {
    function fulfilled(value2) {
      try {
        step2(generator.next(value2));
      } catch (e) {
        reject2(e);
      }
    }
    function rejected(value2) {
      try {
        step2(generator["throw"](value2));
      } catch (e) {
        reject2(e);
      }
    }
    function step2(result2) {
      result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
    }
    step2((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var Fetch = (options) => {
  const { value: value2, format: format3 = value2.split(".").pop(), delimiter = ",", autoType: autoType2 = true } = options;
  return () => __awaiter3(void 0, void 0, void 0, function* () {
    const response = yield fetch(value2);
    if (format3 === "csv") {
      const str7 = yield response.text();
      return dsv_default(delimiter).parse(str7, autoType2 ? autoType : identity5);
    } else if (format3 === "json") {
      return yield response.json();
    }
    throw new Error(`Unknown format: ${format3}.`);
  });
};
Fetch.props = {};

// node_modules/@antv/g2/esm/data/fold.js
function isEmpty(obj) {
  return !obj || Object.keys(obj).length === 0;
}
var Fold = (options) => {
  const { fields, key = "key", value: value2 = "value" } = options;
  return (data2) => {
    if (isEmpty(fields))
      return data2;
    return data2.flatMap((d2) => fields.map((f) => Object.assign(Object.assign({}, d2), { [key]: f, [value2]: d2[f] })));
  };
};
Fold.props = {};

// node_modules/@antv/g2/esm/data/filter.js
function defined3(d2) {
  return d2 !== void 0 && d2 !== null && !Number.isNaN(d2);
}
var Filter2 = (options) => {
  const { callback = defined3 } = options;
  return (data2) => data2.filter(callback);
};
Filter2.props = {};

// node_modules/@antv/g2/esm/data/sort.js
var Sort2 = (options) => {
  const { callback } = options;
  return (data2) => Array.isArray(data2) ? [...data2].sort(callback) : data2;
};
Sort2.props = {};

// node_modules/@antv/g2/esm/data/pick.js
function pick(v, fields = []) {
  return fields.reduce((datum, field3) => {
    if (field3 in v) {
      datum[field3] = v[field3];
    }
    return datum;
  }, {});
}
var Pick = (options) => {
  const { fields } = options;
  return (data2) => data2.map((d2) => pick(d2, fields));
};
Pick.props = {};

// node_modules/@antv/g2/esm/data/rename.js
function isEmpty2(obj) {
  return Object.keys(obj).length === 0;
}
var Rename = (options) => {
  return (data2) => {
    if (!options || isEmpty2(options))
      return data2;
    const rename = (v) => Object.entries(v).reduce((datum, [key, value2]) => (datum[options[key] || key] = value2, datum), {});
    return data2.map(rename);
  };
};
Rename.props = {};

// node_modules/@antv/g2/esm/data/utils/fields.js
function normalizeFields(fields, defaultValue) {
  return fields.map((d2) => {
    if (Array.isArray(d2)) {
      const [field3, value2 = defaultValue] = d2;
      return [field3, value2];
    }
    return [d2, defaultValue];
  });
}

// node_modules/@antv/g2/esm/data/sortBy.js
var SortBy = (options) => {
  const { fields: F = [] } = options;
  const normalizedF = normalizeFields(F, true);
  return (data2) => {
    const comparator = (a4, b) => normalizedF.reduce((ret, [field3, order = true]) => {
      if (ret !== 0) {
        return ret;
      }
      if (order) {
        return a4[field3] < b[field3] ? -1 : +(a4[field3] !== b[field3]);
      } else {
        return a4[field3] > b[field3] ? -1 : +(a4[field3] !== b[field3]);
      }
    }, 0);
    return [...data2].sort(comparator);
  };
};
SortBy.props = {};

// node_modules/@antv/g2/esm/data/inline.js
var Inline = (options) => {
  const { value: value2 } = options;
  return () => value2;
};
Inline.props = {};

// node_modules/@antv/g2/esm/data/custom.js
var Custom = (options) => {
  const { callback = identity5 } = options;
  return (data2) => callback(data2);
};
Custom.props = {};

// node_modules/@antv/g2/esm/data/map.js
var Map2 = (options) => {
  const { callback = identity5 } = options;
  return (data2) => Array.isArray(data2) ? data2.map(callback) : data2;
};
Map2.props = {};

// node_modules/@antv/g2/esm/data/utils/d3-cloud/index.js
var cloudRadians = Math.PI / 180;
var cw = 1 << 11 >> 5;
var ch = 1 << 11;
function cloudText(d2) {
  return d2.text;
}
function cloudFont() {
  return "serif";
}
function cloudFontNormal() {
  return "normal";
}
function cloudFontSize(d2) {
  return d2.value;
}
function cloudRotate() {
  return ~~(Math.random() * 2) * 90;
}
function cloudPadding() {
  return 1;
}
function cloudDispatch() {
  return;
}
function cloudSprite(contextAndRatio, d2, data2, di) {
  if (d2.sprite)
    return;
  const c5 = contextAndRatio.context, ratio = contextAndRatio.ratio;
  c5.clearRect(0, 0, (cw << 5) / ratio, ch / ratio);
  let x3 = 0, y3 = 0, maxh = 0;
  const n = data2.length;
  --di;
  while (++di < n) {
    d2 = data2[di];
    c5.save();
    c5.font = d2.style + " " + d2.weight + " " + ~~((d2.size + 1) / ratio) + "px " + d2.font;
    let w = c5.measureText(d2.text + "m").width * ratio, h = d2.size << 1;
    if (d2.rotate) {
      const sr = Math.sin(d2.rotate * cloudRadians), cr = Math.cos(d2.rotate * cloudRadians), wcr = w * cr, wsr = w * sr, hcr = h * cr, hsr = h * sr;
      w = Math.max(Math.abs(wcr + hsr), Math.abs(wcr - hsr)) + 31 >> 5 << 5;
      h = ~~Math.max(Math.abs(wsr + hcr), Math.abs(wsr - hcr));
    } else {
      w = w + 31 >> 5 << 5;
    }
    if (h > maxh)
      maxh = h;
    if (x3 + w >= cw << 5) {
      x3 = 0;
      y3 += maxh;
      maxh = 0;
    }
    if (y3 + h >= ch)
      break;
    c5.translate((x3 + (w >> 1)) / ratio, (y3 + (h >> 1)) / ratio);
    if (d2.rotate)
      c5.rotate(d2.rotate * cloudRadians);
    c5.fillText(d2.text, 0, 0);
    if (d2.padding) {
      c5.lineWidth = 2 * d2.padding;
      c5.strokeText(d2.text, 0, 0);
    }
    c5.restore();
    d2.width = w;
    d2.height = h;
    d2.xoff = x3;
    d2.yoff = y3;
    d2.x1 = w >> 1;
    d2.y1 = h >> 1;
    d2.x0 = -d2.x1;
    d2.y0 = -d2.y1;
    d2.hasText = true;
    x3 += w;
  }
  const pixels = c5.getImageData(0, 0, (cw << 5) / ratio, ch / ratio).data, sprite = [];
  while (--di >= 0) {
    d2 = data2[di];
    if (!d2.hasText)
      continue;
    const w = d2.width, w32 = w >> 5;
    let h = d2.y1 - d2.y0;
    for (let i = 0; i < h * w32; i++)
      sprite[i] = 0;
    x3 = d2.xoff;
    if (x3 == null)
      return;
    y3 = d2.yoff;
    let seen = 0, seenRow = -1;
    for (let j = 0; j < h; j++) {
      for (let i = 0; i < w; i++) {
        const k2 = w32 * j + (i >> 5), m3 = pixels[(y3 + j) * (cw << 5) + (x3 + i) << 2] ? 1 << 31 - i % 32 : 0;
        sprite[k2] |= m3;
        seen |= m3;
      }
      if (seen)
        seenRow = j;
      else {
        d2.y0++;
        h--;
        j--;
        y3++;
      }
    }
    d2.y1 = d2.y0 + seenRow;
    d2.sprite = sprite.slice(0, (d2.y1 - d2.y0) * w32);
  }
}
function cloudCollide(tag, board, sw) {
  sw >>= 5;
  const sprite = tag.sprite, w = tag.width >> 5, lx = tag.x - (w << 4), sx = lx & 127, msx = 32 - sx, h = tag.y1 - tag.y0;
  let x3 = (tag.y + tag.y0) * sw + (lx >> 5), last7;
  for (let j = 0; j < h; j++) {
    last7 = 0;
    for (let i = 0; i <= w; i++) {
      if ((last7 << msx | (i < w ? (last7 = sprite[j * w + i]) >>> sx : 0)) & board[x3 + i])
        return true;
    }
    x3 += sw;
  }
  return false;
}
function cloudBounds(bounds, d2) {
  const b0 = bounds[0], b1 = bounds[1];
  if (d2.x + d2.x0 < b0.x)
    b0.x = d2.x + d2.x0;
  if (d2.y + d2.y0 < b0.y)
    b0.y = d2.y + d2.y0;
  if (d2.x + d2.x1 > b1.x)
    b1.x = d2.x + d2.x1;
  if (d2.y + d2.y1 > b1.y)
    b1.y = d2.y + d2.y1;
}
function collideRects(a4, b) {
  return a4.x + a4.x1 > b[0].x && a4.x + a4.x0 < b[1].x && a4.y + a4.y1 > b[0].y && a4.y + a4.y0 < b[1].y;
}
function archimedeanSpiral(size5) {
  const e = size5[0] / size5[1];
  return function(t) {
    return [e * (t *= 0.1) * Math.cos(t), t * Math.sin(t)];
  };
}
function rectangularSpiral(size5) {
  const dy = 4, dx = dy * size5[0] / size5[1];
  let x3 = 0, y3 = 0;
  return function(t) {
    const sign3 = t < 0 ? -1 : 1;
    switch (Math.sqrt(1 + 4 * sign3 * t) - sign3 & 3) {
      case 0:
        x3 += dx;
        break;
      case 1:
        y3 += dy;
        break;
      case 2:
        x3 -= dx;
        break;
      default:
        y3 -= dy;
        break;
    }
    return [x3, y3];
  };
}
function zeroArray(n) {
  const a4 = [];
  let i = -1;
  while (++i < n)
    a4[i] = 0;
  return a4;
}
function cloudCanvas() {
  return document.createElement("canvas");
}
function functor(d2) {
  return typeof d2 === "function" ? d2 : function() {
    return d2;
  };
}
var spirals = {
  archimedean: archimedeanSpiral,
  rectangular: rectangularSpiral
};
function tagCloud() {
  let size5 = [256, 256], text = cloudText, font = cloudFont, fontSize = cloudFontSize, fontWeight = cloudFontNormal, rotate6 = cloudRotate, padding = cloudPadding, spiral = archimedeanSpiral, random6 = Math.random, event = cloudDispatch, words2 = [], timer2 = null, timeInterval = Infinity;
  const fontStyle = cloudFontNormal;
  const canvas = cloudCanvas;
  const cloud = {};
  cloud.start = function() {
    const [width, height] = size5;
    const contextAndRatio = getContext(canvas()), board = cloud.board ? cloud.board : zeroArray((size5[0] >> 5) * size5[1]), n = words2.length, tags = [], data2 = words2.map(function(d2, i2, data3) {
      d2.text = text.call(this, d2, i2, data3);
      d2.font = font.call(this, d2, i2, data3);
      d2.style = fontStyle.call(this, d2, i2, data3);
      d2.weight = fontWeight.call(this, d2, i2, data3);
      d2.rotate = rotate6.call(this, d2, i2, data3);
      d2.size = ~~fontSize.call(this, d2, i2, data3);
      d2.padding = padding.call(this, d2, i2, data3);
      return d2;
    }).sort(function(a4, b) {
      return b.size - a4.size;
    });
    let i = -1, bounds = !cloud.board ? void 0 : [
      {
        x: 0,
        y: 0
      },
      {
        x: width,
        y: height
      }
    ];
    if (timer2)
      clearInterval(timer2);
    timer2 = setInterval(step2, 0);
    step2();
    function step2() {
      const start = Date.now();
      while (Date.now() - start < timeInterval && ++i < n) {
        const d2 = data2[i];
        d2.x = width * (random6() + 0.5) >> 1;
        d2.y = height * (random6() + 0.5) >> 1;
        cloudSprite(contextAndRatio, d2, data2, i);
        if (d2.hasText && place2(board, d2, bounds)) {
          event.call(null, "word", { cloud, word: d2 });
          tags.push(d2);
          if (bounds) {
            if (!cloud.hasImage) {
              cloudBounds(bounds, d2);
            }
          } else {
            bounds = [
              { x: d2.x + d2.x0, y: d2.y + d2.y0 },
              { x: d2.x + d2.x1, y: d2.y + d2.y1 }
            ];
          }
          d2.x -= size5[0] >> 1;
          d2.y -= size5[1] >> 1;
        }
      }
      cloud._tags = tags;
      cloud._bounds = bounds;
      if (i >= n) {
        cloud.stop();
        event.call(null, "end", { cloud, words: tags, bounds });
      }
    }
    return cloud;
  };
  cloud.stop = function() {
    if (timer2) {
      clearInterval(timer2);
      timer2 = null;
    }
    return cloud;
  };
  function getContext(canvas2) {
    canvas2.width = canvas2.height = 1;
    const ratio = Math.sqrt(canvas2.getContext("2d").getImageData(0, 0, 1, 1).data.length >> 2);
    canvas2.width = (cw << 5) / ratio;
    canvas2.height = ch / ratio;
    const context = canvas2.getContext("2d");
    context.fillStyle = context.strokeStyle = "red";
    context.textAlign = "center";
    return { context, ratio };
  }
  function place2(board, tag, bounds) {
    const startX = tag.x, startY = tag.y, maxDelta = Math.sqrt(size5[0] * size5[0] + size5[1] * size5[1]), s2 = spiral(size5), dt = random6() < 0.5 ? 1 : -1;
    let dxdy, t = -dt, dx, dy;
    while (dxdy = s2(t += dt)) {
      dx = ~~dxdy[0];
      dy = ~~dxdy[1];
      if (Math.min(Math.abs(dx), Math.abs(dy)) >= maxDelta)
        break;
      tag.x = startX + dx;
      tag.y = startY + dy;
      if (tag.x + tag.x0 < 0 || tag.y + tag.y0 < 0 || tag.x + tag.x1 > size5[0] || tag.y + tag.y1 > size5[1])
        continue;
      if (!bounds || !cloudCollide(tag, board, size5[0])) {
        if (!bounds || collideRects(tag, bounds)) {
          const sprite = tag.sprite, w = tag.width >> 5, sw = size5[0] >> 5, lx = tag.x - (w << 4), sx = lx & 127, msx = 32 - sx, h = tag.y1 - tag.y0;
          let last7, x3 = (tag.y + tag.y0) * sw + (lx >> 5);
          for (let j = 0; j < h; j++) {
            last7 = 0;
            for (let i = 0; i <= w; i++) {
              board[x3 + i] |= last7 << msx | (i < w ? (last7 = sprite[j * w + i]) >>> sx : 0);
            }
            x3 += sw;
          }
          delete tag.sprite;
          return true;
        }
      }
    }
    return false;
  }
  cloud.createMask = (img) => {
    const can = document.createElement("canvas");
    const [width, height] = size5;
    if (!width || !height) {
      return;
    }
    const w32 = width >> 5;
    const board = zeroArray((width >> 5) * height);
    can.width = width;
    can.height = height;
    const cxt = can.getContext("2d");
    cxt.drawImage(img, 0, 0, img.width, img.height, 0, 0, width, height);
    const imageData = cxt.getImageData(0, 0, width, height).data;
    for (let j = 0; j < height; j++) {
      for (let i = 0; i < width; i++) {
        const k2 = w32 * j + (i >> 5);
        const tmp2 = j * width + i << 2;
        const flag = imageData[tmp2] >= 250 && imageData[tmp2 + 1] >= 250 && imageData[tmp2 + 2] >= 250;
        const m3 = flag ? 1 << 31 - i % 32 : 0;
        board[k2] |= m3;
      }
    }
    cloud.board = board;
    cloud.hasImage = true;
  };
  cloud.timeInterval = function(_2) {
    timeInterval = _2 == null ? Infinity : _2;
  };
  cloud.words = function(_2) {
    words2 = _2;
  };
  cloud.size = function(_2 = []) {
    size5 = [+_2[0], +_2[1]];
  };
  cloud.text = function(_2) {
    text = functor(_2);
  };
  cloud.font = function(_2) {
    font = functor(_2);
  };
  cloud.fontWeight = function(_2) {
    fontWeight = functor(_2);
  };
  cloud.rotate = function(_2) {
    rotate6 = functor(_2);
  };
  cloud.spiral = function(_2) {
    spiral = spirals[_2] || _2;
  };
  cloud.fontSize = function(_2) {
    fontSize = functor(_2);
  };
  cloud.padding = function(_2) {
    padding = functor(_2);
  };
  cloud.random = function(_2) {
    random6 = functor(_2);
  };
  cloud.on = function(_2) {
    event = functor(_2);
  };
  return cloud;
}

// node_modules/@antv/g2/esm/data/utils/flow.js
var __awaiter4 = function(thisArg, _arguments, P, generator) {
  function adopt(value2) {
    return value2 instanceof P ? value2 : new P(function(resolve) {
      resolve(value2);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject2) {
    function fulfilled(value2) {
      try {
        step2(generator.next(value2));
      } catch (e) {
        reject2(e);
      }
    }
    function rejected(value2) {
      try {
        step2(generator["throw"](value2));
      } catch (e) {
        reject2(e);
      }
    }
    function step2(result2) {
      result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
    }
    step2((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
function flow(target, source) {
  return {
    set(key, normalize10, callback) {
      if (source[key] === void 0)
        return this;
      const value2 = normalize10 ? normalize10.call(null, source[key]) : source[key];
      if (callback)
        callback.call(null, value2);
      else if (typeof target[key] === "function")
        target[key](value2);
      else
        target[key] = value2;
      return this;
    },
    setAsync(key, normalize10, callback) {
      return __awaiter4(this, void 0, void 0, function* () {
        if (source[key] === void 0)
          return this;
        const value2 = normalize10 ? yield normalize10.call(null, source[key]) : source[key];
        if (callback)
          callback.call(null, value2);
        else if (typeof target[key] === "function")
          target[key](value2);
        else
          target[key] = value2;
        return this;
      });
    }
  };
}

// node_modules/@antv/g2/esm/data/wordCloud.js
var __awaiter5 = function(thisArg, _arguments, P, generator) {
  function adopt(value2) {
    return value2 instanceof P ? value2 : new P(function(resolve) {
      resolve(value2);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject2) {
    function fulfilled(value2) {
      try {
        step2(generator.next(value2));
      } catch (e) {
        reject2(e);
      }
    }
    function rejected(value2) {
      try {
        step2(generator["throw"](value2));
      } catch (e) {
        reject2(e);
      }
    }
    function step2(result2) {
      result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
    }
    step2((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __rest49 = function(s2, e) {
  var t = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
      t[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t[p2[i]] = s2[p2[i]];
    }
  return t;
};
var DEFAULT_OPTIONS3 = {
  size: [500, 500],
  fontSize: [14, 28]
};
function processImageMask(img) {
  return new Promise((res, rej) => {
    if (img instanceof HTMLImageElement) {
      res(img);
      return;
    }
    if (typeof img === "string") {
      const image = new Image();
      image.crossOrigin = "anonymous";
      image.src = img;
      image.onload = () => res(image);
      image.onerror = () => {
        console.error(`'image ${img} load failed !!!'`);
        rej();
      };
      return;
    }
    rej();
  });
}
function normalizeFontSize(fontSize, range4) {
  if (typeof fontSize === "function")
    return fontSize;
  if (Array.isArray(fontSize)) {
    const [fMin, fMax] = fontSize;
    if (!range4)
      return () => (fMax + fMin) / 2;
    const [min11, max11] = range4;
    if (max11 === min11)
      return () => (fMax + fMin) / 2;
    return ({ value: value2 }) => (fMax - fMin) / (max11 - min11) * (value2 - min11) + fMin;
  }
  return () => fontSize;
}
var WordCloud = (options) => {
  return (data2) => __awaiter5(void 0, void 0, void 0, function* () {
    const cloudOptions = Object.assign({}, DEFAULT_OPTIONS3, options);
    const layout = tagCloud();
    yield flow(layout, cloudOptions).set("fontSize", (v) => {
      const arr = data2.map((d2) => d2.value);
      return normalizeFontSize(v, [min4(arr), max4(arr)]);
    }).set("font").set("fontStyle").set("fontWeight").set("padding").set("rotate").set("size").set("spiral").set("timeInterval").set("random").set("text").set("on").setAsync("imageMask", processImageMask, layout.createMask);
    layout.words([...data2]);
    const result2 = layout.start();
    const [cw2, ch2] = cloudOptions.size;
    const defaultBounds = [
      { x: 0, y: 0 },
      { x: cw2, y: ch2 }
    ];
    const { _bounds: bounds = defaultBounds, _tags, hasImage } = result2;
    const tags = _tags.map((_a2) => {
      var { x: x3, y: y3 } = _a2, rest2 = __rest49(_a2, ["x", "y"]);
      return Object.assign(Object.assign({}, rest2), { x: x3 + cw2 / 2, y: y3 + ch2 / 2 });
    });
    const [{ x: tlx, y: tly }, { x: brx, y: bry }] = bounds;
    const invisibleText = { text: "", value: 0, opacity: 0, fontSize: 0 };
    tags.push(Object.assign(Object.assign({}, invisibleText), { x: hasImage ? 0 : tlx, y: hasImage ? 0 : tly }), Object.assign(Object.assign({}, invisibleText), { x: hasImage ? cw2 : brx, y: hasImage ? ch2 : bry }));
    return tags;
  });
};
WordCloud.props = {};

// node_modules/@antv/g2/esm/data/join.js
function field2(key) {
  return typeof key === "string" ? (d2) => d2[key] : key;
}
var Join = (options) => {
  const { join: join2, on, select: select3 = [], as = select3, unknown = NaN } = options;
  const [key, fromKey] = on;
  const fk = field2(fromKey);
  const k2 = field2(key);
  const keyData = rollup(
    join2,
    ([d2]) => d2,
    // Get the first matched.
    (d2) => fk(d2)
  );
  return (data2) => data2.map((d2) => {
    const source = keyData.get(k2(d2));
    return Object.assign(Object.assign({}, d2), select3.reduce((prev, key2, idx) => (prev[as[idx]] = source ? source[key2] : unknown, prev), {}));
  });
};
Join.props = {};

// node_modules/@antv/g2/esm/data/slice.js
var Slice = (options) => {
  const { start, end } = options;
  return (data2) => data2.slice(start, end);
};
Slice.props = {};

// node_modules/@antv/g2/esm/data/kde.js
var import_pdfast = __toESM(require_src());
var KDE = (options) => {
  const { field: field3, groupBy: groupBy3, as = ["y", "size"], min: min11, max: max11, size: size5 = 10, width } = options;
  const [yField, sizeField] = as;
  return (data2) => {
    const gs = Array.from(group(data2, (d2) => groupBy3.map((gb) => d2[gb]).join("-")).values());
    return gs.map((g) => {
      const pdfResult = import_pdfast.default.create(g.map((i) => i[field3]), {
        min: min11,
        max: max11,
        size: size5,
        width
      });
      const _y = pdfResult.map((result2) => result2.x);
      const _size = pdfResult.map((result2) => result2.y);
      return Object.assign(Object.assign({}, g[0]), { [yField]: _y, [sizeField]: _size });
    });
  };
};
KDE.props = {};

// node_modules/fmin/src/bisect.js
function bisect2(f, a4, b, parameters) {
  parameters = parameters || {};
  var maxIterations = parameters.maxIterations || 100, tolerance2 = parameters.tolerance || 1e-10, fA = f(a4), fB = f(b), delta = b - a4;
  if (fA * fB > 0) {
    throw "Initial bisect points must have opposite signs";
  }
  if (fA === 0)
    return a4;
  if (fB === 0)
    return b;
  for (var i = 0; i < maxIterations; ++i) {
    delta /= 2;
    var mid2 = a4 + delta, fMid = f(mid2);
    if (fMid * fA >= 0) {
      a4 = mid2;
    }
    if (Math.abs(delta) < tolerance2 || fMid === 0) {
      return mid2;
    }
  }
  return a4 + delta;
}

// node_modules/fmin/src/blas1.js
function zeros(x3) {
  var r = new Array(x3);
  for (var i = 0; i < x3; ++i) {
    r[i] = 0;
  }
  return r;
}
function zerosM(x3, y3) {
  return zeros(x3).map(function() {
    return zeros(y3);
  });
}
function dot8(a4, b) {
  var ret = 0;
  for (var i = 0; i < a4.length; ++i) {
    ret += a4[i] * b[i];
  }
  return ret;
}
function norm2(a4) {
  return Math.sqrt(dot8(a4, a4));
}
function scale8(ret, value2, c5) {
  for (var i = 0; i < value2.length; ++i) {
    ret[i] = value2[i] * c5;
  }
}
function weightedSum(ret, w1, v1, w2, v2) {
  for (var j = 0; j < ret.length; ++j) {
    ret[j] = w1 * v1[j] + w2 * v2[j];
  }
}

// node_modules/fmin/src/nelderMead.js
function nelderMead(f, x05, parameters) {
  parameters = parameters || {};
  var maxIterations = parameters.maxIterations || x05.length * 200, nonZeroDelta = parameters.nonZeroDelta || 1.05, zeroDelta = parameters.zeroDelta || 1e-3, minErrorDelta = parameters.minErrorDelta || 1e-6, minTolerance = parameters.minErrorDelta || 1e-5, rho = parameters.rho !== void 0 ? parameters.rho : 1, chi = parameters.chi !== void 0 ? parameters.chi : 2, psi = parameters.psi !== void 0 ? parameters.psi : -0.5, sigma = parameters.sigma !== void 0 ? parameters.sigma : 0.5, maxDiff;
  var N = x05.length, simplex = new Array(N + 1);
  simplex[0] = x05;
  simplex[0].fx = f(x05);
  simplex[0].id = 0;
  for (var i = 0; i < N; ++i) {
    var point7 = x05.slice();
    point7[i] = point7[i] ? point7[i] * nonZeroDelta : zeroDelta;
    simplex[i + 1] = point7;
    simplex[i + 1].fx = f(point7);
    simplex[i + 1].id = i + 1;
  }
  function updateSimplex(value2) {
    for (var i2 = 0; i2 < value2.length; i2++) {
      simplex[N][i2] = value2[i2];
    }
    simplex[N].fx = value2.fx;
  }
  var sortOrder = function(a4, b) {
    return a4.fx - b.fx;
  };
  var centroid = x05.slice(), reflected = x05.slice(), contracted = x05.slice(), expanded = x05.slice();
  for (var iteration = 0; iteration < maxIterations; ++iteration) {
    simplex.sort(sortOrder);
    if (parameters.history) {
      var sortedSimplex = simplex.map(function(x3) {
        var state = x3.slice();
        state.fx = x3.fx;
        state.id = x3.id;
        return state;
      });
      sortedSimplex.sort(function(a4, b) {
        return a4.id - b.id;
      });
      parameters.history.push({
        x: simplex[0].slice(),
        fx: simplex[0].fx,
        simplex: sortedSimplex
      });
    }
    maxDiff = 0;
    for (i = 0; i < N; ++i) {
      maxDiff = Math.max(maxDiff, Math.abs(simplex[0][i] - simplex[1][i]));
    }
    if (Math.abs(simplex[0].fx - simplex[N].fx) < minErrorDelta && maxDiff < minTolerance) {
      break;
    }
    for (i = 0; i < N; ++i) {
      centroid[i] = 0;
      for (var j = 0; j < N; ++j) {
        centroid[i] += simplex[j][i];
      }
      centroid[i] /= N;
    }
    var worst = simplex[N];
    weightedSum(reflected, 1 + rho, centroid, -rho, worst);
    reflected.fx = f(reflected);
    if (reflected.fx < simplex[0].fx) {
      weightedSum(expanded, 1 + chi, centroid, -chi, worst);
      expanded.fx = f(expanded);
      if (expanded.fx < reflected.fx) {
        updateSimplex(expanded);
      } else {
        updateSimplex(reflected);
      }
    } else if (reflected.fx >= simplex[N - 1].fx) {
      var shouldReduce = false;
      if (reflected.fx > worst.fx) {
        weightedSum(contracted, 1 + psi, centroid, -psi, worst);
        contracted.fx = f(contracted);
        if (contracted.fx < worst.fx) {
          updateSimplex(contracted);
        } else {
          shouldReduce = true;
        }
      } else {
        weightedSum(contracted, 1 - psi * rho, centroid, psi * rho, worst);
        contracted.fx = f(contracted);
        if (contracted.fx < reflected.fx) {
          updateSimplex(contracted);
        } else {
          shouldReduce = true;
        }
      }
      if (shouldReduce) {
        if (sigma >= 1)
          break;
        for (i = 1; i < simplex.length; ++i) {
          weightedSum(simplex[i], 1 - sigma, simplex[0], sigma, simplex[i]);
          simplex[i].fx = f(simplex[i]);
        }
      }
    } else {
      updateSimplex(reflected);
    }
  }
  simplex.sort(sortOrder);
  return {
    fx: simplex[0].fx,
    x: simplex[0]
  };
}

// node_modules/fmin/src/linesearch.js
function wolfeLineSearch(f, pk, current, next, a4, c1, c22) {
  var phi0 = current.fx, phiPrime0 = dot8(current.fxprime, pk), phi2 = phi0, phi_old = phi0, phiPrime = phiPrime0, a0 = 0;
  a4 = a4 || 1;
  c1 = c1 || 1e-6;
  c22 = c22 || 0.1;
  function zoom(a_lo, a_high, phi_lo) {
    for (var iteration2 = 0; iteration2 < 16; ++iteration2) {
      a4 = (a_lo + a_high) / 2;
      weightedSum(next.x, 1, current.x, a4, pk);
      phi2 = next.fx = f(next.x, next.fxprime);
      phiPrime = dot8(next.fxprime, pk);
      if (phi2 > phi0 + c1 * a4 * phiPrime0 || phi2 >= phi_lo) {
        a_high = a4;
      } else {
        if (Math.abs(phiPrime) <= -c22 * phiPrime0) {
          return a4;
        }
        if (phiPrime * (a_high - a_lo) >= 0) {
          a_high = a_lo;
        }
        a_lo = a4;
        phi_lo = phi2;
      }
    }
    return 0;
  }
  for (var iteration = 0; iteration < 10; ++iteration) {
    weightedSum(next.x, 1, current.x, a4, pk);
    phi2 = next.fx = f(next.x, next.fxprime);
    phiPrime = dot8(next.fxprime, pk);
    if (phi2 > phi0 + c1 * a4 * phiPrime0 || iteration && phi2 >= phi_old) {
      return zoom(a0, a4, phi_old);
    }
    if (Math.abs(phiPrime) <= -c22 * phiPrime0) {
      return a4;
    }
    if (phiPrime >= 0) {
      return zoom(a4, a0, phi2);
    }
    phi_old = phi2;
    a0 = a4;
    a4 *= 2;
  }
  return a4;
}

// node_modules/fmin/src/conjugateGradient.js
function conjugateGradient(f, initial2, params) {
  var current = { x: initial2.slice(), fx: 0, fxprime: initial2.slice() }, next = { x: initial2.slice(), fx: 0, fxprime: initial2.slice() }, yk = initial2.slice(), pk, temp, a4 = 1, maxIterations;
  params = params || {};
  maxIterations = params.maxIterations || initial2.length * 20;
  current.fx = f(current.x, current.fxprime);
  pk = current.fxprime.slice();
  scale8(pk, current.fxprime, -1);
  for (var i = 0; i < maxIterations; ++i) {
    a4 = wolfeLineSearch(f, pk, current, next, a4);
    if (params.history) {
      params.history.push({
        x: current.x.slice(),
        fx: current.fx,
        fxprime: current.fxprime.slice(),
        alpha: a4
      });
    }
    if (!a4) {
      scale8(pk, current.fxprime, -1);
    } else {
      weightedSum(yk, 1, next.fxprime, -1, current.fxprime);
      var delta_k = dot8(current.fxprime, current.fxprime), beta_k = Math.max(0, dot8(yk, next.fxprime) / delta_k);
      weightedSum(pk, beta_k, pk, -1, next.fxprime);
      temp = current;
      current = next;
      next = temp;
    }
    if (norm2(current.fxprime) <= 1e-5) {
      break;
    }
  }
  if (params.history) {
    params.history.push({
      x: current.x.slice(),
      fx: current.fx,
      fxprime: current.fxprime.slice(),
      alpha: a4
    });
  }
  return current;
}

// node_modules/@antv/g2/esm/data/utils/venn/circleintersection.js
var SMALL = 1e-10;
function intersectionArea(circles, stats) {
  const intersectionPoints = getIntersectionPoints(circles);
  const innerPoints = intersectionPoints.filter(function(p2) {
    return containedInCircles(p2, circles);
  });
  let arcArea = 0, polygonArea = 0, i;
  const arcs = [];
  if (innerPoints.length > 1) {
    const center2 = getCenter(innerPoints);
    for (i = 0; i < innerPoints.length; ++i) {
      const p3 = innerPoints[i];
      p3.angle = Math.atan2(p3.x - center2.x, p3.y - center2.y);
    }
    innerPoints.sort(function(a4, b) {
      return b.angle - a4.angle;
    });
    let p2 = innerPoints[innerPoints.length - 1];
    for (i = 0; i < innerPoints.length; ++i) {
      const p1 = innerPoints[i];
      polygonArea += (p2.x + p1.x) * (p1.y - p2.y);
      const midPoint2 = { x: (p1.x + p2.x) / 2, y: (p1.y + p2.y) / 2 };
      let arc = null;
      for (let j = 0; j < p1.parentIndex.length; ++j) {
        if (p2.parentIndex.indexOf(p1.parentIndex[j]) > -1) {
          const circle3 = circles[p1.parentIndex[j]], a1 = Math.atan2(p1.x - circle3.x, p1.y - circle3.y), a22 = Math.atan2(p2.x - circle3.x, p2.y - circle3.y);
          let angleDiff = a22 - a1;
          if (angleDiff < 0) {
            angleDiff += 2 * Math.PI;
          }
          const a4 = a22 - angleDiff / 2;
          let width = distance6(midPoint2, {
            x: circle3.x + circle3.radius * Math.sin(a4),
            y: circle3.y + circle3.radius * Math.cos(a4)
          });
          if (width > circle3.radius * 2) {
            width = circle3.radius * 2;
          }
          if (arc === null || arc.width > width) {
            arc = { circle: circle3, width, p1, p2 };
          }
        }
      }
      if (arc !== null) {
        arcs.push(arc);
        arcArea += circleArea(arc.circle.radius, arc.width);
        p2 = p1;
      }
    }
  } else {
    let smallest = circles[0];
    for (i = 1; i < circles.length; ++i) {
      if (circles[i].radius < smallest.radius) {
        smallest = circles[i];
      }
    }
    let disjoint2 = false;
    for (i = 0; i < circles.length; ++i) {
      if (distance6(circles[i], smallest) > Math.abs(smallest.radius - circles[i].radius)) {
        disjoint2 = true;
        break;
      }
    }
    if (disjoint2) {
      arcArea = polygonArea = 0;
    } else {
      arcArea = smallest.radius * smallest.radius * Math.PI;
      arcs.push({
        circle: smallest,
        p1: { x: smallest.x, y: smallest.y + smallest.radius },
        p2: { x: smallest.x - SMALL, y: smallest.y + smallest.radius },
        width: smallest.radius * 2
      });
    }
  }
  polygonArea /= 2;
  if (stats) {
    stats.area = arcArea + polygonArea;
    stats.arcArea = arcArea;
    stats.polygonArea = polygonArea;
    stats.arcs = arcs;
    stats.innerPoints = innerPoints;
    stats.intersectionPoints = intersectionPoints;
  }
  return arcArea + polygonArea;
}
function containedInCircles(point7, circles) {
  for (let i = 0; i < circles.length; ++i) {
    if (distance6(point7, circles[i]) > circles[i].radius + SMALL) {
      return false;
    }
  }
  return true;
}
function getIntersectionPoints(circles) {
  const ret = [];
  for (let i = 0; i < circles.length; ++i) {
    for (let j = i + 1; j < circles.length; ++j) {
      const intersect4 = circleCircleIntersection(circles[i], circles[j]);
      for (let k2 = 0; k2 < intersect4.length; ++k2) {
        const p2 = intersect4[k2];
        p2.parentIndex = [i, j];
        ret.push(p2);
      }
    }
  }
  return ret;
}
function circleArea(r, width) {
  return r * r * Math.acos(1 - width / r) - (r - width) * Math.sqrt(width * (2 * r - width));
}
function distance6(p1, p2) {
  return Math.sqrt((p1.x - p2.x) * (p1.x - p2.x) + (p1.y - p2.y) * (p1.y - p2.y));
}
function circleOverlap(r1, r2, d2) {
  if (d2 >= r1 + r2) {
    return 0;
  }
  if (d2 <= Math.abs(r1 - r2)) {
    return Math.PI * Math.min(r1, r2) * Math.min(r1, r2);
  }
  const w1 = r1 - (d2 * d2 - r2 * r2 + r1 * r1) / (2 * d2), w2 = r2 - (d2 * d2 - r1 * r1 + r2 * r2) / (2 * d2);
  return circleArea(r1, w1) + circleArea(r2, w2);
}
function circleCircleIntersection(p1, p2) {
  const d2 = distance6(p1, p2), r1 = p1.radius, r2 = p2.radius;
  if (d2 >= r1 + r2 || d2 <= Math.abs(r1 - r2)) {
    return [];
  }
  const a4 = (r1 * r1 - r2 * r2 + d2 * d2) / (2 * d2), h = Math.sqrt(r1 * r1 - a4 * a4), x05 = p1.x + a4 * (p2.x - p1.x) / d2, y05 = p1.y + a4 * (p2.y - p1.y) / d2, rx = -(p2.y - p1.y) * (h / d2), ry = -(p2.x - p1.x) * (h / d2);
  return [
    { x: x05 + rx, y: y05 - ry },
    { x: x05 - rx, y: y05 + ry }
  ];
}
function getCenter(points) {
  const center2 = { x: 0, y: 0 };
  for (let i = 0; i < points.length; ++i) {
    center2.x += points[i].x;
    center2.y += points[i].y;
  }
  center2.x /= points.length;
  center2.y /= points.length;
  return center2;
}

// node_modules/@antv/g2/esm/data/utils/venn/layout.js
function venn(areas, parameters) {
  parameters = parameters || {};
  parameters.maxIterations = parameters.maxIterations || 500;
  const initialLayout = parameters.initialLayout || bestInitialLayout;
  const loss = parameters.lossFunction || lossFunction;
  areas = addMissingAreas(areas);
  const circles = initialLayout(areas, parameters);
  const initial2 = [], setids = [];
  let setid;
  for (setid in circles) {
    if (circles.hasOwnProperty(setid)) {
      initial2.push(circles[setid].x);
      initial2.push(circles[setid].y);
      setids.push(setid);
    }
  }
  const solution = nelderMead(function(values4) {
    const current = {};
    for (let i = 0; i < setids.length; ++i) {
      const setid2 = setids[i];
      current[setid2] = {
        x: values4[2 * i],
        y: values4[2 * i + 1],
        radius: circles[setid2].radius
      };
    }
    return loss(current, areas);
  }, initial2, parameters);
  const positions = solution.x;
  for (let i = 0; i < setids.length; ++i) {
    setid = setids[i];
    circles[setid].x = positions[2 * i];
    circles[setid].y = positions[2 * i + 1];
  }
  return circles;
}
var SMALL2 = 1e-10;
function distanceFromIntersectArea(r1, r2, overlap) {
  if (Math.min(r1, r2) * Math.min(r1, r2) * Math.PI <= overlap + SMALL2) {
    return Math.abs(r1 - r2);
  }
  return bisect2(function(distance7) {
    return circleOverlap(r1, r2, distance7) - overlap;
  }, 0, r1 + r2);
}
function addMissingAreas(areas) {
  areas = areas.slice();
  const ids = [], pairs2 = {};
  let i, j, a4, b;
  for (i = 0; i < areas.length; ++i) {
    const area2 = areas[i];
    if (area2.sets.length == 1) {
      ids.push(area2.sets[0]);
    } else if (area2.sets.length == 2) {
      a4 = area2.sets[0];
      b = area2.sets[1];
      pairs2[[a4, b]] = true;
      pairs2[[b, a4]] = true;
    }
  }
  ids.sort((a5, b2) => {
    return a5 > b2 ? 1 : -1;
  });
  for (i = 0; i < ids.length; ++i) {
    a4 = ids[i];
    for (j = i + 1; j < ids.length; ++j) {
      b = ids[j];
      if (!([a4, b] in pairs2)) {
        areas.push({ sets: [a4, b], size: 0 });
      }
    }
  }
  return areas;
}
function getDistanceMatrices(areas, sets, setids) {
  const distances = zerosM(sets.length, sets.length), constraints = zerosM(sets.length, sets.length);
  areas.filter(function(x3) {
    return x3.sets.length == 2;
  }).map(function(current) {
    const left2 = setids[current.sets[0]], right2 = setids[current.sets[1]], r1 = Math.sqrt(sets[left2].size / Math.PI), r2 = Math.sqrt(sets[right2].size / Math.PI), distance7 = distanceFromIntersectArea(r1, r2, current.size);
    distances[left2][right2] = distances[right2][left2] = distance7;
    let c5 = 0;
    if (current.size + 1e-10 >= Math.min(sets[left2].size, sets[right2].size)) {
      c5 = 1;
    } else if (current.size <= 1e-10) {
      c5 = -1;
    }
    constraints[left2][right2] = constraints[right2][left2] = c5;
  });
  return { distances, constraints };
}
function constrainedMDSGradient(x3, fxprime, distances, constraints) {
  let loss = 0, i;
  for (i = 0; i < fxprime.length; ++i) {
    fxprime[i] = 0;
  }
  for (i = 0; i < distances.length; ++i) {
    const xi = x3[2 * i], yi = x3[2 * i + 1];
    for (let j = i + 1; j < distances.length; ++j) {
      const xj = x3[2 * j], yj = x3[2 * j + 1], dij = distances[i][j], constraint = constraints[i][j];
      const squaredDistance4 = (xj - xi) * (xj - xi) + (yj - yi) * (yj - yi), distance7 = Math.sqrt(squaredDistance4), delta = squaredDistance4 - dij * dij;
      if (constraint > 0 && distance7 <= dij || constraint < 0 && distance7 >= dij) {
        continue;
      }
      loss += 2 * delta * delta;
      fxprime[2 * i] += 4 * delta * (xi - xj);
      fxprime[2 * i + 1] += 4 * delta * (yi - yj);
      fxprime[2 * j] += 4 * delta * (xj - xi);
      fxprime[2 * j + 1] += 4 * delta * (yj - yi);
    }
  }
  return loss;
}
function bestInitialLayout(areas, params) {
  let initial2 = greedyLayout(areas, params);
  const loss = params.lossFunction || lossFunction;
  if (areas.length >= 8) {
    const constrained = constrainedMDSLayout(areas, params), constrainedLoss = loss(constrained, areas), greedyLoss = loss(initial2, areas);
    if (constrainedLoss + 1e-8 < greedyLoss) {
      initial2 = constrained;
    }
  }
  return initial2;
}
function constrainedMDSLayout(areas, params) {
  params = params || {};
  const restarts = params.restarts || 10;
  const sets = [], setids = {};
  let i;
  for (i = 0; i < areas.length; ++i) {
    const area2 = areas[i];
    if (area2.sets.length == 1) {
      setids[area2.sets[0]] = sets.length;
      sets.push(area2);
    }
  }
  const matrices = getDistanceMatrices(areas, sets, setids);
  let distances = matrices.distances;
  const constraints = matrices.constraints;
  const norm = norm2(distances.map(norm2)) / distances.length;
  distances = distances.map(function(row2) {
    return row2.map(function(value2) {
      return value2 / norm;
    });
  });
  const obj = function(x3, fxprime) {
    return constrainedMDSGradient(x3, fxprime, distances, constraints);
  };
  let best, current;
  for (i = 0; i < restarts; ++i) {
    const initial2 = zeros(distances.length * 2).map(Math.random);
    current = conjugateGradient(obj, initial2, params);
    if (!best || current.fx < best.fx) {
      best = current;
    }
  }
  const positions = best.x;
  const circles = {};
  for (i = 0; i < sets.length; ++i) {
    const set9 = sets[i];
    circles[set9.sets[0]] = {
      x: positions[2 * i] * norm,
      y: positions[2 * i + 1] * norm,
      radius: Math.sqrt(set9.size / Math.PI)
    };
  }
  if (params.history) {
    for (i = 0; i < params.history.length; ++i) {
      scale8(params.history[i].x, norm);
    }
  }
  return circles;
}
function greedyLayout(areas, params) {
  const loss = params && params.lossFunction ? params.lossFunction : lossFunction;
  const circles = {}, setOverlaps = {};
  let set9;
  for (let i = 0; i < areas.length; ++i) {
    const area2 = areas[i];
    if (area2.sets.length == 1) {
      set9 = area2.sets[0];
      circles[set9] = {
        x: 1e10,
        y: 1e10,
        // rowid: circles.length, // fix to ->
        rowid: Object.keys(circles).length,
        size: area2.size,
        radius: Math.sqrt(area2.size / Math.PI)
      };
      setOverlaps[set9] = [];
    }
  }
  areas = areas.filter(function(a4) {
    return a4.sets.length == 2;
  });
  for (let i = 0; i < areas.length; ++i) {
    const current = areas[i];
    let weight2 = current.hasOwnProperty("weight") ? current.weight : 1;
    const left2 = current.sets[0], right2 = current.sets[1];
    if (current.size + SMALL2 >= Math.min(circles[left2].size, circles[right2].size)) {
      weight2 = 0;
    }
    setOverlaps[left2].push({ set: right2, size: current.size, weight: weight2 });
    setOverlaps[right2].push({ set: left2, size: current.size, weight: weight2 });
  }
  const mostOverlapped = [];
  for (set9 in setOverlaps) {
    if (setOverlaps.hasOwnProperty(set9)) {
      let size5 = 0;
      for (let i = 0; i < setOverlaps[set9].length; ++i) {
        size5 += setOverlaps[set9][i].size * setOverlaps[set9][i].weight;
      }
      mostOverlapped.push({ set: set9, size: size5 });
    }
  }
  function sortOrder(a4, b) {
    return b.size - a4.size;
  }
  mostOverlapped.sort(sortOrder);
  const positioned = {};
  function isPositioned(element) {
    return element.set in positioned;
  }
  function positionSet(point7, index3) {
    circles[index3].x = point7.x;
    circles[index3].y = point7.y;
    positioned[index3] = true;
  }
  positionSet({ x: 0, y: 0 }, mostOverlapped[0].set);
  for (let i = 1; i < mostOverlapped.length; ++i) {
    const setIndex = mostOverlapped[i].set, overlap = setOverlaps[setIndex].filter(isPositioned);
    set9 = circles[setIndex];
    overlap.sort(sortOrder);
    if (overlap.length === 0) {
      throw "ERROR: missing pairwise overlap information";
    }
    const points = [];
    for (let j = 0; j < overlap.length; ++j) {
      const p1 = circles[overlap[j].set], d1 = distanceFromIntersectArea(set9.radius, p1.radius, overlap[j].size);
      points.push({ x: p1.x + d1, y: p1.y });
      points.push({ x: p1.x - d1, y: p1.y });
      points.push({ y: p1.y + d1, x: p1.x });
      points.push({ y: p1.y - d1, x: p1.x });
      for (let k2 = j + 1; k2 < overlap.length; ++k2) {
        const p2 = circles[overlap[k2].set], d2 = distanceFromIntersectArea(set9.radius, p2.radius, overlap[k2].size);
        const extraPoints = circleCircleIntersection({ x: p1.x, y: p1.y, radius: d1 }, { x: p2.x, y: p2.y, radius: d2 });
        for (let l = 0; l < extraPoints.length; ++l) {
          points.push(extraPoints[l]);
        }
      }
    }
    let bestLoss = 1e50, bestPoint = points[0];
    for (let j = 0; j < points.length; ++j) {
      circles[setIndex].x = points[j].x;
      circles[setIndex].y = points[j].y;
      const localLoss = loss(circles, areas);
      if (localLoss < bestLoss) {
        bestLoss = localLoss;
        bestPoint = points[j];
      }
    }
    positionSet(bestPoint, setIndex);
  }
  return circles;
}
function lossFunction(sets, overlaps) {
  let output = 0;
  function getCircles(indices) {
    return indices.map(function(i) {
      return sets[i];
    });
  }
  for (let i = 0; i < overlaps.length; ++i) {
    const area2 = overlaps[i];
    let overlap;
    if (area2.sets.length == 1) {
      continue;
    } else if (area2.sets.length == 2) {
      const left2 = sets[area2.sets[0]], right2 = sets[area2.sets[1]];
      overlap = circleOverlap(left2.radius, right2.radius, distance6(left2, right2));
    } else {
      overlap = intersectionArea(getCircles(area2.sets));
    }
    const weight2 = area2.hasOwnProperty("weight") ? area2.weight : 1;
    output += weight2 * (overlap - area2.size) * (overlap - area2.size);
  }
  return output;
}
function getBoundingBox(circles) {
  const minMax = function(d2) {
    const hi = Math.max.apply(null, circles.map(function(c5) {
      return c5[d2] + c5.radius;
    })), lo = Math.min.apply(null, circles.map(function(c5) {
      return c5[d2] - c5.radius;
    }));
    return { max: hi, min: lo };
  };
  return { xRange: minMax("x"), yRange: minMax("y") };
}
function scaleSolution(solution, width, height, padding) {
  const circles = [], setids = [];
  for (const setid in solution) {
    if (solution.hasOwnProperty(setid)) {
      setids.push(setid);
      circles.push(solution[setid]);
    }
  }
  width -= 2 * padding;
  height -= 2 * padding;
  const bounds = getBoundingBox(circles), xRange = bounds.xRange, yRange = bounds.yRange;
  if (xRange.max == xRange.min || yRange.max == yRange.min) {
    console.log("not scaling solution: zero size detected");
    return solution;
  }
  const xScaling = width / (xRange.max - xRange.min), yScaling = height / (yRange.max - yRange.min), scaling = Math.min(yScaling, xScaling), xOffset = (width - (xRange.max - xRange.min) * scaling) / 2, yOffset = (height - (yRange.max - yRange.min) * scaling) / 2;
  const scaled = {};
  for (let i = 0; i < circles.length; ++i) {
    const circle3 = circles[i];
    scaled[setids[i]] = {
      radius: scaling * circle3.radius,
      x: padding + xOffset + (circle3.x - xRange.min) * scaling,
      y: padding + yOffset + (circle3.y - yRange.min) * scaling
    };
  }
  return scaled;
}

// node_modules/@antv/g2/esm/data/utils/venn/diagram.js
function circlePath(x3, y3, r) {
  const ret = [];
  const x05 = x3 - r;
  const y05 = y3;
  ret.push("M", x05, y05);
  ret.push("A", r, r, 0, 1, 0, x05 + 2 * r, y05);
  ret.push("A", r, r, 0, 1, 0, x05, y05);
  return ret.join(" ");
}
function intersectionAreaPath(circles) {
  const stats = {};
  intersectionArea(circles, stats);
  const arcs = stats.arcs;
  if (arcs.length === 0) {
    return "M 0 0";
  } else if (arcs.length == 1) {
    const circle3 = arcs[0].circle;
    return circlePath(circle3.x, circle3.y, circle3.radius);
  } else {
    const ret = ["\nM", arcs[0].p2.x, arcs[0].p2.y];
    for (let i = 0; i < arcs.length; ++i) {
      const arc = arcs[i], r = arc.circle.radius, wide = arc.width > r;
      ret.push("\nA", r, r, 0, wide ? 1 : 0, 1, arc.p1.x, arc.p1.y);
    }
    return ret.join(" ");
  }
}

// node_modules/@antv/g2/esm/data/venn.js
var Venn = (options) => {
  const { sets = "sets", size: size5 = "size", as = ["key", "path"], padding = 0 } = options;
  const [key, path2] = as;
  return (data2) => {
    const vennData = data2.map((d2) => Object.assign(Object.assign({}, d2), { sets: d2[sets], size: d2[size5], [key]: d2.sets.join("&") }));
    vennData.sort((a4, b) => a4.sets.length - b.sets.length);
    const solution = venn(vennData);
    let circles;
    return vennData.map((datum) => {
      const setsValue = datum[sets];
      const pathFunc = ({ width, height }) => {
        circles = circles ? circles : scaleSolution(solution, width, height, padding);
        const setCircles = setsValue.map((set9) => circles[set9]);
        let p2 = intersectionAreaPath(setCircles);
        if (!/[zZ]$/.test(p2))
          p2 += " Z";
        return p2;
      };
      return Object.assign(Object.assign({}, datum), { [path2]: pathFunc });
    });
  };
};
Venn.props = {};

// node_modules/@antv/g2/esm/data/log.js
var Log2 = () => {
  return (data2) => {
    console.log("G2 data section:", data2);
    return data2;
  };
};
Log2.props = {};

// node_modules/@antv/g2/esm/mark/wordCloud.js
var __awaiter6 = function(thisArg, _arguments, P, generator) {
  function adopt(value2) {
    return value2 instanceof P ? value2 : new P(function(resolve) {
      resolve(value2);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject2) {
    function fulfilled(value2) {
      try {
        step2(generator.next(value2));
      } catch (e) {
        reject2(e);
      }
    }
    function rejected(value2) {
      try {
        step2(generator["throw"](value2));
      } catch (e) {
        reject2(e);
      }
    }
    function step2(result2) {
      result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
    }
    step2((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __rest50 = function(s2, e) {
  var t = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
      t[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t[p2[i]] = s2[p2[i]];
    }
  return t;
};
function initializeData2(data2, encode) {
  const { text = "text", value: value2 = "value" } = encode;
  return data2.map((d2) => Object.assign(Object.assign({}, d2), { text: d2[text], value: d2[value2] }));
}
var GET_DEFAULT_LAYOUT_OPTIONS3 = (width, height) => ({
  size: [width, height]
});
var GET_DEFAULT_OPTIONS3 = (width, height) => ({
  axis: false,
  type: "text",
  encode: {
    x: "x",
    y: "y",
    text: "text",
    rotate: "rotate",
    fontSize: "size"
  },
  scale: {
    x: { domain: [0, width], range: [0, 1] },
    y: { domain: [0, height], range: [0, 1] },
    fontSize: { type: "identity" },
    rotate: { type: "identity" }
  },
  style: {
    textAlign: "center"
  }
});
var WordCloud2 = (options, context) => __awaiter6(void 0, void 0, void 0, function* () {
  const { width, height } = context;
  const { data: data2, encode = {}, scale: scale10, style = {}, layout = {} } = options, resOptions = __rest50(options, ["data", "encode", "scale", "style", "layout"]);
  const initializedData = initializeData2(data2, encode);
  const transformData2 = yield WordCloud(Object.assign(Object.assign({}, GET_DEFAULT_LAYOUT_OPTIONS3(width, height)), layout))(initializedData);
  return deep_mix_default({}, GET_DEFAULT_OPTIONS3(width, height), Object.assign(Object.assign({
    data: transformData2,
    encode,
    scale: scale10,
    style
  }, resOptions), { axis: false }));
});
WordCloud2.props = {};

// node_modules/@antv/g2/esm/mark/gauge.js
var __rest51 = function(s2, e) {
  var t = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
      t[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t[p2[i]] = s2[p2[i]];
    }
  return t;
};
var indicatorShape = (options, context) => {
  const { shape: shape23, radius } = options, style = __rest51(options, ["shape", "radius"]);
  const pointerStyle = subObject(style, "pointer");
  const pinStyle = subObject(style, "pin");
  const { shape: pointerShape } = pointerStyle, resPointerStyle = __rest51(pointerStyle, ["shape"]);
  const { shape: pinShape } = pinStyle, resPinStyle = __rest51(pinStyle, ["shape"]);
  const { coordinate: coordinate2, theme } = context;
  return (points, value2) => {
    const invertedPoints = points.map((p2) => coordinate2.invert(p2));
    const [startAngle, endAngle, innerRadius] = getTransformOptions(coordinate2, "polar");
    const newCoordinate = coordinate2.clone();
    const { color: stroke2 } = value2;
    const newTransformations = Radial({
      startAngle,
      endAngle,
      innerRadius,
      outerRadius: radius
    });
    newTransformations.push(["cartesian"]);
    newCoordinate.update({
      transformations: newTransformations
    });
    const newPoints = invertedPoints.map((p2) => newCoordinate.map(p2));
    const [x3, y3] = getOrigin(newPoints);
    const [cx, cy] = coordinate2.getCenter();
    const pointerAttrs = Object.assign(Object.assign({ x1: x3, y1: y3, x2: cx, y2: cy, stroke: stroke2 }, resPointerStyle), style);
    const pinAttrs = Object.assign(Object.assign({
      cx,
      cy,
      stroke: stroke2
    }, resPinStyle), style);
    const indicatorGroup = select(new Group2());
    if (!isUnset(pointerShape)) {
      typeof pointerShape === "function" ? indicatorGroup.append(() => pointerShape(newPoints, value2, newCoordinate, theme)) : indicatorGroup.append("line").call(applyStyle, pointerAttrs).node();
    }
    if (!isUnset(pinShape)) {
      typeof pinShape === "function" ? indicatorGroup.append(() => pinShape(newPoints, value2, newCoordinate, theme)) : indicatorGroup.append("circle").call(applyStyle, pinAttrs).node();
    }
    return indicatorGroup.node();
  };
};
var DEFAULT_OPTIONS4 = {
  coordinate: {
    type: "radial",
    innerRadius: 0.9,
    outerRadius: 1,
    startAngle: -11 / 10 * Math.PI,
    endAngle: 1 / 10 * Math.PI
  },
  axis: {
    x: false
  },
  legend: false,
  tooltip: false,
  encode: {
    x: "x",
    y: "y",
    color: "color"
  },
  scale: {
    color: {
      range: ["#30BF78", "#D0D0D0"]
    }
  }
};
var DEFAULT_INDICATOR_OPTIONS = {
  style: {
    shape: indicatorShape,
    lineWidth: 4,
    pointerLineCap: "round",
    pinR: 10,
    pinFill: "#fff",
    radius: 0.6
  }
};
var DEFAULT_TEXT_OPTIONS = {
  type: "text",
  style: {
    x: "50%",
    y: "60%",
    textAlign: "center",
    textBaseline: "middle",
    fontSize: 20,
    fontWeight: 800,
    fill: "#888"
  }
};
function getGaugeData(data2) {
  if (is_number_default(data2)) {
    const percent = Math.max(0, Math.min(data2, 1));
    return {
      percent,
      target: percent,
      total: 1
    };
  }
  return data2;
}
function dataTransform4(data2, scale10) {
  const { name: name2 = "score", target, total, percent, thresholds = [] } = getGaugeData(data2);
  const _target = percent || target;
  const _total = percent ? 1 : total;
  const newScale = Object.assign({ y: {
    domain: [0, _total]
  } }, scale10);
  if (!thresholds.length) {
    return {
      targetData: [{ x: name2, y: _target, color: "target" }],
      totalData: [
        { x: name2, y: _target, color: "target" },
        { x: name2, y: _total - _target, color: "total" }
      ],
      target: _target,
      total: _total,
      scale: newScale
    };
  }
  return {
    targetData: [{ x: name2, y: _target, color: "target" }],
    totalData: thresholds.map((d2, i) => ({
      x: name2,
      y: i >= 1 ? d2 - thresholds[i - 1] : d2,
      color: i
    })),
    target: _target,
    total: _total,
    scale: newScale
  };
}
function getTextContent(textStyle, { target, total }) {
  const { content } = textStyle;
  return content ? content(target, total) : target.toString();
}
var Gauge = (options) => {
  const { data: data2 = {}, scale: scale10 = {}, style = {}, animate: animate2 = {}, transform: transform3 = [] } = options, resOptions = __rest51(options, ["data", "scale", "style", "animate", "transform"]);
  const { targetData, totalData, target, total, scale: newScale } = dataTransform4(data2, scale10);
  const textStyle = subObject(style, "text");
  const indicatorStyle = filterPrefixObject(style, ["pointer", "pin"]);
  return [
    deep_mix_default({}, DEFAULT_OPTIONS4, Object.assign({ type: "interval", transform: [{ type: "stackY" }], data: totalData, scale: newScale, style: subObject(style, "arc"), animate: typeof animate2 === "object" ? subObject(animate2, "arc") : animate2 }, resOptions)),
    deep_mix_default({}, DEFAULT_OPTIONS4, DEFAULT_INDICATOR_OPTIONS, Object.assign({ type: "point", data: targetData, scale: newScale, style: indicatorStyle, animate: typeof animate2 === "object" ? subObject(animate2, "indicator") : animate2 }, resOptions)),
    deep_mix_default({}, DEFAULT_TEXT_OPTIONS, {
      style: Object.assign({ text: getTextContent(textStyle, { target, total }) }, textStyle),
      animate: typeof animate2 === "object" ? subObject(animate2, "text") : animate2
    })
  ];
};
Gauge.props = {};

// node_modules/@antv/g2/esm/mark/density.js
var shape21 = {
  density: Density
};
var Density2 = () => {
  return (index3, scale10, value2, coordinate2) => {
    const { x: X, series: S } = value2;
    const Yn2 = Object.entries(value2).filter(([key]) => key.startsWith("y")).map(([, value3]) => value3);
    const SZn = Object.entries(value2).filter(([key]) => key.startsWith("size")).map(([, value3]) => value3);
    if (X === void 0 || Yn2 === void 0 || SZn === void 0) {
      throw new Error("Missing encode for x or y or size channel.");
    }
    const xScale = scale10.x;
    const series = scale10.series;
    const P = Array.from(index3, (i) => {
      const groupWidth = xScale.getBandWidth(xScale.invert(+X[i]));
      const ratio = series ? series.getBandWidth(series.invert(+(S === null || S === void 0 ? void 0 : S[i]))) : 1;
      const width = groupWidth * ratio;
      const offset2 = (+(S === null || S === void 0 ? void 0 : S[i]) || 0) * groupWidth;
      const x3 = +X[i] + offset2 + width / 2;
      const PN = [
        ...Yn2.map((_2, idx) => [x3 + +SZn[idx][i] / index3.length, +Yn2[idx][i]]),
        ...Yn2.map((_2, idx) => [
          x3 - +SZn[idx][i] / index3.length,
          +Yn2[idx][i]
        ]).reverse()
        // left
      ];
      return PN.map((p2) => coordinate2.map(p2));
    });
    return [index3, P];
  };
};
Density2.props = {
  defaultShape: "density",
  defaultLabelShape: "label",
  composite: false,
  shape: shape21,
  channels: [
    ...baseGeometryChannels({ shapes: Object.keys(shape21) }),
    { name: "x", scale: "band", required: true },
    { name: "y", required: true },
    { name: "size", required: true },
    { name: "series", scale: "band" },
    { name: "size", required: true, scale: "identity" }
  ],
  preInference: [
    ...basePreInference(),
    { type: MaybeZeroY1 },
    { type: MaybeZeroX }
  ],
  postInference: [...basePostInference(), ...tooltip1d()],
  interaction: { shareTooltip: true }
};

// node_modules/@antv/g2/esm/mark/heatmap.js
var shape22 = {
  heatmap: Heatmap
};
var Heatmap2 = (options) => {
  return (index3, scale10, value2, coordinate2) => {
    const { x: X, y: Y, size: S, color: C3 } = value2;
    const P = Array.from(index3, (i) => {
      const r = S ? +S[i] : 40;
      return [...coordinate2.map([+X[i], +Y[i]]), C3[i], r];
    });
    return [[0], [P]];
  };
};
Heatmap2.props = {
  defaultShape: "heatmap",
  defaultLabelShape: "label",
  composite: false,
  shape: shape22,
  channels: [
    ...baseGeometryChannels({ shapes: Object.keys(shape22) }),
    { name: "x", required: true },
    { name: "y", required: true },
    { name: "color", scale: "identity", required: true },
    { name: "size" }
  ],
  preInference: [
    ...basePreInference(),
    { type: MaybeZeroX },
    { type: MaybeZeroY }
  ],
  postInference: [...basePostInference(), ...tooltip2d()]
};

// node_modules/@antv/g2/esm/mark/liquid.js
var __rest52 = function(s2, e) {
  var t = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
      t[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t[p2[i]] = s2[p2[i]];
    }
  return t;
};
var DEFAULT_OPTIONS5 = {
  axis: {
    x: false,
    y: false
  },
  legend: false,
  tooltip: false,
  encode: {
    x: "type",
    y: "percent"
  },
  scale: {
    y: {
      domain: [0, 1]
    }
  },
  style: {
    shape: Liquid
  },
  animate: {
    enter: {
      type: "fadeIn"
    }
  }
};
var DEFAULT_TEXT_OPTIONS2 = {
  type: "text",
  style: {
    x: "50%",
    y: "50%",
    textAlign: "center",
    textBaseline: "middle",
    fontSize: 20,
    fontWeight: 800,
    fill: "#888"
  },
  animate: {
    enter: {
      type: "fadeIn"
    }
  }
};
var Liquid2 = (options) => {
  const { data: data2 = {}, style = {}, animate: animate2 } = options, resOptions = __rest52(options, ["data", "style", "animate"]);
  const percent = Math.max(0, is_number_default(data2) ? data2 : data2 === null || data2 === void 0 ? void 0 : data2.percent);
  const newData = [{ percent, type: "liquid" }];
  const contentStyle = Object.assign(Object.assign({}, subObject(style, "text")), subObject(style, "content"));
  const outline = subObject(style, "outline");
  const wave = subObject(style, "wave");
  const background = subObject(style, "background");
  return [
    deep_mix_default({}, DEFAULT_OPTIONS5, Object.assign({ type: "interval", data: newData, style: {
      liquidOptions: {
        percent,
        liquidShape: style === null || style === void 0 ? void 0 : style.shape
      },
      styleOptions: Object.assign(Object.assign({}, style), {
        outline,
        wave,
        background
      })
    }, animate: animate2 }, resOptions)),
    deep_mix_default({}, DEFAULT_TEXT_OPTIONS2, {
      style: Object.assign({ text: `${prettyNumber2(percent * 100)} %` }, contentStyle),
      animate: animate2
    })
  ];
};
Liquid2.props = {};

// node_modules/@antv/g2/esm/palette/category10.js
var Category10 = () => {
  return [
    "#5B8FF9",
    "#5AD8A6",
    "#5D7092",
    "#F6BD16",
    "#6F5EF9",
    "#6DC8EC",
    "#945FB9",
    "#FF9845",
    "#1E9493",
    "#FF99C3"
  ];
};
Category10.props = {};

// node_modules/@antv/g2/esm/palette/category20.js
var Category20 = () => {
  return [
    "#5B8FF9",
    "#CDDDFD",
    "#5AD8A6",
    "#CDF3E4",
    "#5D7092",
    "#CED4DE",
    "#F6BD16",
    "#FCEBB9",
    "#6F5EF9",
    "#D3CEFD",
    "#6DC8EC",
    "#D3EEF9",
    "#945FB9",
    "#DECFEA",
    "#FF9845",
    "#FFE0C7",
    "#1E9493",
    "#BBDEDE",
    "#FF99C3",
    "#FFE0ED"
  ];
};
Category20.props = {};

// node_modules/@antv/g2/esm/scale/band.js
var Band2 = (options) => {
  return new Band(options);
};
Band2.props = {};

// node_modules/@antv/g2/esm/scale/linear.js
var Linear3 = (options) => {
  return new Linear(options);
};
Linear3.props = {};

// node_modules/@antv/g2/esm/scale/ordinal.js
var Ordinal2 = (options) => {
  return new Ordinal(options);
};
Ordinal2.props = {};

// node_modules/@antv/g2/esm/scale/identity.js
var Identity2 = (options) => {
  return new Identity(options);
};
Identity2.props = {};

// node_modules/@antv/g2/esm/scale/point.js
var Point5 = (options) => {
  return new Point(options);
};
Point5.props = {};

// node_modules/@antv/g2/esm/scale/time.js
var Time2 = (options) => {
  return new Time(options);
};
Time2.props = {};

// node_modules/@antv/g2/esm/scale/log.js
var Log3 = (options) => {
  return new Log(options);
};
Log3.props = {};

// node_modules/@antv/g2/esm/scale/pow.js
var Pow2 = (options) => {
  return new Pow(options);
};
Pow2.props = {};

// node_modules/@antv/g2/esm/scale/threshold.js
var Threshold2 = (options) => {
  return new Threshold(options);
};
Threshold2.props = {};

// node_modules/@antv/g2/esm/scale/quantile.js
var Quantile2 = (options) => {
  return new Quantile(options);
};
Quantile2.props = {};

// node_modules/@antv/g2/esm/scale/quantize.js
var Quantize2 = (options) => {
  return new Quantize(options);
};
Quantize2.props = {};

// node_modules/@antv/g2/esm/scale/sqrt.js
var Sqrt2 = (options) => {
  return new Sqrt(options);
};
Sqrt2.props = {};

// node_modules/@antv/g2/esm/scale/sequential.js
var Sequential3 = (options) => {
  return new Sequential(options);
};
Sequential3.props = {};

// node_modules/@antv/g2/esm/scale/constant.js
var Constant3 = (options) => {
  return new Constant2(options);
};
Constant3.props = {};

// node_modules/@antv/g2/esm/theme/create.js
function create7({ colorDefault, colorBlack, colorWhite, colorStroke, colorBackground, padding1, padding2, padding3, alpha90, alpha65, alpha45, alpha25, alpha10, category10, category20, sizeDefault = 1, padding = "auto", margin = 16 }) {
  return {
    padding,
    margin,
    size: sizeDefault,
    color: colorDefault,
    category10,
    category20,
    enter: {
      duration: 300,
      fill: "both",
      delay: 0
    },
    update: {
      duration: 300,
      fill: "both",
      delay: 0
    },
    exit: {
      duration: 300,
      fill: "both",
      delay: 0
    },
    view: {
      viewFill: colorBackground,
      plotFill: "transparent",
      mainFill: "transparent",
      contentFill: "transparent"
    },
    line: {
      line: {
        fill: "",
        strokeOpacity: 1,
        lineWidth: 1,
        lineCap: "round"
      }
    },
    point: {
      point: {
        r: 3,
        fillOpacity: 0.95,
        lineWidth: 0
      },
      hollow: {
        r: 3,
        strokeOpacity: 0.95,
        lineWidth: 1
      },
      plus: {
        r: 3,
        strokeOpacity: 0.95,
        lineWidth: 3
      },
      diamond: {
        r: 3,
        strokeOpacity: 0.95,
        lineWidth: 1
      }
    },
    interval: {
      rect: {
        fillOpacity: 0.95
      },
      hollow: {
        fill: "",
        strokeOpacity: 1,
        lineWidth: 2
      }
    },
    area: {
      area: {
        fillOpacity: 0.85,
        lineWidth: 0
      }
    },
    polygon: {
      polygon: {
        fillOpacity: 0.95
      }
    },
    cell: {
      cell: {
        fillOpacity: 0.95
      },
      hollow: {
        fill: "",
        strokeOpacity: 1,
        lineWidth: 2
      }
    },
    rect: {
      rect: {
        fillOpacity: 0.95
      },
      hollow: {
        fill: "",
        strokeOpacity: 1,
        lineWidth: 2
      }
    },
    link: {
      link: {
        fill: "",
        strokeOpacity: 1
      }
    },
    vector: {
      vector: {
        fillOpacity: 1
      }
    },
    box: {
      box: {
        fillOpacity: 0.95,
        stroke: colorBlack,
        lineWidth: 1
      }
    },
    text: {
      text: {
        fill: "#1D2129",
        fontSize: 12,
        strokeWidth: 0,
        connectorStroke: colorStroke,
        connectorStrokeOpacity: 0.45,
        connectorLineWidth: 1,
        backgroundFill: colorStroke,
        backgroundFillOpacity: 0.15,
        backgroundPadding: [2, 4],
        startMarkerSymbol: "circle",
        startMarkerSize: 4,
        endMarkerSymbol: "circle",
        endMarkerSize: 4
      },
      badge: {
        fill: "#1D2129",
        fillOpacity: 0.65,
        strokeWidth: 0,
        fontSize: 10,
        textAlign: "center",
        textBaseline: "middle",
        markerFill: colorStroke,
        markerFillOpacity: 0.25,
        markerStrokeOpacity: 0
      }
    },
    lineX: {
      line: {
        stroke: colorStroke,
        strokeOpacity: 0.45,
        lineWidth: 1
      }
    },
    lineY: {
      line: {
        stroke: colorStroke,
        strokeOpacity: 0.45,
        lineWidth: 1
      }
    },
    rangeX: {
      range: {
        fill: colorStroke,
        fillOpacity: 0.15,
        lineWidth: 0
      }
    },
    rangeY: {
      range: {
        fill: colorStroke,
        fillOpacity: 0.15,
        lineWidth: 0
      }
    },
    connector: {
      connector: {
        stroke: colorStroke,
        strokeOpacity: 0.45,
        lineWidth: 1,
        connectLength1: 12,
        endMarker: true,
        endMarkerSize: 6,
        endMarkerFill: colorStroke,
        endMarkerFillOpacity: 0.95
      }
    },
    axis: {
      arrow: false,
      gridLineDash: [3, 4],
      gridLineWidth: 0.5,
      gridStroke: colorBlack,
      gridStrokeOpacity: alpha10,
      labelAlign: "horizontal",
      labelFill: colorBlack,
      labelOpacity: alpha45,
      labelFontSize: 12,
      labelFontWeight: "normal",
      labelSpacing: padding1,
      line: false,
      lineLineWidth: 0.5,
      lineStroke: colorBlack,
      lineStrokeOpacity: alpha45,
      tickLength: 4,
      tickLineWidth: 1,
      tickStroke: colorBlack,
      tickOpacity: alpha45,
      titleFill: colorBlack,
      titleOpacity: alpha90,
      titleFontSize: 12,
      titleFontWeight: "normal",
      titleSpacing: 12,
      titleTransformOrigin: "center",
      lineArrowOffset: 6,
      lineArrowSize: 6
    },
    axisTop: {
      gridDirection: "positive",
      labelDirection: "negative",
      tickDirection: "negative",
      titlePosition: "top",
      titleSpacing: 12,
      labelSpacing: 4,
      titleTextBaseline: "middle"
    },
    axisBottom: {
      gridDirection: "negative",
      labelDirection: "positive",
      tickDirection: "positive",
      titlePosition: "bottom",
      titleSpacing: 12,
      labelSpacing: 4,
      titleTextBaseline: "bottom"
    },
    axisLeft: {
      gridDirection: "positive",
      labelDirection: "negative",
      labelSpacing: 4,
      tickDirection: "negative",
      titlePosition: "left",
      titleSpacing: 12,
      titleTextBaseline: "middle",
      titleDirection: "vertical",
      titleTransformOrigin: "center"
    },
    axisRight: {
      gridDirection: "negative",
      labelDirection: "positive",
      labelSpacing: 4,
      tickDirection: "positive",
      titlePosition: "right",
      titleSpacing: 12,
      titleTextBaseline: "top",
      titleDirection: "vertical",
      titleTransformOrigin: "center"
    },
    axisLinear: {
      girdClosed: true,
      gridConnect: "arc",
      gridDirection: "negative",
      gridType: "surround",
      titlePosition: "top",
      titleSpacing: 0
    },
    axisArc: {
      title: false,
      titlePosition: "inner",
      line: false,
      tick: true,
      labelSpacing: 4
    },
    axisRadar: {
      girdClosed: true,
      gridStrokeOpacity: 0.3,
      gridType: "surround",
      label: false,
      tick: false,
      titlePosition: "start"
    },
    legendCategory: {
      backgroundFill: "transparent",
      itemBackgroundFill: "transparent",
      itemLabelFill: colorBlack,
      itemLabelFillOpacity: alpha90,
      itemLabelFontSize: 12,
      itemLabelFontWeight: "normal",
      itemMarkerFillOpacity: 1,
      itemMarkerSize: 8,
      itemSpacing: [padding1, padding1],
      itemValueFill: colorBlack,
      itemValueFillOpacity: 0.65,
      itemValueFontSize: 12,
      itemValueFontWeight: "normal",
      navButtonFill: colorBlack,
      navButtonFillOpacity: 0.65,
      navPageNumFill: colorBlack,
      navPageNumFillOpacity: 0.45,
      navPageNumFontSize: 12,
      padding: 8,
      title: false,
      titleFill: colorBlack,
      titleFillOpacity: 0.65,
      titleFontSize: 12,
      titleFontWeight: "normal",
      titleSpacing: 4,
      tickStroke: colorBlack,
      tickStrokeOpacity: 0.25,
      rowPadding: padding1,
      colPadding: padding2,
      maxRows: 3,
      maxCols: 3
    },
    legendContinuous: {
      handleHeight: 12,
      handleLabelFill: colorBlack,
      handleLabelFillOpacity: alpha45,
      handleLabelFontSize: 12,
      handleLabelFontWeight: "normal",
      handleMarkerFill: colorBlack,
      handleMarkerFillOpacity: 0.6,
      handleMarkerLineWidth: 1,
      handleMarkerStroke: colorBlack,
      handleMarkerStrokeOpacity: 0.25,
      handleWidth: 10,
      labelFill: colorBlack,
      labelFillOpacity: alpha45,
      labelFontSize: 12,
      labelFontWeight: "normal",
      labelSpacing: 3,
      tick: true,
      tickLength: 12,
      ribbonSize: 12,
      ribbonFill: "#aaa",
      handle: true,
      handleLabel: false,
      handleShape: "slider",
      handleIconSize: 12 / 1.8,
      indicator: false,
      titleFontSize: 12,
      titleSpacing: 4,
      titleFontWeight: "normal",
      titleFillOpacity: alpha90,
      tickStroke: colorBlack,
      tickStrokeOpacity: alpha45
    },
    label: {
      fill: colorBlack,
      fillOpacity: 0.65,
      fontSize: 12,
      fontWeight: "normal",
      stroke: void 0,
      offset: 12,
      connectorStroke: colorBlack,
      connectorStrokeOpacity: 0.45,
      connectorLineWidth: 1,
      connectorLength: 12,
      connectorLength2: 8,
      connectorDistance: 4
    },
    innerLabel: {
      fill: colorWhite,
      fontSize: 12,
      fillOpacity: 0.85,
      fontWeight: "normal",
      stroke: void 0,
      offset: 0
    },
    htmlLabel: {
      fontSize: 12,
      opacity: 0.65,
      color: colorBlack,
      fontWeight: "normal"
    },
    slider: {
      trackSize: 16,
      trackFill: colorStroke,
      trackFillOpacity: 1,
      selectionFill: colorDefault,
      selectionFillOpacity: 0.15,
      handleIconSize: 10,
      handleIconFill: "#f7f7f7",
      handleIconFillOpacity: 1,
      handleIconStroke: colorBlack,
      handleIconStrokeOpacity: 0.25,
      handleIconLineWidth: 1,
      handleIconRadius: 2,
      handleLabelFill: colorBlack,
      handleLabelFillOpacity: 0.45,
      handleLabelFontSize: 12,
      handleLabelFontWeight: "normal"
    },
    scrollbar: {
      padding: [0, 0, 0, 0],
      trackSize: 6,
      isRound: true,
      slidable: true,
      scrollable: true,
      trackFill: "#e5e5e5",
      trackFillOpacity: 0,
      thumbFill: "#000",
      thumbFillOpacity: 0.15,
      thumbHighlightedFillOpacity: 0.2
    },
    title: {
      spacing: 8,
      titleFill: colorBlack,
      titleFillOpacity: alpha90,
      titleFontSize: 16,
      titleFontWeight: "bold",
      titleTextBaseline: "top",
      subtitleFill: colorBlack,
      subtitleFillOpacity: alpha65,
      subtitleFontSize: 12,
      subtitleFontWeight: "normal",
      subtitleTextBaseline: "top"
    }
  };
}

// node_modules/@antv/g2/esm/theme/light.js
var tokens = {
  colorBlack: "#1D2129",
  colorWhite: "#ffffff",
  colorStroke: "#416180",
  colorDefault: "#1783FF",
  colorBackground: "transparent",
  category10: [
    "#1783FF",
    "#00C9C9",
    "#F0884D",
    "#D580FF",
    "#7863FF",
    "#60C42D",
    "#BD8F24",
    "#FF80CA",
    "#2491B3",
    "#17C76F"
  ],
  category20: [
    "#1783FF",
    "#00C9C9",
    "#F0884D",
    "#D580FF",
    "#7863FF",
    "#60C42D",
    "#BD8F24",
    "#FF80CA",
    "#2491B3",
    "#17C76F",
    "#AABA01",
    "#BC7CFC",
    "#237CBC",
    "#2DE379",
    "#CE8032",
    "#FF7AF4",
    "#545FD3",
    "#AFE410",
    "#D8C608",
    "#FFA1E0"
  ],
  padding1: 8,
  padding2: 12,
  padding3: 20,
  alpha90: 0.9,
  alpha65: 0.65,
  alpha45: 0.45,
  alpha25: 0.25,
  alpha10: 0.1
};
var defaults = create7(tokens);
var Light = (options) => {
  return deep_mix_default({}, defaults, options);
};
Light.props = {};

// node_modules/@antv/g2/esm/theme/classic.js
var Classic = (options) => {
  return deep_mix_default({}, Light(), {
    category10: "category10",
    category20: "category20"
  }, options);
};
Classic.props = {};

// node_modules/@antv/g2/esm/theme/dark.js
var tokens2 = {
  colorBlack: "#fff",
  colorWhite: "#000",
  colorStroke: "#416180",
  colorDefault: "#1783FF",
  colorBackground: "#141414",
  category10: [
    "#1783FF",
    "#00C9C9",
    "#F0884D",
    "#D580FF",
    "#7863FF",
    "#60C42D",
    "#BD8F24",
    "#FF80CA",
    "#2491B3",
    "#17C76F"
  ],
  category20: [
    "#1783FF",
    "#00C9C9",
    "#F0884D",
    "#D580FF",
    "#7863FF",
    "#60C42D",
    "#BD8F24",
    "#FF80CA",
    "#2491B3",
    "#17C76F",
    "#AABA01",
    "#BC7CFC",
    "#237CBC",
    "#2DE379",
    "#CE8032",
    "#FF7AF4",
    "#545FD3",
    "#AFE410",
    "#D8C608",
    "#FFA1E0"
  ],
  padding1: 8,
  padding2: 12,
  padding3: 20,
  alpha90: 0.9,
  alpha65: 0.65,
  alpha45: 0.45,
  alpha25: 0.25,
  alpha10: 0.25
};
var defaults2 = create7(tokens2);
var Dark = (options) => {
  return deep_mix_default({}, defaults2, {
    tooltip: {
      crosshairsStroke: "#fff",
      crosshairsLineWidth: 1,
      crosshairsStrokeOpacity: 0.25,
      css: {
        ".g2-tooltip": {
          background: "#1f1f1f",
          opacity: 0.95
        },
        ".g2-tooltip-title": {
          color: "#A6A6A6"
        },
        ".g2-tooltip-list-item-name-label": {
          color: "#A6A6A6"
        },
        ".g2-tooltip-list-item-value": {
          color: "#A6A6A6"
        }
      }
    }
  }, options);
};

// node_modules/@antv/g2/esm/theme/classicDark.js
var ClassicDark = (options) => {
  return Object.assign({}, Dark(), {
    category10: "category10",
    category20: "category20"
  }, options);
};
ClassicDark.props = {};

// node_modules/@antv/g2/esm/theme/academy.js
var tokens3 = {
  colorBlack: "#000",
  colorWhite: "#fff",
  colorStroke: "#888",
  colorDefault: "#4e79a7",
  colorBackground: "transparent",
  category10: [
    "#4e79a7",
    "#f28e2c",
    "#e15759",
    "#76b7b2",
    "#59a14f",
    "#edc949",
    "#af7aa1",
    "#ff9da7",
    "#9c755f",
    "#bab0ab"
  ],
  category20: [
    "#4e79a7",
    "#f28e2c",
    "#e15759",
    "#76b7b2",
    "#59a14f",
    "#edc949",
    "#af7aa1",
    "#ff9da7",
    "#9c755f",
    "#bab0ab"
  ],
  padding1: 8,
  padding2: 12,
  padding3: 20,
  alpha90: 0.9,
  alpha65: 0.65,
  alpha45: 0.45,
  alpha25: 0.25,
  alpha10: 0.1
};
var defaults3 = create7(tokens3);
var Academy = (options) => {
  return deep_mix_default({}, defaults3, {
    text: { text: { fontSize: 10 } },
    axis: {
      gridLineDash: [0, 0],
      gridLineWidth: 1,
      gridStroke: "#ddd",
      gridStrokeOpacity: 1,
      labelOpacity: 1,
      labelStrokeOpacity: 1,
      labelFontSize: 10,
      line: true,
      lineLineWidth: 1,
      lineStroke: "#888",
      lineStrokeOpacity: 1,
      tickLength: 5,
      tickStrokeOpacity: 1,
      titleOpacity: 1,
      titleStrokeOpacity: 1,
      titleFillOpacity: 1,
      titleFontSize: 11,
      titleFontWeight: "bold"
    },
    axisLeft: {
      gridFilter: (_2, i) => i !== 0
    },
    axisRight: {
      gridFilter: (_2, i) => i !== 0
    },
    legendCategory: {
      itemLabelFillOpacity: 1,
      itemLabelFontSize: 10,
      itemValueFillOpacity: 1,
      itemValueFontSize: 10,
      titleFillOpacity: 1,
      titleFontSize: 11,
      titleFontWeight: "bold"
    },
    legendContinuous: {
      handleLabelFontSize: 10,
      labelFillOpacity: 0.45,
      labelFontSize: 10
    },
    label: {
      fontSize: 10
    },
    innerLabel: {
      fontSize: 10
    },
    htmlLabel: {
      fontSize: 10
    },
    slider: {
      handleLabelFontSize: 10,
      trackFillOpacity: 0.05
    }
  }, options);
};
Academy.props = {};

// node_modules/d3-format/src/formatDecimal.js
function formatDecimal_default(x3) {
  return Math.abs(x3 = Math.round(x3)) >= 1e21 ? x3.toLocaleString("en").replace(/,/g, "") : x3.toString(10);
}
function formatDecimalParts(x3, p2) {
  if ((i = (x3 = p2 ? x3.toExponential(p2 - 1) : x3.toExponential()).indexOf("e")) < 0)
    return null;
  var i, coefficient = x3.slice(0, i);
  return [
    coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient,
    +x3.slice(i + 1)
  ];
}

// node_modules/d3-format/src/exponent.js
function exponent_default(x3) {
  return x3 = formatDecimalParts(Math.abs(x3)), x3 ? x3[1] : NaN;
}

// node_modules/d3-format/src/formatGroup.js
function formatGroup_default(grouping, thousands) {
  return function(value2, width) {
    var i = value2.length, t = [], j = 0, g = grouping[0], length5 = 0;
    while (i > 0 && g > 0) {
      if (length5 + g + 1 > width)
        g = Math.max(1, width - length5);
      t.push(value2.substring(i -= g, i + g));
      if ((length5 += g + 1) > width)
        break;
      g = grouping[j = (j + 1) % grouping.length];
    }
    return t.reverse().join(thousands);
  };
}

// node_modules/d3-format/src/formatNumerals.js
function formatNumerals_default(numerals) {
  return function(value2) {
    return value2.replace(/[0-9]/g, function(i) {
      return numerals[+i];
    });
  };
}

// node_modules/d3-format/src/formatSpecifier.js
var re = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;
function formatSpecifier(specifier) {
  if (!(match = re.exec(specifier)))
    throw new Error("invalid format: " + specifier);
  var match;
  return new FormatSpecifier({
    fill: match[1],
    align: match[2],
    sign: match[3],
    symbol: match[4],
    zero: match[5],
    width: match[6],
    comma: match[7],
    precision: match[8] && match[8].slice(1),
    trim: match[9],
    type: match[10]
  });
}
formatSpecifier.prototype = FormatSpecifier.prototype;
function FormatSpecifier(specifier) {
  this.fill = specifier.fill === void 0 ? " " : specifier.fill + "";
  this.align = specifier.align === void 0 ? ">" : specifier.align + "";
  this.sign = specifier.sign === void 0 ? "-" : specifier.sign + "";
  this.symbol = specifier.symbol === void 0 ? "" : specifier.symbol + "";
  this.zero = !!specifier.zero;
  this.width = specifier.width === void 0 ? void 0 : +specifier.width;
  this.comma = !!specifier.comma;
  this.precision = specifier.precision === void 0 ? void 0 : +specifier.precision;
  this.trim = !!specifier.trim;
  this.type = specifier.type === void 0 ? "" : specifier.type + "";
}
FormatSpecifier.prototype.toString = function() {
  return this.fill + this.align + this.sign + this.symbol + (this.zero ? "0" : "") + (this.width === void 0 ? "" : Math.max(1, this.width | 0)) + (this.comma ? "," : "") + (this.precision === void 0 ? "" : "." + Math.max(0, this.precision | 0)) + (this.trim ? "~" : "") + this.type;
};

// node_modules/d3-format/src/formatTrim.js
function formatTrim_default(s2) {
  out:
    for (var n = s2.length, i = 1, i0 = -1, i1; i < n; ++i) {
      switch (s2[i]) {
        case ".":
          i0 = i1 = i;
          break;
        case "0":
          if (i0 === 0)
            i0 = i;
          i1 = i;
          break;
        default:
          if (!+s2[i])
            break out;
          if (i0 > 0)
            i0 = 0;
          break;
      }
    }
  return i0 > 0 ? s2.slice(0, i0) + s2.slice(i1 + 1) : s2;
}

// node_modules/d3-format/src/formatPrefixAuto.js
var prefixExponent;
function formatPrefixAuto_default(x3, p2) {
  var d2 = formatDecimalParts(x3, p2);
  if (!d2)
    return x3 + "";
  var coefficient = d2[0], exponent = d2[1], i = exponent - (prefixExponent = Math.max(-8, Math.min(8, Math.floor(exponent / 3))) * 3) + 1, n = coefficient.length;
  return i === n ? coefficient : i > n ? coefficient + new Array(i - n + 1).join("0") : i > 0 ? coefficient.slice(0, i) + "." + coefficient.slice(i) : "0." + new Array(1 - i).join("0") + formatDecimalParts(x3, Math.max(0, p2 + i - 1))[0];
}

// node_modules/d3-format/src/formatRounded.js
function formatRounded_default(x3, p2) {
  var d2 = formatDecimalParts(x3, p2);
  if (!d2)
    return x3 + "";
  var coefficient = d2[0], exponent = d2[1];
  return exponent < 0 ? "0." + new Array(-exponent).join("0") + coefficient : coefficient.length > exponent + 1 ? coefficient.slice(0, exponent + 1) + "." + coefficient.slice(exponent + 1) : coefficient + new Array(exponent - coefficient.length + 2).join("0");
}

// node_modules/d3-format/src/formatTypes.js
var formatTypes_default = {
  "%": (x3, p2) => (x3 * 100).toFixed(p2),
  "b": (x3) => Math.round(x3).toString(2),
  "c": (x3) => x3 + "",
  "d": formatDecimal_default,
  "e": (x3, p2) => x3.toExponential(p2),
  "f": (x3, p2) => x3.toFixed(p2),
  "g": (x3, p2) => x3.toPrecision(p2),
  "o": (x3) => Math.round(x3).toString(8),
  "p": (x3, p2) => formatRounded_default(x3 * 100, p2),
  "r": formatRounded_default,
  "s": formatPrefixAuto_default,
  "X": (x3) => Math.round(x3).toString(16).toUpperCase(),
  "x": (x3) => Math.round(x3).toString(16)
};

// node_modules/d3-format/src/identity.js
function identity_default4(x3) {
  return x3;
}

// node_modules/d3-format/src/locale.js
var map3 = Array.prototype.map;
var prefixes = ["y", "z", "a", "f", "p", "n", "", "m", "", "k", "M", "G", "T", "P", "E", "Z", "Y"];
function locale_default(locale2) {
  var group3 = locale2.grouping === void 0 || locale2.thousands === void 0 ? identity_default4 : formatGroup_default(map3.call(locale2.grouping, Number), locale2.thousands + ""), currencyPrefix = locale2.currency === void 0 ? "" : locale2.currency[0] + "", currencySuffix = locale2.currency === void 0 ? "" : locale2.currency[1] + "", decimal = locale2.decimal === void 0 ? "." : locale2.decimal + "", numerals = locale2.numerals === void 0 ? identity_default4 : formatNumerals_default(map3.call(locale2.numerals, String)), percent = locale2.percent === void 0 ? "%" : locale2.percent + "", minus = locale2.minus === void 0 ? "" : locale2.minus + "", nan = locale2.nan === void 0 ? "NaN" : locale2.nan + "";
  function newFormat(specifier) {
    specifier = formatSpecifier(specifier);
    var fill2 = specifier.fill, align = specifier.align, sign3 = specifier.sign, symbol = specifier.symbol, zero5 = specifier.zero, width = specifier.width, comma = specifier.comma, precision = specifier.precision, trim2 = specifier.trim, type = specifier.type;
    if (type === "n")
      comma = true, type = "g";
    else if (!formatTypes_default[type])
      precision === void 0 && (precision = 12), trim2 = true, type = "g";
    if (zero5 || fill2 === "0" && align === "=")
      zero5 = true, fill2 = "0", align = "=";
    var prefix = symbol === "$" ? currencyPrefix : symbol === "#" && /[boxX]/.test(type) ? "0" + type.toLowerCase() : "", suffix = symbol === "$" ? currencySuffix : /[%p]/.test(type) ? percent : "";
    var formatType = formatTypes_default[type], maybeSuffix = /[defgprs%]/.test(type);
    precision = precision === void 0 ? 6 : /[gprs]/.test(type) ? Math.max(1, Math.min(21, precision)) : Math.max(0, Math.min(20, precision));
    function format3(value2) {
      var valuePrefix = prefix, valueSuffix = suffix, i, n, c5;
      if (type === "c") {
        valueSuffix = formatType(value2) + valueSuffix;
        value2 = "";
      } else {
        value2 = +value2;
        var valueNegative = value2 < 0 || 1 / value2 < 0;
        value2 = isNaN(value2) ? nan : formatType(Math.abs(value2), precision);
        if (trim2)
          value2 = formatTrim_default(value2);
        if (valueNegative && +value2 === 0 && sign3 !== "+")
          valueNegative = false;
        valuePrefix = (valueNegative ? sign3 === "(" ? sign3 : minus : sign3 === "-" || sign3 === "(" ? "" : sign3) + valuePrefix;
        valueSuffix = (type === "s" ? prefixes[8 + prefixExponent / 3] : "") + valueSuffix + (valueNegative && sign3 === "(" ? ")" : "");
        if (maybeSuffix) {
          i = -1, n = value2.length;
          while (++i < n) {
            if (c5 = value2.charCodeAt(i), 48 > c5 || c5 > 57) {
              valueSuffix = (c5 === 46 ? decimal + value2.slice(i + 1) : value2.slice(i)) + valueSuffix;
              value2 = value2.slice(0, i);
              break;
            }
          }
        }
      }
      if (comma && !zero5)
        value2 = group3(value2, Infinity);
      var length5 = valuePrefix.length + value2.length + valueSuffix.length, padding = length5 < width ? new Array(width - length5 + 1).join(fill2) : "";
      if (comma && zero5)
        value2 = group3(padding + value2, padding.length ? width - valueSuffix.length : Infinity), padding = "";
      switch (align) {
        case "<":
          value2 = valuePrefix + value2 + valueSuffix + padding;
          break;
        case "=":
          value2 = valuePrefix + padding + value2 + valueSuffix;
          break;
        case "^":
          value2 = padding.slice(0, length5 = padding.length >> 1) + valuePrefix + value2 + valueSuffix + padding.slice(length5);
          break;
        default:
          value2 = padding + valuePrefix + value2 + valueSuffix;
          break;
      }
      return numerals(value2);
    }
    format3.toString = function() {
      return specifier + "";
    };
    return format3;
  }
  function formatPrefix2(specifier, value2) {
    var f = newFormat((specifier = formatSpecifier(specifier), specifier.type = "f", specifier)), e = Math.max(-8, Math.min(8, Math.floor(exponent_default(value2) / 3))) * 3, k2 = Math.pow(10, -e), prefix = prefixes[8 + e / 3];
    return function(value3) {
      return f(k2 * value3) + prefix;
    };
  }
  return {
    format: newFormat,
    formatPrefix: formatPrefix2
  };
}

// node_modules/d3-format/src/defaultLocale.js
var locale;
var format2;
var formatPrefix;
defaultLocale({
  thousands: ",",
  grouping: [3],
  currency: ["$", ""]
});
function defaultLocale(definition) {
  locale = locale_default(definition);
  format2 = locale.format;
  formatPrefix = locale.formatPrefix;
  return locale;
}

// node_modules/@antv/g2/esm/component/utils.js
var __rest53 = function(s2, e) {
  var t = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
      t[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t[p2[i]] = s2[p2[i]];
    }
  return t;
};
function createComponent(descriptor) {
  return class extends CustomElement {
    constructor(config) {
      super(config);
      this.descriptor = descriptor;
    }
    connectedCallback() {
      var _a2, _b;
      (_b = (_a2 = this.descriptor).render) === null || _b === void 0 ? void 0 : _b.call(_a2, this.attributes, this);
    }
    update(cfg = {}) {
      var _a2, _b;
      this.attr(deep_mix_default({}, this.attributes, cfg));
      (_b = (_a2 = this.descriptor).render) === null || _b === void 0 ? void 0 : _b.call(_a2, this.attributes, this);
    }
  };
}
function maybeAppend2(parent2, selector, node) {
  if (!parent2.querySelector(selector)) {
    return select(parent2).append(node);
  }
  return select(parent2).select(selector);
}
function titleContent(field3) {
  return Array.isArray(field3) ? field3.join(", ") : `${field3 || ""}`;
}
function inferComponentLayout(position, userDefinitions) {
  const preset = {
    display: "flex",
    flexDirection: "row",
    justifyContent: "flex-start",
    alignItems: "center"
  };
  let { flexDirection, justifyContent, alignItems } = preset;
  const layout = {
    top: ["row", "flex-start", "center"],
    bottom: ["row", "flex-start", "center"],
    left: ["column", "flex-start", "center"],
    right: ["column", "flex-start", "center"],
    center: ["column", "center", "center"]
  };
  if (position in layout) {
    [flexDirection, justifyContent, alignItems] = layout[position];
  }
  return Object.assign({
    display: "flex",
    flexDirection,
    justifyContent,
    alignItems
  }, userDefinitions);
}
var G2Layout = class extends Layout {
  get child() {
    var _a2;
    return (_a2 = this.children) === null || _a2 === void 0 ? void 0 : _a2[0];
  }
  update(options) {
    var _a2;
    this.attr(options);
    const { subOptions } = options;
    (_a2 = this.child) === null || _a2 === void 0 ? void 0 : _a2.update(subOptions);
  }
};
var LegendCategoryLayout = class extends G2Layout {
  update(options) {
    var _a2;
    const { subOptions } = options;
    this.attr(options);
    (_a2 = this.child) === null || _a2 === void 0 ? void 0 : _a2.update(subOptions);
  }
};
function scaleOf(scales, type) {
  var _a2;
  return (_a2 = scales.filter((s2) => s2.getOptions().name === type)) === null || _a2 === void 0 ? void 0 : _a2[0];
}
function isHorizontal2(orientation) {
  return orientation === "horizontal" || orientation === 0;
}
function isVertical(orientation) {
  return orientation === "vertical" || orientation === -Math.PI / 2;
}
function inferComponentShape(value2, options, component) {
  const { bbox } = value2;
  const { position = "top", size: userDefinedSize, length: userDefinedLength } = options;
  const isHorizontal3 = ["top", "bottom", "center"].includes(position);
  const [bboxSize, bboxLength] = isHorizontal3 ? [bbox.height, bbox.width] : [bbox.width, bbox.height];
  const { defaultSize, defaultLength } = component.props;
  const size5 = userDefinedSize || defaultSize || bboxSize;
  const length5 = userDefinedLength || defaultLength || bboxLength;
  const orientation = isHorizontal3 ? "horizontal" : "vertical";
  const [width, height] = isHorizontal3 ? [length5, size5] : [size5, length5];
  return {
    orientation,
    width,
    height,
    size: size5,
    length: length5
  };
}
function domainOf2(scales) {
  return scales.find((scale10) => scale10.getOptions().domain.length > 0).getOptions().domain;
}
function adaptor(style) {
  const reservedKeys = [
    "arrow",
    "crosshairs",
    "grid",
    "handle",
    "handleLabel",
    "indicator",
    "label",
    "line",
    "tick",
    "tip",
    "title",
    "trunc"
  ];
  const { style: styles } = style, rest2 = __rest53(style, ["style"]);
  const finalStyle = {};
  Object.entries(rest2).forEach(([key, value2]) => {
    if (reservedKeys.includes(key)) {
      finalStyle[`show${upper_first_default(key)}`] = value2;
    } else
      finalStyle[key] = value2;
  });
  return Object.assign(Object.assign({}, finalStyle), styles);
}

// node_modules/@antv/g2/esm/component/axis.js
var __rest54 = function(s2, e) {
  var t = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
      t[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t[p2[i]] = s2[p2[i]];
    }
  return t;
};
function rotateAxis(axis, options) {
  const { eulerAngles, origin } = options;
  if (origin) {
    axis.setOrigin(origin);
  }
  if (eulerAngles) {
    axis.rotate(eulerAngles[0], eulerAngles[1], eulerAngles[2]);
  }
}
function sizeOf(coordinate2) {
  const { innerWidth, innerHeight, depth } = coordinate2.getOptions();
  return [innerWidth, innerHeight, depth];
}
function createFisheye(position, coordinate2) {
  const { width, height } = coordinate2.getOptions();
  return (tick3) => {
    if (!isFisheye(coordinate2))
      return tick3;
    const tickPoint = position === "bottom" ? [tick3, 1] : [0, tick3];
    const vector = coordinate2.map(tickPoint);
    if (position === "bottom") {
      const v = vector[0];
      const x3 = new Linear({
        domain: [0, width],
        range: [0, 1]
      });
      return x3.map(v);
    } else if (position === "left") {
      const v = vector[1];
      const x3 = new Linear({
        domain: [0, height],
        range: [0, 1]
      });
      return x3.map(v);
    }
    return tick3;
  };
}
function ticksOf(scale10, domain, tickMethod) {
  if (scale10.getTicks)
    return scale10.getTicks();
  if (!tickMethod)
    return domain;
  const [min11, max11] = extent(domain, (d2) => +d2);
  const { tickCount } = scale10.getOptions();
  return tickMethod(min11, max11, tickCount);
}
function createInset(position, coordinate2) {
  if (isPolar(coordinate2))
    return (d2) => d2;
  const options = coordinate2.getOptions();
  const { innerWidth, innerHeight, insetTop, insetBottom, insetLeft, insetRight } = options;
  const [start, end, size5] = position === "left" || position === "right" ? [insetTop, insetBottom, innerHeight] : [insetLeft, insetRight, innerWidth];
  const x3 = new Linear({
    domain: [0, 1],
    range: [start / size5, 1 - end / size5]
  });
  return (i) => x3.map(i);
}
function getData2(scale10, domain, tickCount, defaultTickFormatter, tickFilter, tickMethod, position, coordinate2) {
  var _a2;
  if (tickCount !== void 0 || tickMethod !== void 0) {
    scale10.update(Object.assign(Object.assign({}, tickCount && { tickCount }), tickMethod && { tickMethod }));
  }
  const ticks2 = ticksOf(scale10, domain, tickMethod);
  const filteredTicks = tickFilter ? ticks2.filter(tickFilter) : ticks2;
  const toString8 = (d2) => d2 instanceof Date ? String(d2) : typeof d2 === "object" && !!d2 ? d2 : String(d2);
  const labelFormatter2 = defaultTickFormatter || ((_a2 = scale10.getFormatter) === null || _a2 === void 0 ? void 0 : _a2.call(scale10)) || toString8;
  const applyInset = createInset(position, coordinate2);
  const applyFisheye = createFisheye(position, coordinate2);
  const isHorizontal3 = (position2) => ["top", "bottom", "center", "outer"].includes(position2);
  const isVertical2 = (position2) => ["left", "right"].includes(position2);
  if (isPolar(coordinate2) || isTranspose(coordinate2)) {
    return filteredTicks.map((d2, i, array2) => {
      var _a3, _b;
      const offset2 = ((_a3 = scale10.getBandWidth) === null || _a3 === void 0 ? void 0 : _a3.call(scale10, d2)) / 2 || 0;
      const tick3 = applyInset(scale10.map(d2) + offset2);
      const shouldReverse = isRadial(coordinate2) && position === "center" || isTranspose(coordinate2) && ((_b = scale10.getTicks) === null || _b === void 0 ? void 0 : _b.call(scale10)) && isHorizontal3(position) || isTranspose(coordinate2) && isVertical2(position);
      return {
        value: shouldReverse ? 1 - tick3 : tick3,
        label: toString8(labelFormatter2(prettyNumber2(d2), i, array2)),
        id: String(i)
      };
    });
  }
  return filteredTicks.map((d2, i, array2) => {
    var _a3;
    const offset2 = ((_a3 = scale10.getBandWidth) === null || _a3 === void 0 ? void 0 : _a3.call(scale10, d2)) / 2 || 0;
    const tick3 = applyFisheye(applyInset(scale10.map(d2) + offset2));
    const shouldReverse = isVertical2(position);
    return {
      value: shouldReverse ? 1 - tick3 : tick3,
      label: toString8(labelFormatter2(prettyNumber2(d2), i, array2)),
      id: String(i)
    };
  });
}
function inferGridLength(position, coordinate2, plane = "xy") {
  const [width, height, depth] = sizeOf(coordinate2);
  if (plane === "xy") {
    if (position.includes("bottom") || position.includes("top"))
      return height;
    return width;
  } else if (plane === "xz") {
    if (position.includes("bottom") || position.includes("top"))
      return depth;
    return width;
  } else {
    if (position.includes("bottom") || position.includes("top"))
      return height;
    return depth;
  }
}
function inferLabelOverlap(transform3 = [], style) {
  if (transform3.length > 0)
    return transform3;
  const { labelAutoRotate, labelAutoHide, labelAutoEllipsis, labelAutoWrap } = style;
  const finalTransforms = [];
  const addToTransforms = (overlap, state) => {
    if (state) {
      finalTransforms.push(Object.assign(Object.assign({}, overlap), state));
    }
  };
  addToTransforms({
    type: "rotate",
    optionalAngles: [0, 15, 30, 45, 60, 90]
  }, labelAutoRotate);
  addToTransforms({ type: "ellipsis", minLength: 20 }, labelAutoEllipsis);
  addToTransforms({ type: "hide" }, labelAutoHide);
  addToTransforms({ type: "wrap", wordWrapWidth: 100, maxLines: 3, recoveryWhenFail: true }, labelAutoWrap);
  return finalTransforms;
}
function inferArcStyle(position, bbox, innerRadius, outerRadius, coordinate2) {
  const { x: x3, y: y3, width, height } = bbox;
  const center2 = [x3 + width / 2, y3 + height / 2];
  const radius = Math.min(width, height) / 2;
  const [startAngle, endAngle] = angleOf(coordinate2);
  const [w, h] = sizeOf(coordinate2);
  const r = Math.min(w, h) / 2;
  const common = {
    center: center2,
    radius,
    startAngle,
    endAngle,
    gridLength: (outerRadius - innerRadius) * r
  };
  if (position === "inner") {
    const { insetLeft, insetTop } = coordinate2.getOptions();
    return Object.assign(Object.assign({}, common), { center: [center2[0] - insetLeft, center2[1] - insetTop], labelAlign: "perpendicular", labelDirection: "positive", tickDirection: "positive", gridDirection: "negative" });
  }
  return Object.assign(Object.assign({}, common), { labelAlign: "parallel", labelDirection: "negative", tickDirection: "negative", gridDirection: "positive" });
}
function inferGrid(value2, coordinate2, scale10) {
  if (isTheta(coordinate2) || isParallel(coordinate2))
    return false;
  return value2 === void 0 ? !!scale10.getTicks : value2;
}
function infer3DAxisLinearOverrideStyle(coordinate2) {
  const { depth } = coordinate2.getOptions();
  return depth ? {
    tickIsBillboard: true,
    lineIsBillboard: true,
    labelIsBillboard: true,
    titleIsBillboard: true,
    gridIsBillboard: true
  } : {};
}
function inferAxisLinearOverrideStyle(position, orientation, bbox, coordinate2) {
  const { x: x3, y: y3, width, height } = bbox;
  if (position === "bottom") {
    return { startPos: [x3, y3], endPos: [x3 + width, y3] };
  }
  if (position === "left") {
    return { startPos: [x3 + width, y3 + height], endPos: [x3 + width, y3] };
  }
  if (position === "right") {
    return { startPos: [x3, y3 + height], endPos: [x3, y3] };
  }
  if (position === "top") {
    return { startPos: [x3, y3 + height], endPos: [x3 + width, y3 + height] };
  }
  if (position === "center") {
    if (orientation === "vertical") {
      return {
        startPos: [x3, y3],
        endPos: [x3, y3 + height]
      };
    } else if (orientation === "horizontal") {
      return {
        startPos: [x3, y3],
        endPos: [x3 + width, y3]
      };
    } else if (typeof orientation === "number") {
      const [cx, cy] = coordinate2.getCenter();
      const [innerRadius, outerRadius] = radiusOf(coordinate2);
      const [startAngle, endAngle] = angleOf(coordinate2);
      const r = Math.min(width, height) / 2;
      const { insetLeft, insetTop } = coordinate2.getOptions();
      const innerR = innerRadius * r;
      const outerR = outerRadius * r;
      const [actualCx, actualCy] = [cx + x3 - insetLeft, cy + y3 - insetTop];
      const [cos4, sin3] = [Math.cos(orientation), Math.sin(orientation)];
      const startPos = [
        actualCx + outerR * cos4,
        actualCy + outerR * sin3
      ];
      const endPos = [
        actualCx + innerR * cos4,
        actualCy + innerR * sin3
      ];
      return {
        startPos,
        endPos,
        gridClosed: endAngle - startAngle === 360,
        gridCenter: [actualCx, actualCy],
        gridControlAngles: new Array(3).fill(0).map((d2, i, arr) => (endAngle - startAngle) / (arr.length - 1) * i)
      };
    }
  }
  return {};
}
var ArcAxisComponent = (options) => {
  const { order, size: size5, position, orientation, labelFormatter: labelFormatter2, tickFilter, tickCount, tickMethod, important = {}, style = {}, indexBBox, title, grid: grid2 = false } = options, rest2 = __rest54(options, ["order", "size", "position", "orientation", "labelFormatter", "tickFilter", "tickCount", "tickMethod", "important", "style", "indexBBox", "title", "grid"]);
  return ({ scales: [scale10], value: value2, coordinate: coordinate2, theme }) => {
    const { bbox } = value2;
    const { domain } = scale10.getOptions();
    const data2 = getData2(scale10, domain, tickCount, labelFormatter2, tickFilter, tickMethod, position, coordinate2);
    const labels = indexBBox ? data2.map((d2, i) => {
      const bbox2 = indexBBox.get(i);
      if (!bbox2)
        return d2;
      if (bbox2[0] !== d2.label)
        return d2;
      return Object.assign(Object.assign({}, d2), { bbox: bbox2[1] });
    }) : data2;
    const [innerRadius, outerRadius] = radiusOf(coordinate2);
    const defaultStyle2 = inferArcStyle(position, bbox, innerRadius, outerRadius, coordinate2);
    const { axis: axisTheme, axisArc = {} } = theme;
    const finalStyle = adaptor(deep_mix_default({}, axisTheme, axisArc, defaultStyle2, Object.assign(Object.assign({ type: "arc", data: labels, titleText: titleContent(title), grid: grid2 }, rest2), important)));
    return new Axis({
      // @fixme transform is not valid for arcAxis.
      // @ts-ignore
      style: omit_default(finalStyle, ["transform"])
    });
  };
};
function inferThemeStyle(scale10, coordinate2, theme, direction3, position, orientation) {
  const baseStyle = theme.axis;
  const positionStyle = ["top", "right", "bottom", "left"].includes(position) ? theme[`axis${capitalizeFirst(position)}`] : theme.axisLinear;
  const channel = scale10.getOptions().name;
  const channelStyle = theme[`axis${upper_first_default(channel)}`] || {};
  return Object.assign({}, baseStyle, positionStyle, channelStyle);
}
function inferDefaultStyle(scale10, coordinate2, theme, direction3, position, orientation) {
  const themeStyle = inferThemeStyle(scale10, coordinate2, theme, direction3, position, orientation);
  if (position === "center") {
    return Object.assign(Object.assign(Object.assign(Object.assign({}, themeStyle), { labelDirection: direction3 === "right" ? "negative" : "positive" }), direction3 === "center" ? { labelTransform: "translate(50%,0)" } : null), { tickDirection: direction3 === "right" ? "negative" : "positive", labelSpacing: direction3 === "center" ? 0 : 4, titleSpacing: isVertical(orientation) ? 10 : 0, tick: direction3 === "center" ? false : void 0 });
  }
  return themeStyle;
}
var LinearAxisComponent = (options) => {
  const { direction: direction3 = "left", important = {}, labelFormatter: labelFormatter2, order, orientation, actualPosition, position, size: size5, style = {}, title, tickCount, tickFilter, tickMethod, transform: transform3, indexBBox } = options, userDefinitions = __rest54(options, ["direction", "important", "labelFormatter", "order", "orientation", "actualPosition", "position", "size", "style", "title", "tickCount", "tickFilter", "tickMethod", "transform", "indexBBox"]);
  return ({ scales: [scale10], value: value2, coordinate: coordinate2, theme }) => {
    const { bbox } = value2;
    const { domain } = scale10.getOptions();
    const defaultStyle2 = inferDefaultStyle(scale10, coordinate2, theme, direction3, position, orientation);
    const internalAxisStyle = Object.assign(Object.assign(Object.assign({}, defaultStyle2), style), userDefinitions);
    const gridLength = inferGridLength(actualPosition || position, coordinate2, options.plane);
    const overrideStyle = inferAxisLinearOverrideStyle(position, orientation, bbox, coordinate2);
    const threeDOverrideStyle = infer3DAxisLinearOverrideStyle(coordinate2);
    const data2 = getData2(scale10, domain, tickCount, labelFormatter2, tickFilter, tickMethod, position, coordinate2);
    const labels = indexBBox ? data2.map((d2, i) => {
      const bbox2 = indexBBox.get(i);
      if (!bbox2)
        return d2;
      if (bbox2[0] !== d2.label)
        return d2;
      return Object.assign(Object.assign({}, d2), { bbox: bbox2[1] });
    }) : data2;
    const finalAxisStyle = Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, internalAxisStyle), {
      type: "linear",
      data: labels,
      crossSize: size5,
      titleText: titleContent(title),
      labelOverlap: inferLabelOverlap(transform3, internalAxisStyle),
      grid: inferGrid(internalAxisStyle.grid, coordinate2, scale10),
      gridLength,
      // Always showLine, make title could align the end of axis.
      line: true,
      indexBBox
    }), !internalAxisStyle.line ? { lineOpacity: 0 } : null), overrideStyle), threeDOverrideStyle), important);
    const hasHide = finalAxisStyle.labelOverlap.find((d2) => d2.type === "hide");
    if (hasHide)
      finalAxisStyle.crossSize = false;
    return new Axis({
      className: "axis",
      style: adaptor(finalAxisStyle)
    });
  };
};
var axisFactor = (axis) => {
  return (options) => {
    const { labelFormatter: useDefinedLabelFormatter, labelFilter: userDefinedLabelFilter = () => true } = options;
    return (context) => {
      var _a2;
      const { scales: [scale10] } = context;
      const ticks2 = ((_a2 = scale10.getTicks) === null || _a2 === void 0 ? void 0 : _a2.call(scale10)) || scale10.getOptions().domain;
      const labelFormatter2 = typeof useDefinedLabelFormatter === "string" ? format2(useDefinedLabelFormatter) : useDefinedLabelFormatter;
      const labelFilter = (datum, index3, array2) => userDefinedLabelFilter(ticks2[index3], index3, ticks2);
      const normalizedOptions = Object.assign(Object.assign({}, options), {
        labelFormatter: labelFormatter2,
        labelFilter,
        scale: scale10
      });
      return axis(normalizedOptions)(context);
    };
  };
};
var LinearAxis = axisFactor(LinearAxisComponent);
var ArcAxis = axisFactor(ArcAxisComponent);
LinearAxis.props = {
  defaultPosition: "center",
  defaultSize: 45,
  defaultOrder: 0,
  defaultCrossPadding: [12, 12],
  defaultPadding: [12, 12]
};
ArcAxis.props = {
  defaultPosition: "outer",
  defaultOrientation: "vertical",
  defaultSize: 45,
  defaultOrder: 0,
  defaultCrossPadding: [12, 12],
  defaultPadding: [12, 12]
};

// node_modules/@antv/g2/esm/component/axisX.js
var AxisX = (options) => {
  return (...args) => {
    const axisX = LinearAxis(Object.assign({}, { crossPadding: 50 }, options))(...args);
    rotateAxis(axisX, options);
    return axisX;
  };
};
AxisX.props = Object.assign(Object.assign({}, LinearAxis.props), { defaultPosition: "bottom" });

// node_modules/@antv/g2/esm/component/axisY.js
var AxisY = (options) => {
  return (...args) => {
    const axisY = LinearAxis(Object.assign({}, { crossPadding: 10 }, options))(...args);
    rotateAxis(axisY, options);
    return axisY;
  };
};
AxisY.props = Object.assign(Object.assign({}, LinearAxis.props), { defaultPosition: "left" });

// node_modules/@antv/g2/esm/component/axisRadar.js
var __rest55 = function(s2, e) {
  var t = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
      t[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t[p2[i]] = s2[p2[i]];
    }
  return t;
};
function inferTitleTransform(orientation) {
  const internalOrientation = orientation % (Math.PI * 2);
  if (internalOrientation === Math.PI / 2) {
    return { titleTransform: "translate(0, 50%)" };
  }
  if (internalOrientation > -Math.PI / 2 && internalOrientation < Math.PI / 2) {
    return { titleTransform: "translate(50%, 0)" };
  }
  if (internalOrientation > Math.PI / 2 && internalOrientation < Math.PI * 3 / 2) {
    return { titleTransform: "translate(-50%, 0)" };
  }
  return {};
}
function inferAxisStyle(options, theme, coordinate2, scales) {
  const { radar } = options;
  const [scale10] = scales;
  const name2 = scale10.getOptions().name;
  const [startAngle, endAngle] = angleOf(coordinate2);
  const { axisRadar: radarTheme = {} } = theme;
  return Object.assign(Object.assign({}, radarTheme), { grid: name2 === "position", gridConnect: "line", gridControlAngles: new Array(radar.count).fill(0).map((_2, i) => {
    const angle4 = (endAngle - startAngle) / radar.count;
    return angle4 * i;
  }) });
}
var AxisRadar = (options) => {
  const { important = {} } = options, restOptions = __rest55(options, ["important"]);
  return (context) => {
    const { theme, coordinate: coordinate2, scales } = context;
    return LinearAxis(Object.assign(Object.assign(Object.assign({}, restOptions), inferTitleTransform(options.orientation)), { important: Object.assign(Object.assign({}, inferAxisStyle(options, theme, coordinate2, scales)), important) }))(context);
  };
};
AxisRadar.props = Object.assign(Object.assign({}, LinearAxis.props), { defaultPosition: "center" });

// node_modules/@antv/g2/esm/component/legendCategory.js
var __rest56 = function(s2, e) {
  var t = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
      t[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t[p2[i]] = s2[p2[i]];
    }
  return t;
};
function inferShape(scales, markState) {
  const shapeScale = scaleOf(scales, "shape");
  const colorScale = scaleOf(scales, "color");
  const shapeScale1 = shapeScale ? shapeScale.clone() : null;
  const shapes = [];
  for (const [mark2, state] of markState) {
    const namespace = mark2.type;
    const domain = (colorScale === null || colorScale === void 0 ? void 0 : colorScale.getOptions().domain.length) > 0 ? colorScale === null || colorScale === void 0 ? void 0 : colorScale.getOptions().domain : state.data;
    const shape23 = domain.map((d2, i) => {
      var _a2;
      if (shapeScale1)
        return shapeScale1.map(d2 || "point");
      return ((_a2 = mark2 === null || mark2 === void 0 ? void 0 : mark2.style) === null || _a2 === void 0 ? void 0 : _a2.shape) || state.defaultShape || "point";
    });
    if (typeof namespace === "string")
      shapes.push([namespace, shape23]);
  }
  if (shapes.length === 0)
    return ["point", ["point"]];
  if (shapes.length === 1)
    return shapes[0];
  if (!shapeScale)
    return shapes[0];
  const { range: range4 } = shapeScale.getOptions();
  return shapes.map(([namespace, shape23]) => {
    let sum5 = 0;
    for (let i = 0; i < shapes.length; i++) {
      const targetShape = range4[i % range4.length];
      if (shape23[i] === targetShape)
        sum5++;
    }
    return [sum5 / shape23.length, [namespace, shape23]];
  }).sort((a4, b) => b[0] - a4[0])[0][1];
}
function inferItemMarker(options, context) {
  const { scales, library: library3, markState } = context;
  const [mark2, shapes] = inferShape(scales, markState);
  const { itemMarker, itemMarkerSize: size5 } = options;
  const create9 = (name2, d2) => {
    var _a2, _b, _c;
    const marker = ((_c = (_b = (_a2 = library3[`mark.${mark2}`]) === null || _a2 === void 0 ? void 0 : _a2.props) === null || _b === void 0 ? void 0 : _b.shape[name2]) === null || _c === void 0 ? void 0 : _c.props.defaultMarker) || last(name2.split("."));
    const radius = typeof size5 === "function" ? size5(d2) : size5;
    return () => useMarker(marker, { color: d2.color })(0, 0, radius);
  };
  const shapeOf = (i) => `${shapes[i]}`;
  const shapeScale = scaleOf(scales, "shape");
  if (shapeScale && !itemMarker)
    return (d2, i) => create9(shapeOf(i), d2);
  if (typeof itemMarker === "function") {
    return (d2, i) => {
      const node = itemMarker(d2.id, i);
      if (typeof node === "string")
        return create9(node, d2);
      return node;
    };
  }
  return (d2, i) => create9(itemMarker || shapeOf(i), d2);
}
function inferItemMarkerOpacity(scales) {
  const scale10 = scaleOf(scales, "opacity");
  if (scale10) {
    const { range: range4 } = scale10.getOptions();
    return (d2, i) => range4[i];
  }
  return void 0;
}
function inferItemMarkerSize(scales, defaults5) {
  const scale10 = scaleOf(scales, "size");
  if (scale10 instanceof Identity)
    return scale10.map(NaN) * 2;
  return defaults5;
}
function inferCategoryStyle(options, context) {
  const { labelFormatter: labelFormatter2 = (d2) => `${d2}` } = options;
  const { scales, theme } = context;
  const defaultSize = theme.legendCategory.itemMarkerSize;
  const itemMarkerSize = inferItemMarkerSize(scales, defaultSize);
  const baseStyle = {
    itemMarker: inferItemMarker(Object.assign(Object.assign({}, options), { itemMarkerSize }), context),
    itemMarkerSize,
    itemMarkerOpacity: inferItemMarkerOpacity(scales)
  };
  const finalLabelFormatter = typeof labelFormatter2 === "string" ? format2(labelFormatter2) : labelFormatter2;
  const colorScale = scaleOf(scales, "color");
  const domain = domainOf2(scales);
  const colorOf = colorScale ? (d2) => colorScale.map(d2) : () => context.theme.color;
  return Object.assign(Object.assign({}, baseStyle), { data: domain.map((d2) => ({
    id: d2,
    label: finalLabelFormatter(d2),
    color: colorOf(d2)
  })) });
}
function inferLegendShape(value2, options, component) {
  const { position } = options;
  if (position === "center") {
    const { bbox } = value2;
    const { width: width2, height: height2 } = bbox;
    return { width: width2, height: height2 };
  }
  const { width, height } = inferComponentShape(value2, options, component);
  return { width, height };
}
var LegendCategory = (options) => {
  const { labelFormatter: labelFormatter2, layout, order, orientation, position, size: size5, title, cols, itemMarker } = options, style = __rest56(options, ["labelFormatter", "layout", "order", "orientation", "position", "size", "title", "cols", "itemMarker"]);
  const { gridRow } = style;
  return (context) => {
    const { value: value2, theme } = context;
    const { bbox } = value2;
    const { width, height } = inferLegendShape(value2, options, LegendCategory);
    const finalLayout = inferComponentLayout(position, layout);
    const legendStyle = Object.assign(Object.assign(Object.assign(Object.assign({
      orientation: ["right", "left", "center"].includes(position) ? "vertical" : "horizontal",
      width,
      height,
      layout: cols !== void 0 ? "grid" : "flex"
    }, cols !== void 0 && { gridCol: cols }), gridRow !== void 0 && { gridRow }), { titleText: titleContent(title) }), inferCategoryStyle(options, context));
    const { legendCategory: legendTheme = {} } = theme;
    const categoryStyle = adaptor(Object.assign({}, legendTheme, legendStyle, style));
    const layoutWrapper = new LegendCategoryLayout({
      style: Object.assign(Object.assign({ x: bbox.x, y: bbox.y, width: bbox.width, height: bbox.height }, finalLayout), {
        // @ts-ignore
        subOptions: categoryStyle
      })
    });
    layoutWrapper.appendChild(new Category({
      className: "legend-category",
      style: categoryStyle
    }));
    return layoutWrapper;
  };
};
LegendCategory.props = {
  defaultPosition: "top",
  defaultOrder: 1,
  defaultSize: 40,
  defaultCrossPadding: [12, 12],
  defaultPadding: [12, 12]
};

// node_modules/@antv/g2/esm/component/legendContinuous.js
var __rest57 = function(s2, e) {
  var t = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
      t[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t[p2[i]] = s2[p2[i]];
    }
  return t;
};
function updateShapeDimensions(shape23, finalSize, orientation) {
  shape23.size = finalSize;
  if (isHorizontal2(orientation)) {
    shape23.height = finalSize;
  } else {
    shape23.width = finalSize;
  }
  return shape23;
}
function inferContinuousShape(value2, options, component) {
  const { size: size5 } = options;
  const shape23 = inferComponentShape(value2, options, component);
  return updateShapeDimensions(shape23, size5, shape23.orientation);
}
function getFormatter(max11) {
  return (value2) => ({
    value: value2 / max11,
    label: String(value2)
  });
}
function getQuantizeOrQuantileConfig(shape23, colorScale, min11, max11, range4) {
  const thresholds = colorScale.thresholds;
  const formatter2 = getFormatter(max11);
  return Object.assign(Object.assign({}, shape23), { color: range4, data: [min11, ...thresholds, max11].map(formatter2) });
}
function getThresholdConfig(shape23, colorScale, range4) {
  const thresholds = colorScale.thresholds;
  const data2 = [-Infinity, ...thresholds, Infinity].map((value2, index3) => ({
    value: index3,
    label: value2
  }));
  return Object.assign(Object.assign({}, shape23), { data: data2, color: range4, labelFilter: (datum, index3) => {
    return index3 > 0 && index3 < data2.length - 1;
  } });
}
function rangeOf4(scale10) {
  const { domain } = scale10.getOptions();
  const [min11, max11] = [domain[0], lastOf(domain)];
  return [min11, max11];
}
function createColorScale(scale10, defaultColor) {
  const options = scale10.getOptions();
  const newScale = scale10.clone();
  newScale.update(Object.assign(Object.assign({}, options), { range: [parseColor(defaultColor).toString()] }));
  return newScale;
}
function getLinearConfig(shape23, colorScale, sizeScale, opacityScale, scales, theme) {
  const { length: length5 } = shape23;
  const definedScale = sizeScale || opacityScale;
  const defaultColor = scales.color ? theme.legendContinuous.ribbonFill || "black" : theme.color;
  const scale10 = colorScale || createColorScale(definedScale, defaultColor);
  const [min11, max11] = rangeOf4(scale10);
  const [domainMin, domainMax] = rangeOf4([colorScale, sizeScale, opacityScale].filter((d2) => d2 !== void 0).find((d2) => !(d2 instanceof Constant2)));
  return Object.assign(Object.assign({}, shape23), { domain: [domainMin, domainMax], data: scale10.getTicks().map((value2) => ({ value: value2 })), color: new Array(Math.floor(length5)).fill(0).map((d2, i) => {
    const value2 = (max11 - min11) / (length5 - 1) * i + min11;
    const color2 = scale10.map(value2) || defaultColor;
    const opacity = opacityScale ? opacityScale.map(value2) : 1;
    return color2.replace(/rgb[a]*\(([\d]{1,3}) *, *([\d]{1,3}) *, *([\d]{1,3})[\S\s]*\)/, (match, p1, p2, p3) => `rgba(${p1}, ${p2}, ${p3}, ${opacity})`);
  }) });
}
function inferContinuousConfig(scales, scale10, value2, options, component, theme) {
  const colorScale = scaleOf(scales, "color");
  const shape23 = inferContinuousShape(value2, options, component);
  if (colorScale instanceof Threshold) {
    const { range: range4 } = colorScale.getOptions();
    const [min11, max11] = rangeOf4(colorScale);
    if (colorScale instanceof Quantize || colorScale instanceof Quantile) {
      return getQuantizeOrQuantileConfig(shape23, colorScale, min11, max11, range4);
    }
    return getThresholdConfig(shape23, colorScale, range4);
  }
  const sizeScale = scaleOf(scales, "size");
  const opacityScale = scaleOf(scales, "opacity");
  return getLinearConfig(shape23, colorScale, sizeScale, opacityScale, scale10, theme);
}
var LegendContinuous = (options) => {
  const { labelFormatter: labelFormatter2, layout, order, orientation, position, size: size5, title, style, crossPadding, padding } = options, rest2 = __rest57(options, ["labelFormatter", "layout", "order", "orientation", "position", "size", "title", "style", "crossPadding", "padding"]);
  return ({ scales, value: value2, theme, scale: scale10 }) => {
    const { bbox } = value2;
    const { x: x3, y: y3, width, height } = bbox;
    const finalLayout = inferComponentLayout(position, layout);
    const { legendContinuous: legendTheme = {} } = theme;
    const finalStyle = adaptor(Object.assign({}, legendTheme, Object.assign(Object.assign({ titleText: titleContent(title), labelAlign: "value", labelFormatter: typeof labelFormatter2 === "string" ? (d2) => format2(labelFormatter2)(d2.label) : labelFormatter2 }, inferContinuousConfig(scales, scale10, value2, options, LegendContinuous, theme)), style), rest2));
    const layoutWrapper = new G2Layout({
      style: Object.assign(Object.assign({
        x: x3,
        y: y3,
        width,
        height
      }, finalLayout), {
        // @ts-ignore
        subOptions: finalStyle
      })
    });
    layoutWrapper.appendChild(new Continuous2({
      className: "legend-continuous",
      style: finalStyle
    }));
    return layoutWrapper;
  };
};
LegendContinuous.props = {
  defaultPosition: "top",
  defaultOrientation: "vertical",
  defaultOrder: 1,
  defaultSize: 60,
  defaultLength: 200,
  defaultLegendSize: 60,
  defaultPadding: [20, 10],
  defaultCrossPadding: [12, 12]
  // [horizontal, vertical]
};

// node_modules/@antv/g2/esm/component/legendContinuousBlock.js
var LegendContinuousBlock = (options) => {
  return (...args) => LegendContinuous(Object.assign({}, { block: true }, options))(...args);
};
LegendContinuousBlock.props = Object.assign(Object.assign({}, LegendContinuous.props), { defaultPosition: "top", defaultOrientation: "horizontal" });

// node_modules/@antv/g2/esm/component/legendContinuousSize.js
var LegendContinuousSize = (options) => {
  return (context) => {
    const { scales } = context;
    const sizeScale = scaleOf(scales, "size");
    return LegendContinuous(Object.assign({}, {
      type: "size",
      data: sizeScale.getTicks().map((value2, index3) => ({
        value: value2,
        label: String(value2)
      }))
    }, options))(context);
  };
};
LegendContinuousSize.props = Object.assign(Object.assign({}, LegendContinuous.props), { defaultPosition: "top", defaultOrientation: "horizontal" });

// node_modules/@antv/g2/esm/component/legendContinuousBlockSize.js
var LegendContinuousBlockSize = (options) => {
  return LegendContinuousSize(Object.assign({}, { block: true }, options));
};
LegendContinuousBlockSize.props = Object.assign(Object.assign({}, LegendContinuous.props), { defaultPosition: "top", defaultOrientation: "horizontal" });

// node_modules/@antv/g2/esm/component/title.js
var __rest58 = function(s2, e) {
  var t = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
      t[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t[p2[i]] = s2[p2[i]];
    }
  return t;
};
function inferStyleByAlign(x3, y3, width, align) {
  switch (align) {
    case "center":
      return {
        x: x3 + width / 2,
        y: y3,
        textAlign: "middle"
      };
    case "right":
      return {
        x: x3 + width,
        y: y3,
        textAlign: "right"
      };
    default:
      return {
        x: x3,
        y: y3,
        textAlign: "left"
      };
  }
}
var Title2 = createComponent({
  render(attributes, container) {
    const { width, title, subtitle, spacing = 2, align = "left" } = attributes, style = __rest58(attributes, ["width", "title", "subtitle", "spacing", "align"]);
    const titleStyle = subObject(style, "title");
    const subtitleStyle = subObject(style, "subtitle");
    const mainTitle = maybeAppend2(container, ".title", "text").attr("className", "title").call(applyStyle, Object.assign(Object.assign(Object.assign({}, inferStyleByAlign(0, 0, width, align)), { fontSize: 14, textBaseline: "top", text: title }), titleStyle)).node();
    const bounds = mainTitle.getLocalBounds();
    maybeAppend2(container, ".sub-title", "text").attr("className", "sub-title").call((selection) => {
      if (!subtitle)
        return selection.node().remove();
      selection.node().attr(Object.assign(Object.assign(Object.assign({}, inferStyleByAlign(0, bounds.max[1] + spacing, width, align)), { fontSize: 12, textBaseline: "top", text: subtitle }), subtitleStyle));
    });
  }
});
var TitleComponent = (options) => {
  return ({ value: value2, theme }) => {
    const { x: x3, y: y3, width, height } = value2.bbox;
    return new Title2({
      style: deep_mix_default({}, theme.title, Object.assign({
        x: x3,
        y: y3,
        width,
        height
      }, options))
    });
  };
};
TitleComponent.props = {
  defaultPosition: "top",
  defaultOrder: 2,
  defaultSize: 36,
  defaultCrossPadding: [20, 20],
  defaultPadding: [12, 12]
};

// node_modules/@antv/g2/esm/utils/scale.js
function constrain(x3, lo, hi) {
  return Math.min(hi, Math.max(lo, x3));
}
function isOrdinalScale(scale10) {
  return !!scale10.getBandWidth;
}
function invert4(scale10, x3, start) {
  if (!isOrdinalScale(scale10))
    return scale10.invert(x3);
  const { adjustedRange } = scale10;
  const { domain } = scale10.getOptions();
  const offset2 = start ? -1 : 0;
  const step2 = scale10.getStep();
  const range4 = start ? adjustedRange : adjustedRange.map((d2) => d2 + step2);
  const i0 = bisectLeft(range4, x3);
  const i1 = constrain(i0 + offset2, 0, domain.length - 1);
  return domain[i1];
}
function domainOf3(scale10, values4, ratioX) {
  if (!values4)
    return scale10.getOptions().domain;
  if (!isOrdinalScale(scale10)) {
    const sortedDomain = sort(values4);
    if (!ratioX)
      return sortedDomain;
    const [d2] = sortedDomain;
    const { range: range4 } = scale10.getOptions();
    const [r0, r1] = range4;
    const v = r0 > r1 ? -1 : 1;
    const d1 = scale10.invert(scale10.map(d2) + v * ratioX);
    return [d2, d1];
  }
  const { domain } = scale10.getOptions();
  const v1 = values4[0];
  const start = domain.indexOf(v1);
  if (ratioX) {
    const end2 = start + Math.round(domain.length * ratioX);
    return domain.slice(start, end2);
  }
  const v2 = values4[values4.length - 1];
  const end = domain.indexOf(v2);
  return domain.slice(start, end + 1);
}
function selectionOf(x3, y3, x12, y12, scale10, coordinate2) {
  const { x: scaleX, y: scaleY } = scale10;
  const abstractDomain = (point7, start) => {
    const [x4, y4] = coordinate2.invert(point7);
    return [invert4(scaleX, x4, start), invert4(scaleY, y4, start)];
  };
  const p0 = abstractDomain([x3, y3], true);
  const p1 = abstractDomain([x12, y12], false);
  const domainX = domainOf3(scaleX, [p0[0], p1[0]]);
  const domainY = domainOf3(scaleY, [p0[1], p1[1]]);
  return [domainX, domainY];
}
function abstractOf(domain, scale10) {
  const [d0, d1] = domain;
  const maybeStep = (scale11) => scale11.getStep ? scale11.getStep() : 0;
  return [scale10.map(d0), scale10.map(d1) + maybeStep(scale10)];
}
function pixelsOf(selection, scale10, coordinate2) {
  const { x: scaleX, y: scaleY } = scale10;
  const [X, Y] = selection;
  const AX = abstractOf(X, scaleX);
  const AY = abstractOf(Y, scaleY);
  const p0 = [AX[0], AY[0]];
  const p1 = [AX[1], AY[1]];
  const [x3, y3] = coordinate2.map(p0);
  const [x12, y12] = coordinate2.map(p1);
  return [x3, y3, x12, y12];
}

// node_modules/@antv/g2/esm/component/slider.js
var __rest59 = function(s2, e) {
  var t = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
      t[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t[p2[i]] = s2[p2[i]];
    }
  return t;
};
function inferPosition2(bbox, position, trackSize) {
  const { x: x3, y: y3, width, height } = bbox;
  if (position === "left")
    return [x3 + width - trackSize, y3];
  if (position === "right")
    return [x3, y3];
  if (position === "bottom")
    return [x3, y3];
  if (position === "top")
    return [x3, y3 + height - trackSize];
}
var Slider2 = (options) => {
  const { orientation, labelFormatter: labelFormatter2, size: size5, style = {}, position } = options, rest2 = __rest59(options, ["orientation", "labelFormatter", "size", "style", "position"]);
  return (context) => {
    var _a2;
    const { scales: [scale10], value: value2, theme, coordinate: coordinate2 } = context;
    const { bbox } = value2;
    const { width, height } = bbox;
    const { slider: sliderTheme = {} } = theme;
    const defaultFormatter = ((_a2 = scale10.getFormatter) === null || _a2 === void 0 ? void 0 : _a2.call(scale10)) || ((v) => v + "");
    const formatter2 = typeof labelFormatter2 === "string" ? format2(labelFormatter2) : labelFormatter2;
    const isHorizontal3 = orientation === "horizontal";
    const reverse3 = isTranspose(coordinate2) && isHorizontal3;
    const { trackSize = sliderTheme.trackSize } = style;
    const [x05, y05] = inferPosition2(bbox, position, trackSize);
    return new Slider({
      className: "slider",
      style: Object.assign({}, sliderTheme, Object.assign(Object.assign({ x: x05, y: y05, trackLength: isHorizontal3 ? width : height, orientation, formatter: (v) => {
        const f = formatter2 || defaultFormatter;
        const v1 = reverse3 ? 1 - v : v;
        const tick3 = invert4(scale10, v1, true);
        return f(tick3);
      }, sparklineData: inferSparklineData(options, context) }, style), rest2))
    });
  };
};
function markValue(markState, channels) {
  const [value2] = Array.from(markState.entries()).filter(([mark2]) => mark2.type === "line" || mark2.type === "area").map(([mark2]) => {
    const { encode, slider } = mark2;
    if ((slider === null || slider === void 0 ? void 0 : slider.x) && Object.keys(slider.x).length === 0) {
      const channel = (name2) => {
        const channel2 = encode[name2];
        return [name2, channel2 ? channel2.value : void 0];
      };
      return Object.fromEntries(channels.map(channel));
    }
  });
  if (!(value2 === null || value2 === void 0 ? void 0 : value2.series))
    return value2 === null || value2 === void 0 ? void 0 : value2.y;
  const result2 = value2.series.reduce((acc, curr, index3) => {
    acc[curr] = acc[curr] || [];
    acc[curr].push(value2.y[index3]);
    return acc;
  }, {});
  return Object.values(result2);
}
function inferSparklineData(options, context) {
  const { markState } = context;
  if (is_array_default(options.sparklineData))
    return options.sparklineData;
  return markValue(markState, ["y", "series"]);
}
Slider2.props = {
  defaultPosition: "bottom",
  defaultSize: 24,
  defaultOrder: 1,
  defaultCrossPadding: [12, 12],
  defaultPadding: [12, 12]
};

// node_modules/@antv/g2/esm/component/sliderX.js
var SliderX = (options) => {
  return Slider2(Object.assign(Object.assign({}, options), { orientation: "horizontal" }));
};
SliderX.props = Object.assign(Object.assign({}, Slider2.props), { defaultPosition: "bottom" });

// node_modules/@antv/g2/esm/component/sliderY.js
var SliderY = (options) => {
  return Slider2(Object.assign(Object.assign({}, options), { orientation: "vertical" }));
};
SliderY.props = Object.assign(Object.assign({}, Slider2.props), { defaultPosition: "left" });

// node_modules/@antv/g2/esm/component/scrollbar.js
var __rest60 = function(s2, e) {
  var t = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
      t[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t[p2[i]] = s2[p2[i]];
    }
  return t;
};
var Scrollbar2 = (options) => {
  const { orientation, labelFormatter: labelFormatter2, style } = options, rest2 = __rest60(options, ["orientation", "labelFormatter", "style"]);
  return ({ scales: [scale10], value: value2, theme }) => {
    const { bbox } = value2;
    const { x: x3, y: y3, width, height } = bbox;
    const { scrollbar: scrollbarTheme = {} } = theme;
    const { ratio, range: range4 } = scale10.getOptions();
    const mainSize = orientation === "horizontal" ? width : height;
    const actualSize = mainSize / ratio;
    const [r0, r1] = range4;
    const value1 = r1 > r0 ? 0 : 1;
    return new Scrollbar({
      className: "g2-scrollbar",
      style: Object.assign({}, scrollbarTheme, Object.assign(Object.assign(Object.assign(Object.assign({}, style), {
        x: x3,
        y: y3,
        trackLength: mainSize,
        value: value1
      }), rest2), { orientation, contentLength: actualSize, viewportLength: mainSize }))
    });
  };
};
Scrollbar2.props = {
  defaultPosition: "bottom",
  defaultSize: 24,
  defaultOrder: 1,
  defaultCrossPadding: [12, 12],
  defaultPadding: [12, 12]
};

// node_modules/@antv/g2/esm/component/scrollbarX.js
var ScrollbarX = (options) => {
  return Scrollbar2(Object.assign(Object.assign({}, options), { orientation: "horizontal" }));
};
ScrollbarX.props = Object.assign(Object.assign({}, Scrollbar2.props), { defaultPosition: "bottom" });

// node_modules/@antv/g2/esm/component/scrollbarY.js
var ScrollbarY = (options) => {
  return Scrollbar2(Object.assign(Object.assign({}, options), { orientation: "vertical" }));
};
ScrollbarY.props = Object.assign(Object.assign({}, Scrollbar2.props), { defaultPosition: "left" });

// node_modules/@antv/g2/esm/component/legends.js
var Legends = (options) => {
  return () => {
    return new Group2();
  };
};
Legends.props = {};

// node_modules/@antv/g2/esm/animation/scaleInX.js
var ScaleInX = (options, context) => {
  const ZERO = 1e-4;
  const { coordinate: coordinate2 } = context;
  return (from, _2, defaults5) => {
    const [shape23] = from;
    const { transform: prefix = "", fillOpacity = 1, strokeOpacity = 1, opacity = 1 } = shape23.style;
    const [transformOrigin, transform3] = isTranspose(coordinate2) ? [`left bottom`, `scale(1, ${ZERO})`] : [`left top`, `scale(${ZERO}, 1)`];
    const keyframes = [
      {
        transform: `${prefix} ${transform3}`.trimStart(),
        transformOrigin,
        fillOpacity: 0,
        strokeOpacity: 0,
        opacity: 0
      },
      {
        transform: `${prefix} ${transform3}`.trimStart(),
        transformOrigin,
        fillOpacity,
        strokeOpacity,
        opacity,
        offset: 0.01
      },
      {
        transform: `${prefix} scale(1, 1)`.trimStart(),
        transformOrigin,
        fillOpacity,
        strokeOpacity,
        opacity
      }
    ];
    const animation = shape23.animate(keyframes, Object.assign(Object.assign({}, defaults5), options));
    return animation;
  };
};

// node_modules/@antv/g2/esm/animation/scaleOutX.js
var ScaleOutX = (options, context) => {
  const ZERO = 1e-4;
  const { coordinate: coordinate2 } = context;
  return (from, _2, defaults5) => {
    const [shape23] = from;
    const { transform: prefix = "", fillOpacity = 1, strokeOpacity = 1, opacity = 1 } = shape23.style;
    const [transformOrigin, transform3] = isTranspose(coordinate2) ? [`left bottom`, `scale(1, ${ZERO})`] : [`left top`, `scale(${ZERO}, 1)`];
    const keyframes = [
      {
        transform: `${prefix} scale(1, 1)`.trimStart(),
        transformOrigin
      },
      {
        transform: `${prefix} ${transform3}`.trimStart(),
        transformOrigin,
        fillOpacity,
        strokeOpacity,
        opacity,
        offset: 0.99
      },
      {
        transform: `${prefix} ${transform3}`.trimStart(),
        transformOrigin,
        fillOpacity: 0,
        strokeOpacity: 0,
        opacity: 0
      }
    ];
    const animation = shape23.animate(keyframes, Object.assign(Object.assign({}, defaults5), options));
    return animation;
  };
};

// node_modules/@antv/g2/esm/animation/scaleInY.js
var ScaleInY = (options, context) => {
  const ZERO = 1e-4;
  const { coordinate: coordinate2 } = context;
  CSS.registerProperty({
    name: "scaleInYRadius",
    inherits: false,
    initialValue: "",
    interpolable: true,
    syntax: PropertySyntax.NUMBER
  });
  return (from, _2, defaults5) => {
    const [shape23] = from;
    const PolarScaleInY = (shape24) => {
      const { __data__, style } = shape24;
      const { radius = 0, inset = 0, fillOpacity = 1, strokeOpacity = 1, opacity = 1 } = style;
      const { points, y: y3, y1: y12 } = __data__;
      const arcObject = getArcObject(coordinate2, points, [y3, y12]);
      const { innerRadius, outerRadius } = arcObject;
      const path2 = arc_default().cornerRadius(radius).padAngle(inset * Math.PI / 180);
      const pathForConversion = new Path2({});
      const center2 = coordinate2.getCenter();
      const createArcPath = (arcParams) => {
        pathForConversion.attr({
          d: path2(arcParams),
          transform: `translate(${center2[0]}, ${center2[1]})`
        });
        const convertedPathDefinition = convertToPath(pathForConversion);
        pathForConversion.style.transform = "";
        return convertedPathDefinition;
      };
      const keyframes = [
        {
          scaleInYRadius: innerRadius + ZERO,
          fillOpacity: 0,
          strokeOpacity: 0,
          opacity: 0
        },
        {
          scaleInYRadius: innerRadius + ZERO,
          fillOpacity,
          strokeOpacity,
          opacity,
          offset: 0.01
        },
        {
          scaleInYRadius: outerRadius,
          fillOpacity,
          strokeOpacity,
          opacity
        }
      ];
      const animation = shape24.animate(keyframes, Object.assign(Object.assign({}, defaults5), options));
      animation.onframe = function() {
        shape24.style.path = createArcPath(Object.assign(Object.assign({}, arcObject), { outerRadius: Number(shape24.style.scaleInYRadius) }));
      };
      animation.onfinish = function() {
        shape24.style.path = createArcPath(Object.assign(Object.assign({}, arcObject), { outerRadius }));
      };
      return animation;
    };
    const RectangularScaleInY = (shape24) => {
      const { style } = shape24;
      const { transform: prefix = "", fillOpacity = 1, strokeOpacity = 1, opacity = 1 } = style;
      const [transformOrigin, transform3] = isTranspose(coordinate2) ? [`left top`, `scale(${ZERO}, 1)`] : [`left bottom`, `scale(1, ${ZERO})`];
      const keyframes = [
        {
          transform: `${prefix} ${transform3}`.trimStart(),
          transformOrigin,
          fillOpacity: 0,
          strokeOpacity: 0,
          opacity: 0
        },
        {
          transform: `${prefix} ${transform3}`.trimStart(),
          transformOrigin,
          fillOpacity,
          strokeOpacity,
          opacity,
          offset: 0.01
        },
        {
          transform: `${prefix} scale(1, 1)`.trimStart(),
          transformOrigin,
          fillOpacity,
          strokeOpacity,
          opacity
        }
      ];
      const animation = shape24.animate(keyframes, Object.assign(Object.assign({}, defaults5), options));
      return animation;
    };
    if (isPolar(coordinate2)) {
      return PolarScaleInY(shape23);
    } else {
      return RectangularScaleInY(shape23);
    }
  };
};

// node_modules/@antv/g2/esm/animation/scaleOutY.js
var ScaleOutY = (options, context) => {
  const ZERO = 1e-4;
  const { coordinate: coordinate2 } = context;
  return (from, _2, defaults5) => {
    const [shape23] = from;
    const { transform: prefix = "", fillOpacity = 1, strokeOpacity = 1, opacity = 1 } = shape23.style;
    const [transformOrigin, transform3] = isTranspose(coordinate2) ? [`left top`, `scale(${ZERO}, 1)`] : [`left bottom`, `scale(1, ${ZERO})`];
    const keyframes = [
      {
        transform: `${prefix} scale(1, 1)`.trimStart(),
        transformOrigin
      },
      {
        transform: `${prefix} ${transform3}`.trimStart(),
        transformOrigin,
        fillOpacity,
        strokeOpacity,
        opacity,
        offset: 0.99
      },
      {
        transform: `${prefix} ${transform3}`.trimStart(),
        transformOrigin,
        fillOpacity: 0,
        strokeOpacity: 0,
        opacity: 0
      }
    ];
    const animation = shape23.animate(keyframes, Object.assign(Object.assign({}, defaults5), options));
    return animation;
  };
};

// node_modules/@antv/g2/esm/animation/fadeIn.js
var FadeIn = (options) => {
  return (from, _2, defaults5) => {
    const [shape23] = from;
    const { fillOpacity = 1, strokeOpacity = 1, opacity = 1 } = shape23.style;
    const keyframes = [
      { fillOpacity: 0, strokeOpacity: 0, opacity: 0 },
      {
        fillOpacity,
        strokeOpacity,
        opacity
      }
    ];
    return shape23.animate(keyframes, Object.assign(Object.assign({}, defaults5), options));
  };
};
FadeIn.props = {};

// node_modules/@antv/g2/esm/animation/fadeOut.js
var FadeOut = (options) => {
  return (from, _2, defaults5) => {
    const [shape23] = from;
    const { fillOpacity = 1, strokeOpacity = 1, opacity = 1 } = shape23.style;
    const keyframes = [
      {
        fillOpacity,
        strokeOpacity,
        opacity
      },
      { fillOpacity: 0, strokeOpacity: 0, opacity: 0 }
    ];
    return shape23.animate(keyframes, Object.assign(Object.assign({}, defaults5), options));
  };
};
FadeOut.props = {};

// node_modules/@antv/g2/esm/animation/utils.js
function attributeOf(shape23, keys3) {
  const attribute = {};
  for (const key of keys3) {
    const value2 = shape23.style[key];
    if (value2) {
      attribute[key] = value2;
    }
  }
  return attribute;
}
var attributeKeys = [
  "fill",
  "stroke",
  "fillOpacity",
  "strokeOpacity",
  "opacity",
  "lineWidth"
];

// node_modules/@antv/g2/esm/animation/morphing.js
function localBBoxOf(shape23) {
  const { min: min11, max: max11 } = shape23.getLocalBounds();
  const [x05, y05] = min11;
  const [x12, y12] = max11;
  const height = y12 - y05;
  const width = x12 - x05;
  return [x05, y05, width, height];
}
function d(bbox) {
  const [x3, y3, width, height] = bbox;
  return `
    M ${x3} ${y3}
    L ${x3 + width} ${y3}
    L ${x3 + width} ${y3 + height}
    L ${x3} ${y3 + height}
    Z
  `;
}
function pack2(shape23, count4) {
  const [x05, y05, width, height] = localBBoxOf(shape23);
  const aspect = height / width;
  const col = Math.ceil(Math.sqrt(count4 / aspect));
  const row2 = Math.ceil(count4 / col);
  const B3 = [];
  const h = height / row2;
  let j = 0;
  let n = count4;
  while (n > 0) {
    const c5 = Math.min(n, col);
    const w = width / c5;
    for (let i = 0; i < c5; i++) {
      const x3 = x05 + i * w;
      const y3 = y05 + j * h;
      B3.push(d([x3, y3, w, h]));
    }
    n -= c5;
    j += 1;
  }
  return B3;
}
function normalizeSplit(split2 = "pack") {
  if (typeof split2 == "function")
    return split2;
  return pack2;
}
function shapeToShape(from, to, timeEffect) {
  const [x05, y05, w0, h0] = localBBoxOf(from);
  const { transform: fromTransform } = from.style;
  const { transform: toTransform } = to.style;
  replaceChild(to, from);
  const [x12, y12, w1, h1] = localBBoxOf(to);
  const dx = x05 - x12;
  const dy = y05 - y12;
  const sx = w0 / w1;
  const sy = h0 / h1;
  const keyframes = [
    Object.assign({ transform: `${fromTransform ? fromTransform + " " : ""}translate(${dx}, ${dy}) scale(${sx}, ${sy})` }, attributeOf(from, attributeKeys)),
    Object.assign({ transform: `${toTransform ? toTransform + " " : ""}translate(0, 0) scale(1, 1)` }, attributeOf(to, attributeKeys))
  ];
  const animation = to.animate(keyframes, timeEffect);
  return animation;
}
function replaceChild(newChild, oldChild) {
  newChild["__data__"] = oldChild["__data__"];
  newChild.className = oldChild.className;
  newChild.markType = oldChild.markType;
  oldChild.parentNode.replaceChild(newChild, oldChild);
}
function maybePath(node, d2) {
  const { nodeName } = node;
  if (nodeName === "path")
    return node;
  const path2 = new Path2({
    style: Object.assign(Object.assign({}, attributeOf(node, attributeKeys)), { d: d2 })
  });
  replaceChild(path2, node);
  return path2;
}
function hasUniqueString(search2, pattern) {
  const first3 = search2.indexOf(pattern);
  const last7 = search2.lastIndexOf(pattern);
  return first3 === last7;
}
function hasSubPath(path2) {
  return !hasUniqueString(path2, "m") || !hasUniqueString(path2, "M");
}
function shape2path(shape23) {
  const path2 = convertToPath(shape23);
  if (!path2)
    return;
  if (hasSubPath(path2))
    return;
  return path2;
}
function oneToOne(shape23, from, to, timeEffect) {
  const { nodeName: fromName } = from;
  const { nodeName: toName } = to;
  const fromPath = shape2path(from);
  const toPath2 = shape2path(to);
  const isSameNodes = fromName === toName && fromName !== "path";
  const hasNonPathNode = fromPath === void 0 || toPath2 === void 0;
  if (isSameNodes || hasNonPathNode)
    return shapeToShape(from, to, timeEffect);
  const pathShape = maybePath(shape23, fromPath);
  const keyframes = [
    Object.assign({ path: fromPath }, attributeOf(from, attributeKeys)),
    Object.assign({ path: toPath2 }, attributeOf(to, attributeKeys))
  ];
  const animation = pathShape.animate(keyframes, timeEffect);
  animation.onfinish = () => {
    pathShape.style.transform = "none";
    copyAttributes(pathShape, to);
  };
  pathShape.style.transform = "none";
  return animation;
}
function oneToMultiple(from, to, timeEffect, split2) {
  from.style.visibility = "hidden";
  const D2 = split2(from, to.length);
  return to.map((shape23, i) => {
    const path2 = new Path2({
      style: Object.assign({ path: D2[i] }, attributeOf(from, attributeKeys))
    });
    return oneToOne(shape23, path2, shape23, timeEffect);
  });
}
function multipleToOne(from, to, timeEffect, split2) {
  const D2 = split2(to, from.length);
  const { fillOpacity = 1, strokeOpacity = 1, opacity = 1 } = to.style;
  const keyframes = [
    { fillOpacity: 0, strokeOpacity: 0, opacity: 0 },
    { fillOpacity: 0, strokeOpacity: 0, opacity: 0, offset: 0.99 },
    {
      fillOpacity,
      strokeOpacity,
      opacity
    }
  ];
  const animation = to.animate(keyframes, timeEffect);
  const animations = from.map((shape23, i) => {
    const path2 = new Path2({
      style: {
        path: D2[i],
        fill: to.style.fill
      }
    });
    return oneToOne(shape23, shape23, path2, timeEffect);
  });
  return [...animations, animation];
}
var Morphing = (options) => {
  return (from, to, defaults5) => {
    const split2 = normalizeSplit(options.split);
    const timeEffect = Object.assign(Object.assign({}, defaults5), options);
    const { length: fl } = from;
    const { length: tl } = to;
    if (fl === 1 && tl === 1 || fl > 1 && tl > 1) {
      const [f] = from;
      const [t] = to;
      return oneToOne(f, f, t, timeEffect);
    }
    if (fl === 1 && tl > 1) {
      const [f] = from;
      return oneToMultiple(f, to, timeEffect, split2);
    }
    if (fl > 1 && tl === 1) {
      const [t] = to;
      return multipleToOne(from, t, timeEffect, split2);
    }
    return null;
  };
};
Morphing.props = {};

// node_modules/@antv/g2/esm/animation/waveIn.js
var WaveIn = (options, context) => {
  const ZERO = 1e-4;
  CSS.registerProperty({
    name: "waveInArcAngle",
    inherits: false,
    initialValue: "",
    interpolable: true,
    syntax: PropertySyntax.NUMBER
  });
  const { coordinate: coordinate2 } = context;
  return (from, to, defaults5) => {
    const [shape23] = from;
    if (!isPolar(coordinate2)) {
      return ScaleInX(options, context)(from, to, defaults5);
    }
    const center2 = coordinate2.getCenter();
    const { __data__, style } = shape23;
    const { radius = 0, inset = 0, fillOpacity = 1, strokeOpacity = 1, opacity = 1 } = style;
    const { points, y: y3, y1: y12 } = __data__;
    const path2 = arc_default().cornerRadius(radius).padAngle(inset * Math.PI / 180);
    const arcObject = getArcObject(coordinate2, points, [y3, y12]);
    const { startAngle, endAngle } = arcObject;
    const pathForConversion = new Path2({});
    const createArcPath = (arcParams) => {
      pathForConversion.attr({
        d: path2(arcParams),
        transform: `translate(${center2[0]}, ${center2[1]})`
      });
      const convertedPathDefinition = convertToPath(pathForConversion);
      pathForConversion.style.transform = "";
      return convertedPathDefinition;
    };
    const keyframes = [
      // Use custom interpolable CSS property.
      {
        waveInArcAngle: startAngle + ZERO,
        fillOpacity: 0,
        strokeOpacity: 0,
        opacity: 0
      },
      {
        waveInArcAngle: startAngle + ZERO,
        fillOpacity,
        strokeOpacity,
        opacity,
        offset: 0.01
      },
      {
        waveInArcAngle: endAngle,
        fillOpacity,
        strokeOpacity,
        opacity
      }
    ];
    const animation = shape23.animate(keyframes, Object.assign(Object.assign({}, defaults5), options));
    animation.onframe = function() {
      shape23.style.path = createArcPath(Object.assign(Object.assign({}, arcObject), { endAngle: Number(shape23.style.waveInArcAngle) }));
    };
    animation.onfinish = function() {
      shape23.style.path = createArcPath(Object.assign(Object.assign({}, arcObject), { endAngle }));
    };
    return animation;
  };
};
WaveIn.props = {};

// node_modules/@antv/g2/esm/animation/zoomIn.js
var ZoomIn = (options) => {
  const ZERO = 1e-4;
  return (from, _2, defaults5) => {
    const [shape23] = from;
    const { transform: prefix = "", fillOpacity = 1, strokeOpacity = 1, opacity = 1 } = shape23.style;
    const transformOrigin = "center center";
    const keyframes = [
      {
        transform: `${prefix} scale(${ZERO})`.trimStart(),
        transformOrigin,
        fillOpacity: 0,
        strokeOpacity: 0,
        opacity: 0
      },
      {
        transform: `${prefix} scale(${ZERO})`.trimStart(),
        transformOrigin,
        fillOpacity,
        strokeOpacity,
        opacity,
        offset: 0.01
      },
      {
        transform: `${prefix} scale(1)`.trimStart(),
        transformOrigin,
        fillOpacity,
        strokeOpacity,
        opacity
      }
    ];
    const animation = shape23.animate(keyframes, Object.assign(Object.assign({}, defaults5), options));
    return animation;
  };
};

// node_modules/@antv/g2/esm/animation/zoomOut.js
var ZoomOut = (options) => {
  const ZERO = 1e-4;
  return (from, _2, defaults5) => {
    const [shape23] = from;
    const { transform: prefix = "", fillOpacity = 1, strokeOpacity = 1, opacity = 1 } = shape23.style;
    const transformOrigin = "center center";
    const keyframes = [
      { transform: `${prefix} scale(1)`.trimStart(), transformOrigin },
      {
        transform: `${prefix} scale(${ZERO})`.trimStart(),
        transformOrigin,
        fillOpacity,
        strokeOpacity,
        opacity,
        offset: 0.99
      },
      {
        transform: `${prefix} scale(${ZERO})`.trimStart(),
        transformOrigin,
        fillOpacity: 0,
        strokeOpacity: 0,
        opacity: 0
      }
    ];
    const animation = shape23.animate(keyframes, Object.assign(Object.assign({}, defaults5), options));
    return animation;
  };
};

// node_modules/@antv/g2/esm/animation/pathIn.js
var PathIn = (options) => {
  return (from, _2, defaults5) => {
    var _a2, _b;
    const [shape23] = from;
    const length5 = ((_b = (_a2 = shape23).getTotalLength) === null || _b === void 0 ? void 0 : _b.call(_a2)) || 0;
    const keyframes = [
      { lineDash: [0, length5] },
      { lineDash: [length5, 0] }
    ];
    return shape23.animate(keyframes, Object.assign(Object.assign({}, defaults5), options));
  };
};
PathIn.props = {};

// node_modules/@antv/g2/esm/animation/growInX.js
var GrowInX = (options, context) => {
  return (from, to, defaults5) => {
    const [shape23] = from;
    const { height, width } = shape23.getBoundingClientRect();
    const clipPath = new Path2({
      style: {
        path: `M0,0L${width},0L${width},${height}L0,${height}Z`
      }
    });
    shape23.appendChild(clipPath);
    shape23.style.clipPath = clipPath;
    const animation = ScaleInX(options, context)([clipPath], to, defaults5);
    return animation;
  };
};
GrowInX.props = {};

// node_modules/@antv/g2/esm/animation/growInY.js
var GrowInY = (options, context) => {
  return (from, to, defaults5) => {
    const [shape23] = from;
    const { height, width } = shape23.getBoundingClientRect();
    const clipPath = new Path2({
      style: {
        path: `M0,0L${width},0L${width},${height}L0,${height}Z`
      }
    });
    shape23.appendChild(clipPath);
    shape23.style.clipPath = clipPath;
    const animation = ScaleInY(options, context)([clipPath], to, defaults5);
    return animation;
  };
};
GrowInY.props = {};

// node_modules/@antv/g2/esm/runtime/constant.js
var MAIN_LAYER_CLASS_NAME = "main-layer";
var LABEL_LAYER_CLASS_NAME = "label-layer";
var ELEMENT_CLASS_NAME = "element";
var VIEW_CLASS_NAME = "view";
var PLOT_CLASS_NAME = "plot";
var COMPONENT_CLASS_NAME = "component";
var LABEL_CLASS_NAME = "label";
var AREA_CLASS_NAME = "area";
var MASK_CLASS_NAME = "mask";

// node_modules/@antv/g-plugin-canvas-path-generator/dist/index.esm.js
function generatePath$6(context, parsedStyle) {
  var r = parsedStyle.r;
  context.arc(r, r, r, 0, Math.PI * 2, false);
}
function generatePath$5(context, parsedStyle) {
  var rxInPixels = parsedStyle.rx, ryInPixels = parsedStyle.ry;
  var rx = rxInPixels;
  var ry = ryInPixels;
  if (context.ellipse) {
    context.ellipse(rx, ry, rx, ry, 0, 0, Math.PI * 2, false);
  } else {
    var r = rx > ry ? rx : ry;
    var scaleX = rx > ry ? 1 : rx / ry;
    var scaleY = rx > ry ? ry / rx : 1;
    context.save();
    context.scale(scaleX, scaleY);
    context.arc(r, r, r, 0, Math.PI * 2);
  }
}
function generatePath$4(context, parsedStyle) {
  var x12 = parsedStyle.x1, y12 = parsedStyle.y1, x22 = parsedStyle.x2, y22 = parsedStyle.y2, _a2 = parsedStyle.defX, defX = _a2 === void 0 ? 0 : _a2, _b = parsedStyle.defY, defY = _b === void 0 ? 0 : _b, markerStart = parsedStyle.markerStart, markerEnd = parsedStyle.markerEnd, markerStartOffset = parsedStyle.markerStartOffset, markerEndOffset = parsedStyle.markerEndOffset;
  var startOffsetX = 0;
  var startOffsetY = 0;
  var endOffsetX = 0;
  var endOffsetY = 0;
  var rad = 0;
  var x3;
  var y3;
  if (markerStart && isDisplayObject(markerStart) && markerStartOffset) {
    x3 = x22 - x12;
    y3 = y22 - y12;
    rad = Math.atan2(y3, x3);
    startOffsetX = Math.cos(rad) * (markerStartOffset || 0);
    startOffsetY = Math.sin(rad) * (markerStartOffset || 0);
  }
  if (markerEnd && isDisplayObject(markerEnd) && markerEndOffset) {
    x3 = x12 - x22;
    y3 = y12 - y22;
    rad = Math.atan2(y3, x3);
    endOffsetX = Math.cos(rad) * (markerEndOffset || 0);
    endOffsetY = Math.sin(rad) * (markerEndOffset || 0);
  }
  context.moveTo(x12 - defX + startOffsetX, y12 - defY + startOffsetY);
  context.lineTo(x22 - defX + endOffsetX, y22 - defY + endOffsetY);
}
function generatePath$3(context, parsedStyle) {
  var _a2 = parsedStyle.defX, defX = _a2 === void 0 ? 0 : _a2, _b = parsedStyle.defY, defY = _b === void 0 ? 0 : _b, markerStart = parsedStyle.markerStart, markerEnd = parsedStyle.markerEnd, markerStartOffset = parsedStyle.markerStartOffset, markerEndOffset = parsedStyle.markerEndOffset;
  var _c = parsedStyle.path, absolutePath = _c.absolutePath, segments = _c.segments;
  var startOffsetX = 0;
  var startOffsetY = 0;
  var endOffsetX = 0;
  var endOffsetY = 0;
  var rad = 0;
  var x3;
  var y3;
  if (markerStart && isDisplayObject(markerStart) && markerStartOffset) {
    var _d = __read(markerStart.parentNode.getStartTangent(), 2), p1 = _d[0], p2 = _d[1];
    x3 = p1[0] - p2[0];
    y3 = p1[1] - p2[1];
    rad = Math.atan2(y3, x3);
    startOffsetX = Math.cos(rad) * (markerStartOffset || 0);
    startOffsetY = Math.sin(rad) * (markerStartOffset || 0);
  }
  if (markerEnd && isDisplayObject(markerEnd) && markerEndOffset) {
    var _e = __read(markerEnd.parentNode.getEndTangent(), 2), p1 = _e[0], p2 = _e[1];
    x3 = p1[0] - p2[0];
    y3 = p1[1] - p2[1];
    rad = Math.atan2(y3, x3);
    endOffsetX = Math.cos(rad) * (markerEndOffset || 0);
    endOffsetY = Math.sin(rad) * (markerEndOffset || 0);
  }
  for (var i = 0; i < absolutePath.length; i++) {
    var params = absolutePath[i];
    var command = params[0];
    var nextSegment = absolutePath[i + 1];
    var useStartOffset = i === 0 && (startOffsetX !== 0 || startOffsetY !== 0);
    var useEndOffset = (i === absolutePath.length - 1 || nextSegment && (nextSegment[0] === "M" || nextSegment[0] === "Z")) && endOffsetX !== 0 && endOffsetY !== 0;
    switch (command) {
      case "M":
        if (useStartOffset) {
          context.moveTo(params[1] - defX + startOffsetX, params[2] - defY + startOffsetY);
          context.lineTo(params[1] - defX, params[2] - defY);
        } else {
          context.moveTo(params[1] - defX, params[2] - defY);
        }
        break;
      case "L":
        if (useEndOffset) {
          context.lineTo(params[1] - defX + endOffsetX, params[2] - defY + endOffsetY);
        } else {
          context.lineTo(params[1] - defX, params[2] - defY);
        }
        break;
      case "Q":
        context.quadraticCurveTo(params[1] - defX, params[2] - defY, params[3] - defX, params[4] - defY);
        if (useEndOffset) {
          context.lineTo(params[3] - defX + endOffsetX, params[4] - defY + endOffsetY);
        }
        break;
      case "C":
        context.bezierCurveTo(params[1] - defX, params[2] - defY, params[3] - defX, params[4] - defY, params[5] - defX, params[6] - defY);
        if (useEndOffset) {
          context.lineTo(params[5] - defX + endOffsetX, params[6] - defY + endOffsetY);
        }
        break;
      case "A": {
        var arcParams = segments[i].arcParams;
        var cx = arcParams.cx, cy = arcParams.cy, rx = arcParams.rx, ry = arcParams.ry, startAngle = arcParams.startAngle, endAngle = arcParams.endAngle, xRotation = arcParams.xRotation, sweepFlag = arcParams.sweepFlag;
        if (context.ellipse) {
          context.ellipse(cx - defX, cy - defY, rx, ry, xRotation, startAngle, endAngle, !!(1 - sweepFlag));
        } else {
          var r = rx > ry ? rx : ry;
          var scaleX = rx > ry ? 1 : rx / ry;
          var scaleY = rx > ry ? ry / rx : 1;
          context.translate(cx - defX, cy - defY);
          context.rotate(xRotation);
          context.scale(scaleX, scaleY);
          context.arc(0, 0, r, startAngle, endAngle, !!(1 - sweepFlag));
          context.scale(1 / scaleX, 1 / scaleY);
          context.rotate(-xRotation);
          context.translate(-(cx - defX), -(cy - defY));
        }
        if (useEndOffset) {
          context.lineTo(params[6] - defX + endOffsetX, params[7] - defY + endOffsetY);
        }
        break;
      }
      case "Z":
        context.closePath();
        break;
    }
  }
}
function generatePath$2(context, parsedStyle) {
  var _a2 = parsedStyle.defX, defX = _a2 === void 0 ? 0 : _a2, _b = parsedStyle.defY, defY = _b === void 0 ? 0 : _b, markerStart = parsedStyle.markerStart, markerEnd = parsedStyle.markerEnd, markerStartOffset = parsedStyle.markerStartOffset, markerEndOffset = parsedStyle.markerEndOffset;
  var points = parsedStyle.points.points;
  var length5 = points.length;
  var x12 = points[0][0] - defX;
  var y12 = points[0][1] - defY;
  var x22 = points[length5 - 1][0] - defX;
  var y22 = points[length5 - 1][1] - defY;
  var startOffsetX = 0;
  var startOffsetY = 0;
  var endOffsetX = 0;
  var endOffsetY = 0;
  var rad = 0;
  var x3;
  var y3;
  if (markerStart && isDisplayObject(markerStart) && markerStartOffset) {
    x3 = points[1][0] - points[0][0];
    y3 = points[1][1] - points[0][1];
    rad = Math.atan2(y3, x3);
    startOffsetX = Math.cos(rad) * (markerStartOffset || 0);
    startOffsetY = Math.sin(rad) * (markerStartOffset || 0);
  }
  if (markerEnd && isDisplayObject(markerEnd) && markerEndOffset) {
    x3 = points[length5 - 1][0] - points[0][0];
    y3 = points[length5 - 1][1] - points[0][1];
    rad = Math.atan2(y3, x3);
    endOffsetX = Math.cos(rad) * (markerEndOffset || 0);
    endOffsetY = Math.sin(rad) * (markerEndOffset || 0);
  }
  context.moveTo(x12 + (startOffsetX || endOffsetX), y12 + (startOffsetY || endOffsetY));
  for (var i = 1; i < length5 - 1; i++) {
    var point7 = points[i];
    context.lineTo(point7[0] - defX, point7[1] - defY);
  }
  context.lineTo(x22, y22);
}
function generatePath$1(context, parsedStyle) {
  var _a2 = parsedStyle.defX, defX = _a2 === void 0 ? 0 : _a2, _b = parsedStyle.defY, defY = _b === void 0 ? 0 : _b, markerStart = parsedStyle.markerStart, markerEnd = parsedStyle.markerEnd, markerStartOffset = parsedStyle.markerStartOffset, markerEndOffset = parsedStyle.markerEndOffset;
  var points = parsedStyle.points.points;
  var length5 = points.length;
  var x12 = points[0][0] - defX;
  var y12 = points[0][1] - defY;
  var x22 = points[length5 - 1][0] - defX;
  var y22 = points[length5 - 1][1] - defY;
  var startOffsetX = 0;
  var startOffsetY = 0;
  var endOffsetX = 0;
  var endOffsetY = 0;
  var rad = 0;
  var x3;
  var y3;
  if (markerStart && isDisplayObject(markerStart) && markerStartOffset) {
    x3 = points[1][0] - points[0][0];
    y3 = points[1][1] - points[0][1];
    rad = Math.atan2(y3, x3);
    startOffsetX = Math.cos(rad) * (markerStartOffset || 0);
    startOffsetY = Math.sin(rad) * (markerStartOffset || 0);
  }
  if (markerEnd && isDisplayObject(markerEnd) && markerEndOffset) {
    x3 = points[length5 - 2][0] - points[length5 - 1][0];
    y3 = points[length5 - 2][1] - points[length5 - 1][1];
    rad = Math.atan2(y3, x3);
    endOffsetX = Math.cos(rad) * (markerEndOffset || 0);
    endOffsetY = Math.sin(rad) * (markerEndOffset || 0);
  }
  context.moveTo(x12 + startOffsetX, y12 + startOffsetY);
  for (var i = 1; i < length5 - 1; i++) {
    var point7 = points[i];
    context.lineTo(point7[0] - defX, point7[1] - defY);
  }
  context.lineTo(x22 + endOffsetX, y22 + endOffsetY);
}
function generatePath(context, parsedStyle) {
  var radius = parsedStyle.radius, width = parsedStyle.width, height = parsedStyle.height;
  var w = width;
  var h = height;
  var hasRadius = radius && radius.some(function(r) {
    return r !== 0;
  });
  if (!hasRadius) {
    context.rect(0, 0, w, h);
  } else {
    var signX = width > 0 ? 1 : -1;
    var signY = height > 0 ? 1 : -1;
    var sweepFlag = signX + signY === 0;
    var _a2 = __read(radius.map(function(r) {
      return clamp_default(r, 0, Math.min(Math.abs(w) / 2, Math.abs(h) / 2));
    }), 4), tlr = _a2[0], trr = _a2[1], brr = _a2[2], blr = _a2[3];
    context.moveTo(signX * tlr, 0);
    context.lineTo(w - signX * trr, 0);
    if (trr !== 0) {
      context.arc(w - signX * trr, signY * trr, trr, -signY * Math.PI / 2, signX > 0 ? 0 : Math.PI, sweepFlag);
    }
    context.lineTo(w, h - signY * brr);
    if (brr !== 0) {
      context.arc(w - signX * brr, h - signY * brr, brr, signX > 0 ? 0 : Math.PI, signY > 0 ? Math.PI / 2 : 1.5 * Math.PI, sweepFlag);
    }
    context.lineTo(signX * blr, h);
    if (blr !== 0) {
      context.arc(signX * blr, h - signY * blr, blr, signY > 0 ? Math.PI / 2 : -Math.PI / 2, signX > 0 ? Math.PI : 0, sweepFlag);
    }
    context.lineTo(0, signY * tlr);
    if (tlr !== 0) {
      context.arc(signX * tlr, signY * tlr, tlr, signX > 0 ? Math.PI : 0, signY > 0 ? Math.PI * 1.5 : Math.PI / 2, sweepFlag);
    }
  }
}
var Plugin = (
  /** @class */
  function(_super) {
    __extends(Plugin8, _super);
    function Plugin8() {
      var _this2 = _super.apply(this, __spreadArray([], __read(arguments), false)) || this;
      _this2.name = "canvas-path-generator";
      return _this2;
    }
    Plugin8.prototype.init = function() {
      var _a2;
      var pathGeneratorFactory = (_a2 = {}, _a2[Shape.CIRCLE] = generatePath$6, _a2[Shape.ELLIPSE] = generatePath$5, _a2[Shape.RECT] = generatePath, _a2[Shape.LINE] = generatePath$4, _a2[Shape.POLYLINE] = generatePath$1, _a2[Shape.POLYGON] = generatePath$2, _a2[Shape.PATH] = generatePath$3, _a2[Shape.TEXT] = void 0, _a2[Shape.GROUP] = void 0, _a2[Shape.IMAGE] = void 0, _a2[Shape.HTML] = void 0, _a2[Shape.MESH] = void 0, _a2);
      this.context.pathGeneratorFactory = pathGeneratorFactory;
    };
    Plugin8.prototype.destroy = function() {
      delete this.context.pathGeneratorFactory;
    };
    return Plugin8;
  }(AbstractRendererPlugin)
);

// node_modules/@antv/g-plugin-canvas-picker/dist/index.esm.js
var tmpVec3a = vec3_exports.create();
var tmpVec3b = vec3_exports.create();
var tmpVec3c = vec3_exports.create();
var tmpMat42 = mat4_exports.create();
var CanvasPickerPlugin = (
  /** @class */
  function() {
    function CanvasPickerPlugin2() {
      var _this2 = this;
      this.isHit = function(displayObject, position, worldTransform, isClipPath) {
        var pick3 = _this2.context.pointInPathPickerFactory[displayObject.nodeName];
        if (pick3) {
          var invertWorldMat = mat4_exports.invert(tmpMat42, worldTransform);
          var localPosition = vec3_exports.transformMat4(tmpVec3b, vec3_exports.set(tmpVec3c, position[0], position[1], 0), invertWorldMat);
          var halfExtents = displayObject.getGeometryBounds().halfExtents;
          var anchor = displayObject.parsedStyle.anchor;
          localPosition[0] += (anchor && anchor[0] || 0) * halfExtents[0] * 2;
          localPosition[1] += (anchor && anchor[1] || 0) * halfExtents[1] * 2;
          if (pick3(displayObject, new Point2(localPosition[0], localPosition[1]), isClipPath, _this2.isPointInPath, _this2.context, _this2.runtime)) {
            return true;
          }
        }
        return false;
      };
      this.isPointInPath = function(displayObject, position) {
        var context = _this2.runtime.offscreenCanvasCreator.getOrCreateContext(_this2.context.config.offscreenCanvas);
        var generatePath2 = _this2.context.pathGeneratorFactory[displayObject.nodeName];
        if (generatePath2) {
          context.beginPath();
          generatePath2(context, displayObject.parsedStyle);
          context.closePath();
        }
        return context.isPointInPath(position.x, position.y);
      };
    }
    CanvasPickerPlugin2.prototype.apply = function(context, runtime2) {
      var _this2 = this;
      var _a2;
      var renderingService = context.renderingService, renderingContext = context.renderingContext;
      this.context = context;
      this.runtime = runtime2;
      var document2 = (_a2 = renderingContext.root) === null || _a2 === void 0 ? void 0 : _a2.ownerDocument;
      renderingService.hooks.pick.tapPromise(CanvasPickerPlugin2.tag, function(result2) {
        return __awaiter(_this2, void 0, void 0, function() {
          return __generator(this, function(_a3) {
            return [2, this.pick(document2, result2)];
          });
        });
      });
      renderingService.hooks.pickSync.tap(CanvasPickerPlugin2.tag, function(result2) {
        return _this2.pick(document2, result2);
      });
    };
    CanvasPickerPlugin2.prototype.pick = function(document2, result2) {
      var e_1, _a2;
      var topmost = result2.topmost, _b = result2.position, x3 = _b.x, y3 = _b.y;
      var position = vec3_exports.set(tmpVec3a, x3, y3, 0);
      var hitTestList = document2.elementsFromBBox(position[0], position[1], position[0], position[1]);
      var pickedDisplayObjects = [];
      try {
        for (var hitTestList_1 = __values(hitTestList), hitTestList_1_1 = hitTestList_1.next(); !hitTestList_1_1.done; hitTestList_1_1 = hitTestList_1.next()) {
          var displayObject = hitTestList_1_1.value;
          var worldTransform = displayObject.getWorldTransform();
          var isHitOriginShape = this.isHit(displayObject, position, worldTransform, false);
          if (isHitOriginShape) {
            var clipped = findClosestClipPathTarget(displayObject);
            if (clipped) {
              var clipPath = clipped.parsedStyle.clipPath;
              var isHitClipPath = this.isHit(clipPath, position, clipPath.getWorldTransform(), true);
              if (isHitClipPath) {
                if (topmost) {
                  result2.picked = [displayObject];
                  return result2;
                } else {
                  pickedDisplayObjects.push(displayObject);
                }
              }
            } else {
              if (topmost) {
                result2.picked = [displayObject];
                return result2;
              } else {
                pickedDisplayObjects.push(displayObject);
              }
            }
          }
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (hitTestList_1_1 && !hitTestList_1_1.done && (_a2 = hitTestList_1.return))
            _a2.call(hitTestList_1);
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
      result2.picked = pickedDisplayObjects;
      return result2;
    };
    CanvasPickerPlugin2.tag = "CanvasPicker";
    return CanvasPickerPlugin2;
  }()
);
function isPointInPath$7(displayObject, position, isClipPath) {
  var _a2 = displayObject.parsedStyle, r = _a2.r, fill2 = _a2.fill, stroke2 = _a2.stroke, lineWidth = _a2.lineWidth, increasedLineWidthForHitTesting = _a2.increasedLineWidthForHitTesting, pointerEvents = _a2.pointerEvents;
  var halfLineWidth = ((lineWidth || 0) + (increasedLineWidthForHitTesting || 0)) / 2;
  var absDistance = distance4(r, r, position.x, position.y);
  var _b = __read(isFillOrStrokeAffected(pointerEvents, fill2, stroke2), 2), hasFill = _b[0], hasStroke = _b[1];
  if (hasFill && hasStroke || isClipPath) {
    return absDistance <= r + halfLineWidth;
  }
  if (hasFill) {
    return absDistance <= r;
  }
  if (hasStroke) {
    return absDistance >= r - halfLineWidth && absDistance <= r + halfLineWidth;
  }
  return false;
}
function ellipseDistance(squareX, squareY, rx, ry) {
  return squareX / (rx * rx) + squareY / (ry * ry);
}
function isPointInPath$6(displayObject, position, isClipPath) {
  var _a2 = displayObject.parsedStyle, rx = _a2.rx, ry = _a2.ry, fill2 = _a2.fill, stroke2 = _a2.stroke, lineWidth = _a2.lineWidth, increasedLineWidthForHitTesting = _a2.increasedLineWidthForHitTesting, pointerEvents = _a2.pointerEvents;
  var x3 = position.x, y3 = position.y;
  var _b = __read(isFillOrStrokeAffected(pointerEvents, fill2, stroke2), 2), hasFill = _b[0], hasStroke = _b[1];
  var halfLineWith = ((lineWidth || 0) + (increasedLineWidthForHitTesting || 0)) / 2;
  var squareX = (x3 - rx) * (x3 - rx);
  var squareY = (y3 - ry) * (y3 - ry);
  if (hasFill && hasStroke || isClipPath) {
    return ellipseDistance(squareX, squareY, rx + halfLineWith, ry + halfLineWith) <= 1;
  }
  if (hasFill) {
    return ellipseDistance(squareX, squareY, rx, ry) <= 1;
  }
  if (hasStroke) {
    return ellipseDistance(squareX, squareY, rx - halfLineWith, ry - halfLineWith) >= 1 && ellipseDistance(squareX, squareY, rx + halfLineWith, ry + halfLineWith) <= 1;
  }
  return false;
}
function inBox(minX, minY, width, height, x3, y3) {
  return x3 >= minX && x3 <= minX + width && y3 >= minY && y3 <= minY + height;
}
function inRect(minX, minY, width, height, lineWidth, x3, y3) {
  var halfWidth = lineWidth / 2;
  return inBox(minX - halfWidth, minY - halfWidth, width, lineWidth, x3, y3) || // 
  inBox(minX + width - halfWidth, minY - halfWidth, lineWidth, height, x3, y3) || // 
  inBox(minX + halfWidth, minY + height - halfWidth, width, lineWidth, x3, y3) || // 
  inBox(minX - halfWidth, minY + halfWidth, lineWidth, height, x3, y3);
}
function inArc(cx, cy, r, startAngle, endAngle, lineWidth, x3, y3) {
  var angle4 = (Math.atan2(y3 - cy, x3 - cx) + Math.PI * 2) % (Math.PI * 2);
  var point7 = {
    x: cx + r * Math.cos(angle4),
    y: cy + r * Math.sin(angle4)
  };
  return distance4(point7.x, point7.y, x3, y3) <= lineWidth / 2;
}
function inLine(x12, y12, x22, y22, lineWidth, x3, y3) {
  var minX = Math.min(x12, x22);
  var maxX = Math.max(x12, x22);
  var minY = Math.min(y12, y22);
  var maxY2 = Math.max(y12, y22);
  var halfWidth = lineWidth / 2;
  if (!(x3 >= minX - halfWidth && x3 <= maxX + halfWidth && y3 >= minY - halfWidth && y3 <= maxY2 + halfWidth)) {
    return false;
  }
  return pointToLine(x12, y12, x22, y22, x3, y3) <= lineWidth / 2;
}
function inPolyline(points, lineWidth, x3, y3, isClose) {
  var count4 = points.length;
  if (count4 < 2) {
    return false;
  }
  for (var i = 0; i < count4 - 1; i++) {
    var x12 = points[i][0];
    var y12 = points[i][1];
    var x22 = points[i + 1][0];
    var y22 = points[i + 1][1];
    if (inLine(x12, y12, x22, y22, lineWidth, x3, y3)) {
      return true;
    }
  }
  if (isClose) {
    var first3 = points[0];
    var last7 = points[count4 - 1];
    if (inLine(first3[0], first3[1], last7[0], last7[1], lineWidth, x3, y3)) {
      return true;
    }
  }
  return false;
}
var tolerance = 1e-6;
function dcmp(x3) {
  if (Math.abs(x3) < tolerance) {
    return 0;
  }
  return x3 < 0 ? -1 : 1;
}
function onSegment(p1, p2, q) {
  if ((q[0] - p1[0]) * (p2[1] - p1[1]) === (p2[0] - p1[0]) * (q[1] - p1[1]) && Math.min(p1[0], p2[0]) <= q[0] && q[0] <= Math.max(p1[0], p2[0]) && Math.min(p1[1], p2[1]) <= q[1] && q[1] <= Math.max(p1[1], p2[1])) {
    return true;
  }
  return false;
}
function inPolygon(points, x3, y3) {
  var isHit = false;
  var n = points.length;
  if (n <= 2) {
    return false;
  }
  for (var i = 0; i < n; i++) {
    var p1 = points[i];
    var p2 = points[(i + 1) % n];
    if (onSegment(p1, p2, [x3, y3])) {
      return true;
    }
    if (dcmp(p1[1] - y3) > 0 !== dcmp(p2[1] - y3) > 0 && dcmp(x3 - (y3 - p1[1]) * (p1[0] - p2[0]) / (p1[1] - p2[1]) - p1[0]) < 0) {
      isHit = !isHit;
    }
  }
  return isHit;
}
function inPolygons(polygons, x3, y3) {
  var isHit = false;
  for (var i = 0; i < polygons.length; i++) {
    var points = polygons[i];
    isHit = inPolygon(points, x3, y3);
    if (isHit) {
      break;
    }
  }
  return isHit;
}
function isPointInPath$5(displayObject, position, isClipPath) {
  var _a2 = displayObject.parsedStyle, x12 = _a2.x1, y12 = _a2.y1, x22 = _a2.x2, y22 = _a2.y2, lineWidth = _a2.lineWidth, increasedLineWidthForHitTesting = _a2.increasedLineWidthForHitTesting, _b = _a2.defX, x3 = _b === void 0 ? 0 : _b, _c = _a2.defY, y3 = _c === void 0 ? 0 : _c, pointerEvents = _a2.pointerEvents, fill2 = _a2.fill, stroke2 = _a2.stroke;
  var _d = __read(isFillOrStrokeAffected(pointerEvents, fill2, stroke2), 2), hasStroke = _d[1];
  if (!hasStroke && !isClipPath || !lineWidth) {
    return false;
  }
  return inLine(x12, y12, x22, y22, (lineWidth || 0) + (increasedLineWidthForHitTesting || 0), position.x + x3, position.y + y3);
}
function isPointInStroke2(segments, lineWidth, px, py, length5) {
  var isHit = false;
  var halfWidth = lineWidth / 2;
  for (var i = 0; i < segments.length; i++) {
    var segment = segments[i];
    var currentPoint = segment.currentPoint, params = segment.params, prePoint = segment.prePoint, box2 = segment.box;
    if (box2 && !inBox(box2.x - halfWidth, box2.y - halfWidth, box2.width + lineWidth, box2.height + lineWidth, px, py)) {
      continue;
    }
    switch (segment.command) {
      case "L":
      case "Z":
        isHit = inLine(prePoint[0], prePoint[1], currentPoint[0], currentPoint[1], lineWidth, px, py);
        if (isHit) {
          return true;
        }
        break;
      case "Q":
        var qDistance = pointDistance(prePoint[0], prePoint[1], params[1], params[2], params[3], params[4], px, py);
        isHit = qDistance <= lineWidth / 2;
        if (isHit) {
          return true;
        }
        break;
      case "C":
        var cDistance = pointDistance$3(
          prePoint[0],
          // ,  C 
          prePoint[1],
          params[1],
          // 'C' 12 34 56 
          params[2],
          params[3],
          params[4],
          params[5],
          params[6],
          px,
          py,
          length5
        );
        isHit = cDistance <= lineWidth / 2;
        if (isHit) {
          return true;
        }
        break;
      case "A":
        if (!segment.cubicParams) {
          segment.cubicParams = arcToCubic(prePoint[0], prePoint[1], params[1], params[2], params[3], params[4], params[5], params[6], params[7], void 0);
        }
        var args = segment.cubicParams;
        var prePointInCubic = prePoint;
        for (var i_1 = 0; i_1 < args.length; i_1 += 6) {
          var cDistance_1 = pointDistance$3(
            prePointInCubic[0],
            // ,  C 
            prePointInCubic[1],
            args[i_1],
            args[i_1 + 1],
            args[i_1 + 2],
            args[i_1 + 3],
            args[i_1 + 4],
            args[i_1 + 5],
            px,
            py,
            length5
          );
          prePointInCubic = [args[i_1 + 4], args[i_1 + 5]];
          isHit = cDistance_1 <= lineWidth / 2;
          if (isHit) {
            return true;
          }
        }
        break;
    }
  }
  return isHit;
}
function isPointInPath$4(displayObject, position, isClipPath, isPointInPath2, renderingPluginContext, runtime2) {
  var _a2 = displayObject.parsedStyle, lineWidth = _a2.lineWidth, increasedLineWidthForHitTesting = _a2.increasedLineWidthForHitTesting, stroke2 = _a2.stroke, fill2 = _a2.fill, _b = _a2.defX, x3 = _b === void 0 ? 0 : _b, _c = _a2.defY, y3 = _c === void 0 ? 0 : _c, path2 = _a2.path, pointerEvents = _a2.pointerEvents;
  var segments = path2.segments, hasArc = path2.hasArc, polylines = path2.polylines, polygons = path2.polygons;
  var _d = __read(isFillOrStrokeAffected(
    pointerEvents,
    // Only a closed path can be filled.
    (polygons === null || polygons === void 0 ? void 0 : polygons.length) && fill2,
    stroke2
  ), 2), hasFill = _d[0], hasStroke = _d[1];
  var totalLength = getOrCalculatePathTotalLength(displayObject);
  var isHit = false;
  if (hasFill || isClipPath) {
    if (hasArc) {
      isHit = isPointInPath2(displayObject, position);
    } else {
      isHit = inPolygons(polygons, position.x + x3, position.y + y3) || inPolygons(polylines, position.x + x3, position.y + y3);
    }
    return isHit;
  } else if (hasStroke || isClipPath) {
    isHit = isPointInStroke2(segments, (lineWidth || 0) + (increasedLineWidthForHitTesting || 0), position.x + x3, position.y + y3, totalLength);
  }
  return isHit;
}
function isPointInPath$3(displayObject, position, isClipPath) {
  var _a2 = displayObject.parsedStyle, stroke2 = _a2.stroke, fill2 = _a2.fill, lineWidth = _a2.lineWidth, increasedLineWidthForHitTesting = _a2.increasedLineWidthForHitTesting, points = _a2.points, _b = _a2.defX, x3 = _b === void 0 ? 0 : _b, _c = _a2.defY, y3 = _c === void 0 ? 0 : _c, pointerEvents = _a2.pointerEvents;
  var _d = __read(isFillOrStrokeAffected(pointerEvents, fill2, stroke2), 2), hasFill = _d[0], hasStroke = _d[1];
  var isHit = false;
  if (hasStroke || isClipPath) {
    isHit = inPolyline(points.points, (lineWidth || 0) + (increasedLineWidthForHitTesting || 0), position.x + x3, position.y + y3, true);
  }
  if (!isHit && (hasFill || isClipPath)) {
    isHit = inPolygon(points.points, position.x + x3, position.y + y3);
  }
  return isHit;
}
function isPointInPath$2(displayObject, position, isClipPath) {
  var _a2 = displayObject.parsedStyle, lineWidth = _a2.lineWidth, increasedLineWidthForHitTesting = _a2.increasedLineWidthForHitTesting, points = _a2.points, _b = _a2.defX, x3 = _b === void 0 ? 0 : _b, _c = _a2.defY, y3 = _c === void 0 ? 0 : _c, pointerEvents = _a2.pointerEvents, fill2 = _a2.fill, stroke2 = _a2.stroke;
  var _d = __read(isFillOrStrokeAffected(pointerEvents, fill2, stroke2), 2), hasStroke = _d[1];
  if (!hasStroke && !isClipPath || !lineWidth) {
    return false;
  }
  return inPolyline(points.points, (lineWidth || 0) + (increasedLineWidthForHitTesting || 0), position.x + x3, position.y + y3, false);
}
function isPointInPath$1(displayObject, position, isClipPath, isPointInPath2, runtime2) {
  var _a2 = displayObject.parsedStyle, radius = _a2.radius, fill2 = _a2.fill, stroke2 = _a2.stroke, lineWidth = _a2.lineWidth, increasedLineWidthForHitTesting = _a2.increasedLineWidthForHitTesting, width = _a2.width, height = _a2.height, pointerEvents = _a2.pointerEvents;
  var _b = __read(isFillOrStrokeAffected(pointerEvents, fill2, stroke2), 2), hasFill = _b[0], hasStroke = _b[1];
  var hasRadius = radius && radius.some(function(r) {
    return r !== 0;
  });
  var lineWidthForHitTesting = (lineWidth || 0) + (increasedLineWidthForHitTesting || 0);
  if (!hasRadius) {
    var halfWidth = lineWidthForHitTesting / 2;
    if (hasFill && hasStroke || isClipPath) {
      return inBox(0 - halfWidth, 0 - halfWidth, width + halfWidth, height + halfWidth, position.x, position.y);
    }
    if (hasFill) {
      return inBox(0, 0, width, height, position.x, position.y);
    }
    if (hasStroke) {
      return inRect(0, 0, width, height, lineWidthForHitTesting, position.x, position.y);
    }
  } else {
    var isHit = false;
    if (hasStroke || isClipPath) {
      isHit = inRectWithRadius(0, 0, width, height, radius.map(function(r) {
        return clamp_default(r, 0, Math.min(Math.abs(width) / 2, Math.abs(height) / 2));
      }), lineWidthForHitTesting, position.x, position.y);
    }
    if (!isHit && (hasFill || isClipPath)) {
      isHit = isPointInPath2(displayObject, position);
    }
    return isHit;
  }
  return false;
}
function inRectWithRadius(minX, minY, width, height, radiusArray, lineWidth, x3, y3) {
  var _a2 = __read(radiusArray, 4), tlr = _a2[0], trr = _a2[1], brr = _a2[2], blr = _a2[3];
  return inLine(minX + tlr, minY, minX + width - trr, minY, lineWidth, x3, y3) || inLine(minX + width, minY + trr, minX + width, minY + height - brr, lineWidth, x3, y3) || inLine(minX + width - brr, minY + height, minX + blr, minY + height, lineWidth, x3, y3) || inLine(minX, minY + height - blr, minX, minY + tlr, lineWidth, x3, y3) || inArc(minX + width - trr, minY + trr, trr, 1.5 * Math.PI, 2 * Math.PI, lineWidth, x3, y3) || inArc(minX + width - brr, minY + height - brr, brr, 0, 0.5 * Math.PI, lineWidth, x3, y3) || inArc(minX + blr, minY + height - blr, blr, 0.5 * Math.PI, Math.PI, lineWidth, x3, y3) || inArc(minX + tlr, minY + tlr, tlr, Math.PI, 1.5 * Math.PI, lineWidth, x3, y3);
}
function isPointInPath(displayObject, position, isClipPath, isPointInPath2, renderingPluginContext, runtime2) {
  var _a2 = displayObject.parsedStyle, pointerEvents = _a2.pointerEvents, width = _a2.width, height = _a2.height;
  if (pointerEvents === "non-transparent-pixel") {
    var offscreenCanvas = renderingPluginContext.config.offscreenCanvas;
    var canvas = runtime2.offscreenCanvasCreator.getOrCreateCanvas(offscreenCanvas);
    var context = runtime2.offscreenCanvasCreator.getOrCreateContext(offscreenCanvas, {
      willReadFrequently: true
    });
    canvas.width = width;
    canvas.height = height;
    renderingPluginContext.defaultStyleRendererFactory[Shape.IMAGE].render(context, displayObject.parsedStyle, displayObject, void 0, void 0, void 0);
    var imagedata = context.getImageData(position.x, position.y, 1, 1).data;
    return imagedata.every(function(component) {
      return component !== 0;
    });
  }
  return true;
}
var Plugin2 = (
  /** @class */
  function(_super) {
    __extends(Plugin8, _super);
    function Plugin8() {
      var _this2 = _super.apply(this, __spreadArray([], __read(arguments), false)) || this;
      _this2.name = "canvas-picker";
      return _this2;
    }
    Plugin8.prototype.init = function() {
      var _a2;
      var trueFunc = function() {
        return true;
      };
      var pointInPathPickerFactory = (_a2 = {}, _a2[Shape.CIRCLE] = isPointInPath$7, _a2[Shape.ELLIPSE] = isPointInPath$6, _a2[Shape.RECT] = isPointInPath$1, _a2[Shape.LINE] = isPointInPath$5, _a2[Shape.POLYLINE] = isPointInPath$2, _a2[Shape.POLYGON] = isPointInPath$3, _a2[Shape.PATH] = isPointInPath$4, _a2[Shape.TEXT] = trueFunc, _a2[Shape.GROUP] = null, _a2[Shape.IMAGE] = isPointInPath, _a2[Shape.HTML] = null, _a2[Shape.MESH] = null, _a2);
      this.context.pointInPathPickerFactory = pointInPathPickerFactory;
      this.addRenderingPlugin(new CanvasPickerPlugin());
    };
    Plugin8.prototype.destroy = function() {
      delete this.context.pointInPathPickerFactory;
      this.removeAllRenderingPlugins();
    };
    return Plugin8;
  }(AbstractRendererPlugin)
);

// node_modules/@antv/g-plugin-canvas-renderer/dist/index.esm.js
var CanvasRendererPlugin = (
  /** @class */
  function() {
    function CanvasRendererPlugin2(canvasRendererPluginOptions) {
      this.canvasRendererPluginOptions = canvasRendererPluginOptions;
      this.removedRBushNodeAABBs = [];
      this.renderQueue = [];
      this.restoreStack = [];
      this.clearFullScreen = false;
      this.vpMatrix = mat4_exports.create();
      this.dprMatrix = mat4_exports.create();
      this.tmpMat4 = mat4_exports.create();
      this.vec3a = vec3_exports.create();
      this.vec3b = vec3_exports.create();
      this.vec3c = vec3_exports.create();
      this.vec3d = vec3_exports.create();
    }
    CanvasRendererPlugin2.prototype.apply = function(context, runtime2) {
      var _this2 = this;
      this.context = context;
      var config = context.config, camera = context.camera, renderingService = context.renderingService, renderingContext = context.renderingContext, rBushRoot = context.rBushRoot, pathGeneratorFactory = context.pathGeneratorFactory;
      this.rBush = rBushRoot;
      this.pathGeneratorFactory = pathGeneratorFactory;
      var contextService = context.contextService;
      var canvas = renderingContext.root.ownerDocument.defaultView;
      var handleUnmounted = function(e) {
        var object = e.target;
        var rBushNode = object.rBushNode;
        if (rBushNode.aabb) {
          _this2.removedRBushNodeAABBs.push(rBushNode.aabb);
        }
      };
      var handleCulled = function(e) {
        var object = e.target;
        var rBushNode = object.rBushNode;
        if (rBushNode.aabb) {
          _this2.removedRBushNodeAABBs.push(rBushNode.aabb);
        }
      };
      renderingService.hooks.init.tap(CanvasRendererPlugin2.tag, function() {
        canvas.addEventListener(ElementEvent.UNMOUNTED, handleUnmounted);
        canvas.addEventListener(ElementEvent.CULLED, handleCulled);
        var dpr = contextService.getDPR();
        var width = config.width, height = config.height;
        var context2 = contextService.getContext();
        _this2.clearRect(context2, 0, 0, width * dpr, height * dpr, config.background);
      });
      renderingService.hooks.destroy.tap(CanvasRendererPlugin2.tag, function() {
        canvas.removeEventListener(ElementEvent.UNMOUNTED, handleUnmounted);
        canvas.removeEventListener(ElementEvent.CULLED, handleCulled);
        _this2.renderQueue = [];
        _this2.removedRBushNodeAABBs = [];
        _this2.restoreStack = [];
      });
      renderingService.hooks.beginFrame.tap(CanvasRendererPlugin2.tag, function() {
        var context2 = contextService.getContext();
        var dpr = contextService.getDPR();
        var width = config.width, height = config.height;
        var _a2 = _this2.canvasRendererPluginOptions, dirtyObjectNumThreshold = _a2.dirtyObjectNumThreshold, dirtyObjectRatioThreshold = _a2.dirtyObjectRatioThreshold;
        var _b = renderingService.getStats(), total = _b.total, rendered = _b.rendered;
        var ratio = rendered / total;
        _this2.clearFullScreen = renderingService.disableDirtyRectangleRendering() || rendered > dirtyObjectNumThreshold && ratio > dirtyObjectRatioThreshold;
        if (context2) {
          context2.resetTransform ? context2.resetTransform() : context2.setTransform(1, 0, 0, 1, 0, 0);
          if (_this2.clearFullScreen) {
            _this2.clearRect(context2, 0, 0, width * dpr, height * dpr, config.background);
          }
        }
      });
      var renderByZIndex = function(object, context2) {
        if (object.isVisible() && !object.isCulled()) {
          _this2.renderDisplayObject(object, context2, _this2.context, _this2.restoreStack, runtime2);
          _this2.saveDirtyAABB(object);
        }
        var sorted = object.sortable.sorted || object.childNodes;
        sorted.forEach(function(child) {
          renderByZIndex(child, context2);
        });
      };
      renderingService.hooks.endFrame.tap(CanvasRendererPlugin2.tag, function() {
        var context2 = contextService.getContext();
        var dpr = contextService.getDPR();
        mat4_exports.fromScaling(_this2.dprMatrix, [dpr, dpr, 1]);
        mat4_exports.multiply(_this2.vpMatrix, _this2.dprMatrix, camera.getOrthoMatrix());
        if (_this2.clearFullScreen) {
          renderByZIndex(renderingContext.root, context2);
        } else {
          var dirtyRenderBounds = _this2.safeMergeAABB.apply(_this2, __spreadArray([_this2.mergeDirtyAABBs(_this2.renderQueue)], __read(_this2.removedRBushNodeAABBs.map(function(_a2) {
            var minX = _a2.minX, minY = _a2.minY, maxX = _a2.maxX, maxY2 = _a2.maxY;
            var aabb = new AABB();
            aabb.setMinMax(
              // vec3.fromValues(minX, minY, 0),
              // vec3.fromValues(maxX, maxY, 0),
              [minX, minY, 0],
              [maxX, maxY2, 0]
            );
            return aabb;
          })), false));
          _this2.removedRBushNodeAABBs = [];
          if (AABB.isEmpty(dirtyRenderBounds)) {
            _this2.renderQueue = [];
            return;
          }
          var dirtyRect = _this2.convertAABB2Rect(dirtyRenderBounds);
          var x3 = dirtyRect.x, y3 = dirtyRect.y, width = dirtyRect.width, height = dirtyRect.height;
          var tl = vec3_exports.transformMat4(_this2.vec3a, [x3, y3, 0], _this2.vpMatrix);
          var tr = vec3_exports.transformMat4(_this2.vec3b, [x3 + width, y3, 0], _this2.vpMatrix);
          var bl = vec3_exports.transformMat4(_this2.vec3c, [x3, y3 + height, 0], _this2.vpMatrix);
          var br = vec3_exports.transformMat4(_this2.vec3d, [x3 + width, y3 + height, 0], _this2.vpMatrix);
          var minx = Math.min(tl[0], tr[0], br[0], bl[0]);
          var miny = Math.min(tl[1], tr[1], br[1], bl[1]);
          var maxx = Math.max(tl[0], tr[0], br[0], bl[0]);
          var maxy = Math.max(tl[1], tr[1], br[1], bl[1]);
          var ix = Math.floor(minx);
          var iy = Math.floor(miny);
          var iwidth = Math.ceil(maxx - minx);
          var iheight = Math.ceil(maxy - miny);
          context2.save();
          _this2.clearRect(context2, ix, iy, iwidth, iheight, config.background);
          context2.beginPath();
          context2.rect(ix, iy, iwidth, iheight);
          context2.clip();
          context2.setTransform(_this2.vpMatrix[0], _this2.vpMatrix[1], _this2.vpMatrix[4], _this2.vpMatrix[5], _this2.vpMatrix[12], _this2.vpMatrix[13]);
          var enableDirtyRectangleRenderingDebug = config.renderer.getConfig().enableDirtyRectangleRenderingDebug;
          if (enableDirtyRectangleRenderingDebug) {
            canvas.dispatchEvent(new CustomEvent(CanvasEvent.DIRTY_RECTANGLE, {
              dirtyRect: {
                x: ix,
                y: iy,
                width: iwidth,
                height: iheight
              }
            }));
          }
          var dirtyObjects = _this2.searchDirtyObjects(dirtyRenderBounds);
          dirtyObjects.sort(function(a4, b) {
            return a4.sortable.renderOrder - b.sortable.renderOrder;
          }).forEach(function(object) {
            if (object && object.isVisible() && !object.isCulled()) {
              _this2.renderDisplayObject(object, context2, _this2.context, _this2.restoreStack, runtime2);
            }
          });
          context2.restore();
          _this2.renderQueue.forEach(function(object) {
            _this2.saveDirtyAABB(object);
          });
          _this2.renderQueue = [];
        }
        _this2.restoreStack.forEach(function() {
          context2.restore();
        });
        _this2.restoreStack = [];
      });
      renderingService.hooks.render.tap(CanvasRendererPlugin2.tag, function(object) {
        if (!_this2.clearFullScreen) {
          _this2.renderQueue.push(object);
        }
      });
    };
    CanvasRendererPlugin2.prototype.clearRect = function(context, x3, y3, width, height, background) {
      context.clearRect(x3, y3, width, height);
      if (background) {
        context.fillStyle = background;
        context.fillRect(x3, y3, width, height);
      }
    };
    CanvasRendererPlugin2.prototype.renderDisplayObject = function(object, context, canvasContext, restoreStack, runtime2) {
      var nodeName = object.nodeName;
      var parent2 = restoreStack[restoreStack.length - 1];
      if (parent2 && !(object.compareDocumentPosition(parent2) & Node.DOCUMENT_POSITION_CONTAINS)) {
        context.restore();
        restoreStack.pop();
      }
      var styleRenderer = this.context.styleRendererFactory[nodeName];
      var generatePath2 = this.pathGeneratorFactory[nodeName];
      var clipPath = object.parsedStyle.clipPath;
      if (clipPath) {
        this.applyWorldTransform(context, clipPath);
        var generatePath_1 = this.pathGeneratorFactory[clipPath.nodeName];
        if (generatePath_1) {
          context.save();
          restoreStack.push(object);
          context.beginPath();
          generatePath_1(context, clipPath.parsedStyle);
          context.closePath();
          context.clip();
        }
      }
      if (styleRenderer) {
        this.applyWorldTransform(context, object);
        context.save();
        this.applyAttributesToContext(context, object);
      }
      if (generatePath2) {
        context.beginPath();
        generatePath2(context, object.parsedStyle);
        if (object.nodeName !== Shape.LINE && object.nodeName !== Shape.PATH && object.nodeName !== Shape.POLYLINE) {
          context.closePath();
        }
      }
      if (styleRenderer) {
        styleRenderer.render(context, object.parsedStyle, object, canvasContext, this, runtime2);
        context.restore();
      }
      object.renderable.dirty = false;
    };
    CanvasRendererPlugin2.prototype.convertAABB2Rect = function(aabb) {
      var min11 = aabb.getMin();
      var max11 = aabb.getMax();
      var minX = Math.floor(min11[0]);
      var minY = Math.floor(min11[1]);
      var maxX = Math.ceil(max11[0]);
      var maxY2 = Math.ceil(max11[1]);
      var width = maxX - minX;
      var height = maxY2 - minY;
      return { x: minX, y: minY, width, height };
    };
    CanvasRendererPlugin2.prototype.mergeDirtyAABBs = function(dirtyObjects) {
      var aabb = new AABB();
      dirtyObjects.forEach(function(object) {
        var renderBounds = object.getRenderBounds();
        aabb.add(renderBounds);
        var dirtyRenderBounds = object.renderable.dirtyRenderBounds;
        if (dirtyRenderBounds) {
          aabb.add(dirtyRenderBounds);
        }
      });
      return aabb;
    };
    CanvasRendererPlugin2.prototype.searchDirtyObjects = function(dirtyRectangle) {
      var _a2 = __read(dirtyRectangle.getMin(), 2), minX = _a2[0], minY = _a2[1];
      var _b = __read(dirtyRectangle.getMax(), 2), maxX = _b[0], maxY2 = _b[1];
      var rBushNodes = this.rBush.search({
        minX,
        minY,
        maxX,
        maxY: maxY2
      });
      return rBushNodes.map(function(_a3) {
        var displayObject = _a3.displayObject;
        return displayObject;
      });
    };
    CanvasRendererPlugin2.prototype.saveDirtyAABB = function(object) {
      var renderable = object.renderable;
      if (!renderable.dirtyRenderBounds) {
        renderable.dirtyRenderBounds = new AABB();
      }
      var renderBounds = object.getRenderBounds();
      if (renderBounds) {
        renderable.dirtyRenderBounds.update(renderBounds.center, renderBounds.halfExtents);
      }
    };
    CanvasRendererPlugin2.prototype.applyAttributesToContext = function(context, object) {
      var _a2 = object.parsedStyle, stroke2 = _a2.stroke, fill2 = _a2.fill, opacity = _a2.opacity, lineDash = _a2.lineDash, lineDashOffset = _a2.lineDashOffset;
      if (lineDash) {
        context.setLineDash(lineDash);
      }
      if (!is_nil_default(lineDashOffset)) {
        context.lineDashOffset = lineDashOffset;
      }
      if (!is_nil_default(opacity)) {
        context.globalAlpha *= opacity;
      }
      if (!is_nil_default(stroke2) && !Array.isArray(stroke2) && !stroke2.isNone) {
        context.strokeStyle = object.attributes.stroke;
      }
      if (!is_nil_default(fill2) && !Array.isArray(fill2) && !fill2.isNone) {
        context.fillStyle = object.attributes.fill;
      }
    };
    CanvasRendererPlugin2.prototype.applyWorldTransform = function(context, object, matrix2) {
      var tx = 0;
      var ty = 0;
      var anchor = (object.parsedStyle || {}).anchor;
      var anchorX = anchor && anchor[0] || 0;
      var anchorY = anchor && anchor[1] || 0;
      if (anchorX !== 0 || anchorY !== 0) {
        var bounds = object.geometry.contentBounds;
        var width = bounds && bounds.halfExtents[0] * 2 || 0;
        var height = bounds && bounds.halfExtents[1] * 2 || 0;
        tx = -(anchorX * width);
        ty = -(anchorY * height);
      }
      if (matrix2) {
        mat4_exports.copy(this.tmpMat4, object.getLocalTransform());
        this.vec3a[0] = tx;
        this.vec3a[1] = ty;
        this.vec3a[2] = 0;
        mat4_exports.translate(this.tmpMat4, this.tmpMat4, this.vec3a);
        mat4_exports.multiply(this.tmpMat4, matrix2, this.tmpMat4);
        mat4_exports.multiply(this.tmpMat4, this.vpMatrix, this.tmpMat4);
      } else {
        mat4_exports.copy(this.tmpMat4, object.getWorldTransform());
        this.vec3a[0] = tx;
        this.vec3a[1] = ty;
        this.vec3a[2] = 0;
        mat4_exports.translate(this.tmpMat4, this.tmpMat4, this.vec3a);
        mat4_exports.multiply(this.tmpMat4, this.vpMatrix, this.tmpMat4);
      }
      context.setTransform(this.tmpMat4[0], this.tmpMat4[1], this.tmpMat4[4], this.tmpMat4[5], this.tmpMat4[12], this.tmpMat4[13]);
    };
    CanvasRendererPlugin2.prototype.safeMergeAABB = function() {
      var aabbs = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        aabbs[_i] = arguments[_i];
      }
      var merged = new AABB();
      aabbs.forEach(function(aabb) {
        merged.add(aabb);
      });
      return merged;
    };
    CanvasRendererPlugin2.tag = "CanvasRenderer";
    return CanvasRendererPlugin2;
  }()
);
var DefaultRenderer = (
  /** @class */
  function() {
    function DefaultRenderer2(imagePool) {
      this.imagePool = imagePool;
    }
    DefaultRenderer2.prototype.render = function(context, parsedStyle, object, canvasContext, plugin, runtime2) {
      var fill2 = parsedStyle.fill, fillRule = parsedStyle.fillRule, opacity = parsedStyle.opacity, fillOpacity = parsedStyle.fillOpacity, stroke2 = parsedStyle.stroke, strokeOpacity = parsedStyle.strokeOpacity, lineWidth = parsedStyle.lineWidth, lineCap = parsedStyle.lineCap, lineJoin = parsedStyle.lineJoin, shadowType = parsedStyle.shadowType, shadowColor = parsedStyle.shadowColor, shadowBlur = parsedStyle.shadowBlur, filter4 = parsedStyle.filter, miterLimit = parsedStyle.miterLimit;
      var hasFill = !is_nil_default(fill2) && !fill2.isNone;
      var hasStroke = !is_nil_default(stroke2) && !stroke2.isNone && lineWidth > 0;
      var isFillTransparent = fill2.alpha === 0;
      var hasFilter = !!(filter4 && filter4.length);
      var hasShadow = !is_nil_default(shadowColor) && shadowBlur > 0;
      var nodeName = object.nodeName;
      var isInnerShadow = shadowType === "inner";
      var shouldDrawShadowWithStroke = hasStroke && hasShadow && (nodeName === Shape.PATH || nodeName === Shape.LINE || nodeName === Shape.POLYLINE || isFillTransparent || isInnerShadow);
      if (hasFill) {
        context.globalAlpha = opacity * fillOpacity;
        if (!shouldDrawShadowWithStroke) {
          setShadowAndFilter(object, context, hasShadow);
        }
        this.fill(context, object, fill2, fillRule, canvasContext, plugin, runtime2);
        if (!shouldDrawShadowWithStroke) {
          this.clearShadowAndFilter(context, hasFilter, hasShadow);
        }
      }
      if (hasStroke) {
        context.globalAlpha = opacity * strokeOpacity;
        context.lineWidth = lineWidth;
        if (!is_nil_default(miterLimit)) {
          context.miterLimit = miterLimit;
        }
        if (!is_nil_default(lineCap)) {
          context.lineCap = lineCap;
        }
        if (!is_nil_default(lineJoin)) {
          context.lineJoin = lineJoin;
        }
        if (shouldDrawShadowWithStroke) {
          if (isInnerShadow) {
            context.globalCompositeOperation = "source-atop";
          }
          setShadowAndFilter(object, context, true);
          if (isInnerShadow) {
            this.stroke(context, object, stroke2, canvasContext, plugin, runtime2);
            context.globalCompositeOperation = "source-over";
            this.clearShadowAndFilter(context, hasFilter, true);
          }
        }
        this.stroke(context, object, stroke2, canvasContext, plugin, runtime2);
      }
    };
    DefaultRenderer2.prototype.clearShadowAndFilter = function(context, hasFilter, hasShadow) {
      if (hasShadow) {
        context.shadowColor = "transparent";
        context.shadowBlur = 0;
      }
      if (hasFilter) {
        var oldFilter = context.filter;
        if (!is_nil_default(oldFilter) && oldFilter.indexOf("drop-shadow") > -1) {
          context.filter = oldFilter.replace(/drop-shadow\([^)]*\)/, "").trim() || "none";
        }
      }
    };
    DefaultRenderer2.prototype.fill = function(context, object, fill2, fillRule, canvasContext, plugin, runtime2) {
      var _this2 = this;
      if (Array.isArray(fill2)) {
        fill2.forEach(function(gradient2) {
          context.fillStyle = _this2.getColor(gradient2, object, context);
          fillRule ? context.fill(fillRule) : context.fill();
        });
      } else {
        if (isPattern(fill2)) {
          context.fillStyle = this.getPattern(fill2, object, context, canvasContext, plugin, runtime2);
        }
        fillRule ? context.fill(fillRule) : context.fill();
      }
    };
    DefaultRenderer2.prototype.stroke = function(context, object, stroke2, canvasContext, plugin, runtime2) {
      var _this2 = this;
      if (Array.isArray(stroke2)) {
        stroke2.forEach(function(gradient2) {
          context.strokeStyle = _this2.getColor(gradient2, object, context);
          context.stroke();
        });
      } else {
        if (isPattern(stroke2)) {
          context.strokeStyle = this.getPattern(stroke2, object, context, canvasContext, plugin, runtime2);
        }
        context.stroke();
      }
    };
    DefaultRenderer2.prototype.getPattern = function(pattern, object, context, canvasContext, plugin, runtime2) {
      var $offscreenCanvas;
      var dpr;
      if (pattern.image.nodeName === "rect") {
        var _a2 = pattern.image.parsedStyle, width = _a2.width, height = _a2.height;
        dpr = canvasContext.contextService.getDPR();
        var offscreenCanvas = canvasContext.config.offscreenCanvas;
        $offscreenCanvas = runtime2.offscreenCanvasCreator.getOrCreateCanvas(offscreenCanvas);
        $offscreenCanvas.width = width * dpr;
        $offscreenCanvas.height = height * dpr;
        var offscreenCanvasContext_1 = runtime2.offscreenCanvasCreator.getOrCreateContext(offscreenCanvas);
        var restoreStack_1 = [];
        pattern.image.forEach(function(object2) {
          plugin.renderDisplayObject(object2, offscreenCanvasContext_1, canvasContext, restoreStack_1, runtime2);
        });
        restoreStack_1.forEach(function() {
          offscreenCanvasContext_1.restore();
        });
      }
      var canvasPattern = this.imagePool.getOrCreatePatternSync(pattern, context, $offscreenCanvas, dpr, function() {
        object.renderable.dirty = true;
        canvasContext.renderingService.dirtify();
      });
      return canvasPattern;
    };
    DefaultRenderer2.prototype.getColor = function(parsedColor, object, context) {
      var color2;
      if (parsedColor.type === GradientType.LinearGradient || parsedColor.type === GradientType.RadialGradient) {
        var bounds = object.getGeometryBounds();
        var width = bounds && bounds.halfExtents[0] * 2 || 1;
        var height = bounds && bounds.halfExtents[1] * 2 || 1;
        color2 = this.imagePool.getOrCreateGradient(__assign(__assign({ type: parsedColor.type }, parsedColor.value), { width, height }), context);
      }
      return color2;
    };
    return DefaultRenderer2;
  }()
);
function setShadowAndFilter(object, context, hasShadow) {
  var _a2 = object.parsedStyle, filter4 = _a2.filter, shadowColor = _a2.shadowColor, shadowBlur = _a2.shadowBlur, shadowOffsetX = _a2.shadowOffsetX, shadowOffsetY = _a2.shadowOffsetY;
  if (filter4 && filter4.length) {
    context.filter = object.style.filter;
  }
  if (hasShadow) {
    context.shadowColor = shadowColor.toString();
    context.shadowBlur = shadowBlur || 0;
    context.shadowOffsetX = shadowOffsetX || 0;
    context.shadowOffsetY = shadowOffsetY || 0;
  }
}
var ImageRenderer = (
  /** @class */
  function() {
    function ImageRenderer2(imagePool) {
      this.imagePool = imagePool;
    }
    ImageRenderer2.prototype.render = function(context, parsedStyle, object) {
      var width = parsedStyle.width, height = parsedStyle.height, img = parsedStyle.img, shadowColor = parsedStyle.shadowColor, shadowBlur = parsedStyle.shadowBlur;
      var image;
      var iw = width;
      var ih = height;
      if (is_string_default(img)) {
        image = this.imagePool.getImageSync(img);
      } else {
        iw || (iw = img.width);
        ih || (ih = img.height);
        image = img;
      }
      if (image) {
        var hasShadow = !is_nil_default(shadowColor) && shadowBlur > 0;
        setShadowAndFilter(object, context, hasShadow);
        try {
          context.drawImage(image, 0, 0, iw, ih);
        } catch (e) {
        }
      }
    };
    return ImageRenderer2;
  }()
);
var TextRenderer = (
  /** @class */
  function() {
    function TextRenderer2() {
    }
    TextRenderer2.prototype.render = function(context, parsedStyle, object, canvasContext, plugin, runtime2) {
      var _a2 = parsedStyle, lineWidth = _a2.lineWidth, textAlign = _a2.textAlign, textBaseline = _a2.textBaseline, lineJoin = _a2.lineJoin, miterLimit = _a2.miterLimit, letterSpacing = _a2.letterSpacing, stroke2 = _a2.stroke, fill2 = _a2.fill, fillOpacity = _a2.fillOpacity, strokeOpacity = _a2.strokeOpacity, opacity = _a2.opacity, metrics = _a2.metrics, dx = _a2.dx, dy = _a2.dy, shadowColor = _a2.shadowColor, shadowBlur = _a2.shadowBlur;
      var font = metrics.font, lines = metrics.lines, height = metrics.height, lineHeight = metrics.lineHeight, lineMetrics = metrics.lineMetrics;
      context.font = font;
      context.lineWidth = lineWidth;
      context.textAlign = textAlign === "middle" ? "center" : textAlign;
      var formattedTextBaseline = textBaseline;
      if (
        // formattedTextBaseline === 'bottom' ||
        !runtime2.enableCSSParsing && formattedTextBaseline === "alphabetic"
      ) {
        formattedTextBaseline = "bottom";
      }
      context.lineJoin = lineJoin;
      if (!is_nil_default(miterLimit)) {
        context.miterLimit = miterLimit;
      }
      var linePositionY = 0;
      if (textBaseline === "middle") {
        linePositionY = -height / 2 - lineHeight / 2;
      } else if (textBaseline === "bottom" || textBaseline === "alphabetic" || textBaseline === "ideographic") {
        linePositionY = -height;
      } else if (textBaseline === "top" || textBaseline === "hanging") {
        linePositionY = -lineHeight;
      }
      var offsetX = dx || 0;
      linePositionY += dy || 0;
      if (lines.length === 1) {
        if (formattedTextBaseline === "bottom") {
          formattedTextBaseline = "middle";
          linePositionY -= 0.5 * height;
        } else if (formattedTextBaseline === "top") {
          formattedTextBaseline = "middle";
          linePositionY += 0.5 * height;
        }
      }
      context.textBaseline = formattedTextBaseline;
      var hasShadow = !is_nil_default(shadowColor) && shadowBlur > 0;
      setShadowAndFilter(object, context, hasShadow);
      for (var i = 0; i < lines.length; i++) {
        var linePositionX = lineWidth / 2 + offsetX;
        linePositionY += lineHeight;
        if (!is_nil_default(stroke2) && !stroke2.isNone && lineWidth) {
          this.drawLetterSpacing(context, lines[i], lineMetrics[i], textAlign, linePositionX, linePositionY, letterSpacing, fillOpacity, strokeOpacity, opacity, true);
        }
        if (!is_nil_default(fill2)) {
          this.drawLetterSpacing(context, lines[i], lineMetrics[i], textAlign, linePositionX, linePositionY, letterSpacing, fillOpacity, strokeOpacity, opacity);
        }
      }
    };
    TextRenderer2.prototype.drawLetterSpacing = function(context, text, lineMetrics, textAlign, x3, y3, letterSpacing, fillOpacity, strokeOpacity, opacity, isStroke) {
      if (isStroke === void 0) {
        isStroke = false;
      }
      if (letterSpacing === 0) {
        if (isStroke) {
          this.strokeText(context, text, x3, y3, strokeOpacity);
        } else {
          this.fillText(context, text, x3, y3, fillOpacity, opacity);
        }
        return;
      }
      var currentTextAlign = context.textAlign;
      context.textAlign = "left";
      var currentPosition = x3;
      if (textAlign === "center" || textAlign === "middle") {
        currentPosition = x3 - lineMetrics.width / 2;
      } else if (textAlign === "right" || textAlign === "end") {
        currentPosition = x3 - lineMetrics.width;
      }
      var stringArray = Array.from(text);
      var previousWidth = context.measureText(text).width;
      var currentWidth = 0;
      for (var i = 0; i < stringArray.length; ++i) {
        var currentChar = stringArray[i];
        if (isStroke) {
          this.strokeText(context, currentChar, currentPosition, y3, strokeOpacity);
        } else {
          this.fillText(context, currentChar, currentPosition, y3, fillOpacity, opacity);
        }
        currentWidth = context.measureText(text.substring(i + 1)).width;
        currentPosition += previousWidth - currentWidth + letterSpacing;
        previousWidth = currentWidth;
      }
      context.textAlign = currentTextAlign;
    };
    TextRenderer2.prototype.fillText = function(context, text, x3, y3, fillOpacity, opacity) {
      var currentGlobalAlpha;
      var applyOpacity = !is_nil_default(fillOpacity) && fillOpacity !== 1;
      if (applyOpacity) {
        currentGlobalAlpha = context.globalAlpha;
        context.globalAlpha = fillOpacity * opacity;
      }
      context.fillText(text, x3, y3);
      if (applyOpacity) {
        context.globalAlpha = currentGlobalAlpha;
      }
    };
    TextRenderer2.prototype.strokeText = function(context, text, x3, y3, strokeOpacity) {
      var currentGlobalAlpha;
      var applyOpacity = !is_nil_default(strokeOpacity) && strokeOpacity !== 1;
      if (applyOpacity) {
        currentGlobalAlpha = context.globalAlpha;
        context.globalAlpha = strokeOpacity;
      }
      context.strokeText(text, x3, y3);
      if (applyOpacity) {
        context.globalAlpha = currentGlobalAlpha;
      }
    };
    return TextRenderer2;
  }()
);
var RectRenderer = (
  /** @class */
  function(_super) {
    __extends(RectRenderer2, _super);
    function RectRenderer2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    return RectRenderer2;
  }(DefaultRenderer)
);
var CircleRenderer = (
  /** @class */
  function(_super) {
    __extends(CircleRenderer2, _super);
    function CircleRenderer2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    return CircleRenderer2;
  }(DefaultRenderer)
);
var EllipseRenderer = (
  /** @class */
  function(_super) {
    __extends(EllipseRenderer2, _super);
    function EllipseRenderer2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    return EllipseRenderer2;
  }(DefaultRenderer)
);
var LineRenderer = (
  /** @class */
  function(_super) {
    __extends(LineRenderer2, _super);
    function LineRenderer2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    return LineRenderer2;
  }(DefaultRenderer)
);
var PolylineRenderer = (
  /** @class */
  function(_super) {
    __extends(PolylineRenderer2, _super);
    function PolylineRenderer2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    return PolylineRenderer2;
  }(DefaultRenderer)
);
var PolygonRenderer = (
  /** @class */
  function(_super) {
    __extends(PolygonRenderer2, _super);
    function PolygonRenderer2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    return PolygonRenderer2;
  }(DefaultRenderer)
);
var PathRenderer = (
  /** @class */
  function(_super) {
    __extends(PathRenderer2, _super);
    function PathRenderer2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    return PathRenderer2;
  }(DefaultRenderer)
);
var Plugin3 = (
  /** @class */
  function(_super) {
    __extends(Plugin8, _super);
    function Plugin8(options) {
      if (options === void 0) {
        options = {};
      }
      var _this2 = _super.call(this) || this;
      _this2.options = options;
      _this2.name = "canvas-renderer";
      return _this2;
    }
    Plugin8.prototype.init = function() {
      var _a2;
      var canvasRendererPluginOptions = __assign({ dirtyObjectNumThreshold: 500, dirtyObjectRatioThreshold: 0.8 }, this.options);
      var imagePool = this.context.imagePool;
      var defaultRenderer = new DefaultRenderer(imagePool);
      var defaultStyleRendererFactory = (_a2 = {}, _a2[Shape.CIRCLE] = defaultRenderer, _a2[Shape.ELLIPSE] = defaultRenderer, _a2[Shape.RECT] = defaultRenderer, _a2[Shape.IMAGE] = new ImageRenderer(imagePool), _a2[Shape.TEXT] = new TextRenderer(), _a2[Shape.LINE] = defaultRenderer, _a2[Shape.POLYLINE] = defaultRenderer, _a2[Shape.POLYGON] = defaultRenderer, _a2[Shape.PATH] = defaultRenderer, _a2[Shape.GROUP] = void 0, _a2[Shape.HTML] = void 0, _a2[Shape.MESH] = void 0, _a2);
      this.context.defaultStyleRendererFactory = defaultStyleRendererFactory;
      this.context.styleRendererFactory = defaultStyleRendererFactory;
      this.addRenderingPlugin(new CanvasRendererPlugin(canvasRendererPluginOptions));
    };
    Plugin8.prototype.destroy = function() {
      this.removeAllRenderingPlugins();
      delete this.context.defaultStyleRendererFactory;
      delete this.context.styleRendererFactory;
    };
    return Plugin8;
  }(AbstractRendererPlugin)
);

// node_modules/@antv/g-plugin-dom-interaction/dist/index.esm.js
var DOMInteractionPlugin = (
  /** @class */
  function() {
    function DOMInteractionPlugin2() {
    }
    DOMInteractionPlugin2.prototype.apply = function(context, runtime2) {
      var _this2 = this;
      var renderingService = context.renderingService, renderingContext = context.renderingContext, config = context.config;
      this.context = context;
      var canvas = renderingContext.root.ownerDocument.defaultView;
      var onPointerMove = function(ev) {
        renderingService.hooks.pointerMove.call(ev);
      };
      var onPointerUp = function(ev) {
        renderingService.hooks.pointerUp.call(ev);
      };
      var onPointerDown = function(ev) {
        renderingService.hooks.pointerDown.call(ev);
      };
      var onPointerOver = function(ev) {
        renderingService.hooks.pointerOver.call(ev);
      };
      var onPointerOut = function(ev) {
        renderingService.hooks.pointerOut.call(ev);
      };
      var onPointerCancel = function(ev) {
        renderingService.hooks.pointerCancel.call(ev);
      };
      var onPointerWheel = function(ev) {
        renderingService.hooks.pointerWheel.call(ev);
      };
      var onClick = function(ev) {
        renderingService.hooks.click.call(ev);
      };
      var addPointerEventListener = function($el) {
        runtime2.globalThis.document.addEventListener("pointermove", onPointerMove, true);
        $el.addEventListener("pointerdown", onPointerDown, true);
        $el.addEventListener("pointerleave", onPointerOut, true);
        $el.addEventListener("pointerover", onPointerOver, true);
        runtime2.globalThis.addEventListener("pointerup", onPointerUp, true);
        runtime2.globalThis.addEventListener("pointercancel", onPointerCancel, true);
      };
      var addTouchEventListener = function($el) {
        $el.addEventListener("touchstart", onPointerDown, true);
        $el.addEventListener("touchend", onPointerUp, true);
        $el.addEventListener("touchmove", onPointerMove, true);
        $el.addEventListener("touchcancel", onPointerCancel, true);
      };
      var addMouseEventListener = function($el) {
        runtime2.globalThis.document.addEventListener("mousemove", onPointerMove, true);
        $el.addEventListener("mousedown", onPointerDown, true);
        $el.addEventListener("mouseout", onPointerOut, true);
        $el.addEventListener("mouseover", onPointerOver, true);
        runtime2.globalThis.addEventListener("mouseup", onPointerUp, true);
      };
      var removePointerEventListener = function($el) {
        runtime2.globalThis.document.removeEventListener("pointermove", onPointerMove, true);
        $el.removeEventListener("pointerdown", onPointerDown, true);
        $el.removeEventListener("pointerleave", onPointerOut, true);
        $el.removeEventListener("pointerover", onPointerOver, true);
        runtime2.globalThis.removeEventListener("pointerup", onPointerUp, true);
      };
      var removeTouchEventListener = function($el) {
        $el.removeEventListener("touchstart", onPointerDown, true);
        $el.removeEventListener("touchend", onPointerUp, true);
        $el.removeEventListener("touchmove", onPointerMove, true);
        $el.removeEventListener("touchcancel", onPointerCancel, true);
      };
      var removeMouseEventListener = function($el) {
        runtime2.globalThis.document.removeEventListener("mousemove", onPointerMove, true);
        $el.removeEventListener("mousedown", onPointerDown, true);
        $el.removeEventListener("mouseout", onPointerOut, true);
        $el.removeEventListener("mouseover", onPointerOver, true);
        runtime2.globalThis.removeEventListener("mouseup", onPointerUp, true);
      };
      renderingService.hooks.init.tap(DOMInteractionPlugin2.tag, function() {
        var $el = _this2.context.contextService.getDomElement();
        if (runtime2.globalThis.navigator.msPointerEnabled) {
          $el.style.msContentZooming = "none";
          $el.style.msTouchAction = "none";
        } else if (canvas.supportsPointerEvents) {
          $el.style.touchAction = "none";
        }
        if (canvas.supportsPointerEvents) {
          addPointerEventListener($el);
        } else {
          addMouseEventListener($el);
        }
        if (canvas.supportsTouchEvents) {
          addTouchEventListener($el);
        }
        if (config.useNativeClickEvent) {
          $el.addEventListener("click", onClick, true);
        }
        $el.addEventListener("wheel", onPointerWheel, {
          passive: true,
          capture: true
        });
      });
      renderingService.hooks.destroy.tap(DOMInteractionPlugin2.tag, function() {
        var $el = _this2.context.contextService.getDomElement();
        if (runtime2.globalThis.navigator.msPointerEnabled) {
          $el.style.msContentZooming = "";
          $el.style.msTouchAction = "";
        } else if (canvas.supportsPointerEvents) {
          $el.style.touchAction = "";
        }
        if (canvas.supportsPointerEvents) {
          removePointerEventListener($el);
        } else {
          removeMouseEventListener($el);
        }
        if (canvas.supportsTouchEvents) {
          removeTouchEventListener($el);
        }
        if (config.useNativeClickEvent) {
          $el.removeEventListener("click", onClick, true);
        }
        $el.removeEventListener("wheel", onPointerWheel, true);
      });
    };
    DOMInteractionPlugin2.tag = "DOMInteraction";
    return DOMInteractionPlugin2;
  }()
);
var Plugin4 = (
  /** @class */
  function(_super) {
    __extends(Plugin8, _super);
    function Plugin8() {
      var _this2 = _super.apply(this, __spreadArray([], __read(arguments), false)) || this;
      _this2.name = "dom-interaction";
      return _this2;
    }
    Plugin8.prototype.init = function() {
      this.addRenderingPlugin(new DOMInteractionPlugin());
    };
    Plugin8.prototype.destroy = function() {
      this.removeAllRenderingPlugins();
    };
    return Plugin8;
  }(AbstractRendererPlugin)
);

// node_modules/@antv/g-plugin-html-renderer/dist/index.esm.js
var CANVAS_CAMERA_ID = "g-canvas-camera";
var HTMLRenderingPlugin = (
  /** @class */
  function() {
    function HTMLRenderingPlugin2() {
      this.displayObjectHTMLElementMap = /* @__PURE__ */ new WeakMap();
    }
    HTMLRenderingPlugin2.prototype.joinTransformMatrix = function(matrix2) {
      return "matrix(".concat([
        matrix2[0],
        matrix2[1],
        matrix2[4],
        matrix2[5],
        matrix2[12],
        matrix2[13]
      ].join(","), ")");
    };
    HTMLRenderingPlugin2.prototype.apply = function(context, runtime2) {
      var _this2 = this;
      var camera = context.camera, renderingContext = context.renderingContext, renderingService = context.renderingService;
      this.context = context;
      var canvas = renderingContext.root.ownerDocument.defaultView;
      var nativeHTMLMap = canvas.context.eventService.nativeHTMLMap;
      var setTransform = function(object, $el) {
        $el.style.transform = _this2.joinTransformMatrix(object.getWorldTransform());
      };
      var handleMounted = function(e) {
        var object = e.target;
        if (object.nodeName === Shape.HTML) {
          if (!_this2.$camera) {
            _this2.$camera = _this2.createCamera(camera);
          }
          var $el_1 = _this2.getOrCreateEl(object);
          _this2.$camera.appendChild($el_1);
          if (runtime2.enableCSSParsing) {
            var attributes_1 = object.ownerDocument.documentElement.attributes;
            Object.keys(attributes_1).forEach(function(name2) {
              $el_1.style[name2] = attributes_1[name2];
            });
          }
          Object.keys(object.attributes).forEach(function(name2) {
            _this2.updateAttribute(name2, object);
          });
          setTransform(object, $el_1);
          nativeHTMLMap.set($el_1, object);
        }
      };
      var handleUnmounted = function(e) {
        var object = e.target;
        if (object.nodeName === Shape.HTML && _this2.$camera) {
          var $el = _this2.getOrCreateEl(object);
          if ($el) {
            $el.remove();
            nativeHTMLMap.delete($el);
          }
        }
      };
      var handleAttributeChanged = function(e) {
        var object = e.target;
        if (object.nodeName === Shape.HTML) {
          var attrName = e.attrName;
          _this2.updateAttribute(attrName, object);
        }
      };
      var handleBoundsChanged = function(e) {
        var object = e.target;
        if (object.nodeName === Shape.HTML) {
          var $el = _this2.getOrCreateEl(object);
          setTransform(object, $el);
        }
      };
      var handleCanvasResize = function() {
        if (_this2.$camera) {
          var _a2 = _this2.context.config, width = _a2.width, height = _a2.height;
          _this2.$camera.style.width = "".concat(width || 0, "px");
          _this2.$camera.style.height = "".concat(height || 0, "px");
        }
      };
      renderingService.hooks.init.tap(HTMLRenderingPlugin2.tag, function() {
        canvas.addEventListener(CanvasEvent.RESIZE, handleCanvasResize);
        canvas.addEventListener(ElementEvent.MOUNTED, handleMounted);
        canvas.addEventListener(ElementEvent.UNMOUNTED, handleUnmounted);
        canvas.addEventListener(ElementEvent.ATTR_MODIFIED, handleAttributeChanged);
        canvas.addEventListener(ElementEvent.BOUNDS_CHANGED, handleBoundsChanged);
      });
      renderingService.hooks.endFrame.tap(HTMLRenderingPlugin2.tag, function() {
        if (_this2.$camera && renderingContext.renderReasons.has(RenderReason.CAMERA_CHANGED)) {
          _this2.$camera.style.transform = _this2.joinTransformMatrix(camera.getOrthoMatrix());
        }
      });
      renderingService.hooks.destroy.tap(HTMLRenderingPlugin2.tag, function() {
        if (_this2.$camera) {
          _this2.$camera.remove();
        }
        canvas.removeEventListener(CanvasEvent.RESIZE, handleCanvasResize);
        canvas.removeEventListener(ElementEvent.MOUNTED, handleMounted);
        canvas.removeEventListener(ElementEvent.UNMOUNTED, handleUnmounted);
        canvas.removeEventListener(ElementEvent.ATTR_MODIFIED, handleAttributeChanged);
        canvas.removeEventListener(ElementEvent.BOUNDS_CHANGED, handleBoundsChanged);
      });
    };
    HTMLRenderingPlugin2.prototype.createCamera = function(camera) {
      var _a2 = this.context.config, doc = _a2.document, width = _a2.width, height = _a2.height;
      var $canvas = this.context.contextService.getDomElement();
      var $container = $canvas.parentNode;
      if ($container) {
        var cameraId = CANVAS_CAMERA_ID;
        var $existedCamera = $container.querySelector("#" + cameraId);
        if (!$existedCamera) {
          var $camera = (doc || document).createElement("div");
          $existedCamera = $camera;
          $camera.id = cameraId;
          $camera.style.position = "absolute";
          $camera.style.left = "".concat($canvas.offsetLeft || 0, "px");
          $camera.style.top = "".concat($canvas.offsetTop || 0, "px");
          $camera.style.transformOrigin = "left top";
          $camera.style.transform = this.joinTransformMatrix(camera.getOrthoMatrix());
          $camera.style.overflow = "hidden";
          $camera.style.pointerEvents = "none";
          $camera.style.width = "".concat(width || 0, "px");
          $camera.style.height = "".concat(height || 0, "px");
          $container.appendChild($camera);
        }
        return $existedCamera;
      }
      return null;
    };
    HTMLRenderingPlugin2.prototype.getOrCreateEl = function(object) {
      var doc = this.context.config.document;
      var $existedElement = this.displayObjectHTMLElementMap.get(object);
      if (!$existedElement) {
        $existedElement = (doc || document).createElement("div");
        object.parsedStyle.$el = $existedElement;
        this.displayObjectHTMLElementMap.set(object, $existedElement);
        if (object.id) {
          $existedElement.id = object.id;
        }
        if (object.name) {
          $existedElement.setAttribute("name", object.name);
        }
        if (object.className) {
          $existedElement.className = object.className;
        }
        $existedElement.style.position = "absolute";
        $existedElement.style.left = "0px";
        $existedElement.style.top = "0px";
        $existedElement.style["will-change"] = "transform";
        $existedElement.style.transform = this.joinTransformMatrix(object.getWorldTransform());
      }
      return $existedElement;
    };
    HTMLRenderingPlugin2.prototype.updateAttribute = function(name2, object) {
      var $el = this.getOrCreateEl(object);
      switch (name2) {
        case "innerHTML":
          var innerHTML = object.parsedStyle.innerHTML;
          if (is_string_default(innerHTML)) {
            $el.innerHTML = innerHTML;
          } else {
            $el.innerHTML = "";
            $el.appendChild(innerHTML);
          }
          break;
        case "transformOrigin":
          var transformOrigin = object.parsedStyle.transformOrigin;
          $el.style["transform-origin"] = "".concat(transformOrigin[0].value, " ").concat(transformOrigin[1].value);
          break;
        case "width":
          if (this.context.enableCSSParsing) {
            var width = object.computedStyleMap().get("width");
            $el.style.width = width.toString();
          } else {
            var width = object.parsedStyle.width;
            $el.style.width = is_number_default(width) ? "".concat(width, "px") : width.toString();
          }
          break;
        case "height":
          if (this.context.enableCSSParsing) {
            var height = object.computedStyleMap().get("height");
            $el.style.height = height.toString();
          } else {
            var height = object.parsedStyle.height;
            $el.style.height = is_number_default(height) ? "".concat(height, "px") : height.toString();
          }
          break;
        case "zIndex":
          var zIndex = object.parsedStyle.zIndex;
          $el.style["z-index"] = "".concat(zIndex);
          break;
        case "visibility":
          var visibility2 = object.parsedStyle.visibility;
          $el.style.visibility = visibility2;
          break;
        case "pointerEvents":
          var pointerEvents = object.parsedStyle.pointerEvents;
          $el.style.pointerEvents = pointerEvents;
          break;
        case "opacity":
          var opacity = object.parsedStyle.opacity;
          $el.style.opacity = "".concat(opacity);
          break;
        case "fill":
          var fill2 = object.parsedStyle.fill;
          var color2 = "";
          if (isCSSRGB(fill2)) {
            if (fill2.isNone) {
              color2 = "transparent";
            } else {
              color2 = object.getAttribute("fill");
            }
          } else if (Array.isArray(fill2)) {
            color2 = object.getAttribute("fill");
          } else if (isPattern(fill2))
            ;
          $el.style.background = color2;
          break;
        case "stroke":
          var stroke2 = object.parsedStyle.stroke;
          var borderColor = "";
          if (isCSSRGB(stroke2)) {
            if (stroke2.isNone) {
              borderColor = "transparent";
            } else {
              borderColor = object.getAttribute("stroke");
            }
          } else if (Array.isArray(stroke2)) {
            borderColor = object.getAttribute("stroke");
          } else if (isPattern(stroke2))
            ;
          $el.style["border-color"] = borderColor;
          $el.style["border-style"] = "solid";
          break;
        case "lineWidth":
          var lineWidth = object.parsedStyle.lineWidth;
          $el.style["border-width"] = "".concat(lineWidth || 0, "px");
          break;
        case "lineDash":
          $el.style["border-style"] = "dashed";
          break;
        case "filter":
          var filter4 = object.style.filter;
          $el.style.filter = filter4;
          break;
        default:
          if (name2 !== "x" && name2 !== "y") {
            if (!is_nil_default(object.style[name2]) && object.style[name2] !== "") {
              $el.style[name2] = object.style[name2];
            }
          }
      }
    };
    HTMLRenderingPlugin2.tag = "HTMLRendering";
    return HTMLRenderingPlugin2;
  }()
);
var Plugin5 = (
  /** @class */
  function(_super) {
    __extends(Plugin8, _super);
    function Plugin8() {
      var _this2 = _super.apply(this, __spreadArray([], __read(arguments), false)) || this;
      _this2.name = "html-renderer";
      return _this2;
    }
    Plugin8.prototype.init = function() {
      this.addRenderingPlugin(new HTMLRenderingPlugin());
    };
    Plugin8.prototype.destroy = function() {
      this.removeAllRenderingPlugins();
    };
    return Plugin8;
  }(AbstractRendererPlugin)
);

// node_modules/@antv/g-plugin-image-loader/dist/index.esm.js
var ImagePool = (
  /** @class */
  function() {
    function ImagePool2(canvasConfig) {
      this.canvasConfig = canvasConfig;
      this.imageCache = {};
      this.gradientCache = {};
      this.patternCache = {};
    }
    ImagePool2.prototype.getImageSync = function(src, callback) {
      if (!this.imageCache[src]) {
        this.getOrCreateImage(src).then(function(img) {
          if (callback) {
            callback(img);
          }
        });
      } else {
        if (callback) {
          callback(this.imageCache[src]);
        }
      }
      return this.imageCache[src];
    };
    ImagePool2.prototype.getOrCreateImage = function(src) {
      var _this2 = this;
      if (this.imageCache[src]) {
        return Promise.resolve(this.imageCache[src]);
      }
      var createImage = this.canvasConfig.createImage;
      return new Promise(function(resolve, reject2) {
        var image;
        if (createImage) {
          image = createImage(src);
        } else if (isBrowser) {
          image = new window.Image();
        }
        if (image) {
          image.onload = function() {
            _this2.imageCache[src] = image;
            resolve(image);
          };
          image.onerror = function(ev) {
            reject2(ev);
          };
          image.crossOrigin = "Anonymous";
          image.src = src;
        }
      });
    };
    ImagePool2.prototype.getOrCreatePatternSync = function(pattern, context, $offscreenCanvas, dpr, callback) {
      var patternKey = this.generatePatternKey(pattern);
      if (patternKey && this.patternCache[patternKey]) {
        return this.patternCache[patternKey];
      }
      var image = pattern.image, repetition = pattern.repetition, transform3 = pattern.transform;
      var src;
      var needScaleWithDPR = false;
      if (is_string_default(image)) {
        src = this.getImageSync(image, callback);
      } else if ($offscreenCanvas) {
        src = $offscreenCanvas;
        needScaleWithDPR = true;
      } else {
        src = image;
      }
      var canvasPattern = src && context.createPattern(src, repetition);
      if (canvasPattern) {
        var mat = void 0;
        if (transform3) {
          mat = parsedTransformToMat4(parseTransform(transform3), new DisplayObject({}));
        } else {
          mat = mat4_exports.identity(mat4_exports.create());
        }
        if (needScaleWithDPR) {
          mat4_exports.scale(mat, mat, [1 / dpr, 1 / dpr, 1]);
        }
        canvasPattern.setTransform({
          a: mat[0],
          b: mat[1],
          c: mat[4],
          d: mat[5],
          e: mat[12],
          f: mat[13]
        });
      }
      if (patternKey && canvasPattern) {
        this.patternCache[patternKey] = canvasPattern;
      }
      return canvasPattern;
    };
    ImagePool2.prototype.getOrCreateGradient = function(params, context) {
      var key = this.generateGradientKey(params);
      var type = params.type, steps = params.steps, width = params.width, height = params.height, angle4 = params.angle, cx = params.cx, cy = params.cy, size5 = params.size;
      if (this.gradientCache[key]) {
        return this.gradientCache[key];
      }
      var gradient2 = null;
      if (type === GradientType.LinearGradient) {
        var _a2 = computeLinearGradient(width, height, angle4), x12 = _a2.x1, y12 = _a2.y1, x22 = _a2.x2, y22 = _a2.y2;
        gradient2 = context.createLinearGradient(x12, y12, x22, y22);
      } else if (type === GradientType.RadialGradient) {
        var _b = computeRadialGradient(width, height, cx, cy, size5), x3 = _b.x, y3 = _b.y, r = _b.r;
        gradient2 = context.createRadialGradient(x3, y3, 0, x3, y3, r);
      }
      if (gradient2) {
        steps.forEach(function(_a3) {
          var offset2 = _a3.offset, color2 = _a3.color;
          if (offset2.unit === UnitType.kPercentage) {
            gradient2 === null || gradient2 === void 0 ? void 0 : gradient2.addColorStop(offset2.value / 100, color2.toString());
          }
        });
        this.gradientCache[key] = gradient2;
      }
      return this.gradientCache[key];
    };
    ImagePool2.prototype.generateGradientKey = function(params) {
      var type = params.type, width = params.width, height = params.height, steps = params.steps, angle4 = params.angle, cx = params.cx, cy = params.cy, size5 = params.size;
      return "gradient-".concat(type, "-").concat((angle4 === null || angle4 === void 0 ? void 0 : angle4.toString()) || 0, "-").concat((cx === null || cx === void 0 ? void 0 : cx.toString()) || 0, "-").concat((cy === null || cy === void 0 ? void 0 : cy.toString()) || 0, "-").concat((size5 === null || size5 === void 0 ? void 0 : size5.toString()) || 0, "-").concat(width, "-").concat(height, "-").concat(steps.map(function(_a2) {
        var offset2 = _a2.offset, color2 = _a2.color;
        return "".concat(offset2).concat(color2);
      }).join("-"));
    };
    ImagePool2.prototype.generatePatternKey = function(pattern) {
      var image = pattern.image, repetition = pattern.repetition;
      if (is_string_default(image)) {
        return "pattern-".concat(image, "-").concat(repetition);
      } else if (image.nodeName === "rect") {
        return "pattern-".concat(image.entity, "-").concat(repetition);
      }
    };
    return ImagePool2;
  }()
);
var LoadImagePlugin = (
  /** @class */
  function() {
    function LoadImagePlugin2() {
    }
    LoadImagePlugin2.prototype.apply = function(context) {
      var renderingService = context.renderingService, renderingContext = context.renderingContext, imagePool = context.imagePool;
      var canvas = renderingContext.root.ownerDocument.defaultView;
      var calculateWithAspectRatio = function(object, imageWidth, imageHeight) {
        var _a2 = object.parsedStyle, width = _a2.width, height = _a2.height;
        if (width && !height) {
          object.setAttribute("height", imageHeight / imageWidth * width);
        } else if (!width && height) {
          object.setAttribute("width", imageWidth / imageHeight * height);
        }
      };
      var handleMounted = function(e) {
        var object = e.target;
        var nodeName = object.nodeName, attributes = object.attributes;
        if (nodeName === Shape.IMAGE) {
          var img = attributes.img, keepAspectRatio_1 = attributes.keepAspectRatio;
          if (is_string_default(img)) {
            imagePool.getImageSync(img, function(_a2) {
              var width = _a2.width, height = _a2.height;
              if (keepAspectRatio_1) {
                calculateWithAspectRatio(object, width, height);
              }
              object.renderable.dirty = true;
              renderingService.dirtify();
            });
          }
        }
      };
      var handleAttributeChanged = function(e) {
        var object = e.target;
        var attrName = e.attrName, newValue = e.newValue;
        if (object.nodeName === Shape.IMAGE) {
          if (attrName === "img") {
            if (is_string_default(newValue)) {
              imagePool.getOrCreateImage(newValue).then(function(_a2) {
                var width = _a2.width, height = _a2.height;
                if (object.attributes.keepAspectRatio) {
                  calculateWithAspectRatio(object, width, height);
                }
                object.renderable.dirty = true;
                renderingService.dirtify();
              });
            }
          }
        }
      };
      renderingService.hooks.init.tap(LoadImagePlugin2.tag, function() {
        canvas.addEventListener(ElementEvent.MOUNTED, handleMounted);
        canvas.addEventListener(ElementEvent.ATTR_MODIFIED, handleAttributeChanged);
      });
      renderingService.hooks.destroy.tap(LoadImagePlugin2.tag, function() {
        canvas.removeEventListener(ElementEvent.MOUNTED, handleMounted);
        canvas.removeEventListener(ElementEvent.ATTR_MODIFIED, handleAttributeChanged);
      });
    };
    LoadImagePlugin2.tag = "LoadImage";
    return LoadImagePlugin2;
  }()
);
var Plugin6 = (
  /** @class */
  function(_super) {
    __extends(Plugin8, _super);
    function Plugin8() {
      var _this2 = _super.apply(this, __spreadArray([], __read(arguments), false)) || this;
      _this2.name = "image-loader";
      return _this2;
    }
    Plugin8.prototype.init = function() {
      this.context.imagePool = new ImagePool(this.context.config);
      this.addRenderingPlugin(new LoadImagePlugin());
    };
    Plugin8.prototype.destroy = function() {
      this.removeAllRenderingPlugins();
    };
    return Plugin8;
  }(AbstractRendererPlugin)
);

// node_modules/@antv/g-canvas/dist/index.esm.js
var Canvas2DContextService = (
  /** @class */
  function() {
    function Canvas2DContextService2(context) {
      this.renderingContext = context.renderingContext;
      this.canvasConfig = context.config;
    }
    Canvas2DContextService2.prototype.init = function() {
      var _a2 = this.canvasConfig, container = _a2.container, canvas = _a2.canvas;
      if (canvas) {
        this.$canvas = canvas;
        if (container && canvas.parentElement !== container) {
          container.appendChild(canvas);
        }
        this.$container = canvas.parentElement;
        this.canvasConfig.container = this.$container;
      } else if (container) {
        this.$container = is_string_default(container) ? document.getElementById(container) : container;
        if (this.$container) {
          var $canvas = document.createElement("canvas");
          this.$container.appendChild($canvas);
          if (!this.$container.style.position) {
            this.$container.style.position = "relative";
          }
          this.$canvas = $canvas;
        }
      }
      this.context = this.$canvas.getContext("2d");
      this.resize(this.canvasConfig.width, this.canvasConfig.height);
    };
    Canvas2DContextService2.prototype.getContext = function() {
      return this.context;
    };
    Canvas2DContextService2.prototype.getDomElement = function() {
      return this.$canvas;
    };
    Canvas2DContextService2.prototype.getDPR = function() {
      return this.dpr;
    };
    Canvas2DContextService2.prototype.getBoundingClientRect = function() {
      if (this.$canvas.getBoundingClientRect) {
        return this.$canvas.getBoundingClientRect();
      }
    };
    Canvas2DContextService2.prototype.destroy = function() {
      if (this.$container && this.$canvas && this.$canvas.parentNode) {
        this.$container.removeChild(this.$canvas);
      }
    };
    Canvas2DContextService2.prototype.resize = function(width, height) {
      var devicePixelRatio = this.canvasConfig.devicePixelRatio;
      var dpr = devicePixelRatio || isBrowser && window.devicePixelRatio || 1;
      dpr = dpr >= 1 ? Math.ceil(dpr) : 1;
      this.dpr = dpr;
      if (this.$canvas) {
        this.$canvas.width = this.dpr * width;
        this.$canvas.height = this.dpr * height;
        setDOMSize(this.$canvas, width, height);
      }
      this.renderingContext.renderReasons.add(RenderReason.CAMERA_CHANGED);
    };
    Canvas2DContextService2.prototype.applyCursorStyle = function(cursor) {
      if (this.$container && this.$container.style) {
        this.$container.style.cursor = cursor;
      }
    };
    Canvas2DContextService2.prototype.toDataURL = function(options) {
      if (options === void 0) {
        options = {};
      }
      return __awaiter(this, void 0, void 0, function() {
        var type, encoderOptions;
        return __generator(this, function(_a2) {
          type = options.type, encoderOptions = options.encoderOptions;
          return [2, this.context.canvas.toDataURL(type, encoderOptions)];
        });
      });
    };
    return Canvas2DContextService2;
  }()
);
var ContextRegisterPlugin = (
  /** @class */
  function(_super) {
    __extends(ContextRegisterPlugin2, _super);
    function ContextRegisterPlugin2() {
      var _this2 = _super.apply(this, __spreadArray([], __read(arguments), false)) || this;
      _this2.name = "canvas-context-register";
      return _this2;
    }
    ContextRegisterPlugin2.prototype.init = function() {
      this.context.ContextService = Canvas2DContextService;
    };
    ContextRegisterPlugin2.prototype.destroy = function() {
      delete this.context.ContextService;
    };
    return ContextRegisterPlugin2;
  }(AbstractRendererPlugin)
);
var Renderer = (
  /** @class */
  function(_super) {
    __extends(Renderer2, _super);
    function Renderer2(config) {
      var _this2 = _super.call(this, config) || this;
      _this2.registerPlugin(new ContextRegisterPlugin());
      _this2.registerPlugin(new Plugin6());
      _this2.registerPlugin(new Plugin());
      _this2.registerPlugin(new Plugin3());
      _this2.registerPlugin(new Plugin4());
      _this2.registerPlugin(new Plugin2());
      _this2.registerPlugin(new Plugin5());
      return _this2;
    }
    return Renderer2;
  }(AbstractRenderer)
);

// node_modules/@antv/g-plugin-dragndrop/dist/index.esm.js
var DragndropPlugin = (
  /** @class */
  function() {
    function DragndropPlugin2(dragndropPluginOptions) {
      this.dragndropPluginOptions = dragndropPluginOptions;
    }
    DragndropPlugin2.prototype.apply = function(context) {
      var _this2 = this;
      var renderingService = context.renderingService, renderingContext = context.renderingContext;
      var document2 = renderingContext.root.ownerDocument;
      var canvas = document2.defaultView;
      var handlePointerdown = function(event) {
        var target = event.target;
        var isDocument = target === document2;
        var draggableEventTarget = isDocument && _this2.dragndropPluginOptions.isDocumentDraggable ? document2 : target.closest && target.closest("[draggable=true]");
        if (draggableEventTarget) {
          var dragstartTriggered_1 = false;
          var dragstartTimeStamp_1 = event.timeStamp;
          var dragstartClientCoordinates_1 = [
            event.clientX,
            event.clientY
          ];
          var currentDroppable_1 = null;
          var lastDragClientCoordinates_1 = [event.clientX, event.clientY];
          var handlePointermove_1 = function(event2) {
            return __awaiter(_this2, void 0, void 0, function() {
              var timeElapsed, distanceMoved, point7, elementsBelow, elementBelow, droppableBelow;
              return __generator(this, function(_a2) {
                switch (_a2.label) {
                  case 0:
                    if (!dragstartTriggered_1) {
                      timeElapsed = event2.timeStamp - dragstartTimeStamp_1;
                      distanceMoved = distanceSquareRoot([event2.clientX, event2.clientY], dragstartClientCoordinates_1);
                      if (timeElapsed <= this.dragndropPluginOptions.dragstartTimeThreshold || distanceMoved <= this.dragndropPluginOptions.dragstartDistanceThreshold) {
                        return [
                          2
                          /*return*/
                        ];
                      }
                      event2.type = "dragstart";
                      draggableEventTarget.dispatchEvent(event2);
                      dragstartTriggered_1 = true;
                    }
                    event2.type = "drag";
                    event2.dx = event2.clientX - lastDragClientCoordinates_1[0];
                    event2.dy = event2.clientY - lastDragClientCoordinates_1[1];
                    draggableEventTarget.dispatchEvent(event2);
                    lastDragClientCoordinates_1 = [event2.clientX, event2.clientY];
                    if (!!isDocument)
                      return [3, 2];
                    point7 = this.dragndropPluginOptions.overlap === "pointer" ? [event2.canvasX, event2.canvasY] : target.getBounds().center;
                    return [4, document2.elementsFromPoint(point7[0], point7[1])];
                  case 1:
                    elementsBelow = _a2.sent();
                    elementBelow = elementsBelow[elementsBelow.indexOf(target) + 1];
                    droppableBelow = (elementBelow === null || elementBelow === void 0 ? void 0 : elementBelow.closest("[droppable=true]")) || (this.dragndropPluginOptions.isDocumentDroppable ? document2 : null);
                    if (currentDroppable_1 !== droppableBelow) {
                      if (currentDroppable_1) {
                        event2.type = "dragleave";
                        event2.target = currentDroppable_1;
                        currentDroppable_1.dispatchEvent(event2);
                      }
                      if (droppableBelow) {
                        event2.type = "dragenter";
                        event2.target = droppableBelow;
                        droppableBelow.dispatchEvent(event2);
                      }
                      currentDroppable_1 = droppableBelow;
                      if (currentDroppable_1) {
                        event2.type = "dragover";
                        event2.target = currentDroppable_1;
                        currentDroppable_1.dispatchEvent(event2);
                      }
                    }
                    _a2.label = 2;
                  case 2:
                    return [
                      2
                      /*return*/
                    ];
                }
              });
            });
          };
          canvas.addEventListener("pointermove", handlePointermove_1);
          var stopDragging = function(originalPointerUpEvent) {
            if (dragstartTriggered_1) {
              originalPointerUpEvent.detail = {
                preventClick: true
              };
              var event_1 = originalPointerUpEvent.clone();
              if (currentDroppable_1) {
                event_1.type = "drop";
                event_1.target = currentDroppable_1;
                currentDroppable_1.dispatchEvent(event_1);
              }
              event_1.type = "dragend";
              draggableEventTarget.dispatchEvent(event_1);
              dragstartTriggered_1 = false;
            }
            canvas.removeEventListener("pointermove", handlePointermove_1);
          };
          target.addEventListener("pointerup", stopDragging, { once: true });
          target.addEventListener("pointerupoutside", stopDragging, {
            once: true
          });
        }
      };
      renderingService.hooks.init.tap(DragndropPlugin2.tag, function() {
        canvas.addEventListener("pointerdown", handlePointerdown);
      });
      renderingService.hooks.destroy.tap(DragndropPlugin2.tag, function() {
        canvas.removeEventListener("pointerdown", handlePointerdown);
      });
    };
    DragndropPlugin2.tag = "Dragndrop";
    return DragndropPlugin2;
  }()
);
var Plugin7 = (
  /** @class */
  function(_super) {
    __extends(Plugin8, _super);
    function Plugin8(options) {
      if (options === void 0) {
        options = {};
      }
      var _this2 = _super.call(this) || this;
      _this2.options = options;
      _this2.name = "dragndrop";
      return _this2;
    }
    Plugin8.prototype.init = function() {
      this.addRenderingPlugin(new DragndropPlugin(__assign({ overlap: "pointer", isDocumentDraggable: false, isDocumentDroppable: false, dragstartDistanceThreshold: 0, dragstartTimeThreshold: 0 }, this.options)));
    };
    Plugin8.prototype.destroy = function() {
      this.removeAllRenderingPlugins();
    };
    Plugin8.prototype.setOptions = function(options) {
      Object.assign(this.plugins[0].dragndropPluginOptions, options);
    };
    return Plugin8;
  }(AbstractRendererPlugin)
);

// node_modules/@antv/event-emitter/esm/index.js
var WILDCARD = "*";
var EventEmitter2 = (
  /** @class */
  function() {
    function EventEmitter3() {
      this._events = {};
    }
    EventEmitter3.prototype.on = function(evt, callback, once2) {
      if (!this._events[evt]) {
        this._events[evt] = [];
      }
      this._events[evt].push({
        callback,
        once: !!once2
      });
      return this;
    };
    EventEmitter3.prototype.once = function(evt, callback) {
      return this.on(evt, callback, true);
    };
    EventEmitter3.prototype.emit = function(evt) {
      var _this2 = this;
      var args = [];
      for (var _i = 1; _i < arguments.length; _i++) {
        args[_i - 1] = arguments[_i];
      }
      var events = this._events[evt] || [];
      var wildcardEvents = this._events[WILDCARD] || [];
      var doEmit = function(es) {
        var length5 = es.length;
        for (var i = 0; i < length5; i++) {
          if (!es[i]) {
            continue;
          }
          var _a2 = es[i], callback = _a2.callback, once2 = _a2.once;
          if (once2) {
            es.splice(i, 1);
            if (es.length === 0) {
              delete _this2._events[evt];
            }
            length5--;
            i--;
          }
          callback.apply(_this2, args);
        }
      };
      doEmit(events);
      doEmit(wildcardEvents);
    };
    EventEmitter3.prototype.off = function(evt, callback) {
      if (!evt) {
        this._events = {};
      } else {
        if (!callback) {
          delete this._events[evt];
        } else {
          var events = this._events[evt] || [];
          var length_1 = events.length;
          for (var i = 0; i < length_1; i++) {
            if (events[i].callback === callback) {
              events.splice(i, 1);
              length_1--;
              i--;
            }
          }
          if (events.length === 0) {
            delete this._events[evt];
          }
        }
      }
      return this;
    };
    EventEmitter3.prototype.getEvents = function() {
      return this._events;
    };
    return EventEmitter3;
  }()
);
var esm_default = EventEmitter2;

// node_modules/@antv/g2/esm/utils/event.js
var ChartEvent = {
  BEFORE_RENDER: "beforerender",
  AFTER_RENDER: "afterrender",
  BEFORE_PAINT: "beforepaint",
  AFTER_PAINT: "afterpaint",
  BEFORE_CHANGE_DATA: "beforechangedata",
  AFTER_CHANGE_DATA: "afterchangedata",
  BEFORE_CLEAR: "beforeclear",
  AFTER_CLEAR: "afterclear",
  BEFORE_DESTROY: "beforedestroy",
  AFTER_DESTROY: "afterdestroy",
  BEFORE_CHANGE_SIZE: "beforechangesize",
  AFTER_CHANGE_SIZE: "afterchangesize",
  POINTER_TAP: "pointertap",
  POINTER_DOWN: "pointerdown",
  POINTER_UP: "pointerup",
  POINTER_OVER: "pointerover",
  POINTER_OUT: "pointerout",
  POINTER_MOVE: "pointermove",
  POINTER_ENTER: "pointerenter",
  POINTER_LEAVE: "pointerleave",
  POINTER_UPOUTSIDE: "pointerupoutside",
  DRAG_START: "dragstart",
  DRAG: "drag",
  DRAG_END: "dragend",
  DRAG_ENTER: "dragenter",
  DRAG_LEAVE: "dragleave",
  DRAG_OVER: "dragover",
  DROP: "DROP",
  CLICK: "click",
  DBLCLICK: "dblclick"
};

// node_modules/@antv/g2/esm/component/constant.js
var LEGEND_INFER_STRATEGIES = [
  [
    "legendCategory",
    [
      [
        ["color", "discrete"],
        ["opacity", "discrete"],
        ["shape", "discrete"],
        ["size", "constant"]
      ],
      [
        ["color", "discrete"],
        ["opacity", "constant"],
        ["shape", "discrete"],
        ["size", "constant"]
      ],
      [
        ["color", "discrete"],
        ["opacity", "discrete"],
        ["shape", "constant"],
        ["size", "constant"]
      ],
      [
        ["color", "discrete"],
        ["opacity", "constant"],
        ["shape", "constant"],
        ["size", "constant"]
      ],
      [
        ["color", "constant"],
        ["opacity", "discrete"],
        ["shape", "discrete"],
        ["size", "constant"]
      ],
      [
        ["color", "constant"],
        ["opacity", "constant"],
        ["shape", "discrete"],
        ["size", "constant"]
      ],
      [
        ["color", "constant"],
        ["opacity", "discrete"],
        ["shape", "constant"],
        ["size", "constant"]
      ],
      [
        ["color", "discrete"],
        ["shape", "discrete"],
        ["size", "constant"]
      ],
      [
        ["color", "discrete"],
        ["opacity", "discrete"],
        ["shape", "discrete"]
      ],
      [
        ["color", "discrete"],
        ["opacity", "discrete"],
        ["size", "constant"]
      ],
      [
        ["color", "discrete"],
        ["opacity", "constant"],
        ["shape", "discrete"]
      ],
      [
        ["color", "discrete"],
        ["opacity", "constant"],
        ["size", "constant"]
      ],
      [
        ["color", "discrete"],
        ["shape", "constant"],
        ["size", "constant"]
      ],
      [
        ["color", "discrete"],
        ["opacity", "discrete"],
        ["shape", "constant"]
      ],
      [
        ["color", "discrete"],
        ["opacity", "constant"],
        ["shape", "constant"]
      ],
      [
        ["color", "constant"],
        ["shape", "discrete"],
        ["size", "constant"]
      ],
      [
        ["color", "constant"],
        ["opacity", "discrete"],
        ["shape", "discrete"]
      ],
      [
        ["color", "constant"],
        ["opacity", "discrete"],
        ["size", "constant"]
      ],
      [
        ["color", "constant"],
        ["opacity", "constant"],
        ["shape", "discrete"]
      ],
      // [
      //   ['color', 'constant'],
      //   ['opacity', 'constant'],
      //   ['size', 'constant'],
      // ],
      // [
      //   ['color', 'constant'],
      //   ['shape', 'constant'],
      //   ['size', 'constant'],
      // ],
      [
        ["color", "constant"],
        ["opacity", "discrete"],
        ["shape", "constant"]
      ],
      [
        ["color", "discrete"],
        ["shape", "discrete"]
      ],
      [
        ["color", "discrete"],
        ["size", "constant"]
      ],
      [
        ["color", "discrete"],
        ["opacity", "discrete"]
      ],
      [
        ["color", "discrete"],
        ["opacity", "constant"]
      ],
      [
        ["color", "discrete"],
        ["shape", "constant"]
      ],
      [
        ["color", "constant"],
        ["shape", "discrete"]
      ],
      [
        ["color", "constant"],
        ["size", "constant"]
      ],
      [
        ["color", "constant"],
        ["opacity", "discrete"]
      ],
      // [
      //   ['color', 'constant'],
      //   ['opacity', 'constant'],
      // ],
      // [
      //   ['color', 'constant'],
      //   ['shape', 'constant'],
      // ],
      [["color", "discrete"]]
      // [['color', 'constant']],
    ]
  ],
  [
    "legendContinuousSize",
    [
      [
        ["color", "continuous"],
        ["opacity", "continuous"],
        ["size", "continuous"]
      ],
      [
        ["color", "constant"],
        ["opacity", "continuous"],
        ["size", "continuous"]
      ],
      [
        ["color", "continuous"],
        ["size", "continuous"]
      ],
      [
        ["color", "constant"],
        ["size", "continuous"]
      ],
      [
        ["size", "continuous"],
        ["opacity", "continuous"]
      ],
      [["size", "continuous"]]
    ]
  ],
  [
    "legendContinuousBlockSize",
    [
      [
        ["color", "distribution"],
        ["opacity", "distribution"],
        ["size", "distribution"]
      ],
      [
        ["color", "distribution"],
        ["size", "distribution"]
      ]
    ]
  ],
  [
    "legendContinuousBlock",
    [
      [
        ["color", "distribution"],
        ["opacity", "continuous"]
      ],
      [["color", "distribution"]]
    ]
  ],
  [
    "legendContinuous",
    [
      [
        ["color", "continuous"],
        ["opacity", "continuous"]
      ],
      [["color", "continuous"]],
      [["opacity", "continuous"]]
    ]
  ]
];

// node_modules/@antv/coord/node_modules/@antv/util/esm/is-type.js
var toString5 = {}.toString;
var isType3 = function(value2, type) {
  return toString5.call(value2) === "[object " + type + "]";
};
var is_type_default3 = isType3;

// node_modules/@antv/coord/node_modules/@antv/util/esm/is-function.js
var is_function_default3 = function(value2) {
  return is_type_default3(value2, "Function");
};

// node_modules/@antv/coord/node_modules/@antv/util/esm/is-array.js
var is_array_default3 = function(value2) {
  return Array.isArray ? Array.isArray(value2) : is_type_default3(value2, "Array");
};

// node_modules/@antv/coord/node_modules/@antv/util/esm/is-object.js
var is_object_default3 = function(value2) {
  var type = typeof value2;
  return value2 !== null && type === "object" || type === "function";
};

// node_modules/@antv/coord/node_modules/@antv/util/esm/each.js
function each3(elements, func) {
  if (!elements) {
    return;
  }
  var rst;
  if (is_array_default3(elements)) {
    for (var i = 0, len5 = elements.length; i < len5; i++) {
      rst = func(elements[i], i);
      if (rst === false) {
        break;
      }
    }
  } else if (is_object_default3(elements)) {
    for (var k2 in elements) {
      if (elements.hasOwnProperty(k2)) {
        rst = func(elements[k2], k2);
        if (rst === false) {
          break;
        }
      }
    }
  }
}
var each_default4 = each3;

// node_modules/@antv/coord/node_modules/@antv/util/esm/is-object-like.js
var isObjectLike3 = function(value2) {
  return typeof value2 === "object" && value2 !== null;
};
var is_object_like_default3 = isObjectLike3;

// node_modules/@antv/coord/node_modules/@antv/util/esm/is-plain-object.js
var isPlainObject3 = function(value2) {
  if (!is_object_like_default3(value2) || !is_type_default3(value2, "Object")) {
    return false;
  }
  if (Object.getPrototypeOf(value2) === null) {
    return true;
  }
  var proto = value2;
  while (Object.getPrototypeOf(proto) !== null) {
    proto = Object.getPrototypeOf(proto);
  }
  return Object.getPrototypeOf(value2) === proto;
};
var is_plain_object_default3 = isPlainObject3;

// node_modules/@antv/coord/node_modules/@antv/util/esm/pull.js
var arrPrototype3 = Array.prototype;
var splice6 = arrPrototype3.splice;
var indexOf5 = arrPrototype3.indexOf;

// node_modules/@antv/coord/node_modules/@antv/util/esm/pull-at.js
var splice7 = Array.prototype.splice;

// node_modules/@antv/coord/node_modules/@antv/util/esm/is-string.js
var is_string_default3 = function(str7) {
  return is_type_default3(str7, "String");
};

// node_modules/@antv/coord/node_modules/@antv/util/esm/is-number.js
var isNumber3 = function(value2) {
  return is_type_default3(value2, "Number");
};
var is_number_default3 = isNumber3;

// node_modules/@antv/coord/node_modules/@antv/util/esm/is-integer.js
var isInteger3 = Number.isInteger ? Number.isInteger : function(num) {
  return is_number_default3(num) && num % 1 === 0;
};

// node_modules/@antv/coord/node_modules/@antv/util/esm/to-degree.js
var DEGREE3 = 180 / Math.PI;

// node_modules/@antv/coord/node_modules/@antv/util/esm/to-radian.js
var RADIAN3 = Math.PI / 180;

// node_modules/@antv/coord/node_modules/@antv/util/esm/values.js
var values2 = Object.values ? function(obj) {
  return Object.values(obj);
} : function(obj) {
  var result2 = [];
  each_default4(obj, function(value2, key) {
    if (!(is_function_default3(obj) && key === "prototype")) {
      result2.push(value2);
    }
  });
  return result2;
};
var values_default3 = values2;

// node_modules/@antv/coord/node_modules/@antv/util/esm/get-type.js
var toString6 = {}.toString;

// node_modules/@antv/coord/node_modules/@antv/util/esm/is-prototype.js
var objectProto3 = Object.prototype;

// node_modules/@antv/coord/node_modules/@antv/util/esm/memoize.js
var memoize_default3 = function(f, resolver) {
  if (!is_function_default3(f)) {
    throw new TypeError("Expected a function");
  }
  var memoized = function() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    var key = resolver ? resolver.apply(this, args) : args[0];
    var cache2 = memoized.cache;
    if (cache2.has(key)) {
      return cache2.get(key);
    }
    var result2 = f.apply(this, args);
    cache2.set(key, result2);
    return result2;
  };
  memoized.cache = /* @__PURE__ */ new Map();
  return memoized;
};

// node_modules/@antv/coord/node_modules/@antv/util/esm/deep-mix.js
var MAX_MIX_LEVEL4 = 5;
function _deepMix3(dist5, src, level, maxLevel) {
  level = level || 0;
  maxLevel = maxLevel || MAX_MIX_LEVEL4;
  for (var key in src) {
    if (src.hasOwnProperty(key)) {
      var value2 = src[key];
      if (value2 !== null && is_plain_object_default3(value2)) {
        if (!is_plain_object_default3(dist5[key])) {
          dist5[key] = {};
        }
        if (level < maxLevel) {
          _deepMix3(dist5[key], value2, level + 1, maxLevel);
        } else {
          dist5[key] = src[key];
        }
      } else if (is_array_default3(value2)) {
        dist5[key] = [];
        dist5[key] = dist5[key].concat(value2);
      } else if (value2 !== void 0) {
        dist5[key] = value2;
      }
    }
  }
}
var deepMix3 = function(rst) {
  var args = [];
  for (var _i = 1; _i < arguments.length; _i++) {
    args[_i - 1] = arguments[_i];
  }
  for (var i = 0; i < args.length; i += 1) {
    _deepMix3(rst, args[i]);
  }
  return rst;
};
var deep_mix_default3 = deepMix3;

// node_modules/@antv/coord/node_modules/@antv/util/esm/identity.js
var identity_default5 = function(v) {
  return v;
};

// node_modules/@antv/coord/node_modules/@antv/util/esm/measure-text-width.js
var ctx3;
var measure_text_width_default2 = memoize_default3(function(text, font) {
  if (font === void 0) {
    font = {};
  }
  var fontSize = font.fontSize, fontFamily = font.fontFamily, fontWeight = font.fontWeight, fontStyle = font.fontStyle, fontVariant = font.fontVariant;
  if (!ctx3) {
    ctx3 = document.createElement("canvas").getContext("2d");
  }
  ctx3.font = [fontStyle, fontVariant, fontWeight, fontSize + "px", fontFamily].join(" ");
  return ctx3.measureText(is_string_default3(text) ? text : "").width;
}, function(text, font) {
  if (font === void 0) {
    font = {};
  }
  return __spreadArrays([text], values_default3(font)).join("");
});

// node_modules/@antv/coord/node_modules/@antv/util/esm/cache.js
var default_13 = (
  /** @class */
  function() {
    function default_14() {
      this.map = {};
    }
    default_14.prototype.has = function(key) {
      return this.map[key] !== void 0;
    };
    default_14.prototype.get = function(key, def) {
      var v = this.map[key];
      return v === void 0 ? def : v;
    };
    default_14.prototype.set = function(key, value2) {
      this.map[key] = value2;
    };
    default_14.prototype.clear = function() {
      this.map = {};
    };
    default_14.prototype.delete = function(key) {
      delete this.map[key];
    };
    default_14.prototype.size = function() {
      return Object.keys(this.map).length;
    };
    return default_14;
  }()
);

// node_modules/@antv/coord/esm/utils/compose.js
function compose3(fn) {
  var rest2 = [];
  for (var _i = 1; _i < arguments.length; _i++) {
    rest2[_i - 1] = arguments[_i];
  }
  return fn ? rest2.reduce(function(total, current) {
    return function(x3) {
      return current(total(x3));
    };
  }, fn) : identity_default5;
}

// node_modules/@antv/coord/esm/utils/isMatrix.js
function isMatrix(transformer2) {
  return transformer2 instanceof Float32Array || transformer2 instanceof Array;
}

// node_modules/@antv/coord/esm/utils/extend.js
var __read2 = function(o, n) {
  var m3 = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m3)
    return o;
  var i = m3.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
      ar.push(r.value);
  } catch (error3) {
    e = { error: error3 };
  } finally {
    try {
      if (r && !r.done && (m3 = i["return"]))
        m3.call(i);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
};
var __spreadArray2 = function(to, from, pack3) {
  if (pack3 || arguments.length === 2)
    for (var i = 0, l = from.length, ar; i < l; i++) {
      if (ar || !(i in from)) {
        if (!ar)
          ar = Array.prototype.slice.call(from, 0, i);
        ar[i] = from[i];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from));
};
function extend3(transform3) {
  return function(vector) {
    var v = [];
    for (var i = 0; i < vector.length - 1; i += 2) {
      var from = [vector[i], vector[i + 1]];
      var to = transform3(from);
      v.push.apply(v, __spreadArray2([], __read2(to), false));
    }
    return v;
  };
}
function extend3D(transform3) {
  return function(vector) {
    var v = [];
    for (var i = 0; i < vector.length - 1; i += 3) {
      var from = [vector[i], vector[i + 1], vector[i + 2]];
      var to = transform3(from);
      v.push.apply(v, __spreadArray2([], __read2(to), false));
    }
    return v;
  };
}

// node_modules/@antv/coord/esm/utils/adjustAngle.js
function adjustAngle(theta, min11, max11) {
  while (theta < min11)
    theta += Math.PI * 2;
  while (theta > max11)
    theta -= Math.PI * 2;
  return theta;
}

// node_modules/@antv/coord/esm/transforms/translate.js
var __read3 = function(o, n) {
  var m3 = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m3)
    return o;
  var i = m3.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
      ar.push(r.value);
  } catch (error3) {
    e = { error: error3 };
  } finally {
    try {
      if (r && !r.done && (m3 = i["return"]))
        m3.call(i);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
};
var translate3 = function(params, x3, y3, width, height) {
  var _a2 = __read3(params, 2), tx = _a2[0], ty = _a2[1];
  var matrix2 = mat3_exports.create();
  return mat3_exports.fromTranslation(matrix2, [tx, ty]);
};

// node_modules/@antv/coord/esm/transforms/cartesian.js
var __read4 = function(o, n) {
  var m3 = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m3)
    return o;
  var i = m3.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
      ar.push(r.value);
  } catch (error3) {
    e = { error: error3 };
  } finally {
    try {
      if (r && !r.done && (m3 = i["return"]))
        m3.call(i);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
};
var cartesian = function(params, x3, y3, width, height) {
  var sx = new Linear({
    range: [x3, x3 + width]
  });
  var sy = new Linear({
    range: [y3, y3 + height]
  });
  return {
    transform: function(vector) {
      var _a2 = __read4(vector, 2), v1 = _a2[0], v2 = _a2[1];
      return [sx.map(v1), sy.map(v2)];
    },
    untransform: function(vector) {
      var _a2 = __read4(vector, 2), v1 = _a2[0], v2 = _a2[1];
      return [sx.invert(v1), sy.invert(v2)];
    }
  };
};

// node_modules/@antv/coord/esm/transforms/custom.js
var __read5 = function(o, n) {
  var m3 = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m3)
    return o;
  var i = m3.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
      ar.push(r.value);
  } catch (error3) {
    e = { error: error3 };
  } finally {
    try {
      if (r && !r.done && (m3 = i["return"]))
        m3.call(i);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
};
var custom10 = function(params, x3, y3, width, height) {
  var _a2 = __read5(params, 1), callback = _a2[0];
  return callback(x3, y3, width, height);
};

// node_modules/@antv/coord/esm/transforms/matrix.js
var __read6 = function(o, n) {
  var m3 = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m3)
    return o;
  var i = m3.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
      ar.push(r.value);
  } catch (error3) {
    e = { error: error3 };
  } finally {
    try {
      if (r && !r.done && (m3 = i["return"]))
        m3.call(i);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
};
var matrix = function(params, x3, y3, width, height) {
  var _a2 = __read6(params, 1), matrix2 = _a2[0];
  return matrix2;
};

// node_modules/@antv/coord/esm/transforms/polar.js
var __read7 = function(o, n) {
  var m3 = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m3)
    return o;
  var i = m3.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
      ar.push(r.value);
  } catch (error3) {
    e = { error: error3 };
  } finally {
    try {
      if (r && !r.done && (m3 = i["return"]))
        m3.call(i);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
};
var polar = function(params, x3, y3, width, height) {
  var _a2 = __read7(params, 4), startAngle = _a2[0], endAngle = _a2[1], innerRadius = _a2[2], outerRadius = _a2[3];
  var radius = new Linear({
    range: [innerRadius, outerRadius]
  });
  var angle4 = new Linear({
    range: [startAngle, endAngle]
  });
  var aspect = height / width;
  var sx = aspect > 1 ? 1 : aspect;
  var sy = aspect > 1 ? 1 / aspect : 1;
  return {
    transform: function(vector) {
      var _a3 = __read7(vector, 2), v1 = _a3[0], v2 = _a3[1];
      var theta = angle4.map(v1);
      var r = radius.map(v2);
      var x4 = r * Math.cos(theta) * sx;
      var y4 = r * Math.sin(theta) * sy;
      var dx = x4 * 0.5 + 0.5;
      var dy = y4 * 0.5 + 0.5;
      return [dx, dy];
    },
    untransform: function(vector) {
      var _a3 = __read7(vector, 2), dx = _a3[0], dy = _a3[1];
      var x4 = (dx - 0.5) * 2 / sx;
      var y4 = (dy - 0.5) * 2 / sy;
      var r = Math.sqrt(Math.pow(x4, 2) + Math.pow(y4, 2));
      var t = Math.atan2(y4, x4);
      var theta = adjustAngle(t, startAngle, endAngle);
      var v1 = angle4.invert(theta);
      var v2 = radius.invert(r);
      return [v1, v2];
    }
  };
};

// node_modules/@antv/coord/esm/transforms/transpose.js
var __read8 = function(o, n) {
  var m3 = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m3)
    return o;
  var i = m3.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
      ar.push(r.value);
  } catch (error3) {
    e = { error: error3 };
  } finally {
    try {
      if (r && !r.done && (m3 = i["return"]))
        m3.call(i);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
};
var transpose5 = function(params, x3, y3, width, height) {
  return {
    transform: function(_a2) {
      var _b = __read8(_a2, 2), x4 = _b[0], y4 = _b[1];
      return [y4, x4];
    },
    untransform: function(_a2) {
      var _b = __read8(_a2, 2), x4 = _b[0], y4 = _b[1];
      return [y4, x4];
    }
  };
};

// node_modules/@antv/coord/esm/transforms/scale.js
var __read9 = function(o, n) {
  var m3 = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m3)
    return o;
  var i = m3.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
      ar.push(r.value);
  } catch (error3) {
    e = { error: error3 };
  } finally {
    try {
      if (r && !r.done && (m3 = i["return"]))
        m3.call(i);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
};
var scale9 = function(params, x3, y3, width, height) {
  var _a2 = __read9(params, 2), sx = _a2[0], sy = _a2[1];
  var matrix2 = mat3_exports.create();
  return mat3_exports.fromScaling(matrix2, [sx, sy]);
};

// node_modules/@antv/coord/esm/transforms/reflect.js
var __read10 = function(o, n) {
  var m3 = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m3)
    return o;
  var i = m3.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
      ar.push(r.value);
  } catch (error3) {
    e = { error: error3 };
  } finally {
    try {
      if (r && !r.done && (m3 = i["return"]))
        m3.call(i);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
};
var __spreadArray3 = function(to, from, pack3) {
  if (pack3 || arguments.length === 2)
    for (var i = 0, l = from.length, ar; i < l; i++) {
      if (ar || !(i in from)) {
        if (!ar)
          ar = Array.prototype.slice.call(from, 0, i);
        ar[i] = from[i];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from));
};
var reflect2 = function(params) {
  var args = [];
  for (var _i = 1; _i < arguments.length; _i++) {
    args[_i - 1] = arguments[_i];
  }
  return scale9.apply(void 0, __spreadArray3([[-1, -1]], __read10(args), false));
};
var reflectX = function(params) {
  var args = [];
  for (var _i = 1; _i < arguments.length; _i++) {
    args[_i - 1] = arguments[_i];
  }
  return scale9.apply(void 0, __spreadArray3([[-1, 1]], __read10(args), false));
};
var reflectY = function(params) {
  var args = [];
  for (var _i = 1; _i < arguments.length; _i++) {
    args[_i - 1] = arguments[_i];
  }
  return scale9.apply(void 0, __spreadArray3([[1, -1]], __read10(args), false));
};

// node_modules/@antv/coord/esm/transforms/rotate.js
var __read11 = function(o, n) {
  var m3 = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m3)
    return o;
  var i = m3.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
      ar.push(r.value);
  } catch (error3) {
    e = { error: error3 };
  } finally {
    try {
      if (r && !r.done && (m3 = i["return"]))
        m3.call(i);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
};
var rotate5 = function(params, x3, y3, width, height) {
  var _a2 = __read11(params, 1), theta = _a2[0];
  var matrix2 = mat3_exports.create();
  return mat3_exports.fromRotation(matrix2, theta);
};

// node_modules/@antv/coord/esm/transforms/helix.js
var __read12 = function(o, n) {
  var m3 = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m3)
    return o;
  var i = m3.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
      ar.push(r.value);
  } catch (error3) {
    e = { error: error3 };
  } finally {
    try {
      if (r && !r.done && (m3 = i["return"]))
        m3.call(i);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
};
var helix = function(params, x3, y3, width, height) {
  var _a2 = __read12(params, 4), startAngle = _a2[0], endAngle = _a2[1], innerRadius = _a2[2], outerRadius = _a2[3];
  var count4 = (endAngle - 0) / (2 * Math.PI) + 1;
  var d2 = (outerRadius - innerRadius) / count4;
  var b = d2 / (Math.PI * 2);
  var step2 = new Linear({
    range: [innerRadius, innerRadius + d2 * 0.99]
    // 
  });
  var angle4 = new Linear({
    range: [startAngle, endAngle]
  });
  var aspect = height / width;
  var sx = aspect > 1 ? 1 : aspect;
  var sy = aspect > 1 ? 1 / aspect : 1;
  return {
    transform: function(vector) {
      var _a3 = __read12(vector, 2), v1 = _a3[0], v2 = _a3[1];
      var theta = angle4.map(v1);
      var a4 = step2.map(v2);
      var x4 = Math.cos(theta) * (b * theta + a4) * sx;
      var y4 = Math.sin(theta) * (b * theta + a4) * sy;
      var dx = x4 * 0.5 + 0.5;
      var dy = y4 * 0.5 + 0.5;
      return [dx, dy];
    },
    untransform: function(vector) {
      var _a3 = __read12(vector, 2), dx = _a3[0], dy = _a3[1];
      var x4 = (dx - 0.5) * 2 / sx;
      var y4 = (dy - 0.5) * 2 / sy;
      var r = Math.sqrt(Math.pow(x4, 2) + Math.pow(y4, 2));
      var t = Math.atan2(y4, x4) + Math.floor(r / d2) * Math.PI * 2;
      var theta = adjustAngle(t, startAngle, endAngle);
      var a4 = r - b * theta;
      var v1 = angle4.invert(theta);
      var v2 = step2.invert(a4);
      return [v1, v2];
    }
  };
};

// node_modules/@antv/coord/esm/transforms/parallel.js
var __read13 = function(o, n) {
  var m3 = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m3)
    return o;
  var i = m3.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
      ar.push(r.value);
  } catch (error3) {
    e = { error: error3 };
  } finally {
    try {
      if (r && !r.done && (m3 = i["return"]))
        m3.call(i);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
};
var parallel2 = function(params, x3, y3, width, height) {
  var _a2 = __read13(params, 4), x05 = _a2[0], x12 = _a2[1], y05 = _a2[2], y12 = _a2[3];
  var sy = new Linear({
    range: [y05, y12]
  });
  return {
    transform: function(vector) {
      var v = [];
      var len5 = vector.length;
      var sx = new Point({
        domain: new Array(len5).fill(0).map(function(_2, i2) {
          return i2;
        }),
        range: [x05, x12]
      });
      for (var i = 0; i < len5; i++) {
        var e = vector[i];
        var x_1 = sx.map(i);
        var y_1 = sy.map(e);
        v.push(x_1, y_1);
      }
      return v;
    },
    untransform: function(vector) {
      var v = [];
      for (var i = 0; i < vector.length; i += 2) {
        var y_2 = vector[i + 1];
        v.push(sy.invert(y_2));
      }
      return v;
    }
  };
};

// node_modules/@antv/coord/esm/transforms/shear.js
var __read14 = function(o, n) {
  var m3 = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m3)
    return o;
  var i = m3.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
      ar.push(r.value);
  } catch (error3) {
    e = { error: error3 };
  } finally {
    try {
      if (r && !r.done && (m3 = i["return"]))
        m3.call(i);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
};
function cot(theta) {
  return 1 / Math.tan(theta);
}
var shearX = function(params, x3, y3, width, height) {
  var _a2 = __read14(params, 1), theta = _a2[0];
  var sx = cot(theta);
  return {
    transform: function(vector) {
      var _a3 = __read14(vector, 2), x4 = _a3[0], y4 = _a3[1];
      var xx = x4 + y4 * sx;
      return [xx, y4];
    },
    untransform: function(vector) {
      var _a3 = __read14(vector, 2), xx = _a3[0], y4 = _a3[1];
      var x4 = xx - y4 * sx;
      return [x4, y4];
    }
  };
};
var shearY = function(params, x3, y3, width, height) {
  var _a2 = __read14(params, 1), theta = _a2[0];
  var sy = cot(theta);
  return {
    transform: function(vector) {
      var _a3 = __read14(vector, 2), x4 = _a3[0], y4 = _a3[1];
      var yy = y4 + x4 * sy;
      return [x4, yy];
    },
    untransform: function(vector) {
      var _a3 = __read14(vector, 2), x4 = _a3[0], yy = _a3[1];
      var y4 = yy - x4 * sy;
      return [x4, y4];
    }
  };
};

// node_modules/@antv/coord/esm/transforms/fisheye.js
var __read15 = function(o, n) {
  var m3 = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m3)
    return o;
  var i = m3.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
      ar.push(r.value);
  } catch (error3) {
    e = { error: error3 };
  } finally {
    try {
      if (r && !r.done && (m3 = i["return"]))
        m3.call(i);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
};
function fisheyeTransform(x3, focus, distortion, min11, max11) {
  var left2 = x3 < focus;
  var m3 = (left2 ? focus - min11 : max11 - focus) || max11 - min11;
  var f = left2 ? -1 : 1;
  return f * m3 * (distortion + 1) / (distortion + m3 / ((x3 - focus) * f)) + focus;
}
function fisheyeUntransform(tx, focus, distortion, min11, max11) {
  var left2 = tx < focus;
  var m3 = (left2 ? focus - min11 : max11 - focus) || max11 - min11;
  var f = left2 ? -1 : 1;
  return m3 / (m3 * (distortion + 1) / (tx - focus) - distortion * f) + focus;
}
function normalize9(focus, length5, isVisual) {
  if (!isVisual)
    return focus;
  var s2 = new Linear({
    range: [0, 1],
    domain: [0, length5]
  });
  return s2.map(focus);
}
var fisheyeX = function(params, x3, y3, width, height) {
  var _a2 = __read15(params, 3), focus = _a2[0], distortion = _a2[1], _b = _a2[2], isVisual = _b === void 0 ? false : _b;
  var normalizedFocusX = normalize9(focus, width, isVisual);
  return {
    transform: function(vector) {
      var _a3 = __read15(vector, 2), vx = _a3[0], vy = _a3[1];
      var fx = fisheyeTransform(vx, normalizedFocusX, distortion, 0, 1);
      return [fx, vy];
    },
    untransform: function(vector) {
      var _a3 = __read15(vector, 2), fx = _a3[0], vy = _a3[1];
      var vx = fisheyeUntransform(fx, normalizedFocusX, distortion, 0, 1);
      return [vx, vy];
    }
  };
};
var fisheyeY = function(params, x3, y3, width, height) {
  var _a2 = __read15(params, 3), focus = _a2[0], distortion = _a2[1], _b = _a2[2], isVisual = _b === void 0 ? false : _b;
  var normalizedFocusY = normalize9(focus, height, isVisual);
  return {
    transform: function(vector) {
      var _a3 = __read15(vector, 2), vx = _a3[0], vy = _a3[1];
      var fy = fisheyeTransform(vy, normalizedFocusY, distortion, 0, 1);
      return [vx, fy];
    },
    untransform: function(vector) {
      var _a3 = __read15(vector, 2), vx = _a3[0], fy = _a3[1];
      var vy = fisheyeUntransform(fy, normalizedFocusY, distortion, 0, 1);
      return [vx, vy];
    }
  };
};
var fisheye = function(params, x3, y3, width, height) {
  var _a2 = __read15(params, 5), focusX = _a2[0], focusY = _a2[1], distortionX = _a2[2], distortionY = _a2[3], _b = _a2[4], isVisual = _b === void 0 ? false : _b;
  var normalizedFocusX = normalize9(focusX, width, isVisual);
  var normalizedFocusY = normalize9(focusY, height, isVisual);
  return {
    transform: function(vector) {
      var _a3 = __read15(vector, 2), vx = _a3[0], vy = _a3[1];
      var fx = fisheyeTransform(vx, normalizedFocusX, distortionX, 0, 1);
      var fy = fisheyeTransform(vy, normalizedFocusY, distortionY, 0, 1);
      return [fx, fy];
    },
    untransform: function(vector) {
      var _a3 = __read15(vector, 2), fx = _a3[0], fy = _a3[1];
      var vx = fisheyeUntransform(fx, normalizedFocusX, distortionX, 0, 1);
      var vy = fisheyeUntransform(fy, normalizedFocusY, distortionY, 0, 1);
      return [vx, vy];
    }
  };
};
var fisheyeCircular = function(params, x3, y3, width, height) {
  var _a2 = __read15(params, 5), focusX = _a2[0], focusY = _a2[1], radius = _a2[2], distortion = _a2[3], _b = _a2[4], isVisual = _b === void 0 ? false : _b;
  var scaleX = new Linear({
    range: [0, width]
  });
  var scaleY = new Linear({
    range: [0, height]
  });
  var nx = isVisual ? focusX : scaleX.map(focusX);
  var ny = isVisual ? focusY : scaleY.map(focusY);
  return {
    transform: function(vector) {
      var _a3 = __read15(vector, 2), x4 = _a3[0], y4 = _a3[1];
      var dx = scaleX.map(x4) - nx;
      var dy = scaleY.map(y4) - ny;
      var dd = Math.sqrt(dx * dx + dy * dy);
      if (dd > radius)
        return [x4, y4];
      var r = fisheyeTransform(dd, 0, distortion, 0, radius);
      var theta = Math.atan2(dy, dx);
      var fx = nx + r * Math.cos(theta);
      var fy = ny + r * Math.sin(theta);
      return [scaleX.invert(fx), scaleY.invert(fy)];
    },
    untransform: function(vector) {
      var _a3 = __read15(vector, 2), tx = _a3[0], ty = _a3[1];
      var dx = scaleX.map(tx) - nx;
      var dy = scaleY.map(ty) - ny;
      var dd = Math.sqrt(dx * dx + dy * dy);
      if (dd > radius)
        return [tx, ty];
      var x4 = fisheyeUntransform(dd, 0, distortion, 0, radius);
      var theta = Math.atan2(dy, dx);
      var fx = nx + x4 * Math.cos(theta);
      var fy = ny + x4 * Math.sin(theta);
      return [scaleX.invert(fx), scaleY.invert(fy)];
    }
  };
};

// node_modules/@antv/coord/esm/transforms/cartesian3D.js
var __read16 = function(o, n) {
  var m3 = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m3)
    return o;
  var i = m3.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
      ar.push(r.value);
  } catch (error3) {
    e = { error: error3 };
  } finally {
    try {
      if (r && !r.done && (m3 = i["return"]))
        m3.call(i);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
};
var cartesian3D = function(params, x3, y3, z, width, height, depth) {
  var sx = new Linear({
    range: [x3, x3 + width]
  });
  var sy = new Linear({
    range: [y3, y3 + height]
  });
  var sz = new Linear({
    range: [z, z + depth]
  });
  return {
    transform: function(vector) {
      var _a2 = __read16(vector, 3), v1 = _a2[0], v2 = _a2[1], v3 = _a2[2];
      return [sx.map(v1), sy.map(v2), sz.map(v3)];
    },
    untransform: function(vector) {
      var _a2 = __read16(vector, 3), v1 = _a2[0], v2 = _a2[1], v3 = _a2[2];
      return [sx.invert(v1), sy.invert(v2), sz.invert(v3)];
    }
  };
};

// node_modules/@antv/coord/esm/transforms/translate3D.js
var __read17 = function(o, n) {
  var m3 = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m3)
    return o;
  var i = m3.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
      ar.push(r.value);
  } catch (error3) {
    e = { error: error3 };
  } finally {
    try {
      if (r && !r.done && (m3 = i["return"]))
        m3.call(i);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
};
var translate3D = function(params, x3, y3, z, width, height, depth) {
  var _a2 = __read17(params, 3), tx = _a2[0], ty = _a2[1], tz = _a2[2];
  return mat4_exports.fromTranslation(mat4_exports.create(), [tx, ty, tz]);
};

// node_modules/@antv/coord/esm/transforms/transpose3D.js
var __read18 = function(o, n) {
  var m3 = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m3)
    return o;
  var i = m3.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
      ar.push(r.value);
  } catch (error3) {
    e = { error: error3 };
  } finally {
    try {
      if (r && !r.done && (m3 = i["return"]))
        m3.call(i);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
};
var transpose3D = function(params, x3, y3, z, width, height, depth) {
  return {
    transform: function(_a2) {
      var _b = __read18(_a2, 3), x4 = _b[0], y4 = _b[1], z2 = _b[2];
      return [y4, x4, z2];
    },
    untransform: function(_a2) {
      var _b = __read18(_a2, 3), x4 = _b[0], y4 = _b[1], z2 = _b[2];
      return [y4, x4, z2];
    }
  };
};

// node_modules/@antv/coord/esm/transforms/scale3D.js
var __read19 = function(o, n) {
  var m3 = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m3)
    return o;
  var i = m3.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
      ar.push(r.value);
  } catch (error3) {
    e = { error: error3 };
  } finally {
    try {
      if (r && !r.done && (m3 = i["return"]))
        m3.call(i);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
};
var scale3D = function(params, x3, y3, z, width, height, depth) {
  var _a2 = __read19(params, 3), sx = _a2[0], sy = _a2[1], sz = _a2[2];
  return mat4_exports.fromScaling(mat4_exports.create(), [sx, sy, sz]);
};

// node_modules/@antv/coord/esm/coordinate.js
var __read20 = function(o, n) {
  var m3 = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m3)
    return o;
  var i = m3.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
      ar.push(r.value);
  } catch (error3) {
    e = { error: error3 };
  } finally {
    try {
      if (r && !r.done && (m3 = i["return"]))
        m3.call(i);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
};
var __spreadArray4 = function(to, from, pack3) {
  if (pack3 || arguments.length === 2)
    for (var i = 0, l = from.length, ar; i < l; i++) {
      if (ar || !(i in from)) {
        if (!ar)
          ar = Array.prototype.slice.call(from, 0, i);
        ar[i] = from[i];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from));
};
var __values2 = function(o) {
  var s2 = typeof Symbol === "function" && Symbol.iterator, m3 = s2 && o[s2], i = 0;
  if (m3)
    return m3.call(o);
  if (o && typeof o.length === "number")
    return {
      next: function() {
        if (o && i >= o.length)
          o = void 0;
        return { value: o && o[i++], done: !o };
      }
    };
  throw new TypeError(s2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var Coordinate = (
  /** @class */
  function() {
    function Coordinate2(options) {
      this.options = {
        x: 0,
        y: 0,
        width: 300,
        height: 150,
        transformations: []
      };
      this.transformers = {
        cartesian,
        translate: translate3,
        custom: custom10,
        matrix,
        polar,
        transpose: transpose5,
        scale: scale9,
        "shear.x": shearX,
        "shear.y": shearY,
        reflect: reflect2,
        "reflect.x": reflectX,
        "reflect.y": reflectY,
        rotate: rotate5,
        helix,
        parallel: parallel2,
        fisheye,
        "fisheye.x": fisheyeX,
        "fisheye.y": fisheyeY,
        "fisheye.circular": fisheyeCircular
      };
      this.update(options);
    }
    Coordinate2.prototype.update = function(options) {
      this.options = deep_mix_default3({}, this.options, options);
      this.recoordinate();
    };
    Coordinate2.prototype.clone = function() {
      return new Coordinate2(this.options);
    };
    Coordinate2.prototype.getOptions = function() {
      return this.options;
    };
    Coordinate2.prototype.clear = function() {
      this.update({
        transformations: []
      });
    };
    Coordinate2.prototype.getSize = function() {
      var _a2 = this.options, width = _a2.width, height = _a2.height;
      return [width, height];
    };
    Coordinate2.prototype.getCenter = function() {
      var _a2 = this.options, x3 = _a2.x, y3 = _a2.y, width = _a2.width, height = _a2.height;
      return [(x3 * 2 + width) / 2, (y3 * 2 + height) / 2];
    };
    Coordinate2.prototype.transform = function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      var transformations = this.options.transformations;
      this.update({
        transformations: __spreadArray4(__spreadArray4([], __read20(transformations), false), [__spreadArray4([], __read20(args), false)], false)
      });
      return this;
    };
    Coordinate2.prototype.map = function(vector) {
      return this.output(vector);
    };
    Coordinate2.prototype.invert = function(vector) {
      return this.input(vector);
    };
    Coordinate2.prototype.recoordinate = function() {
      this.output = this.compose();
      this.input = this.compose(true);
    };
    Coordinate2.prototype.compose = function(invert6) {
      var e_1, _a2;
      if (invert6 === void 0) {
        invert6 = false;
      }
      var transformations = invert6 ? __spreadArray4([], __read20(this.options.transformations), false).reverse() : this.options.transformations;
      var getter = invert6 ? function(d2) {
        return d2.untransform;
      } : function(d2) {
        return d2.transform;
      };
      var matrixes = [];
      var transforms = [];
      var add11 = function(transform4, extended) {
        if (extended === void 0) {
          extended = true;
        }
        return transforms.push(extended ? extend3(transform4) : transform4);
      };
      try {
        for (var transformations_1 = __values2(transformations), transformations_1_1 = transformations_1.next(); !transformations_1_1.done; transformations_1_1 = transformations_1.next()) {
          var _b = __read20(transformations_1_1.value), name_1 = _b[0], args = _b.slice(1);
          var createTransformer = this.transformers[name_1];
          if (createTransformer) {
            var _c = this.options, x3 = _c.x, y3 = _c.y, width = _c.width, height = _c.height;
            var transformer2 = createTransformer(__spreadArray4([], __read20(args), false), x3, y3, width, height);
            if (isMatrix(transformer2)) {
              matrixes.push(transformer2);
            } else {
              if (matrixes.length) {
                var transform_1 = this.createMatrixTransform(matrixes, invert6);
                add11(transform_1);
                matrixes.splice(0, matrixes.length);
              }
              var transform3 = getter(transformer2) || identity_default5;
              add11(transform3, name_1 !== "parallel");
            }
          }
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (transformations_1_1 && !transformations_1_1.done && (_a2 = transformations_1.return))
            _a2.call(transformations_1);
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
      if (matrixes.length) {
        var transform3 = this.createMatrixTransform(matrixes, invert6);
        add11(transform3);
      }
      return compose3.apply(void 0, __spreadArray4([], __read20(transforms), false));
    };
    Coordinate2.prototype.createMatrixTransform = function(matrixes, invert6) {
      var matrix2 = mat3_exports.create();
      if (invert6)
        matrixes.reverse();
      matrixes.forEach(function(m3) {
        return mat3_exports.mul(matrix2, matrix2, m3);
      });
      if (invert6) {
        mat3_exports.invert(matrix2, mat3_exports.clone(matrix2));
      }
      return function(vector) {
        var vector3 = [vector[0], vector[1], 1];
        vec3_exports.transformMat3(vector3, vector3, matrix2);
        return [vector3[0], vector3[1]];
      };
    };
    return Coordinate2;
  }()
);

// node_modules/@antv/coord/esm/coordinate3D.js
var __read21 = function(o, n) {
  var m3 = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m3)
    return o;
  var i = m3.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
      ar.push(r.value);
  } catch (error3) {
    e = { error: error3 };
  } finally {
    try {
      if (r && !r.done && (m3 = i["return"]))
        m3.call(i);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
};
var __spreadArray5 = function(to, from, pack3) {
  if (pack3 || arguments.length === 2)
    for (var i = 0, l = from.length, ar; i < l; i++) {
      if (ar || !(i in from)) {
        if (!ar)
          ar = Array.prototype.slice.call(from, 0, i);
        ar[i] = from[i];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from));
};
var __values3 = function(o) {
  var s2 = typeof Symbol === "function" && Symbol.iterator, m3 = s2 && o[s2], i = 0;
  if (m3)
    return m3.call(o);
  if (o && typeof o.length === "number")
    return {
      next: function() {
        if (o && i >= o.length)
          o = void 0;
        return { value: o && o[i++], done: !o };
      }
    };
  throw new TypeError(s2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var Coordinate3D = (
  /** @class */
  function() {
    function Coordinate3D2(options) {
      this.options = {
        x: 0,
        y: 0,
        z: 0,
        width: 300,
        height: 150,
        depth: 150,
        transformations: []
      };
      this.transformers = {
        cartesian3D,
        translate3D,
        scale3D,
        transpose3D
      };
      this.update(options);
    }
    Coordinate3D2.prototype.update = function(options) {
      this.options = deep_mix_default3({}, this.options, options);
      this.recoordinate();
    };
    Coordinate3D2.prototype.clone = function() {
      return new Coordinate3D2(this.options);
    };
    Coordinate3D2.prototype.getOptions = function() {
      return this.options;
    };
    Coordinate3D2.prototype.clear = function() {
      this.update({
        transformations: []
      });
    };
    Coordinate3D2.prototype.getSize = function() {
      var _a2 = this.options, width = _a2.width, height = _a2.height, depth = _a2.depth;
      return [width, height, depth];
    };
    Coordinate3D2.prototype.getCenter = function() {
      var _a2 = this.options, x3 = _a2.x, y3 = _a2.y, z = _a2.z, width = _a2.width, height = _a2.height, depth = _a2.depth;
      return [(x3 * 2 + width) / 2, (y3 * 2 + height) / 2, (z * 2 + depth) / 2];
    };
    Coordinate3D2.prototype.transform = function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      var transformations = this.options.transformations;
      this.update({
        transformations: __spreadArray5(__spreadArray5([], __read21(transformations), false), [__spreadArray5([], __read21(args), false)], false)
      });
      return this;
    };
    Coordinate3D2.prototype.map = function(vector) {
      return this.output(vector);
    };
    Coordinate3D2.prototype.invert = function(vector) {
      return this.input(vector);
    };
    Coordinate3D2.prototype.recoordinate = function() {
      this.output = this.compose();
      this.input = this.compose(true);
    };
    Coordinate3D2.prototype.compose = function(invert6) {
      var e_1, _a2;
      if (invert6 === void 0) {
        invert6 = false;
      }
      var transformations = invert6 ? __spreadArray5([], __read21(this.options.transformations), false).reverse() : this.options.transformations;
      var getter = invert6 ? function(d2) {
        return d2.untransform;
      } : function(d2) {
        return d2.transform;
      };
      var matrixes = [];
      var transforms = [];
      var add11 = function(transform4, extended) {
        if (extended === void 0) {
          extended = true;
        }
        return transforms.push(extended ? extend3D(transform4) : transform4);
      };
      try {
        for (var transformations_1 = __values3(transformations), transformations_1_1 = transformations_1.next(); !transformations_1_1.done; transformations_1_1 = transformations_1.next()) {
          var _b = __read21(transformations_1_1.value), name_1 = _b[0], args = _b.slice(1);
          var createTransformer = this.transformers[name_1];
          if (createTransformer) {
            var _c = this.options, x3 = _c.x, y3 = _c.y, z = _c.z, width = _c.width, height = _c.height, depth = _c.depth;
            var transformer2 = createTransformer(__spreadArray5([], __read21(args), false), x3, y3, z, width, height, depth);
            if (isMatrix(transformer2)) {
              matrixes.push(transformer2);
            } else {
              if (matrixes.length) {
                var transform_1 = this.createMatrixTransform(matrixes, invert6);
                add11(transform_1);
                matrixes.splice(0, matrixes.length);
              }
              var transform3 = getter(transformer2) || identity_default5;
              add11(transform3, true);
            }
          }
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (transformations_1_1 && !transformations_1_1.done && (_a2 = transformations_1.return))
            _a2.call(transformations_1);
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
      if (matrixes.length) {
        var transform3 = this.createMatrixTransform(matrixes, invert6);
        add11(transform3);
      }
      return compose3.apply(void 0, __spreadArray5([], __read21(transforms), false));
    };
    Coordinate3D2.prototype.createMatrixTransform = function(matrixes, invert6) {
      var matrix2 = mat4_exports.create();
      if (invert6)
        matrixes.reverse();
      matrixes.forEach(function(m3) {
        return mat4_exports.mul(matrix2, matrix2, m3);
      });
      if (invert6) {
        mat4_exports.invert(matrix2, mat4_exports.clone(matrix2));
      }
      return function(vector) {
        var vector4 = [vector[0], vector[1], vector[2], 1];
        vec4_exports.transformMat4(vector4, vector4, matrix2);
        return [vector4[0], vector4[1], vector4[2]];
      };
    };
    return Coordinate3D2;
  }()
);

// node_modules/@antv/g2/esm/composition/utils.js
var __rest61 = function(s2, e) {
  var t = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
      t[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t[p2[i]] = s2[p2[i]];
    }
  return t;
};
function useDefaultAdaptor(adaptor33) {
  return (options, ...rest2) => deep_mix_default({}, adaptor33(options, ...rest2), options);
}
function useOverrideAdaptor(adaptor33) {
  return (options, ...rest2) => deep_mix_default({}, options, adaptor33(options, ...rest2));
}
function mergeData(dataDescriptor, dataValue) {
  if (!dataDescriptor)
    return dataValue;
  if (Array.isArray(dataDescriptor))
    return dataDescriptor;
  const { value: value2 = dataValue } = dataDescriptor, rest2 = __rest61(dataDescriptor, ["value"]);
  return Object.assign(Object.assign({}, rest2), { value: value2 });
}

// node_modules/@antv/g2/esm/composition/spaceLayer.js
var __rest62 = function(s2, e) {
  var t = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
      t[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t[p2[i]] = s2[p2[i]];
    }
  return t;
};
var SpaceLayer = () => {
  return (options) => {
    const { children } = options;
    if (!Array.isArray(children))
      return [];
    const { x: viewX = 0, y: viewY = 0, width: viewWidth, height: viewHeight, data: layerData } = options;
    return children.map((_a2) => {
      var { data: data2, x: x3, y: y3, width, height } = _a2, rest2 = __rest62(_a2, ["data", "x", "y", "width", "height"]);
      return Object.assign(Object.assign({}, rest2), { data: mergeData(data2, layerData), x: x3 !== null && x3 !== void 0 ? x3 : viewX, y: y3 !== null && y3 !== void 0 ? y3 : viewY, width: width !== null && width !== void 0 ? width : viewWidth, height: height !== null && height !== void 0 ? height : viewHeight });
    });
  };
};
SpaceLayer.props = {};

// node_modules/@antv/g2/esm/composition/spaceFlex.js
var __rest63 = function(s2, e) {
  var t = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
      t[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t[p2[i]] = s2[p2[i]];
    }
  return t;
};
var SpaceFlex = () => {
  return (options) => {
    const { children } = options;
    if (!Array.isArray(children))
      return [];
    const { direction: direction3 = "row", ratio = children.map(() => 1), padding = 0, data: flexData } = options;
    const [mainStart, mainSize, crossSize, crossStart] = direction3 === "col" ? ["y", "height", "width", "x"] : ["x", "width", "height", "y"];
    const sum5 = ratio.reduce((total, value2) => total + value2);
    const totalSize = options[mainSize] - padding * (children.length - 1);
    const sizes = ratio.map((value2) => totalSize * (value2 / sum5));
    const newChildren = [];
    let next = options[mainStart] || 0;
    for (let i = 0; i < sizes.length; i += 1) {
      const _a2 = children[i], { data: data2 } = _a2, rest2 = __rest63(_a2, ["data"]);
      const newData = mergeData(data2, flexData);
      newChildren.push(Object.assign({ [mainStart]: next, [mainSize]: sizes[i], [crossStart]: options[crossStart] || 0, [crossSize]: options[crossSize], data: newData }, rest2));
      next += sizes[i] + padding;
    }
    return newChildren;
  };
};
SpaceFlex.props = {};

// node_modules/@antv/g2/esm/composition/view.js
var __rest64 = function(s2, e) {
  var t = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
      t[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t[p2[i]] = s2[p2[i]];
    }
  return t;
};
var View = () => {
  return (options) => {
    const { children } = options, restOptions = __rest64(options, ["children"]);
    if (!Array.isArray(children))
      return [];
    const { data: viewData, scale: viewScale = {}, axis: viewAxis = {}, legend: viewLegend = {}, encode: viewEncode = {}, transform: viewTransform = [] } = restOptions, rest2 = __rest64(restOptions, ["data", "scale", "axis", "legend", "encode", "transform"]);
    const marks = children.map((_a2) => {
      var { data: data2, scale: scale10 = {}, axis = {}, legend = {}, encode = {}, transform: transform3 = [] } = _a2, rest3 = __rest64(_a2, ["data", "scale", "axis", "legend", "encode", "transform"]);
      return Object.assign({ data: mergeData(data2, viewData), scale: deep_mix_default({}, viewScale, scale10), encode: deep_mix_default({}, viewEncode, encode), transform: [...viewTransform, ...transform3], axis: axis && viewAxis ? deep_mix_default({}, viewAxis, axis) : false, legend: legend && viewLegend ? deep_mix_default({}, viewLegend, legend) : false }, rest3);
    });
    return [Object.assign(Object.assign({}, rest2), { marks, type: "standardView" })];
  };
};
View.props = {};

// node_modules/@antv/g2/esm/composition/mark.js
var __rest65 = function(s2, e) {
  var t = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
      t[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t[p2[i]] = s2[p2[i]];
    }
  return t;
};
var Mark = ({ static: isStatic = false } = {}) => {
  return (options) => {
    const { width, height, depth, paddingLeft, paddingRight, paddingTop, paddingBottom, padding, inset, insetLeft, insetTop, insetRight, insetBottom, margin, marginLeft, marginBottom, marginTop, marginRight, data: data2, coordinate: coordinate2, theme, component, interaction, x: x3, y: y3, z, key, frame: frame2, labelTransform, parentKey, clip, viewStyle, title } = options, mark2 = __rest65(options, ["width", "height", "depth", "paddingLeft", "paddingRight", "paddingTop", "paddingBottom", "padding", "inset", "insetLeft", "insetTop", "insetRight", "insetBottom", "margin", "marginLeft", "marginBottom", "marginTop", "marginRight", "data", "coordinate", "theme", "component", "interaction", "x", "y", "z", "key", "frame", "labelTransform", "parentKey", "clip", "viewStyle", "title"]);
    return [
      Object.assign(Object.assign({
        type: "standardView",
        x: x3,
        y: y3,
        z,
        key,
        width,
        height,
        depth,
        padding,
        paddingLeft,
        paddingRight,
        paddingTop,
        inset,
        insetLeft,
        insetTop,
        insetRight,
        insetBottom,
        paddingBottom,
        theme,
        coordinate: coordinate2,
        component,
        interaction,
        frame: frame2,
        labelTransform,
        margin,
        marginLeft,
        marginBottom,
        marginTop,
        marginRight,
        parentKey,
        clip,
        style: viewStyle
      }, !isStatic && { title }), { marks: [Object.assign(Object.assign(Object.assign({}, mark2), { key: `${key}-0`, data: data2 }), isStatic && { title })] })
    ];
  };
};
Mark.props = {};

// node_modules/@antv/g2/esm/utils/container.js
var Container = class _Container {
  constructor(x3) {
    this.$value = x3;
  }
  static of(x3) {
    return new _Container(x3);
  }
  call(f, ...rest2) {
    return this.$value = f(this.$value, ...rest2), this;
  }
  value() {
    return this.$value;
  }
};

// node_modules/@antv/g2/esm/composition/facetRect.js
var __rest66 = function(s2, e) {
  var t = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
      t[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t[p2[i]] = s2[p2[i]];
    }
  return t;
};
var setScale = useDefaultAdaptor((options) => {
  const { encode, data: data2, scale: scale10, shareSize = false } = options;
  const { x: x3, y: y3 } = encode;
  const flexDomain = (encode2, channel) => {
    var _a2;
    if (encode2 === void 0 || !shareSize)
      return {};
    const groups2 = group(data2, (d2) => d2[encode2]);
    const domain = ((_a2 = scale10 === null || scale10 === void 0 ? void 0 : scale10[channel]) === null || _a2 === void 0 ? void 0 : _a2.domain) || Array.from(groups2.keys());
    const flex2 = domain.map((key) => {
      if (!groups2.has(key))
        return 1;
      return groups2.get(key).length;
    });
    return { domain, flex: flex2 };
  };
  return {
    scale: {
      x: Object.assign(Object.assign({ paddingOuter: 0, paddingInner: 0.1, guide: x3 === void 0 ? null : { position: "top" } }, x3 === void 0 && { paddingInner: 0 }), flexDomain(x3, "x")),
      y: Object.assign(Object.assign({ range: [0, 1], paddingOuter: 0, paddingInner: 0.1, guide: y3 === void 0 ? null : { position: "right" } }, y3 === void 0 && { paddingInner: 0 }), flexDomain(y3, "y"))
    }
  };
});
var inferColor = useDefaultAdaptor((options) => {
  const { data: data2, scale: scale10 } = options;
  const discovered = [options];
  let encodeColor;
  let scaleColor;
  let legendColor;
  while (discovered.length) {
    const node = discovered.shift();
    const { children, encode = {}, scale: scale11 = {}, legend = {} } = node;
    const { color: c5 } = encode;
    const { color: cs } = scale11;
    const { color: cl } = legend;
    if (c5 !== void 0)
      encodeColor = c5;
    if (cs !== void 0)
      scaleColor = cs;
    if (cl !== void 0)
      legendColor = cl;
    if (Array.isArray(children)) {
      discovered.push(...children);
    }
  }
  const domainColor = () => {
    var _a2;
    const domain2 = (_a2 = scale10 === null || scale10 === void 0 ? void 0 : scale10.color) === null || _a2 === void 0 ? void 0 : _a2.domain;
    if (domain2 !== void 0)
      return [domain2];
    if (encodeColor === void 0)
      return [void 0];
    const color2 = typeof encodeColor === "function" ? encodeColor : (d2) => d2[encodeColor];
    const values4 = data2.map(color2);
    if (values4.some((d2) => typeof d2 === "number"))
      return [extent(values4)];
    return [Array.from(new Set(values4)), "ordinal"];
  };
  const title = typeof encodeColor === "string" ? encodeColor : "";
  const [domain, type] = domainColor();
  return {
    encode: { color: encodeColor },
    scale: { color: deep_mix_default({}, scaleColor, { domain, type }) },
    legend: { color: deep_mix_default({ title }, legendColor) }
  };
});
var setAnimation = useDefaultAdaptor(() => ({
  animate: {
    enterType: "fadeIn"
  }
}));
var setStyle = useOverrideAdaptor(() => ({
  frame: false,
  encode: {
    shape: "hollow"
  },
  style: {
    lineWidth: 0
  }
}));
var toCell = useOverrideAdaptor(() => ({
  type: "cell"
}));
var setData = useOverrideAdaptor((options) => {
  const { data: data2 } = options;
  const connector = {
    type: "custom",
    callback: () => {
      const { data: data3, encode } = options;
      const { x: x3, y: y3 } = encode;
      const X = x3 ? Array.from(new Set(data3.map((d2) => d2[x3]))) : [];
      const Y = y3 ? Array.from(new Set(data3.map((d2) => d2[y3]))) : [];
      const cellData = () => {
        if (X.length && Y.length) {
          const cellData2 = [];
          for (const vx of X) {
            for (const vy of Y) {
              cellData2.push({ [x3]: vx, [y3]: vy });
            }
          }
          return cellData2;
        }
        if (X.length)
          return X.map((d2) => ({ [x3]: d2 }));
        if (Y.length)
          return Y.map((d2) => ({ [y3]: d2 }));
      };
      return cellData();
    }
  };
  return {
    data: { type: "inline", value: data2, transform: [connector] }
  };
});
var setChildren = useOverrideAdaptor((options, subLayout = subLayoutRect, createGuideX2 = createGuideXRect, createGuideY2 = createGuideYRect, childOptions = {}) => {
  const { data: dataValue, encode, children, scale: facetScale, x: originX = 0, y: originY = 0, shareData = false, key: viewKey } = options;
  const { value: data2 } = dataValue;
  const { x: encodeX, y: encodeY } = encode;
  const { color: facetScaleColor } = facetScale;
  const { domain: facetDomainColor } = facetScaleColor;
  const createChildren = (visualData, scale10, layout) => {
    const { x: scaleX, y: scaleY } = scale10;
    const { paddingLeft, paddingTop, marginLeft, marginTop } = layout;
    const { domain: domainX } = scaleX.getOptions();
    const { domain: domainY } = scaleY.getOptions();
    const index3 = indexOf2(visualData);
    const bboxs = visualData.map(subLayout);
    const values4 = visualData.map(({ x: x3, y: y3 }) => [
      scaleX.invert(x3),
      scaleY.invert(y3)
    ]);
    const filters = values4.map(([fx, fy]) => (d2) => {
      const { [encodeX]: x3, [encodeY]: y3 } = d2;
      const inX = encodeX !== void 0 ? x3 === fx : true;
      const inY = encodeY !== void 0 ? y3 === fy : true;
      return inX && inY;
    });
    const facetData2d = filters.map((f) => data2.filter(f));
    const maxDataDomain = shareData ? max4(facetData2d, (data3) => data3.length) : void 0;
    const facets = values4.map(([fx, fy]) => ({
      columnField: encodeX,
      columnIndex: domainX.indexOf(fx),
      columnValue: fx,
      columnValuesLength: domainX.length,
      rowField: encodeY,
      rowIndex: domainY.indexOf(fy),
      rowValue: fy,
      rowValuesLength: domainY.length
    }));
    const normalizedChildren = facets.map((facet) => {
      if (Array.isArray(children))
        return children;
      return [children(facet)].flat(1);
    });
    return index3.flatMap((i) => {
      const [left2, top, width, height] = bboxs[i];
      const facet = facets[i];
      const facetData = facetData2d[i];
      const children2 = normalizedChildren[i];
      return children2.map((_a2) => {
        var _b, _c;
        var { scale: scale11, key, facet: isFacet = true, axis = {}, legend = {} } = _a2, rest2 = __rest66(_a2, ["scale", "key", "facet", "axis", "legend"]);
        const guideY = ((_b = scale11 === null || scale11 === void 0 ? void 0 : scale11.y) === null || _b === void 0 ? void 0 : _b.guide) || axis.y;
        const guideX = ((_c = scale11 === null || scale11 === void 0 ? void 0 : scale11.x) === null || _c === void 0 ? void 0 : _c.guide) || axis.x;
        const defaultScale = {
          x: { tickCount: encodeX ? 5 : void 0 },
          y: { tickCount: encodeY ? 5 : void 0 }
        };
        const newData = isFacet ? facetData : facetData.length === 0 ? [] : data2;
        const newScale = {
          color: { domain: facetDomainColor }
        };
        const newAxis = {
          x: createGuide(guideX, createGuideX2)(facet, newData),
          y: createGuide(guideY, createGuideY2)(facet, newData)
        };
        return Object.assign(Object.assign({
          key: `${key}-${i}`,
          data: newData,
          margin: 0,
          x: left2 + paddingLeft + originX + marginLeft,
          y: top + paddingTop + originY + marginTop,
          parentKey: viewKey,
          width,
          height,
          paddingLeft: 0,
          paddingRight: 0,
          paddingTop: 0,
          paddingBottom: 0,
          frame: newData.length ? true : false,
          dataDomain: maxDataDomain,
          scale: deep_mix_default(defaultScale, scale11, newScale),
          axis: deep_mix_default({}, axis, newAxis),
          // Hide all legends for child mark by default,
          // they are displayed in the top-level.
          legend: false
        }, rest2), childOptions);
      });
    });
  };
  return {
    children: createChildren
  };
});
function subLayoutRect(data2) {
  const { points } = data2;
  return calcBBox(points);
}
function createInnerGuide(guide, data2) {
  return data2.length ? deep_mix_default({
    title: false,
    tick: null,
    label: null
  }, guide) : deep_mix_default({
    title: false,
    tick: null,
    label: null,
    grid: null
  }, guide);
}
function createGuideXRect(guide) {
  return (facet, data2) => {
    const { rowIndex, rowValuesLength, columnIndex, columnValuesLength } = facet;
    if (rowIndex !== rowValuesLength - 1)
      return createInnerGuide(guide, data2);
    const title = columnIndex !== columnValuesLength - 1 ? false : void 0;
    const grid2 = data2.length ? void 0 : null;
    return deep_mix_default({ title, grid: grid2 }, guide);
  };
}
function createGuideYRect(guide) {
  return (facet, data2) => {
    const { rowIndex, columnIndex } = facet;
    if (columnIndex !== 0)
      return createInnerGuide(guide, data2);
    const title = rowIndex !== 0 ? false : void 0;
    const grid2 = data2.length ? void 0 : null;
    return deep_mix_default({ title, grid: grid2 }, guide);
  };
}
function createGuide(guide, factory) {
  if (typeof guide === "function")
    return guide;
  if (guide === null || guide === false)
    return () => null;
  return factory(guide);
}
var FacetRect = () => {
  return (options) => {
    const newOptions = Container.of(options).call(toCell).call(inferColor).call(setAnimation).call(setScale).call(setStyle).call(setData).call(setChildren).value();
    return [newOptions];
  };
};
FacetRect.props = {};

// node_modules/@antv/g2/esm/composition/repeatMatrix.js
var __rest67 = function(s2, e) {
  var t = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
      t[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t[p2[i]] = s2[p2[i]];
    }
  return t;
};
var setScale2 = useDefaultAdaptor((options) => {
  return {
    scale: {
      x: { guide: null, paddingOuter: 0, paddingInner: 0.1 },
      y: { guide: null, range: [0, 1], paddingOuter: 0, paddingInner: 0.1 }
    }
  };
});
var setChildren2 = useOverrideAdaptor((options) => {
  const { data: data2, children, x: originX = 0, y: originY = 0, key: viewKey } = options;
  const createChildren = (visualData, scale10, layout) => {
    const { x: scaleX, y: scaleY } = scale10;
    const { paddingLeft, paddingTop, marginLeft, marginTop } = layout;
    const { domain: domainX } = scaleX.getOptions();
    const { domain: domainY } = scaleY.getOptions();
    const index3 = indexOf2(visualData);
    const bboxs = visualData.map(({ points }) => calcBBox(points));
    const values4 = visualData.map(({ x: x3, y: y3 }) => [
      scaleX.invert(x3),
      scaleY.invert(y3)
    ]);
    const facets = values4.map(([fx, fy]) => ({
      columnField: fx,
      columnIndex: domainX.indexOf(fx),
      columnValue: fx,
      columnValuesLength: domainX.length,
      rowField: fy,
      rowIndex: domainY.indexOf(fy),
      rowValue: fy,
      rowValuesLength: domainY.length
    }));
    const normalizedChildren = facets.map((facet) => {
      if (Array.isArray(children))
        return children;
      return [children(facet)].flat(1);
    });
    return index3.flatMap((i) => {
      const [left2, top, width, height] = bboxs[i];
      const [fx, fy] = values4[i];
      const facet = facets[i];
      const children2 = normalizedChildren[i];
      return children2.map((d2) => {
        var _a2, _b;
        const { scale: scale11, key, encode, axis, interaction } = d2, rest2 = __rest67(d2, ["scale", "key", "encode", "axis", "interaction"]);
        const guideY = (_a2 = scale11 === null || scale11 === void 0 ? void 0 : scale11.y) === null || _a2 === void 0 ? void 0 : _a2.guide;
        const guideX = (_b = scale11 === null || scale11 === void 0 ? void 0 : scale11.x) === null || _b === void 0 ? void 0 : _b.guide;
        const defaultScale = {
          // Do not sync position scales among facets by default.
          x: { facet: false },
          // Do not sync position scales among facets by default.
          y: { facet: false }
        };
        const newAxis = {
          x: createGuideX(guideX)(facet, data2),
          y: createGuideY(guideY)(facet, data2)
        };
        const defaultAxis = {
          x: { tickCount: 5 },
          y: { tickCount: 5 }
        };
        return Object.assign({
          data: data2,
          parentKey: viewKey,
          key: `${key}-${i}`,
          x: left2 + paddingLeft + originX + marginLeft,
          y: top + paddingTop + originY + marginTop,
          width,
          height,
          margin: 0,
          paddingLeft: 0,
          paddingRight: 0,
          paddingTop: 0,
          paddingBottom: 0,
          frame: true,
          scale: deep_mix_default(defaultScale, scale11),
          axis: deep_mix_default(defaultAxis, axis, newAxis),
          // Hide all legends for child mark by default,
          // they are displayed in the top-level.
          legend: false,
          encode: deep_mix_default({}, encode, {
            x: fx,
            y: fy
          }),
          interaction: deep_mix_default({}, interaction, {
            // Register this interaction in parent node.
            legendFilter: false
          })
        }, rest2);
      });
    });
  };
  return {
    children: createChildren
  };
});
var setData2 = useOverrideAdaptor((options) => {
  const { encode } = options, rest2 = __rest67(options, ["encode"]);
  const { position: P = [], x: X = P, y: Y = [...P].reverse() } = encode, restEncode = __rest67(encode, ["position", "x", "y"]);
  const data2 = [];
  for (const $x of [X].flat(1)) {
    for (const $y of [Y].flat(1)) {
      data2.push({ $x, $y });
    }
  }
  return Object.assign(Object.assign({}, rest2), { data: data2, encode: Object.assign(Object.assign({}, restEncode), { x: "$x", y: "$y" }), scale: Object.assign(Object.assign({}, [X].flat(1).length === 1 && { x: { paddingInner: 0 } }), [Y].flat(1).length === 1 && { y: { paddingInner: 0 } }) });
});
function createGuideX(guideX) {
  if (typeof guideX === "function")
    return guideX;
  if (guideX === null)
    return () => null;
  return (facet, data2) => {
    const { rowIndex, rowValuesLength } = facet;
    if (rowIndex !== rowValuesLength - 1)
      return createInnerGuide(guideX, data2);
  };
}
function createGuideY(guideY) {
  if (typeof guideY === "function")
    return guideY;
  if (guideY === null)
    return () => null;
  return (facet, data2) => {
    const { columnIndex } = facet;
    if (columnIndex !== 0)
      return createInnerGuide(guideY, data2);
  };
}
var RepeatMatrix = () => {
  return (options) => {
    const newOptions = Container.of(options).call(toCell).call(inferColor).call(setChildren2).call(setData2).call(setAnimation).call(setStyle).call(setScale2).value();
    return [newOptions];
  };
};

// node_modules/@antv/g2/esm/composition/facetCircle.js
var __rest68 = function(s2, e) {
  var t = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
      t[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t[p2[i]] = s2[p2[i]];
    }
  return t;
};
var setScale3 = useDefaultAdaptor((options) => {
  return {
    scale: {
      x: { guide: { type: "axisArc" }, paddingOuter: 0, paddingInner: 0.1 },
      y: { guide: null, range: [0, 1], paddingOuter: 0, paddingInner: 0.1 }
    }
  };
});
var setCoordinate = useDefaultAdaptor((options) => {
  return {
    coordinate: { type: "polar" }
  };
});
var setEncode = (options) => {
  const { encode } = options, rest2 = __rest68(options, ["encode"]);
  const { position } = encode;
  return Object.assign(Object.assign({}, rest2), { encode: { x: position } });
};
function createGuideFacetCircle(guide) {
  return (facet) => null;
}
function subLayoutFacetCircle(data2) {
  const { points } = data2;
  const [p0, p1, p2, p3] = points;
  const sr = dist4(p0, p3);
  const v0 = sub6(p0, p3);
  const v1 = sub6(p1, p2);
  const a01 = angleBetween2(v0, v1);
  const t = 1 / Math.sin(a01 / 2);
  const ir = sr / (1 + t);
  const s2 = ir * Math.sqrt(2);
  const [x05, y05] = p2;
  const a0 = angleWithQuadrant(v0);
  const a32 = a0 + a01 / 2;
  const d2 = ir * t;
  const cx = x05 + d2 * Math.sin(a32);
  const cy = y05 - d2 * Math.cos(a32);
  return [cx - s2 / 2, cy - s2 / 2, s2, s2];
}
var FacetCircle = () => {
  return (options) => {
    const newOptions = Container.of(options).call(toCell).call(setEncode).call(inferColor).call(setCoordinate).call(setData).call(setChildren, subLayoutFacetCircle, createGuideFacetCircle, createGuideFacetCircle, { frame: false }).call(setAnimation).call(setStyle).call(setScale3).value();
    return [newOptions];
  };
};

// node_modules/@antv/g2/esm/composition/timingKeyframe.js
function range2(direction3, iterationCount, keyframeCount) {
  const start = 0;
  const end = keyframeCount;
  const normal = [start, end];
  const reverse3 = [-end + 1, -start + 1];
  if (direction3 === "normal")
    return normal;
  if (direction3 === "reverse")
    return reverse3;
  if (direction3 === "alternate") {
    return iterationCount % 2 === 0 ? normal : reverse3;
  }
  if (direction3 === "reverse-alternate") {
    return iterationCount % 2 === 0 ? reverse3 : normal;
  }
}
function setAnimation2(node, duration, easing) {
  const discovered = [node];
  while (discovered.length) {
    const n = discovered.pop();
    n.animate = deep_mix_default({
      enter: {
        duration
      },
      update: {
        duration,
        easing,
        type: "morphing",
        fill: "both"
      },
      exit: {
        type: "fadeOut",
        duration
      }
    }, n.animate || {});
    const { children } = n;
    if (Array.isArray(children))
      discovered.push(...children);
  }
  return node;
}
var TimingKeyframe = () => {
  return (options) => {
    const { children = [], duration = 1e3, iterationCount = 1, direction: direction3 = "normal", easing = "ease-in-out-sine" } = options;
    const n = children.length;
    if (!Array.isArray(children) || n === 0)
      return [];
    const { key } = children[0];
    const newChildren = children.map((d2) => Object.assign(Object.assign({}, d2), { key })).map((d2) => setAnimation2(d2, duration, easing));
    return function* () {
      let count4 = 0;
      let prevIndex;
      while (iterationCount === "infinite" || count4 < iterationCount) {
        const [start, end] = range2(direction3, count4, n);
        for (let i = start; i < end; i += 1) {
          const index3 = Math.abs(i);
          if (prevIndex !== index3)
            yield newChildren[index3];
          prevIndex = index3;
        }
        count4++;
      }
    };
  };
};
TimingKeyframe.props = {};

// node_modules/@antv/g2/esm/composition/geoPath.js
var __rest69 = function(s2, e) {
  var t = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
      t[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t[p2[i]] = s2[p2[i]];
    }
  return t;
};
var GeoPath = () => {
  return (options) => {
    const { type, data: data2, scale: scale10, encode, style, animate: animate2, key, state } = options, rest2 = __rest69(options, ["type", "data", "scale", "encode", "style", "animate", "key", "state"]);
    return [
      Object.assign(Object.assign({ type: "geoView" }, rest2), { children: [
        {
          type: "geoPath",
          key: `${key}-0`,
          data: {
            value: data2
          },
          scale: scale10,
          encode,
          style,
          animate: animate2,
          state
        }
      ] })
    ];
  };
};
GeoPath.props = {};

// node_modules/d3-geo/src/math.js
var epsilon3 = 1e-6;
var epsilon22 = 1e-12;
var pi3 = Math.PI;
var halfPi2 = pi3 / 2;
var quarterPi = pi3 / 4;
var tau3 = pi3 * 2;
var degrees = 180 / pi3;
var radians = pi3 / 180;
var abs2 = Math.abs;
var atan = Math.atan;
var atan22 = Math.atan2;
var cos3 = Math.cos;
var ceil4 = Math.ceil;
var exp2 = Math.exp;
var log = Math.log;
var pow2 = Math.pow;
var sin2 = Math.sin;
var sign2 = Math.sign || function(x3) {
  return x3 > 0 ? 1 : x3 < 0 ? -1 : 0;
};
var sqrt2 = Math.sqrt;
var tan = Math.tan;
function acos2(x3) {
  return x3 > 1 ? 0 : x3 < -1 ? pi3 : Math.acos(x3);
}
function asin2(x3) {
  return x3 > 1 ? halfPi2 : x3 < -1 ? -halfPi2 : Math.asin(x3);
}

// node_modules/d3-geo/src/noop.js
function noop2() {
}

// node_modules/d3-geo/src/stream.js
function streamGeometry(geometry, stream) {
  if (geometry && streamGeometryType.hasOwnProperty(geometry.type)) {
    streamGeometryType[geometry.type](geometry, stream);
  }
}
var streamObjectType = {
  Feature: function(object, stream) {
    streamGeometry(object.geometry, stream);
  },
  FeatureCollection: function(object, stream) {
    var features = object.features, i = -1, n = features.length;
    while (++i < n)
      streamGeometry(features[i].geometry, stream);
  }
};
var streamGeometryType = {
  Sphere: function(object, stream) {
    stream.sphere();
  },
  Point: function(object, stream) {
    object = object.coordinates;
    stream.point(object[0], object[1], object[2]);
  },
  MultiPoint: function(object, stream) {
    var coordinates = object.coordinates, i = -1, n = coordinates.length;
    while (++i < n)
      object = coordinates[i], stream.point(object[0], object[1], object[2]);
  },
  LineString: function(object, stream) {
    streamLine(object.coordinates, stream, 0);
  },
  MultiLineString: function(object, stream) {
    var coordinates = object.coordinates, i = -1, n = coordinates.length;
    while (++i < n)
      streamLine(coordinates[i], stream, 0);
  },
  Polygon: function(object, stream) {
    streamPolygon(object.coordinates, stream);
  },
  MultiPolygon: function(object, stream) {
    var coordinates = object.coordinates, i = -1, n = coordinates.length;
    while (++i < n)
      streamPolygon(coordinates[i], stream);
  },
  GeometryCollection: function(object, stream) {
    var geometries = object.geometries, i = -1, n = geometries.length;
    while (++i < n)
      streamGeometry(geometries[i], stream);
  }
};
function streamLine(coordinates, stream, closed) {
  var i = -1, n = coordinates.length - closed, coordinate2;
  stream.lineStart();
  while (++i < n)
    coordinate2 = coordinates[i], stream.point(coordinate2[0], coordinate2[1], coordinate2[2]);
  stream.lineEnd();
}
function streamPolygon(coordinates, stream) {
  var i = -1, n = coordinates.length;
  stream.polygonStart();
  while (++i < n)
    streamLine(coordinates[i], stream, 1);
  stream.polygonEnd();
}
function stream_default(object, stream) {
  if (object && streamObjectType.hasOwnProperty(object.type)) {
    streamObjectType[object.type](object, stream);
  } else {
    streamGeometry(object, stream);
  }
}

// node_modules/d3-geo/src/area.js
var areaRingSum = new Adder();
var areaSum = new Adder();

// node_modules/d3-geo/src/cartesian.js
function spherical(cartesian3) {
  return [atan22(cartesian3[1], cartesian3[0]), asin2(cartesian3[2])];
}
function cartesian2(spherical2) {
  var lambda = spherical2[0], phi2 = spherical2[1], cosPhi = cos3(phi2);
  return [cosPhi * cos3(lambda), cosPhi * sin2(lambda), sin2(phi2)];
}
function cartesianDot(a4, b) {
  return a4[0] * b[0] + a4[1] * b[1] + a4[2] * b[2];
}
function cartesianCross(a4, b) {
  return [a4[1] * b[2] - a4[2] * b[1], a4[2] * b[0] - a4[0] * b[2], a4[0] * b[1] - a4[1] * b[0]];
}
function cartesianAddInPlace(a4, b) {
  a4[0] += b[0], a4[1] += b[1], a4[2] += b[2];
}
function cartesianScale(vector, k2) {
  return [vector[0] * k2, vector[1] * k2, vector[2] * k2];
}
function cartesianNormalizeInPlace(d2) {
  var l = sqrt2(d2[0] * d2[0] + d2[1] * d2[1] + d2[2] * d2[2]);
  d2[0] /= l, d2[1] /= l, d2[2] /= l;
}

// node_modules/d3-geo/src/compose.js
function compose_default(a4, b) {
  function compose4(x3, y3) {
    return x3 = a4(x3, y3), b(x3[0], x3[1]);
  }
  if (a4.invert && b.invert)
    compose4.invert = function(x3, y3) {
      return x3 = b.invert(x3, y3), x3 && a4.invert(x3[0], x3[1]);
    };
  return compose4;
}

// node_modules/d3-geo/src/rotation.js
function rotationIdentity(lambda, phi2) {
  if (abs2(lambda) > pi3)
    lambda -= Math.round(lambda / tau3) * tau3;
  return [lambda, phi2];
}
rotationIdentity.invert = rotationIdentity;
function rotateRadians(deltaLambda, deltaPhi, deltaGamma) {
  return (deltaLambda %= tau3) ? deltaPhi || deltaGamma ? compose_default(rotationLambda(deltaLambda), rotationPhiGamma(deltaPhi, deltaGamma)) : rotationLambda(deltaLambda) : deltaPhi || deltaGamma ? rotationPhiGamma(deltaPhi, deltaGamma) : rotationIdentity;
}
function forwardRotationLambda(deltaLambda) {
  return function(lambda, phi2) {
    lambda += deltaLambda;
    if (abs2(lambda) > pi3)
      lambda -= Math.round(lambda / tau3) * tau3;
    return [lambda, phi2];
  };
}
function rotationLambda(deltaLambda) {
  var rotation = forwardRotationLambda(deltaLambda);
  rotation.invert = forwardRotationLambda(-deltaLambda);
  return rotation;
}
function rotationPhiGamma(deltaPhi, deltaGamma) {
  var cosDeltaPhi = cos3(deltaPhi), sinDeltaPhi = sin2(deltaPhi), cosDeltaGamma = cos3(deltaGamma), sinDeltaGamma = sin2(deltaGamma);
  function rotation(lambda, phi2) {
    var cosPhi = cos3(phi2), x3 = cos3(lambda) * cosPhi, y3 = sin2(lambda) * cosPhi, z = sin2(phi2), k2 = z * cosDeltaPhi + x3 * sinDeltaPhi;
    return [
      atan22(y3 * cosDeltaGamma - k2 * sinDeltaGamma, x3 * cosDeltaPhi - z * sinDeltaPhi),
      asin2(k2 * cosDeltaGamma + y3 * sinDeltaGamma)
    ];
  }
  rotation.invert = function(lambda, phi2) {
    var cosPhi = cos3(phi2), x3 = cos3(lambda) * cosPhi, y3 = sin2(lambda) * cosPhi, z = sin2(phi2), k2 = z * cosDeltaGamma - y3 * sinDeltaGamma;
    return [
      atan22(y3 * cosDeltaGamma + z * sinDeltaGamma, x3 * cosDeltaPhi + k2 * sinDeltaPhi),
      asin2(k2 * cosDeltaPhi - x3 * sinDeltaPhi)
    ];
  };
  return rotation;
}
function rotation_default(rotate6) {
  rotate6 = rotateRadians(rotate6[0] * radians, rotate6[1] * radians, rotate6.length > 2 ? rotate6[2] * radians : 0);
  function forward(coordinates) {
    coordinates = rotate6(coordinates[0] * radians, coordinates[1] * radians);
    return coordinates[0] *= degrees, coordinates[1] *= degrees, coordinates;
  }
  forward.invert = function(coordinates) {
    coordinates = rotate6.invert(coordinates[0] * radians, coordinates[1] * radians);
    return coordinates[0] *= degrees, coordinates[1] *= degrees, coordinates;
  };
  return forward;
}

// node_modules/d3-geo/src/circle.js
function circleStream(stream, radius, delta, direction3, t02, t12) {
  if (!delta)
    return;
  var cosRadius = cos3(radius), sinRadius = sin2(radius), step2 = direction3 * delta;
  if (t02 == null) {
    t02 = radius + direction3 * tau3;
    t12 = radius - step2 / 2;
  } else {
    t02 = circleRadius(cosRadius, t02);
    t12 = circleRadius(cosRadius, t12);
    if (direction3 > 0 ? t02 < t12 : t02 > t12)
      t02 += direction3 * tau3;
  }
  for (var point7, t = t02; direction3 > 0 ? t > t12 : t < t12; t -= step2) {
    point7 = spherical([cosRadius, -sinRadius * cos3(t), -sinRadius * sin2(t)]);
    stream.point(point7[0], point7[1]);
  }
}
function circleRadius(cosRadius, point7) {
  point7 = cartesian2(point7), point7[0] -= cosRadius;
  cartesianNormalizeInPlace(point7);
  var radius = acos2(-point7[1]);
  return ((-point7[2] < 0 ? -radius : radius) + tau3 - epsilon3) % tau3;
}

// node_modules/d3-geo/src/clip/buffer.js
function buffer_default() {
  var lines = [], line4;
  return {
    point: function(x3, y3, m3) {
      line4.push([x3, y3, m3]);
    },
    lineStart: function() {
      lines.push(line4 = []);
    },
    lineEnd: noop2,
    rejoin: function() {
      if (lines.length > 1)
        lines.push(lines.pop().concat(lines.shift()));
    },
    result: function() {
      var result2 = lines;
      lines = [];
      line4 = null;
      return result2;
    }
  };
}

// node_modules/d3-geo/src/pointEqual.js
function pointEqual_default(a4, b) {
  return abs2(a4[0] - b[0]) < epsilon3 && abs2(a4[1] - b[1]) < epsilon3;
}

// node_modules/d3-geo/src/clip/rejoin.js
function Intersection(point7, points, other, entry) {
  this.x = point7;
  this.z = points;
  this.o = other;
  this.e = entry;
  this.v = false;
  this.n = this.p = null;
}
function rejoin_default(segments, compareIntersection2, startInside, interpolate4, stream) {
  var subject = [], clip = [], i, n;
  segments.forEach(function(segment) {
    if ((n2 = segment.length - 1) <= 0)
      return;
    var n2, p0 = segment[0], p1 = segment[n2], x3;
    if (pointEqual_default(p0, p1)) {
      if (!p0[2] && !p1[2]) {
        stream.lineStart();
        for (i = 0; i < n2; ++i)
          stream.point((p0 = segment[i])[0], p0[1]);
        stream.lineEnd();
        return;
      }
      p1[0] += 2 * epsilon3;
    }
    subject.push(x3 = new Intersection(p0, segment, null, true));
    clip.push(x3.o = new Intersection(p0, null, x3, false));
    subject.push(x3 = new Intersection(p1, segment, null, false));
    clip.push(x3.o = new Intersection(p1, null, x3, true));
  });
  if (!subject.length)
    return;
  clip.sort(compareIntersection2);
  link2(subject);
  link2(clip);
  for (i = 0, n = clip.length; i < n; ++i) {
    clip[i].e = startInside = !startInside;
  }
  var start = subject[0], points, point7;
  while (1) {
    var current = start, isSubject = true;
    while (current.v)
      if ((current = current.n) === start)
        return;
    points = current.z;
    stream.lineStart();
    do {
      current.v = current.o.v = true;
      if (current.e) {
        if (isSubject) {
          for (i = 0, n = points.length; i < n; ++i)
            stream.point((point7 = points[i])[0], point7[1]);
        } else {
          interpolate4(current.x, current.n.x, 1, stream);
        }
        current = current.n;
      } else {
        if (isSubject) {
          points = current.p.z;
          for (i = points.length - 1; i >= 0; --i)
            stream.point((point7 = points[i])[0], point7[1]);
        } else {
          interpolate4(current.x, current.p.x, -1, stream);
        }
        current = current.p;
      }
      current = current.o;
      points = current.z;
      isSubject = !isSubject;
    } while (!current.v);
    stream.lineEnd();
  }
}
function link2(array2) {
  if (!(n = array2.length))
    return;
  var n, i = 0, a4 = array2[0], b;
  while (++i < n) {
    a4.n = b = array2[i];
    b.p = a4;
    a4 = b;
  }
  a4.n = b = array2[0];
  b.p = a4;
}

// node_modules/d3-geo/src/polygonContains.js
function longitude(point7) {
  return abs2(point7[0]) <= pi3 ? point7[0] : sign2(point7[0]) * ((abs2(point7[0]) + pi3) % tau3 - pi3);
}
function polygonContains_default(polygon, point7) {
  var lambda = longitude(point7), phi2 = point7[1], sinPhi = sin2(phi2), normal = [sin2(lambda), -cos3(lambda), 0], angle4 = 0, winding = 0;
  var sum5 = new Adder();
  if (sinPhi === 1)
    phi2 = halfPi2 + epsilon3;
  else if (sinPhi === -1)
    phi2 = -halfPi2 - epsilon3;
  for (var i = 0, n = polygon.length; i < n; ++i) {
    if (!(m3 = (ring = polygon[i]).length))
      continue;
    var ring, m3, point0 = ring[m3 - 1], lambda0 = longitude(point0), phi0 = point0[1] / 2 + quarterPi, sinPhi0 = sin2(phi0), cosPhi0 = cos3(phi0);
    for (var j = 0; j < m3; ++j, lambda0 = lambda1, sinPhi0 = sinPhi1, cosPhi0 = cosPhi1, point0 = point1) {
      var point1 = ring[j], lambda1 = longitude(point1), phi1 = point1[1] / 2 + quarterPi, sinPhi1 = sin2(phi1), cosPhi1 = cos3(phi1), delta = lambda1 - lambda0, sign3 = delta >= 0 ? 1 : -1, absDelta = sign3 * delta, antimeridian = absDelta > pi3, k2 = sinPhi0 * sinPhi1;
      sum5.add(atan22(k2 * sign3 * sin2(absDelta), cosPhi0 * cosPhi1 + k2 * cos3(absDelta)));
      angle4 += antimeridian ? delta + sign3 * tau3 : delta;
      if (antimeridian ^ lambda0 >= lambda ^ lambda1 >= lambda) {
        var arc = cartesianCross(cartesian2(point0), cartesian2(point1));
        cartesianNormalizeInPlace(arc);
        var intersection4 = cartesianCross(normal, arc);
        cartesianNormalizeInPlace(intersection4);
        var phiArc = (antimeridian ^ delta >= 0 ? -1 : 1) * asin2(intersection4[2]);
        if (phi2 > phiArc || phi2 === phiArc && (arc[0] || arc[1])) {
          winding += antimeridian ^ delta >= 0 ? 1 : -1;
        }
      }
    }
  }
  return (angle4 < -epsilon3 || angle4 < epsilon3 && sum5 < -epsilon22) ^ winding & 1;
}

// node_modules/d3-geo/src/clip/index.js
function clip_default(pointVisible, clipLine, interpolate4, start) {
  return function(sink) {
    var line4 = clipLine(sink), ringBuffer = buffer_default(), ringSink = clipLine(ringBuffer), polygonStarted = false, polygon, segments, ring;
    var clip = {
      point: point7,
      lineStart,
      lineEnd,
      polygonStart: function() {
        clip.point = pointRing;
        clip.lineStart = ringStart;
        clip.lineEnd = ringEnd;
        segments = [];
        polygon = [];
      },
      polygonEnd: function() {
        clip.point = point7;
        clip.lineStart = lineStart;
        clip.lineEnd = lineEnd;
        segments = merge(segments);
        var startInside = polygonContains_default(polygon, start);
        if (segments.length) {
          if (!polygonStarted)
            sink.polygonStart(), polygonStarted = true;
          rejoin_default(segments, compareIntersection, startInside, interpolate4, sink);
        } else if (startInside) {
          if (!polygonStarted)
            sink.polygonStart(), polygonStarted = true;
          sink.lineStart();
          interpolate4(null, null, 1, sink);
          sink.lineEnd();
        }
        if (polygonStarted)
          sink.polygonEnd(), polygonStarted = false;
        segments = polygon = null;
      },
      sphere: function() {
        sink.polygonStart();
        sink.lineStart();
        interpolate4(null, null, 1, sink);
        sink.lineEnd();
        sink.polygonEnd();
      }
    };
    function point7(lambda, phi2) {
      if (pointVisible(lambda, phi2))
        sink.point(lambda, phi2);
    }
    function pointLine(lambda, phi2) {
      line4.point(lambda, phi2);
    }
    function lineStart() {
      clip.point = pointLine;
      line4.lineStart();
    }
    function lineEnd() {
      clip.point = point7;
      line4.lineEnd();
    }
    function pointRing(lambda, phi2) {
      ring.push([lambda, phi2]);
      ringSink.point(lambda, phi2);
    }
    function ringStart() {
      ringSink.lineStart();
      ring = [];
    }
    function ringEnd() {
      pointRing(ring[0][0], ring[0][1]);
      ringSink.lineEnd();
      var clean = ringSink.clean(), ringSegments = ringBuffer.result(), i, n = ringSegments.length, m3, segment, point8;
      ring.pop();
      polygon.push(ring);
      ring = null;
      if (!n)
        return;
      if (clean & 1) {
        segment = ringSegments[0];
        if ((m3 = segment.length - 1) > 0) {
          if (!polygonStarted)
            sink.polygonStart(), polygonStarted = true;
          sink.lineStart();
          for (i = 0; i < m3; ++i)
            sink.point((point8 = segment[i])[0], point8[1]);
          sink.lineEnd();
        }
        return;
      }
      if (n > 1 && clean & 2)
        ringSegments.push(ringSegments.pop().concat(ringSegments.shift()));
      segments.push(ringSegments.filter(validSegment));
    }
    return clip;
  };
}
function validSegment(segment) {
  return segment.length > 1;
}
function compareIntersection(a4, b) {
  return ((a4 = a4.x)[0] < 0 ? a4[1] - halfPi2 - epsilon3 : halfPi2 - a4[1]) - ((b = b.x)[0] < 0 ? b[1] - halfPi2 - epsilon3 : halfPi2 - b[1]);
}

// node_modules/d3-geo/src/clip/antimeridian.js
var antimeridian_default = clip_default(
  function() {
    return true;
  },
  clipAntimeridianLine,
  clipAntimeridianInterpolate,
  [-pi3, -halfPi2]
);
function clipAntimeridianLine(stream) {
  var lambda0 = NaN, phi0 = NaN, sign0 = NaN, clean;
  return {
    lineStart: function() {
      stream.lineStart();
      clean = 1;
    },
    point: function(lambda1, phi1) {
      var sign1 = lambda1 > 0 ? pi3 : -pi3, delta = abs2(lambda1 - lambda0);
      if (abs2(delta - pi3) < epsilon3) {
        stream.point(lambda0, phi0 = (phi0 + phi1) / 2 > 0 ? halfPi2 : -halfPi2);
        stream.point(sign0, phi0);
        stream.lineEnd();
        stream.lineStart();
        stream.point(sign1, phi0);
        stream.point(lambda1, phi0);
        clean = 0;
      } else if (sign0 !== sign1 && delta >= pi3) {
        if (abs2(lambda0 - sign0) < epsilon3)
          lambda0 -= sign0 * epsilon3;
        if (abs2(lambda1 - sign1) < epsilon3)
          lambda1 -= sign1 * epsilon3;
        phi0 = clipAntimeridianIntersect(lambda0, phi0, lambda1, phi1);
        stream.point(sign0, phi0);
        stream.lineEnd();
        stream.lineStart();
        stream.point(sign1, phi0);
        clean = 0;
      }
      stream.point(lambda0 = lambda1, phi0 = phi1);
      sign0 = sign1;
    },
    lineEnd: function() {
      stream.lineEnd();
      lambda0 = phi0 = NaN;
    },
    clean: function() {
      return 2 - clean;
    }
  };
}
function clipAntimeridianIntersect(lambda0, phi0, lambda1, phi1) {
  var cosPhi0, cosPhi1, sinLambda0Lambda1 = sin2(lambda0 - lambda1);
  return abs2(sinLambda0Lambda1) > epsilon3 ? atan((sin2(phi0) * (cosPhi1 = cos3(phi1)) * sin2(lambda1) - sin2(phi1) * (cosPhi0 = cos3(phi0)) * sin2(lambda0)) / (cosPhi0 * cosPhi1 * sinLambda0Lambda1)) : (phi0 + phi1) / 2;
}
function clipAntimeridianInterpolate(from, to, direction3, stream) {
  var phi2;
  if (from == null) {
    phi2 = direction3 * halfPi2;
    stream.point(-pi3, phi2);
    stream.point(0, phi2);
    stream.point(pi3, phi2);
    stream.point(pi3, 0);
    stream.point(pi3, -phi2);
    stream.point(0, -phi2);
    stream.point(-pi3, -phi2);
    stream.point(-pi3, 0);
    stream.point(-pi3, phi2);
  } else if (abs2(from[0] - to[0]) > epsilon3) {
    var lambda = from[0] < to[0] ? pi3 : -pi3;
    phi2 = direction3 * lambda / 2;
    stream.point(-lambda, phi2);
    stream.point(0, phi2);
    stream.point(lambda, phi2);
  } else {
    stream.point(to[0], to[1]);
  }
}

// node_modules/d3-geo/src/clip/circle.js
function circle_default2(radius) {
  var cr = cos3(radius), delta = 6 * radians, smallRadius = cr > 0, notHemisphere = abs2(cr) > epsilon3;
  function interpolate4(from, to, direction3, stream) {
    circleStream(stream, radius, delta, direction3, from, to);
  }
  function visible(lambda, phi2) {
    return cos3(lambda) * cos3(phi2) > cr;
  }
  function clipLine(stream) {
    var point0, c0, v0, v00, clean;
    return {
      lineStart: function() {
        v00 = v0 = false;
        clean = 1;
      },
      point: function(lambda, phi2) {
        var point1 = [lambda, phi2], point22, v = visible(lambda, phi2), c5 = smallRadius ? v ? 0 : code(lambda, phi2) : v ? code(lambda + (lambda < 0 ? pi3 : -pi3), phi2) : 0;
        if (!point0 && (v00 = v0 = v))
          stream.lineStart();
        if (v !== v0) {
          point22 = intersect4(point0, point1);
          if (!point22 || pointEqual_default(point0, point22) || pointEqual_default(point1, point22))
            point1[2] = 1;
        }
        if (v !== v0) {
          clean = 0;
          if (v) {
            stream.lineStart();
            point22 = intersect4(point1, point0);
            stream.point(point22[0], point22[1]);
          } else {
            point22 = intersect4(point0, point1);
            stream.point(point22[0], point22[1], 2);
            stream.lineEnd();
          }
          point0 = point22;
        } else if (notHemisphere && point0 && smallRadius ^ v) {
          var t;
          if (!(c5 & c0) && (t = intersect4(point1, point0, true))) {
            clean = 0;
            if (smallRadius) {
              stream.lineStart();
              stream.point(t[0][0], t[0][1]);
              stream.point(t[1][0], t[1][1]);
              stream.lineEnd();
            } else {
              stream.point(t[1][0], t[1][1]);
              stream.lineEnd();
              stream.lineStart();
              stream.point(t[0][0], t[0][1], 3);
            }
          }
        }
        if (v && (!point0 || !pointEqual_default(point0, point1))) {
          stream.point(point1[0], point1[1]);
        }
        point0 = point1, v0 = v, c0 = c5;
      },
      lineEnd: function() {
        if (v0)
          stream.lineEnd();
        point0 = null;
      },
      // Rejoin first and last segments if there were intersections and the first
      // and last points were visible.
      clean: function() {
        return clean | (v00 && v0) << 1;
      }
    };
  }
  function intersect4(a4, b, two) {
    var pa = cartesian2(a4), pb = cartesian2(b);
    var n1 = [1, 0, 0], n2 = cartesianCross(pa, pb), n2n2 = cartesianDot(n2, n2), n1n2 = n2[0], determinant3 = n2n2 - n1n2 * n1n2;
    if (!determinant3)
      return !two && a4;
    var c1 = cr * n2n2 / determinant3, c22 = -cr * n1n2 / determinant3, n1xn2 = cartesianCross(n1, n2), A5 = cartesianScale(n1, c1), B3 = cartesianScale(n2, c22);
    cartesianAddInPlace(A5, B3);
    var u = n1xn2, w = cartesianDot(A5, u), uu = cartesianDot(u, u), t22 = w * w - uu * (cartesianDot(A5, A5) - 1);
    if (t22 < 0)
      return;
    var t = sqrt2(t22), q = cartesianScale(u, (-w - t) / uu);
    cartesianAddInPlace(q, A5);
    q = spherical(q);
    if (!two)
      return q;
    var lambda0 = a4[0], lambda1 = b[0], phi0 = a4[1], phi1 = b[1], z;
    if (lambda1 < lambda0)
      z = lambda0, lambda0 = lambda1, lambda1 = z;
    var delta2 = lambda1 - lambda0, polar2 = abs2(delta2 - pi3) < epsilon3, meridian = polar2 || delta2 < epsilon3;
    if (!polar2 && phi1 < phi0)
      z = phi0, phi0 = phi1, phi1 = z;
    if (meridian ? polar2 ? phi0 + phi1 > 0 ^ q[1] < (abs2(q[0] - lambda0) < epsilon3 ? phi0 : phi1) : phi0 <= q[1] && q[1] <= phi1 : delta2 > pi3 ^ (lambda0 <= q[0] && q[0] <= lambda1)) {
      var q12 = cartesianScale(u, (-w + t) / uu);
      cartesianAddInPlace(q12, A5);
      return [q, spherical(q12)];
    }
  }
  function code(lambda, phi2) {
    var r = smallRadius ? radius : pi3 - radius, code2 = 0;
    if (lambda < -r)
      code2 |= 1;
    else if (lambda > r)
      code2 |= 2;
    if (phi2 < -r)
      code2 |= 4;
    else if (phi2 > r)
      code2 |= 8;
    return code2;
  }
  return clip_default(visible, clipLine, interpolate4, smallRadius ? [0, -radius] : [-pi3, radius - pi3]);
}

// node_modules/d3-geo/src/clip/line.js
function line_default2(a4, b, x05, y05, x12, y12) {
  var ax = a4[0], ay = a4[1], bx = b[0], by = b[1], t02 = 0, t12 = 1, dx = bx - ax, dy = by - ay, r;
  r = x05 - ax;
  if (!dx && r > 0)
    return;
  r /= dx;
  if (dx < 0) {
    if (r < t02)
      return;
    if (r < t12)
      t12 = r;
  } else if (dx > 0) {
    if (r > t12)
      return;
    if (r > t02)
      t02 = r;
  }
  r = x12 - ax;
  if (!dx && r < 0)
    return;
  r /= dx;
  if (dx < 0) {
    if (r > t12)
      return;
    if (r > t02)
      t02 = r;
  } else if (dx > 0) {
    if (r < t02)
      return;
    if (r < t12)
      t12 = r;
  }
  r = y05 - ay;
  if (!dy && r > 0)
    return;
  r /= dy;
  if (dy < 0) {
    if (r < t02)
      return;
    if (r < t12)
      t12 = r;
  } else if (dy > 0) {
    if (r > t12)
      return;
    if (r > t02)
      t02 = r;
  }
  r = y12 - ay;
  if (!dy && r < 0)
    return;
  r /= dy;
  if (dy < 0) {
    if (r > t12)
      return;
    if (r > t02)
      t02 = r;
  } else if (dy > 0) {
    if (r < t02)
      return;
    if (r < t12)
      t12 = r;
  }
  if (t02 > 0)
    a4[0] = ax + t02 * dx, a4[1] = ay + t02 * dy;
  if (t12 < 1)
    b[0] = ax + t12 * dx, b[1] = ay + t12 * dy;
  return true;
}

// node_modules/d3-geo/src/clip/rectangle.js
var clipMax = 1e9;
var clipMin = -clipMax;
function clipRectangle(x05, y05, x12, y12) {
  function visible(x3, y3) {
    return x05 <= x3 && x3 <= x12 && y05 <= y3 && y3 <= y12;
  }
  function interpolate4(from, to, direction3, stream) {
    var a4 = 0, a1 = 0;
    if (from == null || (a4 = corner(from, direction3)) !== (a1 = corner(to, direction3)) || comparePoint(from, to) < 0 ^ direction3 > 0) {
      do
        stream.point(a4 === 0 || a4 === 3 ? x05 : x12, a4 > 1 ? y12 : y05);
      while ((a4 = (a4 + direction3 + 4) % 4) !== a1);
    } else {
      stream.point(to[0], to[1]);
    }
  }
  function corner(p2, direction3) {
    return abs2(p2[0] - x05) < epsilon3 ? direction3 > 0 ? 0 : 3 : abs2(p2[0] - x12) < epsilon3 ? direction3 > 0 ? 2 : 1 : abs2(p2[1] - y05) < epsilon3 ? direction3 > 0 ? 1 : 0 : direction3 > 0 ? 3 : 2;
  }
  function compareIntersection2(a4, b) {
    return comparePoint(a4.x, b.x);
  }
  function comparePoint(a4, b) {
    var ca = corner(a4, 1), cb = corner(b, 1);
    return ca !== cb ? ca - cb : ca === 0 ? b[1] - a4[1] : ca === 1 ? a4[0] - b[0] : ca === 2 ? a4[1] - b[1] : b[0] - a4[0];
  }
  return function(stream) {
    var activeStream = stream, bufferStream = buffer_default(), segments, polygon, ring, x__, y__, v__, x_, y_, v_, first3, clean;
    var clipStream = {
      point: point7,
      lineStart,
      lineEnd,
      polygonStart,
      polygonEnd
    };
    function point7(x3, y3) {
      if (visible(x3, y3))
        activeStream.point(x3, y3);
    }
    function polygonInside() {
      var winding = 0;
      for (var i = 0, n = polygon.length; i < n; ++i) {
        for (var ring2 = polygon[i], j = 1, m3 = ring2.length, point8 = ring2[0], a0, a1, b0 = point8[0], b1 = point8[1]; j < m3; ++j) {
          a0 = b0, a1 = b1, point8 = ring2[j], b0 = point8[0], b1 = point8[1];
          if (a1 <= y12) {
            if (b1 > y12 && (b0 - a0) * (y12 - a1) > (b1 - a1) * (x05 - a0))
              ++winding;
          } else {
            if (b1 <= y12 && (b0 - a0) * (y12 - a1) < (b1 - a1) * (x05 - a0))
              --winding;
          }
        }
      }
      return winding;
    }
    function polygonStart() {
      activeStream = bufferStream, segments = [], polygon = [], clean = true;
    }
    function polygonEnd() {
      var startInside = polygonInside(), cleanInside = clean && startInside, visible2 = (segments = merge(segments)).length;
      if (cleanInside || visible2) {
        stream.polygonStart();
        if (cleanInside) {
          stream.lineStart();
          interpolate4(null, null, 1, stream);
          stream.lineEnd();
        }
        if (visible2) {
          rejoin_default(segments, compareIntersection2, startInside, interpolate4, stream);
        }
        stream.polygonEnd();
      }
      activeStream = stream, segments = polygon = ring = null;
    }
    function lineStart() {
      clipStream.point = linePoint;
      if (polygon)
        polygon.push(ring = []);
      first3 = true;
      v_ = false;
      x_ = y_ = NaN;
    }
    function lineEnd() {
      if (segments) {
        linePoint(x__, y__);
        if (v__ && v_)
          bufferStream.rejoin();
        segments.push(bufferStream.result());
      }
      clipStream.point = point7;
      if (v_)
        activeStream.lineEnd();
    }
    function linePoint(x3, y3) {
      var v = visible(x3, y3);
      if (polygon)
        ring.push([x3, y3]);
      if (first3) {
        x__ = x3, y__ = y3, v__ = v;
        first3 = false;
        if (v) {
          activeStream.lineStart();
          activeStream.point(x3, y3);
        }
      } else {
        if (v && v_)
          activeStream.point(x3, y3);
        else {
          var a4 = [x_ = Math.max(clipMin, Math.min(clipMax, x_)), y_ = Math.max(clipMin, Math.min(clipMax, y_))], b = [x3 = Math.max(clipMin, Math.min(clipMax, x3)), y3 = Math.max(clipMin, Math.min(clipMax, y3))];
          if (line_default2(a4, b, x05, y05, x12, y12)) {
            if (!v_) {
              activeStream.lineStart();
              activeStream.point(a4[0], a4[1]);
            }
            activeStream.point(b[0], b[1]);
            if (!v)
              activeStream.lineEnd();
            clean = false;
          } else if (v) {
            activeStream.lineStart();
            activeStream.point(x3, y3);
            clean = false;
          }
        }
      }
      x_ = x3, y_ = y3, v_ = v;
    }
    return clipStream;
  };
}

// node_modules/d3-geo/src/graticule.js
function graticuleX(y05, y12, dy) {
  var y3 = range(y05, y12 - epsilon3, dy).concat(y12);
  return function(x3) {
    return y3.map(function(y4) {
      return [x3, y4];
    });
  };
}
function graticuleY(x05, x12, dx) {
  var x3 = range(x05, x12 - epsilon3, dx).concat(x12);
  return function(y3) {
    return x3.map(function(x4) {
      return [x4, y3];
    });
  };
}
function graticule() {
  var x12, x05, X12, X02, y12, y05, Y12, Y02, dx = 10, dy = dx, DX = 90, DY = 360, x3, y3, X, Y, precision = 2.5;
  function graticule2() {
    return { type: "MultiLineString", coordinates: lines() };
  }
  function lines() {
    return range(ceil4(X02 / DX) * DX, X12, DX).map(X).concat(range(ceil4(Y02 / DY) * DY, Y12, DY).map(Y)).concat(range(ceil4(x05 / dx) * dx, x12, dx).filter(function(x4) {
      return abs2(x4 % DX) > epsilon3;
    }).map(x3)).concat(range(ceil4(y05 / dy) * dy, y12, dy).filter(function(y4) {
      return abs2(y4 % DY) > epsilon3;
    }).map(y3));
  }
  graticule2.lines = function() {
    return lines().map(function(coordinates) {
      return { type: "LineString", coordinates };
    });
  };
  graticule2.outline = function() {
    return {
      type: "Polygon",
      coordinates: [
        X(X02).concat(
          Y(Y12).slice(1),
          X(X12).reverse().slice(1),
          Y(Y02).reverse().slice(1)
        )
      ]
    };
  };
  graticule2.extent = function(_2) {
    if (!arguments.length)
      return graticule2.extentMinor();
    return graticule2.extentMajor(_2).extentMinor(_2);
  };
  graticule2.extentMajor = function(_2) {
    if (!arguments.length)
      return [[X02, Y02], [X12, Y12]];
    X02 = +_2[0][0], X12 = +_2[1][0];
    Y02 = +_2[0][1], Y12 = +_2[1][1];
    if (X02 > X12)
      _2 = X02, X02 = X12, X12 = _2;
    if (Y02 > Y12)
      _2 = Y02, Y02 = Y12, Y12 = _2;
    return graticule2.precision(precision);
  };
  graticule2.extentMinor = function(_2) {
    if (!arguments.length)
      return [[x05, y05], [x12, y12]];
    x05 = +_2[0][0], x12 = +_2[1][0];
    y05 = +_2[0][1], y12 = +_2[1][1];
    if (x05 > x12)
      _2 = x05, x05 = x12, x12 = _2;
    if (y05 > y12)
      _2 = y05, y05 = y12, y12 = _2;
    return graticule2.precision(precision);
  };
  graticule2.step = function(_2) {
    if (!arguments.length)
      return graticule2.stepMinor();
    return graticule2.stepMajor(_2).stepMinor(_2);
  };
  graticule2.stepMajor = function(_2) {
    if (!arguments.length)
      return [DX, DY];
    DX = +_2[0], DY = +_2[1];
    return graticule2;
  };
  graticule2.stepMinor = function(_2) {
    if (!arguments.length)
      return [dx, dy];
    dx = +_2[0], dy = +_2[1];
    return graticule2;
  };
  graticule2.precision = function(_2) {
    if (!arguments.length)
      return precision;
    precision = +_2;
    x3 = graticuleX(y05, y12, 90);
    y3 = graticuleY(x05, x12, precision);
    X = graticuleX(Y02, Y12, 90);
    Y = graticuleY(X02, X12, precision);
    return graticule2;
  };
  return graticule2.extentMajor([[-180, -90 + epsilon3], [180, 90 - epsilon3]]).extentMinor([[-180, -80 - epsilon3], [180, 80 + epsilon3]]);
}
function graticule10() {
  return graticule()();
}

// node_modules/d3-geo/src/identity.js
var identity_default6 = (x3) => x3;

// node_modules/d3-geo/src/path/area.js
var areaSum2 = new Adder();
var areaRingSum2 = new Adder();
var x00;
var y00;
var x0;
var y0;
var areaStream2 = {
  point: noop2,
  lineStart: noop2,
  lineEnd: noop2,
  polygonStart: function() {
    areaStream2.lineStart = areaRingStart;
    areaStream2.lineEnd = areaRingEnd;
  },
  polygonEnd: function() {
    areaStream2.lineStart = areaStream2.lineEnd = areaStream2.point = noop2;
    areaSum2.add(abs2(areaRingSum2));
    areaRingSum2 = new Adder();
  },
  result: function() {
    var area2 = areaSum2 / 2;
    areaSum2 = new Adder();
    return area2;
  }
};
function areaRingStart() {
  areaStream2.point = areaPointFirst;
}
function areaPointFirst(x3, y3) {
  areaStream2.point = areaPoint;
  x00 = x0 = x3, y00 = y0 = y3;
}
function areaPoint(x3, y3) {
  areaRingSum2.add(y0 * x3 - x0 * y3);
  x0 = x3, y0 = y3;
}
function areaRingEnd() {
  areaPoint(x00, y00);
}
var area_default2 = areaStream2;

// node_modules/d3-geo/src/path/bounds.js
var x02 = Infinity;
var y02 = x02;
var x1 = -x02;
var y1 = x1;
var boundsStream = {
  point: boundsPoint,
  lineStart: noop2,
  lineEnd: noop2,
  polygonStart: noop2,
  polygonEnd: noop2,
  result: function() {
    var bounds = [[x02, y02], [x1, y1]];
    x1 = y1 = -(y02 = x02 = Infinity);
    return bounds;
  }
};
function boundsPoint(x3, y3) {
  if (x3 < x02)
    x02 = x3;
  if (x3 > x1)
    x1 = x3;
  if (y3 < y02)
    y02 = y3;
  if (y3 > y1)
    y1 = y3;
}
var bounds_default = boundsStream;

// node_modules/d3-geo/src/path/centroid.js
var X0 = 0;
var Y0 = 0;
var Z0 = 0;
var X1 = 0;
var Y1 = 0;
var Z1 = 0;
var X2 = 0;
var Y2 = 0;
var Z2 = 0;
var x002;
var y002;
var x03;
var y03;
var centroidStream = {
  point: centroidPoint,
  lineStart: centroidLineStart,
  lineEnd: centroidLineEnd,
  polygonStart: function() {
    centroidStream.lineStart = centroidRingStart;
    centroidStream.lineEnd = centroidRingEnd;
  },
  polygonEnd: function() {
    centroidStream.point = centroidPoint;
    centroidStream.lineStart = centroidLineStart;
    centroidStream.lineEnd = centroidLineEnd;
  },
  result: function() {
    var centroid = Z2 ? [X2 / Z2, Y2 / Z2] : Z1 ? [X1 / Z1, Y1 / Z1] : Z0 ? [X0 / Z0, Y0 / Z0] : [NaN, NaN];
    X0 = Y0 = Z0 = X1 = Y1 = Z1 = X2 = Y2 = Z2 = 0;
    return centroid;
  }
};
function centroidPoint(x3, y3) {
  X0 += x3;
  Y0 += y3;
  ++Z0;
}
function centroidLineStart() {
  centroidStream.point = centroidPointFirstLine;
}
function centroidPointFirstLine(x3, y3) {
  centroidStream.point = centroidPointLine;
  centroidPoint(x03 = x3, y03 = y3);
}
function centroidPointLine(x3, y3) {
  var dx = x3 - x03, dy = y3 - y03, z = sqrt2(dx * dx + dy * dy);
  X1 += z * (x03 + x3) / 2;
  Y1 += z * (y03 + y3) / 2;
  Z1 += z;
  centroidPoint(x03 = x3, y03 = y3);
}
function centroidLineEnd() {
  centroidStream.point = centroidPoint;
}
function centroidRingStart() {
  centroidStream.point = centroidPointFirstRing;
}
function centroidRingEnd() {
  centroidPointRing(x002, y002);
}
function centroidPointFirstRing(x3, y3) {
  centroidStream.point = centroidPointRing;
  centroidPoint(x002 = x03 = x3, y002 = y03 = y3);
}
function centroidPointRing(x3, y3) {
  var dx = x3 - x03, dy = y3 - y03, z = sqrt2(dx * dx + dy * dy);
  X1 += z * (x03 + x3) / 2;
  Y1 += z * (y03 + y3) / 2;
  Z1 += z;
  z = y03 * x3 - x03 * y3;
  X2 += z * (x03 + x3);
  Y2 += z * (y03 + y3);
  Z2 += z * 3;
  centroidPoint(x03 = x3, y03 = y3);
}
var centroid_default = centroidStream;

// node_modules/d3-geo/src/path/context.js
function PathContext(context) {
  this._context = context;
}
PathContext.prototype = {
  _radius: 4.5,
  pointRadius: function(_2) {
    return this._radius = _2, this;
  },
  polygonStart: function() {
    this._line = 0;
  },
  polygonEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line === 0)
      this._context.closePath();
    this._point = NaN;
  },
  point: function(x3, y3) {
    switch (this._point) {
      case 0: {
        this._context.moveTo(x3, y3);
        this._point = 1;
        break;
      }
      case 1: {
        this._context.lineTo(x3, y3);
        break;
      }
      default: {
        this._context.moveTo(x3 + this._radius, y3);
        this._context.arc(x3, y3, this._radius, 0, tau3);
        break;
      }
    }
  },
  result: noop2
};

// node_modules/d3-geo/src/path/measure.js
var lengthSum = new Adder();
var lengthRing;
var x003;
var y003;
var x04;
var y04;
var lengthStream = {
  point: noop2,
  lineStart: function() {
    lengthStream.point = lengthPointFirst;
  },
  lineEnd: function() {
    if (lengthRing)
      lengthPoint(x003, y003);
    lengthStream.point = noop2;
  },
  polygonStart: function() {
    lengthRing = true;
  },
  polygonEnd: function() {
    lengthRing = null;
  },
  result: function() {
    var length5 = +lengthSum;
    lengthSum = new Adder();
    return length5;
  }
};
function lengthPointFirst(x3, y3) {
  lengthStream.point = lengthPoint;
  x003 = x04 = x3, y003 = y04 = y3;
}
function lengthPoint(x3, y3) {
  x04 -= x3, y04 -= y3;
  lengthSum.add(sqrt2(x04 * x04 + y04 * y04));
  x04 = x3, y04 = y3;
}
var measure_default = lengthStream;

// node_modules/d3-geo/src/path/string.js
var cacheDigits;
var cacheAppend;
var cacheRadius;
var cacheCircle;
var PathString = class {
  constructor(digits) {
    this._append = digits == null ? append2 : appendRound2(digits);
    this._radius = 4.5;
    this._ = "";
  }
  pointRadius(_2) {
    this._radius = +_2;
    return this;
  }
  polygonStart() {
    this._line = 0;
  }
  polygonEnd() {
    this._line = NaN;
  }
  lineStart() {
    this._point = 0;
  }
  lineEnd() {
    if (this._line === 0)
      this._ += "Z";
    this._point = NaN;
  }
  point(x3, y3) {
    switch (this._point) {
      case 0: {
        this._append`M${x3},${y3}`;
        this._point = 1;
        break;
      }
      case 1: {
        this._append`L${x3},${y3}`;
        break;
      }
      default: {
        this._append`M${x3},${y3}`;
        if (this._radius !== cacheRadius || this._append !== cacheAppend) {
          const r = this._radius;
          const s2 = this._;
          this._ = "";
          this._append`m0,${r}a${r},${r} 0 1,1 0,${-2 * r}a${r},${r} 0 1,1 0,${2 * r}z`;
          cacheRadius = r;
          cacheAppend = this._append;
          cacheCircle = this._;
          this._ = s2;
        }
        this._ += cacheCircle;
        break;
      }
    }
  }
  result() {
    const result2 = this._;
    this._ = "";
    return result2.length ? result2 : null;
  }
};
function append2(strings) {
  let i = 1;
  this._ += strings[0];
  for (const j = strings.length; i < j; ++i) {
    this._ += arguments[i] + strings[i];
  }
}
function appendRound2(digits) {
  const d2 = Math.floor(digits);
  if (!(d2 >= 0))
    throw new RangeError(`invalid digits: ${digits}`);
  if (d2 > 15)
    return append2;
  if (d2 !== cacheDigits) {
    const k2 = 10 ** d2;
    cacheDigits = d2;
    cacheAppend = function append3(strings) {
      let i = 1;
      this._ += strings[0];
      for (const j = strings.length; i < j; ++i) {
        this._ += Math.round(arguments[i] * k2) / k2 + strings[i];
      }
    };
  }
  return cacheAppend;
}

// node_modules/d3-geo/src/path/index.js
function path_default2(projection3, context) {
  let digits = 3, pointRadius = 4.5, projectionStream, contextStream;
  function path2(object) {
    if (object) {
      if (typeof pointRadius === "function")
        contextStream.pointRadius(+pointRadius.apply(this, arguments));
      stream_default(object, projectionStream(contextStream));
    }
    return contextStream.result();
  }
  path2.area = function(object) {
    stream_default(object, projectionStream(area_default2));
    return area_default2.result();
  };
  path2.measure = function(object) {
    stream_default(object, projectionStream(measure_default));
    return measure_default.result();
  };
  path2.bounds = function(object) {
    stream_default(object, projectionStream(bounds_default));
    return bounds_default.result();
  };
  path2.centroid = function(object) {
    stream_default(object, projectionStream(centroid_default));
    return centroid_default.result();
  };
  path2.projection = function(_2) {
    if (!arguments.length)
      return projection3;
    projectionStream = _2 == null ? (projection3 = null, identity_default6) : (projection3 = _2).stream;
    return path2;
  };
  path2.context = function(_2) {
    if (!arguments.length)
      return context;
    contextStream = _2 == null ? (context = null, new PathString(digits)) : new PathContext(context = _2);
    if (typeof pointRadius !== "function")
      contextStream.pointRadius(pointRadius);
    return path2;
  };
  path2.pointRadius = function(_2) {
    if (!arguments.length)
      return pointRadius;
    pointRadius = typeof _2 === "function" ? _2 : (contextStream.pointRadius(+_2), +_2);
    return path2;
  };
  path2.digits = function(_2) {
    if (!arguments.length)
      return digits;
    if (_2 == null)
      digits = null;
    else {
      const d2 = Math.floor(_2);
      if (!(d2 >= 0))
        throw new RangeError(`invalid digits: ${_2}`);
      digits = d2;
    }
    if (context === null)
      contextStream = new PathString(digits);
    return path2;
  };
  return path2.projection(projection3).digits(digits).context(context);
}

// node_modules/d3-geo/src/transform.js
function transformer(methods2) {
  return function(stream) {
    var s2 = new TransformStream();
    for (var key in methods2)
      s2[key] = methods2[key];
    s2.stream = stream;
    return s2;
  };
}
function TransformStream() {
}
TransformStream.prototype = {
  constructor: TransformStream,
  point: function(x3, y3) {
    this.stream.point(x3, y3);
  },
  sphere: function() {
    this.stream.sphere();
  },
  lineStart: function() {
    this.stream.lineStart();
  },
  lineEnd: function() {
    this.stream.lineEnd();
  },
  polygonStart: function() {
    this.stream.polygonStart();
  },
  polygonEnd: function() {
    this.stream.polygonEnd();
  }
};

// node_modules/d3-geo/src/projection/fit.js
function fit(projection3, fitBounds, object) {
  var clip = projection3.clipExtent && projection3.clipExtent();
  projection3.scale(150).translate([0, 0]);
  if (clip != null)
    projection3.clipExtent(null);
  stream_default(object, projection3.stream(bounds_default));
  fitBounds(bounds_default.result());
  if (clip != null)
    projection3.clipExtent(clip);
  return projection3;
}
function fitExtent(projection3, extent2, object) {
  return fit(projection3, function(b) {
    var w = extent2[1][0] - extent2[0][0], h = extent2[1][1] - extent2[0][1], k2 = Math.min(w / (b[1][0] - b[0][0]), h / (b[1][1] - b[0][1])), x3 = +extent2[0][0] + (w - k2 * (b[1][0] + b[0][0])) / 2, y3 = +extent2[0][1] + (h - k2 * (b[1][1] + b[0][1])) / 2;
    projection3.scale(150 * k2).translate([x3, y3]);
  }, object);
}
function fitSize(projection3, size5, object) {
  return fitExtent(projection3, [[0, 0], size5], object);
}
function fitWidth(projection3, width, object) {
  return fit(projection3, function(b) {
    var w = +width, k2 = w / (b[1][0] - b[0][0]), x3 = (w - k2 * (b[1][0] + b[0][0])) / 2, y3 = -k2 * b[0][1];
    projection3.scale(150 * k2).translate([x3, y3]);
  }, object);
}
function fitHeight(projection3, height, object) {
  return fit(projection3, function(b) {
    var h = +height, k2 = h / (b[1][1] - b[0][1]), x3 = -k2 * b[0][0], y3 = (h - k2 * (b[1][1] + b[0][1])) / 2;
    projection3.scale(150 * k2).translate([x3, y3]);
  }, object);
}

// node_modules/d3-geo/src/projection/resample.js
var maxDepth = 16;
var cosMinDistance = cos3(30 * radians);
function resample_default(project, delta2) {
  return +delta2 ? resample(project, delta2) : resampleNone(project);
}
function resampleNone(project) {
  return transformer({
    point: function(x3, y3) {
      x3 = project(x3, y3);
      this.stream.point(x3[0], x3[1]);
    }
  });
}
function resample(project, delta2) {
  function resampleLineTo(x05, y05, lambda0, a0, b0, c0, x12, y12, lambda1, a1, b1, c1, depth, stream) {
    var dx = x12 - x05, dy = y12 - y05, d2 = dx * dx + dy * dy;
    if (d2 > 4 * delta2 && depth--) {
      var a4 = a0 + a1, b = b0 + b1, c5 = c0 + c1, m3 = sqrt2(a4 * a4 + b * b + c5 * c5), phi2 = asin2(c5 /= m3), lambda2 = abs2(abs2(c5) - 1) < epsilon3 || abs2(lambda0 - lambda1) < epsilon3 ? (lambda0 + lambda1) / 2 : atan22(b, a4), p2 = project(lambda2, phi2), x22 = p2[0], y22 = p2[1], dx2 = x22 - x05, dy2 = y22 - y05, dz = dy * dx2 - dx * dy2;
      if (dz * dz / d2 > delta2 || abs2((dx * dx2 + dy * dy2) / d2 - 0.5) > 0.3 || a0 * a1 + b0 * b1 + c0 * c1 < cosMinDistance) {
        resampleLineTo(x05, y05, lambda0, a0, b0, c0, x22, y22, lambda2, a4 /= m3, b /= m3, c5, depth, stream);
        stream.point(x22, y22);
        resampleLineTo(x22, y22, lambda2, a4, b, c5, x12, y12, lambda1, a1, b1, c1, depth, stream);
      }
    }
  }
  return function(stream) {
    var lambda00, x004, y004, a00, b00, c00, lambda0, x05, y05, a0, b0, c0;
    var resampleStream = {
      point: point7,
      lineStart,
      lineEnd,
      polygonStart: function() {
        stream.polygonStart();
        resampleStream.lineStart = ringStart;
      },
      polygonEnd: function() {
        stream.polygonEnd();
        resampleStream.lineStart = lineStart;
      }
    };
    function point7(x3, y3) {
      x3 = project(x3, y3);
      stream.point(x3[0], x3[1]);
    }
    function lineStart() {
      x05 = NaN;
      resampleStream.point = linePoint;
      stream.lineStart();
    }
    function linePoint(lambda, phi2) {
      var c5 = cartesian2([lambda, phi2]), p2 = project(lambda, phi2);
      resampleLineTo(x05, y05, lambda0, a0, b0, c0, x05 = p2[0], y05 = p2[1], lambda0 = lambda, a0 = c5[0], b0 = c5[1], c0 = c5[2], maxDepth, stream);
      stream.point(x05, y05);
    }
    function lineEnd() {
      resampleStream.point = point7;
      stream.lineEnd();
    }
    function ringStart() {
      lineStart();
      resampleStream.point = ringPoint;
      resampleStream.lineEnd = ringEnd;
    }
    function ringPoint(lambda, phi2) {
      linePoint(lambda00 = lambda, phi2), x004 = x05, y004 = y05, a00 = a0, b00 = b0, c00 = c0;
      resampleStream.point = linePoint;
    }
    function ringEnd() {
      resampleLineTo(x05, y05, lambda0, a0, b0, c0, x004, y004, lambda00, a00, b00, c00, maxDepth, stream);
      resampleStream.lineEnd = lineEnd;
      lineEnd();
    }
    return resampleStream;
  };
}

// node_modules/d3-geo/src/projection/index.js
var transformRadians = transformer({
  point: function(x3, y3) {
    this.stream.point(x3 * radians, y3 * radians);
  }
});
function transformRotate(rotate6) {
  return transformer({
    point: function(x3, y3) {
      var r = rotate6(x3, y3);
      return this.stream.point(r[0], r[1]);
    }
  });
}
function scaleTranslate(k2, dx, dy, sx, sy) {
  function transform3(x3, y3) {
    x3 *= sx;
    y3 *= sy;
    return [dx + k2 * x3, dy - k2 * y3];
  }
  transform3.invert = function(x3, y3) {
    return [(x3 - dx) / k2 * sx, (dy - y3) / k2 * sy];
  };
  return transform3;
}
function scaleTranslateRotate(k2, dx, dy, sx, sy, alpha) {
  if (!alpha)
    return scaleTranslate(k2, dx, dy, sx, sy);
  var cosAlpha = cos3(alpha), sinAlpha = sin2(alpha), a4 = cosAlpha * k2, b = sinAlpha * k2, ai = cosAlpha / k2, bi = sinAlpha / k2, ci = (sinAlpha * dy - cosAlpha * dx) / k2, fi = (sinAlpha * dx + cosAlpha * dy) / k2;
  function transform3(x3, y3) {
    x3 *= sx;
    y3 *= sy;
    return [a4 * x3 - b * y3 + dx, dy - b * x3 - a4 * y3];
  }
  transform3.invert = function(x3, y3) {
    return [sx * (ai * x3 - bi * y3 + ci), sy * (fi - bi * x3 - ai * y3)];
  };
  return transform3;
}
function projection2(project) {
  return projectionMutator(function() {
    return project;
  })();
}
function projectionMutator(projectAt) {
  var project, k2 = 150, x3 = 480, y3 = 250, lambda = 0, phi2 = 0, deltaLambda = 0, deltaPhi = 0, deltaGamma = 0, rotate6, alpha = 0, sx = 1, sy = 1, theta = null, preclip = antimeridian_default, x05 = null, y05, x12, y12, postclip = identity_default6, delta2 = 0.5, projectResample, projectTransform, projectRotateTransform, cache2, cacheStream;
  function projection3(point7) {
    return projectRotateTransform(point7[0] * radians, point7[1] * radians);
  }
  function invert6(point7) {
    point7 = projectRotateTransform.invert(point7[0], point7[1]);
    return point7 && [point7[0] * degrees, point7[1] * degrees];
  }
  projection3.stream = function(stream) {
    return cache2 && cacheStream === stream ? cache2 : cache2 = transformRadians(transformRotate(rotate6)(preclip(projectResample(postclip(cacheStream = stream)))));
  };
  projection3.preclip = function(_2) {
    return arguments.length ? (preclip = _2, theta = void 0, reset()) : preclip;
  };
  projection3.postclip = function(_2) {
    return arguments.length ? (postclip = _2, x05 = y05 = x12 = y12 = null, reset()) : postclip;
  };
  projection3.clipAngle = function(_2) {
    return arguments.length ? (preclip = +_2 ? circle_default2(theta = _2 * radians) : (theta = null, antimeridian_default), reset()) : theta * degrees;
  };
  projection3.clipExtent = function(_2) {
    return arguments.length ? (postclip = _2 == null ? (x05 = y05 = x12 = y12 = null, identity_default6) : clipRectangle(x05 = +_2[0][0], y05 = +_2[0][1], x12 = +_2[1][0], y12 = +_2[1][1]), reset()) : x05 == null ? null : [[x05, y05], [x12, y12]];
  };
  projection3.scale = function(_2) {
    return arguments.length ? (k2 = +_2, recenter()) : k2;
  };
  projection3.translate = function(_2) {
    return arguments.length ? (x3 = +_2[0], y3 = +_2[1], recenter()) : [x3, y3];
  };
  projection3.center = function(_2) {
    return arguments.length ? (lambda = _2[0] % 360 * radians, phi2 = _2[1] % 360 * radians, recenter()) : [lambda * degrees, phi2 * degrees];
  };
  projection3.rotate = function(_2) {
    return arguments.length ? (deltaLambda = _2[0] % 360 * radians, deltaPhi = _2[1] % 360 * radians, deltaGamma = _2.length > 2 ? _2[2] % 360 * radians : 0, recenter()) : [deltaLambda * degrees, deltaPhi * degrees, deltaGamma * degrees];
  };
  projection3.angle = function(_2) {
    return arguments.length ? (alpha = _2 % 360 * radians, recenter()) : alpha * degrees;
  };
  projection3.reflectX = function(_2) {
    return arguments.length ? (sx = _2 ? -1 : 1, recenter()) : sx < 0;
  };
  projection3.reflectY = function(_2) {
    return arguments.length ? (sy = _2 ? -1 : 1, recenter()) : sy < 0;
  };
  projection3.precision = function(_2) {
    return arguments.length ? (projectResample = resample_default(projectTransform, delta2 = _2 * _2), reset()) : sqrt2(delta2);
  };
  projection3.fitExtent = function(extent2, object) {
    return fitExtent(projection3, extent2, object);
  };
  projection3.fitSize = function(size5, object) {
    return fitSize(projection3, size5, object);
  };
  projection3.fitWidth = function(width, object) {
    return fitWidth(projection3, width, object);
  };
  projection3.fitHeight = function(height, object) {
    return fitHeight(projection3, height, object);
  };
  function recenter() {
    var center2 = scaleTranslateRotate(k2, 0, 0, sx, sy, alpha).apply(null, project(lambda, phi2)), transform3 = scaleTranslateRotate(k2, x3 - center2[0], y3 - center2[1], sx, sy, alpha);
    rotate6 = rotateRadians(deltaLambda, deltaPhi, deltaGamma);
    projectTransform = compose_default(project, transform3);
    projectRotateTransform = compose_default(rotate6, projectTransform);
    projectResample = resample_default(projectTransform, delta2);
    return reset();
  }
  function reset() {
    cache2 = cacheStream = null;
    return projection3;
  }
  return function() {
    project = projectAt.apply(this, arguments);
    projection3.invert = project.invert && invert6;
    return recenter();
  };
}

// node_modules/d3-geo/src/projection/conic.js
function conicProjection(projectAt) {
  var phi0 = 0, phi1 = pi3 / 3, m3 = projectionMutator(projectAt), p2 = m3(phi0, phi1);
  p2.parallels = function(_2) {
    return arguments.length ? m3(phi0 = _2[0] * radians, phi1 = _2[1] * radians) : [phi0 * degrees, phi1 * degrees];
  };
  return p2;
}

// node_modules/d3-geo/src/projection/cylindricalEqualArea.js
function cylindricalEqualAreaRaw(phi0) {
  var cosPhi0 = cos3(phi0);
  function forward(lambda, phi2) {
    return [lambda * cosPhi0, sin2(phi2) / cosPhi0];
  }
  forward.invert = function(x3, y3) {
    return [x3 / cosPhi0, asin2(y3 * cosPhi0)];
  };
  return forward;
}

// node_modules/d3-geo/src/projection/conicEqualArea.js
function conicEqualAreaRaw(y05, y12) {
  var sy0 = sin2(y05), n = (sy0 + sin2(y12)) / 2;
  if (abs2(n) < epsilon3)
    return cylindricalEqualAreaRaw(y05);
  var c5 = 1 + sy0 * (2 * n - sy0), r0 = sqrt2(c5) / n;
  function project(x3, y3) {
    var r = sqrt2(c5 - 2 * n * sin2(y3)) / n;
    return [r * sin2(x3 *= n), r0 - r * cos3(x3)];
  }
  project.invert = function(x3, y3) {
    var r0y = r0 - y3, l = atan22(x3, abs2(r0y)) * sign2(r0y);
    if (r0y * n < 0)
      l -= pi3 * sign2(x3) * sign2(r0y);
    return [l / n, asin2((c5 - (x3 * x3 + r0y * r0y) * n * n) / (2 * n))];
  };
  return project;
}
function conicEqualArea_default() {
  return conicProjection(conicEqualAreaRaw).scale(155.424).center([0, 33.6442]);
}

// node_modules/d3-geo/src/projection/albers.js
function albers_default() {
  return conicEqualArea_default().parallels([29.5, 45.5]).scale(1070).translate([480, 250]).rotate([96, 0]).center([-0.6, 38.7]);
}

// node_modules/d3-geo/src/projection/albersUsa.js
function multiplex(streams) {
  var n = streams.length;
  return {
    point: function(x3, y3) {
      var i = -1;
      while (++i < n)
        streams[i].point(x3, y3);
    },
    sphere: function() {
      var i = -1;
      while (++i < n)
        streams[i].sphere();
    },
    lineStart: function() {
      var i = -1;
      while (++i < n)
        streams[i].lineStart();
    },
    lineEnd: function() {
      var i = -1;
      while (++i < n)
        streams[i].lineEnd();
    },
    polygonStart: function() {
      var i = -1;
      while (++i < n)
        streams[i].polygonStart();
    },
    polygonEnd: function() {
      var i = -1;
      while (++i < n)
        streams[i].polygonEnd();
    }
  };
}
function albersUsa_default() {
  var cache2, cacheStream, lower48 = albers_default(), lower48Point, alaska = conicEqualArea_default().rotate([154, 0]).center([-2, 58.5]).parallels([55, 65]), alaskaPoint, hawaii = conicEqualArea_default().rotate([157, 0]).center([-3, 19.9]).parallels([8, 18]), hawaiiPoint, point7, pointStream = { point: function(x3, y3) {
    point7 = [x3, y3];
  } };
  function albersUsa(coordinates) {
    var x3 = coordinates[0], y3 = coordinates[1];
    return point7 = null, (lower48Point.point(x3, y3), point7) || (alaskaPoint.point(x3, y3), point7) || (hawaiiPoint.point(x3, y3), point7);
  }
  albersUsa.invert = function(coordinates) {
    var k2 = lower48.scale(), t = lower48.translate(), x3 = (coordinates[0] - t[0]) / k2, y3 = (coordinates[1] - t[1]) / k2;
    return (y3 >= 0.12 && y3 < 0.234 && x3 >= -0.425 && x3 < -0.214 ? alaska : y3 >= 0.166 && y3 < 0.234 && x3 >= -0.214 && x3 < -0.115 ? hawaii : lower48).invert(coordinates);
  };
  albersUsa.stream = function(stream) {
    return cache2 && cacheStream === stream ? cache2 : cache2 = multiplex([lower48.stream(cacheStream = stream), alaska.stream(stream), hawaii.stream(stream)]);
  };
  albersUsa.precision = function(_2) {
    if (!arguments.length)
      return lower48.precision();
    lower48.precision(_2), alaska.precision(_2), hawaii.precision(_2);
    return reset();
  };
  albersUsa.scale = function(_2) {
    if (!arguments.length)
      return lower48.scale();
    lower48.scale(_2), alaska.scale(_2 * 0.35), hawaii.scale(_2);
    return albersUsa.translate(lower48.translate());
  };
  albersUsa.translate = function(_2) {
    if (!arguments.length)
      return lower48.translate();
    var k2 = lower48.scale(), x3 = +_2[0], y3 = +_2[1];
    lower48Point = lower48.translate(_2).clipExtent([[x3 - 0.455 * k2, y3 - 0.238 * k2], [x3 + 0.455 * k2, y3 + 0.238 * k2]]).stream(pointStream);
    alaskaPoint = alaska.translate([x3 - 0.307 * k2, y3 + 0.201 * k2]).clipExtent([[x3 - 0.425 * k2 + epsilon3, y3 + 0.12 * k2 + epsilon3], [x3 - 0.214 * k2 - epsilon3, y3 + 0.234 * k2 - epsilon3]]).stream(pointStream);
    hawaiiPoint = hawaii.translate([x3 - 0.205 * k2, y3 + 0.212 * k2]).clipExtent([[x3 - 0.214 * k2 + epsilon3, y3 + 0.166 * k2 + epsilon3], [x3 - 0.115 * k2 - epsilon3, y3 + 0.234 * k2 - epsilon3]]).stream(pointStream);
    return reset();
  };
  albersUsa.fitExtent = function(extent2, object) {
    return fitExtent(albersUsa, extent2, object);
  };
  albersUsa.fitSize = function(size5, object) {
    return fitSize(albersUsa, size5, object);
  };
  albersUsa.fitWidth = function(width, object) {
    return fitWidth(albersUsa, width, object);
  };
  albersUsa.fitHeight = function(height, object) {
    return fitHeight(albersUsa, height, object);
  };
  function reset() {
    cache2 = cacheStream = null;
    return albersUsa;
  }
  return albersUsa.scale(1070);
}

// node_modules/d3-geo/src/projection/azimuthal.js
function azimuthalRaw(scale10) {
  return function(x3, y3) {
    var cx = cos3(x3), cy = cos3(y3), k2 = scale10(cx * cy);
    if (k2 === Infinity)
      return [2, 0];
    return [
      k2 * cy * sin2(x3),
      k2 * sin2(y3)
    ];
  };
}
function azimuthalInvert(angle4) {
  return function(x3, y3) {
    var z = sqrt2(x3 * x3 + y3 * y3), c5 = angle4(z), sc = sin2(c5), cc = cos3(c5);
    return [
      atan22(x3 * sc, z * cc),
      asin2(z && y3 * sc / z)
    ];
  };
}

// node_modules/d3-geo/src/projection/azimuthalEqualArea.js
var azimuthalEqualAreaRaw = azimuthalRaw(function(cxcy) {
  return sqrt2(2 / (1 + cxcy));
});
azimuthalEqualAreaRaw.invert = azimuthalInvert(function(z) {
  return 2 * asin2(z / 2);
});
function azimuthalEqualArea_default() {
  return projection2(azimuthalEqualAreaRaw).scale(124.75).clipAngle(180 - 1e-3);
}

// node_modules/d3-geo/src/projection/azimuthalEquidistant.js
var azimuthalEquidistantRaw = azimuthalRaw(function(c5) {
  return (c5 = acos2(c5)) && c5 / sin2(c5);
});
azimuthalEquidistantRaw.invert = azimuthalInvert(function(z) {
  return z;
});
function azimuthalEquidistant_default() {
  return projection2(azimuthalEquidistantRaw).scale(79.4188).clipAngle(180 - 1e-3);
}

// node_modules/d3-geo/src/projection/mercator.js
function mercatorRaw(lambda, phi2) {
  return [lambda, log(tan((halfPi2 + phi2) / 2))];
}
mercatorRaw.invert = function(x3, y3) {
  return [x3, 2 * atan(exp2(y3)) - halfPi2];
};
function mercator_default() {
  return mercatorProjection(mercatorRaw).scale(961 / tau3);
}
function mercatorProjection(project) {
  var m3 = projection2(project), center2 = m3.center, scale10 = m3.scale, translate4 = m3.translate, clipExtent = m3.clipExtent, x05 = null, y05, x12, y12;
  m3.scale = function(_2) {
    return arguments.length ? (scale10(_2), reclip()) : scale10();
  };
  m3.translate = function(_2) {
    return arguments.length ? (translate4(_2), reclip()) : translate4();
  };
  m3.center = function(_2) {
    return arguments.length ? (center2(_2), reclip()) : center2();
  };
  m3.clipExtent = function(_2) {
    return arguments.length ? (_2 == null ? x05 = y05 = x12 = y12 = null : (x05 = +_2[0][0], y05 = +_2[0][1], x12 = +_2[1][0], y12 = +_2[1][1]), reclip()) : x05 == null ? null : [[x05, y05], [x12, y12]];
  };
  function reclip() {
    var k2 = pi3 * scale10(), t = m3(rotation_default(m3.rotate()).invert([0, 0]));
    return clipExtent(x05 == null ? [[t[0] - k2, t[1] - k2], [t[0] + k2, t[1] + k2]] : project === mercatorRaw ? [[Math.max(t[0] - k2, x05), y05], [Math.min(t[0] + k2, x12), y12]] : [[x05, Math.max(t[1] - k2, y05)], [x12, Math.min(t[1] + k2, y12)]]);
  }
  return reclip();
}

// node_modules/d3-geo/src/projection/conicConformal.js
function tany(y3) {
  return tan((halfPi2 + y3) / 2);
}
function conicConformalRaw(y05, y12) {
  var cy0 = cos3(y05), n = y05 === y12 ? sin2(y05) : log(cy0 / cos3(y12)) / log(tany(y12) / tany(y05)), f = cy0 * pow2(tany(y05), n) / n;
  if (!n)
    return mercatorRaw;
  function project(x3, y3) {
    if (f > 0) {
      if (y3 < -halfPi2 + epsilon3)
        y3 = -halfPi2 + epsilon3;
    } else {
      if (y3 > halfPi2 - epsilon3)
        y3 = halfPi2 - epsilon3;
    }
    var r = f / pow2(tany(y3), n);
    return [r * sin2(n * x3), f - r * cos3(n * x3)];
  }
  project.invert = function(x3, y3) {
    var fy = f - y3, r = sign2(n) * sqrt2(x3 * x3 + fy * fy), l = atan22(x3, abs2(fy)) * sign2(fy);
    if (fy * n < 0)
      l -= pi3 * sign2(x3) * sign2(fy);
    return [l / n, 2 * atan(pow2(f / r, 1 / n)) - halfPi2];
  };
  return project;
}
function conicConformal_default() {
  return conicProjection(conicConformalRaw).scale(109.5).parallels([30, 30]);
}

// node_modules/d3-geo/src/projection/equirectangular.js
function equirectangularRaw(lambda, phi2) {
  return [lambda, phi2];
}
equirectangularRaw.invert = equirectangularRaw;
function equirectangular_default() {
  return projection2(equirectangularRaw).scale(152.63);
}

// node_modules/d3-geo/src/projection/conicEquidistant.js
function conicEquidistantRaw(y05, y12) {
  var cy0 = cos3(y05), n = y05 === y12 ? sin2(y05) : (cy0 - cos3(y12)) / (y12 - y05), g = cy0 / n + y05;
  if (abs2(n) < epsilon3)
    return equirectangularRaw;
  function project(x3, y3) {
    var gy = g - y3, nx = n * x3;
    return [gy * sin2(nx), g - gy * cos3(nx)];
  }
  project.invert = function(x3, y3) {
    var gy = g - y3, l = atan22(x3, abs2(gy)) * sign2(gy);
    if (gy * n < 0)
      l -= pi3 * sign2(x3) * sign2(gy);
    return [l / n, g - sign2(n) * sqrt2(x3 * x3 + gy * gy)];
  };
  return project;
}
function conicEquidistant_default() {
  return conicProjection(conicEquidistantRaw).scale(131.154).center([0, 13.9389]);
}

// node_modules/d3-geo/src/projection/equalEarth.js
var A1 = 1.340264;
var A22 = -0.081106;
var A3 = 893e-6;
var A4 = 3796e-6;
var M = sqrt2(3) / 2;
var iterations = 12;
function equalEarthRaw(lambda, phi2) {
  var l = asin2(M * sin2(phi2)), l2 = l * l, l6 = l2 * l2 * l2;
  return [
    lambda * cos3(l) / (M * (A1 + 3 * A22 * l2 + l6 * (7 * A3 + 9 * A4 * l2))),
    l * (A1 + A22 * l2 + l6 * (A3 + A4 * l2))
  ];
}
equalEarthRaw.invert = function(x3, y3) {
  var l = y3, l2 = l * l, l6 = l2 * l2 * l2;
  for (var i = 0, delta, fy, fpy; i < iterations; ++i) {
    fy = l * (A1 + A22 * l2 + l6 * (A3 + A4 * l2)) - y3;
    fpy = A1 + 3 * A22 * l2 + l6 * (7 * A3 + 9 * A4 * l2);
    l -= delta = fy / fpy, l2 = l * l, l6 = l2 * l2 * l2;
    if (abs2(delta) < epsilon22)
      break;
  }
  return [
    M * x3 * (A1 + 3 * A22 * l2 + l6 * (7 * A3 + 9 * A4 * l2)) / cos3(l),
    asin2(sin2(l) / M)
  ];
};
function equalEarth_default() {
  return projection2(equalEarthRaw).scale(177.158);
}

// node_modules/d3-geo/src/projection/gnomonic.js
function gnomonicRaw(x3, y3) {
  var cy = cos3(y3), k2 = cos3(x3) * cy;
  return [cy * sin2(x3) / k2, sin2(y3) / k2];
}
gnomonicRaw.invert = azimuthalInvert(atan);
function gnomonic_default() {
  return projection2(gnomonicRaw).scale(144.049).clipAngle(60);
}

// node_modules/d3-geo/src/projection/identity.js
function identity_default7() {
  var k2 = 1, tx = 0, ty = 0, sx = 1, sy = 1, alpha = 0, ca, sa, x05 = null, y05, x12, y12, kx2 = 1, ky2 = 1, transform3 = transformer({
    point: function(x3, y3) {
      var p2 = projection3([x3, y3]);
      this.stream.point(p2[0], p2[1]);
    }
  }), postclip = identity_default6, cache2, cacheStream;
  function reset() {
    kx2 = k2 * sx;
    ky2 = k2 * sy;
    cache2 = cacheStream = null;
    return projection3;
  }
  function projection3(p2) {
    var x3 = p2[0] * kx2, y3 = p2[1] * ky2;
    if (alpha) {
      var t = y3 * ca - x3 * sa;
      x3 = x3 * ca + y3 * sa;
      y3 = t;
    }
    return [x3 + tx, y3 + ty];
  }
  projection3.invert = function(p2) {
    var x3 = p2[0] - tx, y3 = p2[1] - ty;
    if (alpha) {
      var t = y3 * ca + x3 * sa;
      x3 = x3 * ca - y3 * sa;
      y3 = t;
    }
    return [x3 / kx2, y3 / ky2];
  };
  projection3.stream = function(stream) {
    return cache2 && cacheStream === stream ? cache2 : cache2 = transform3(postclip(cacheStream = stream));
  };
  projection3.postclip = function(_2) {
    return arguments.length ? (postclip = _2, x05 = y05 = x12 = y12 = null, reset()) : postclip;
  };
  projection3.clipExtent = function(_2) {
    return arguments.length ? (postclip = _2 == null ? (x05 = y05 = x12 = y12 = null, identity_default6) : clipRectangle(x05 = +_2[0][0], y05 = +_2[0][1], x12 = +_2[1][0], y12 = +_2[1][1]), reset()) : x05 == null ? null : [[x05, y05], [x12, y12]];
  };
  projection3.scale = function(_2) {
    return arguments.length ? (k2 = +_2, reset()) : k2;
  };
  projection3.translate = function(_2) {
    return arguments.length ? (tx = +_2[0], ty = +_2[1], reset()) : [tx, ty];
  };
  projection3.angle = function(_2) {
    return arguments.length ? (alpha = _2 % 360 * radians, sa = sin2(alpha), ca = cos3(alpha), reset()) : alpha * degrees;
  };
  projection3.reflectX = function(_2) {
    return arguments.length ? (sx = _2 ? -1 : 1, reset()) : sx < 0;
  };
  projection3.reflectY = function(_2) {
    return arguments.length ? (sy = _2 ? -1 : 1, reset()) : sy < 0;
  };
  projection3.fitExtent = function(extent2, object) {
    return fitExtent(projection3, extent2, object);
  };
  projection3.fitSize = function(size5, object) {
    return fitSize(projection3, size5, object);
  };
  projection3.fitWidth = function(width, object) {
    return fitWidth(projection3, width, object);
  };
  projection3.fitHeight = function(height, object) {
    return fitHeight(projection3, height, object);
  };
  return projection3;
}

// node_modules/d3-geo/src/projection/naturalEarth1.js
function naturalEarth1Raw(lambda, phi2) {
  var phi22 = phi2 * phi2, phi4 = phi22 * phi22;
  return [
    lambda * (0.8707 - 0.131979 * phi22 + phi4 * (-0.013791 + phi4 * (3971e-6 * phi22 - 1529e-6 * phi4))),
    phi2 * (1.007226 + phi22 * (0.015085 + phi4 * (-0.044475 + 0.028874 * phi22 - 5916e-6 * phi4)))
  ];
}
naturalEarth1Raw.invert = function(x3, y3) {
  var phi2 = y3, i = 25, delta;
  do {
    var phi22 = phi2 * phi2, phi4 = phi22 * phi22;
    phi2 -= delta = (phi2 * (1.007226 + phi22 * (0.015085 + phi4 * (-0.044475 + 0.028874 * phi22 - 5916e-6 * phi4))) - y3) / (1.007226 + phi22 * (0.015085 * 3 + phi4 * (-0.044475 * 7 + 0.028874 * 9 * phi22 - 5916e-6 * 11 * phi4)));
  } while (abs2(delta) > epsilon3 && --i > 0);
  return [
    x3 / (0.8707 + (phi22 = phi2 * phi2) * (-0.131979 + phi22 * (-0.013791 + phi22 * phi22 * phi22 * (3971e-6 - 1529e-6 * phi22)))),
    phi2
  ];
};
function naturalEarth1_default() {
  return projection2(naturalEarth1Raw).scale(175.295);
}

// node_modules/d3-geo/src/projection/orthographic.js
function orthographicRaw(x3, y3) {
  return [cos3(y3) * sin2(x3), sin2(y3)];
}
orthographicRaw.invert = azimuthalInvert(asin2);
function orthographic_default() {
  return projection2(orthographicRaw).scale(249.5).clipAngle(90 + epsilon3);
}

// node_modules/d3-geo/src/projection/stereographic.js
function stereographicRaw(x3, y3) {
  var cy = cos3(y3), k2 = 1 + cos3(x3) * cy;
  return [cy * sin2(x3) / k2, sin2(y3) / k2];
}
stereographicRaw.invert = azimuthalInvert(function(z) {
  return 2 * atan(z);
});
function stereographic_default() {
  return projection2(stereographicRaw).scale(250).clipAngle(142);
}

// node_modules/d3-geo/src/projection/transverseMercator.js
function transverseMercatorRaw(lambda, phi2) {
  return [log(tan((halfPi2 + phi2) / 2)), -lambda];
}
transverseMercatorRaw.invert = function(x3, y3) {
  return [-y3, 2 * atan(exp2(x3)) - halfPi2];
};
function transverseMercator_default() {
  var m3 = mercatorProjection(transverseMercatorRaw), center2 = m3.center, rotate6 = m3.rotate;
  m3.center = function(_2) {
    return arguments.length ? center2([-_2[1], _2[0]]) : (_2 = center2(), [_2[1], -_2[0]]);
  };
  m3.rotate = function(_2) {
    return arguments.length ? rotate6([_2[0], _2[1], _2.length > 2 ? _2[2] + 90 : 90]) : (_2 = rotate6(), [_2[0], _2[1], _2[2] - 90]);
  };
  return rotate6([0, 0, 90]).scale(159.155);
}

// node_modules/@antv/g2/esm/composition/d3Projection.js
var d3Projection_exports = {};
__export(d3Projection_exports, {
  geoAlbers: () => albers_default,
  geoAlbersUsa: () => albersUsa_default,
  geoAzimuthalEqualArea: () => azimuthalEqualArea_default,
  geoAzimuthalEqualAreaRaw: () => azimuthalEqualAreaRaw,
  geoAzimuthalEquidistant: () => azimuthalEquidistant_default,
  geoAzimuthalEquidistantRaw: () => azimuthalEquidistantRaw,
  geoConicConformal: () => conicConformal_default,
  geoConicConformalRaw: () => conicConformalRaw,
  geoConicEqualArea: () => conicEqualArea_default,
  geoConicEqualAreaRaw: () => conicEqualAreaRaw,
  geoConicEquidistant: () => conicEquidistant_default,
  geoConicEquidistantRaw: () => conicEquidistantRaw,
  geoEqualEarth: () => equalEarth_default,
  geoEqualEarthRaw: () => equalEarthRaw,
  geoEquirectangular: () => equirectangular_default,
  geoEquirectangularRaw: () => equirectangularRaw,
  geoGnomonic: () => gnomonic_default,
  geoGnomonicRaw: () => gnomonicRaw,
  geoIdentity: () => identity_default7,
  geoMercator: () => mercator_default,
  geoMercatorRaw: () => mercatorRaw,
  geoNaturalEarth1: () => naturalEarth1_default,
  geoNaturalEarth1Raw: () => naturalEarth1Raw,
  geoOrthographic: () => orthographic_default,
  geoOrthographicRaw: () => orthographicRaw,
  geoProjection: () => projection2,
  geoProjectionMutator: () => projectionMutator,
  geoStereographic: () => stereographic_default,
  geoStereographicRaw: () => stereographicRaw,
  geoTransverseMercator: () => transverseMercator_default,
  geoTransverseMercatorRaw: () => transverseMercatorRaw
});

// node_modules/@antv/g2/esm/composition/geoView.js
var __rest70 = function(s2, e) {
  var t = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
      t[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t[p2[i]] = s2[p2[i]];
    }
  return t;
};
function normalizeProjection(type) {
  if (typeof type === "function")
    return type;
  const name2 = `geo${upper_first_default(type)}`;
  const projection3 = d3Projection_exports[name2];
  if (!projection3)
    throw new Error(`Unknown coordinate: ${type}`);
  return projection3;
}
function mergeGeoJSON(gjs) {
  return {
    type: "FeatureCollection",
    features: gjs.flatMap((gj) => normalizeGeoJSON(gj).features)
  };
}
function normalizeGeoJSON(gj) {
  const types = {
    Point: "geometry",
    MultiPoint: "geometry",
    LineString: "geometry",
    MultiLineString: "geometry",
    Polygon: "geometry",
    MultiPolygon: "geometry",
    GeometryCollection: "geometry",
    Feature: "feature",
    FeatureCollection: "featureCollection"
  };
  if (!gj || !gj.type)
    return null;
  const type = types[gj.type];
  if (!type)
    return null;
  if (type === "geometry") {
    return {
      type: "FeatureCollection",
      features: [
        {
          type: "Feature",
          properties: {},
          geometry: gj
        }
      ]
    };
  } else if (type === "feature") {
    return {
      type: "FeatureCollection",
      features: [gj]
    };
  } else if (type === "featureCollection") {
    return gj;
  }
}
function setProjectionOptions(projection3, options) {
  var _a2;
  for (const [key, value2] of Object.entries(options)) {
    (_a2 = projection3[key]) === null || _a2 === void 0 ? void 0 : _a2.call(projection3, value2);
  }
}
function setProjectionSize(projection3, nodes, layout, options) {
  const defaultOutline = () => {
    const geoNodes = nodes.filter(isGeoPath);
    const sphere = geoNodes.find((d2) => d2.sphere);
    if (sphere)
      return { type: "Sphere" };
    return mergeGeoJSON(geoNodes.filter((d2) => !d2.sphere).flatMap((d2) => d2.data.value));
  };
  const { outline = defaultOutline() } = options;
  const { size: size5 = "fitExtent" } = options;
  if (size5 === "fitExtent") {
    return setFitExtent(projection3, outline, layout);
  } else if (size5 === "fitWidth") {
    return setFitWidth(projection3, outline, layout);
  }
}
function setFitExtent(projection3, object, layout) {
  const { x: x3, y: y3, width, height } = layout;
  projection3.fitExtent([
    [x3, y3],
    [width, height]
  ], object);
}
function setFitWidth(projection3, object, layout) {
  const { width, height } = layout;
  const [[x05, y05], [x12, y12]] = path_default2(projection3.fitWidth(width, object)).bounds(object);
  const dy = Math.ceil(y12 - y05);
  const l = Math.min(Math.ceil(x12 - x05), dy);
  const s2 = projection3.scale() * (l - 1) / l;
  const [tx, ty] = projection3.translate();
  const t = ty + (height - dy) / 2;
  projection3.scale(s2).translate([tx, t]).precision(0.2);
}
function normalizeDataSource(node) {
  const { data: data2 } = node;
  if (Array.isArray(data2))
    return Object.assign(Object.assign({}, node), { data: { value: data2 } });
  const { type } = data2;
  if (type === "graticule10") {
    return Object.assign(Object.assign({}, node), { data: { value: [graticule10()] } });
  } else if (type === "sphere") {
    return Object.assign(Object.assign({}, node), { sphere: true, data: { value: [{ type: "Sphere" }] } });
  }
  return node;
}
function isGeoPath(d2) {
  return d2.type === "geoPath";
}
var GeoView = () => {
  return (options) => {
    const { children, coordinate: projection3 = {} } = options;
    if (!Array.isArray(children))
      return [];
    const { type = "equalEarth" } = projection3, projectionOptions = __rest70(projection3, ["type"]);
    const createProjection = normalizeProjection(type);
    const nodes = children.map(normalizeDataSource);
    let path2;
    function Geo() {
      return [
        [
          "custom",
          (x3, y3, width, height) => {
            const visual = createProjection();
            const layout = { x: x3, y: y3, width, height };
            setProjectionSize(visual, nodes, layout, projectionOptions);
            setProjectionOptions(visual, projectionOptions);
            path2 = path_default2(visual);
            const scaleX = new Linear({
              domain: [x3, x3 + width]
            });
            const scaleY = new Linear({
              domain: [y3, y3 + height]
            });
            const normalize10 = (point7) => {
              const visualPoint = visual(point7);
              if (!visualPoint)
                return [null, null];
              const [vx, vy] = visualPoint;
              return [scaleX.map(vx), scaleY.map(vy)];
            };
            const normalizeInvert = (point7) => {
              if (!point7)
                return null;
              const [px, py] = point7;
              const visualPoint = [scaleX.invert(px), scaleY.invert(py)];
              return visual.invert(visualPoint);
            };
            return {
              transform: (point7) => normalize10(point7),
              untransform: (point7) => normalizeInvert(point7)
            };
          }
        ]
      ];
    }
    function GeoPath2(options2) {
      const { style, tooltip: tooltip2 = {} } = options2;
      return Object.assign(Object.assign({}, options2), { type: "path", tooltip: maybeTooltip(tooltip2, {
        title: "id",
        items: [{ channel: "color" }]
      }), style: Object.assign(Object.assign({}, style), { d: (d2) => path2(d2) || [] }) });
    }
    const t = (d2) => isGeoPath(d2) ? GeoPath2(d2) : d2;
    return [
      Object.assign(Object.assign({}, options), { type: "view", scale: {
        x: { type: "identity" },
        y: { type: "identity" }
      }, axis: false, coordinate: { type: Geo }, children: nodes.flatMap(t) })
    ];
  };
};
GeoView.props = {};

// node_modules/@antv/g2/esm/interaction/event.js
function dataOf(element, view) {
  const { __data__: datum } = element;
  const { markKey, index: index3, seriesIndex } = datum;
  const { markState } = view;
  const selectedMark = Array.from(markState.keys()).find((mark2) => mark2.key === markKey);
  if (!selectedMark)
    return;
  if (seriesIndex) {
    return seriesIndex.map((i) => selectedMark.data[i]);
  }
  return selectedMark.data[index3];
}
function maybeRoot(node, rootOf) {
  if (rootOf(node))
    return node;
  let root3 = node.parent;
  while (root3 && !rootOf(root3))
    root3 = root3.parent;
  return root3;
}
function maybeComponentRoot(node) {
  return maybeRoot(node, (node2) => node2.className === "component");
}
function maybeElementRoot(node) {
  return maybeRoot(node, (node2) => node2.className === "element");
}
function bubblesEvent(eventType, view, emitter, predicate = (event) => true) {
  return (e) => {
    if (!predicate(e))
      return;
    emitter.emit(`plot:${eventType}`, e);
    const { target } = e;
    if (!target)
      return;
    const { className: className2 } = target;
    if (className2 === "plot")
      return;
    const elementRoot = maybeElementRoot(target);
    const componentRoot = maybeComponentRoot(target);
    const root3 = elementRoot || componentRoot;
    if (!root3)
      return;
    const { className: elementType, markType } = root3;
    if (elementType === "element") {
      const e1 = Object.assign(Object.assign({}, e), { nativeEvent: true, data: { data: dataOf(root3, view) } });
      emitter.emit(`element:${eventType}`, e1);
      emitter.emit(`${markType}:${eventType}`, e1);
    } else {
      const e1 = Object.assign(Object.assign({}, e), { nativeEvent: true });
      emitter.emit(`component:${eventType}`, e1);
      emitter.emit(`${className2}:${eventType}`, e1);
    }
  };
}
function Event2() {
  return (context, _2, emitter) => {
    const { container, view } = context;
    const click = bubblesEvent(ChartEvent.CLICK, view, emitter, (e) => e.detail === 1);
    const dblclick2 = bubblesEvent(ChartEvent.DBLCLICK, view, emitter, (e) => e.detail === 2);
    const pointertap = bubblesEvent(ChartEvent.POINTER_TAP, view, emitter);
    const pointerdown = bubblesEvent(ChartEvent.POINTER_DOWN, view, emitter);
    const pointerup = bubblesEvent(ChartEvent.POINTER_UP, view, emitter);
    const pointerover = bubblesEvent(ChartEvent.POINTER_OVER, view, emitter);
    const pointerout = bubblesEvent(ChartEvent.POINTER_OUT, view, emitter);
    const pointermove = bubblesEvent(ChartEvent.POINTER_MOVE, view, emitter);
    const pointerenter = bubblesEvent(ChartEvent.POINTER_ENTER, view, emitter);
    const pointerleave = bubblesEvent(ChartEvent.POINTER_LEAVE, view, emitter);
    const pointerupoutside = bubblesEvent(ChartEvent.POINTER_UPOUTSIDE, view, emitter);
    const dragstart = bubblesEvent(ChartEvent.DRAG_START, view, emitter);
    const drag = bubblesEvent(ChartEvent.DRAG, view, emitter);
    const dragend = bubblesEvent(ChartEvent.DRAG_END, view, emitter);
    const dragenter = bubblesEvent(ChartEvent.DRAG_ENTER, view, emitter);
    const dragleave = bubblesEvent(ChartEvent.DRAG_LEAVE, view, emitter);
    const dragover = bubblesEvent(ChartEvent.DRAG_OVER, view, emitter);
    const drop2 = bubblesEvent(ChartEvent.DROP, view, emitter);
    container.addEventListener("click", click);
    container.addEventListener("click", dblclick2);
    container.addEventListener("pointertap", pointertap);
    container.addEventListener("pointerdown", pointerdown);
    container.addEventListener("pointerup", pointerup);
    container.addEventListener("pointerover", pointerover);
    container.addEventListener("pointerout", pointerout);
    container.addEventListener("pointermove", pointermove);
    container.addEventListener("pointerenter", pointerenter);
    container.addEventListener("pointerleave", pointerleave);
    container.addEventListener("pointerupoutside", pointerupoutside);
    container.addEventListener("dragstart", dragstart);
    container.addEventListener("drag", drag);
    container.addEventListener("dragend", dragend);
    container.addEventListener("dragenter", dragenter);
    container.addEventListener("dragleave", dragleave);
    container.addEventListener("dragover", dragover);
    container.addEventListener("drop", drop2);
    return () => {
      container.removeEventListener("click", click);
      container.removeEventListener("click", dblclick2);
      container.removeEventListener("pointertap", pointertap);
      container.removeEventListener("pointerdown", pointerdown);
      container.removeEventListener("pointerup", pointerup);
      container.removeEventListener("pointerover", pointerover);
      container.removeEventListener("pointerout", pointerout);
      container.removeEventListener("pointermove", pointermove);
      container.removeEventListener("pointerenter", pointerenter);
      container.removeEventListener("pointerleave", pointerleave);
      container.removeEventListener("pointerupoutside", pointerupoutside);
      container.removeEventListener("dragstart", dragstart);
      container.removeEventListener("drag", drag);
      container.removeEventListener("dragend", dragend);
      container.removeEventListener("dragenter", dragenter);
      container.removeEventListener("dragleave", dragleave);
      container.removeEventListener("dragover", dragover);
      container.removeEventListener("drop", drop2);
    };
  };
}
Event2.props = {
  reapplyWhenUpdate: true
};

// node_modules/@antv/g2/esm/lib/builtinlib.js
function builtinlib() {
  return {
    "component.axisRadar": AxisRadar,
    "component.axisLinear": LinearAxis,
    "component.axisArc": ArcAxis,
    "component.legendContinuousBlock": LegendContinuousBlock,
    "component.legendContinuousBlockSize": LegendContinuousBlockSize,
    "component.legendContinuousSize": LegendContinuousSize,
    "interaction.event": Event2,
    "composition.mark": Mark,
    "composition.view": View,
    "shape.label.label": Label
  };
}

// node_modules/@antv/g2/esm/runtime/library.js
var __rest71 = function(s2, e) {
  var t = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
      t[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t[p2[i]] = s2[p2[i]];
    }
  return t;
};
function useLibrary(namespace, publicLibrary) {
  const library3 = Object.assign(Object.assign({}, builtinlib()), publicLibrary);
  const create9 = (type) => {
    if (typeof type !== "string")
      return type;
    const key = `${namespace}.${type}`;
    return library3[key] || error(`Unknown Component: ${key}`);
  };
  const use = (options, context) => {
    const { type } = options, rest2 = __rest71(options, ["type"]);
    if (!type)
      error(`Plot type is required!`);
    const currentLibrary = create9(type);
    return currentLibrary === null || currentLibrary === void 0 ? void 0 : currentLibrary(rest2, context);
  };
  return [use, create9];
}
function documentOf(library3) {
  const { canvas, group: group3 } = library3;
  return (canvas === null || canvas === void 0 ? void 0 : canvas.document) || (group3 === null || group3 === void 0 ? void 0 : group3.ownerDocument) || error(`Cannot find library document`);
}

// node_modules/@antv/g2/esm/runtime/coordinate.js
var __rest72 = function(s2, e) {
  var t = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
      t[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t[p2[i]] = s2[p2[i]];
    }
  return t;
};
function createCoordinate(layout, partialOptions, library3) {
  const [useCoordinate] = useLibrary("coordinate", library3);
  const { innerHeight, innerWidth, insetLeft, insetTop, insetRight, insetBottom } = layout;
  const { coordinates: partialTransform = [] } = partialOptions;
  const transform3 = inferCoordinate(partialTransform);
  const isCartesian3D = transform3[0].type === "cartesian3D";
  const options = Object.assign(Object.assign({}, layout), { x: insetLeft, y: insetTop, width: innerWidth - insetLeft - insetRight, height: innerHeight - insetBottom - insetTop, transformations: transform3.flatMap(useCoordinate) });
  const coordinate2 = isCartesian3D ? (
    // @ts-ignore
    new Coordinate3D(options)
  ) : new Coordinate(options);
  return coordinate2;
}
function coordinate2Transform(node, library3) {
  const { coordinate: coordinate2 = {} } = node, rest2 = __rest72(node, ["coordinate"]);
  const { type, transform: transform3 = [] } = coordinate2, options = __rest72(coordinate2, ["type", "transform"]);
  if (!type)
    return Object.assign(Object.assign({}, rest2), { coordinates: transform3 });
  const [, createCoordinate2] = useLibrary("coordinate", library3);
  const { transform: isTransform = false } = createCoordinate2(type).props || {};
  if (isTransform) {
    throw new Error(`Unknown coordinate: ${type}.`);
  }
  return Object.assign(Object.assign({}, rest2), { coordinates: [Object.assign({ type }, options), ...transform3] });
}
function coordOf(coordinates, type) {
  return coordinates.filter((d2) => d2.type === type);
}
function isPolar2(coordinates) {
  return coordOf(coordinates, "polar").length > 0;
}
function isHelix2(coordinates) {
  return coordOf(coordinates, "helix").length > 0;
}
function isTranspose2(coordinates) {
  return coordOf(coordinates, "transpose").length % 2 === 1;
}
function isParallel2(coordinates) {
  return coordOf(coordinates, "parallel").length > 0;
}
function isTheta2(coordinates) {
  return coordOf(coordinates, "theta").length > 0;
}
function isReflect(coordinates) {
  return coordOf(coordinates, "reflect").length > 0;
}
function isRadial2(coordinates) {
  return coordOf(coordinates, "radial").length > 0;
}
function isRadar2(coordinates) {
  return coordOf(coordinates, "radar").length > 0;
}
function isReflectY(coordinates) {
  return coordOf(coordinates, "reflectY").length > 0;
}
function inferCoordinate(coordinates) {
  if (coordinates.find((d2) => d2.type === "cartesian" || d2.type === "cartesian3D"))
    return coordinates;
  return [...coordinates, { type: "cartesian" }];
}

// node_modules/d3-scale-chromatic/src/index.js
var src_exports2 = {};
__export(src_exports2, {
  interpolateBlues: () => Blues_default,
  interpolateBrBG: () => BrBG_default,
  interpolateBuGn: () => BuGn_default,
  interpolateBuPu: () => BuPu_default,
  interpolateCividis: () => cividis_default,
  interpolateCool: () => cool,
  interpolateCubehelixDefault: () => cubehelix_default2,
  interpolateGnBu: () => GnBu_default,
  interpolateGreens: () => Greens_default,
  interpolateGreys: () => Greys_default,
  interpolateInferno: () => inferno,
  interpolateMagma: () => magma,
  interpolateOrRd: () => OrRd_default,
  interpolateOranges: () => Oranges_default,
  interpolatePRGn: () => PRGn_default,
  interpolatePiYG: () => PiYG_default,
  interpolatePlasma: () => plasma,
  interpolatePuBu: () => PuBu_default,
  interpolatePuBuGn: () => PuBuGn_default,
  interpolatePuOr: () => PuOr_default,
  interpolatePuRd: () => PuRd_default,
  interpolatePurples: () => Purples_default,
  interpolateRainbow: () => rainbow_default,
  interpolateRdBu: () => RdBu_default,
  interpolateRdGy: () => RdGy_default,
  interpolateRdPu: () => RdPu_default,
  interpolateRdYlBu: () => RdYlBu_default,
  interpolateRdYlGn: () => RdYlGn_default,
  interpolateReds: () => Reds_default,
  interpolateSinebow: () => sinebow_default,
  interpolateSpectral: () => Spectral_default,
  interpolateTurbo: () => turbo_default,
  interpolateViridis: () => viridis_default,
  interpolateWarm: () => warm,
  interpolateYlGn: () => YlGn_default,
  interpolateYlGnBu: () => YlGnBu_default,
  interpolateYlOrBr: () => YlOrBr_default,
  interpolateYlOrRd: () => YlOrRd_default,
  schemeAccent: () => Accent_default,
  schemeBlues: () => scheme22,
  schemeBrBG: () => scheme,
  schemeBuGn: () => scheme10,
  schemeBuPu: () => scheme11,
  schemeCategory10: () => category10_default,
  schemeDark2: () => Dark2_default,
  schemeGnBu: () => scheme12,
  schemeGreens: () => scheme23,
  schemeGreys: () => scheme24,
  schemeOrRd: () => scheme13,
  schemeOranges: () => scheme27,
  schemePRGn: () => scheme2,
  schemePaired: () => Paired_default,
  schemePastel1: () => Pastel1_default,
  schemePastel2: () => Pastel2_default,
  schemePiYG: () => scheme3,
  schemePuBu: () => scheme15,
  schemePuBuGn: () => scheme14,
  schemePuOr: () => scheme4,
  schemePuRd: () => scheme16,
  schemePurples: () => scheme25,
  schemeRdBu: () => scheme5,
  schemeRdGy: () => scheme6,
  schemeRdPu: () => scheme17,
  schemeRdYlBu: () => scheme7,
  schemeRdYlGn: () => scheme8,
  schemeReds: () => scheme26,
  schemeSet1: () => Set1_default,
  schemeSet2: () => Set2_default,
  schemeSet3: () => Set3_default,
  schemeSpectral: () => scheme9,
  schemeTableau10: () => Tableau10_default,
  schemeYlGn: () => scheme19,
  schemeYlGnBu: () => scheme18,
  schemeYlOrBr: () => scheme20,
  schemeYlOrRd: () => scheme21
});

// node_modules/d3-scale-chromatic/src/colors.js
function colors_default(specifier) {
  var n = specifier.length / 6 | 0, colors = new Array(n), i = 0;
  while (i < n)
    colors[i] = "#" + specifier.slice(i * 6, ++i * 6);
  return colors;
}

// node_modules/d3-scale-chromatic/src/categorical/category10.js
var category10_default = colors_default("1f77b4ff7f0e2ca02cd627289467bd8c564be377c27f7f7fbcbd2217becf");

// node_modules/d3-scale-chromatic/src/categorical/Accent.js
var Accent_default = colors_default("7fc97fbeaed4fdc086ffff99386cb0f0027fbf5b17666666");

// node_modules/d3-scale-chromatic/src/categorical/Dark2.js
var Dark2_default = colors_default("1b9e77d95f027570b3e7298a66a61ee6ab02a6761d666666");

// node_modules/d3-scale-chromatic/src/categorical/Paired.js
var Paired_default = colors_default("a6cee31f78b4b2df8a33a02cfb9a99e31a1cfdbf6fff7f00cab2d66a3d9affff99b15928");

// node_modules/d3-scale-chromatic/src/categorical/Pastel1.js
var Pastel1_default = colors_default("fbb4aeb3cde3ccebc5decbe4fed9a6ffffcce5d8bdfddaecf2f2f2");

// node_modules/d3-scale-chromatic/src/categorical/Pastel2.js
var Pastel2_default = colors_default("b3e2cdfdcdaccbd5e8f4cae4e6f5c9fff2aef1e2cccccccc");

// node_modules/d3-scale-chromatic/src/categorical/Set1.js
var Set1_default = colors_default("e41a1c377eb84daf4a984ea3ff7f00ffff33a65628f781bf999999");

// node_modules/d3-scale-chromatic/src/categorical/Set2.js
var Set2_default = colors_default("66c2a5fc8d628da0cbe78ac3a6d854ffd92fe5c494b3b3b3");

// node_modules/d3-scale-chromatic/src/categorical/Set3.js
var Set3_default = colors_default("8dd3c7ffffb3bebadafb807280b1d3fdb462b3de69fccde5d9d9d9bc80bdccebc5ffed6f");

// node_modules/d3-scale-chromatic/src/categorical/Tableau10.js
var Tableau10_default = colors_default("4e79a7f28e2ce1575976b7b259a14fedc949af7aa1ff9da79c755fbab0ab");

// node_modules/d3-interpolate/src/basis.js
function basis(t12, v0, v1, v2, v3) {
  var t22 = t12 * t12, t32 = t22 * t12;
  return ((1 - 3 * t12 + 3 * t22 - t32) * v0 + (4 - 6 * t22 + 3 * t32) * v1 + (1 + 3 * t12 + 3 * t22 - 3 * t32) * v2 + t32 * v3) / 6;
}
function basis_default2(values4) {
  var n = values4.length - 1;
  return function(t) {
    var i = t <= 0 ? t = 0 : t >= 1 ? (t = 1, n - 1) : Math.floor(t * n), v1 = values4[i], v2 = values4[i + 1], v0 = i > 0 ? values4[i - 1] : 2 * v1 - v2, v3 = i < n - 1 ? values4[i + 2] : 2 * v2 - v1;
    return basis((t - i / n) * n, v0, v1, v2, v3);
  };
}

// node_modules/d3-interpolate/src/basisClosed.js
function basisClosed_default2(values4) {
  var n = values4.length;
  return function(t) {
    var i = Math.floor(((t %= 1) < 0 ? ++t : t) * n), v0 = values4[(i + n - 1) % n], v1 = values4[i % n], v2 = values4[(i + 1) % n], v3 = values4[(i + 2) % n];
    return basis((t - i / n) * n, v0, v1, v2, v3);
  };
}

// node_modules/d3-interpolate/src/constant.js
var constant_default5 = (x3) => () => x3;

// node_modules/d3-interpolate/src/color.js
function linear2(a4, d2) {
  return function(t) {
    return a4 + t * d2;
  };
}
function exponential(a4, b, y3) {
  return a4 = Math.pow(a4, y3), b = Math.pow(b, y3) - a4, y3 = 1 / y3, function(t) {
    return Math.pow(a4 + t * b, y3);
  };
}
function hue(a4, b) {
  var d2 = b - a4;
  return d2 ? linear2(a4, d2 > 180 || d2 < -180 ? d2 - 360 * Math.round(d2 / 360) : d2) : constant_default5(isNaN(a4) ? b : a4);
}
function gamma(y3) {
  return (y3 = +y3) === 1 ? nogamma : function(a4, b) {
    return b - a4 ? exponential(a4, b, y3) : constant_default5(isNaN(a4) ? b : a4);
  };
}
function nogamma(a4, b) {
  var d2 = b - a4;
  return d2 ? linear2(a4, d2) : constant_default5(isNaN(a4) ? b : a4);
}

// node_modules/d3-interpolate/src/rgb.js
var rgb_default = function rgbGamma(y3) {
  var color2 = gamma(y3);
  function rgb2(start, end) {
    var r = color2((start = rgb(start)).r, (end = rgb(end)).r), g = color2(start.g, end.g), b = color2(start.b, end.b), opacity = nogamma(start.opacity, end.opacity);
    return function(t) {
      start.r = r(t);
      start.g = g(t);
      start.b = b(t);
      start.opacity = opacity(t);
      return start + "";
    };
  }
  rgb2.gamma = rgbGamma;
  return rgb2;
}(1);
function rgbSpline(spline) {
  return function(colors) {
    var n = colors.length, r = new Array(n), g = new Array(n), b = new Array(n), i, color2;
    for (i = 0; i < n; ++i) {
      color2 = rgb(colors[i]);
      r[i] = color2.r || 0;
      g[i] = color2.g || 0;
      b[i] = color2.b || 0;
    }
    r = spline(r);
    g = spline(g);
    b = spline(b);
    color2.opacity = 1;
    return function(t) {
      color2.r = r(t);
      color2.g = g(t);
      color2.b = b(t);
      return color2 + "";
    };
  };
}
var rgbBasis = rgbSpline(basis_default2);
var rgbBasisClosed = rgbSpline(basisClosed_default2);

// node_modules/d3-interpolate/src/number.js
function number_default(a4, b) {
  return a4 = +a4, b = +b, function(t) {
    return a4 * (1 - t) + b * t;
  };
}

// node_modules/d3-interpolate/src/string.js
var reA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g;
var reB = new RegExp(reA.source, "g");

// node_modules/d3-interpolate/src/transform/decompose.js
var degrees2 = 180 / Math.PI;
var identity6 = {
  translateX: 0,
  translateY: 0,
  rotate: 0,
  skewX: 0,
  scaleX: 1,
  scaleY: 1
};
function decompose_default(a4, b, c5, d2, e, f) {
  var scaleX, scaleY, skewX;
  if (scaleX = Math.sqrt(a4 * a4 + b * b))
    a4 /= scaleX, b /= scaleX;
  if (skewX = a4 * c5 + b * d2)
    c5 -= a4 * skewX, d2 -= b * skewX;
  if (scaleY = Math.sqrt(c5 * c5 + d2 * d2))
    c5 /= scaleY, d2 /= scaleY, skewX /= scaleY;
  if (a4 * d2 < b * c5)
    a4 = -a4, b = -b, skewX = -skewX, scaleX = -scaleX;
  return {
    translateX: e,
    translateY: f,
    rotate: Math.atan2(b, a4) * degrees2,
    skewX: Math.atan(skewX) * degrees2,
    scaleX,
    scaleY
  };
}

// node_modules/d3-interpolate/src/transform/parse.js
var svgNode;
function parseCss(value2) {
  const m3 = new (typeof DOMMatrix === "function" ? DOMMatrix : WebKitCSSMatrix)(value2 + "");
  return m3.isIdentity ? identity6 : decompose_default(m3.a, m3.b, m3.c, m3.d, m3.e, m3.f);
}
function parseSvg(value2) {
  if (value2 == null)
    return identity6;
  if (!svgNode)
    svgNode = document.createElementNS("http://www.w3.org/2000/svg", "g");
  svgNode.setAttribute("transform", value2);
  if (!(value2 = svgNode.transform.baseVal.consolidate()))
    return identity6;
  value2 = value2.matrix;
  return decompose_default(value2.a, value2.b, value2.c, value2.d, value2.e, value2.f);
}

// node_modules/d3-interpolate/src/transform/index.js
function interpolateTransform(parse, pxComma, pxParen, degParen) {
  function pop(s2) {
    return s2.length ? s2.pop() + " " : "";
  }
  function translate4(xa, ya, xb, yb, s2, q) {
    if (xa !== xb || ya !== yb) {
      var i = s2.push("translate(", null, pxComma, null, pxParen);
      q.push({ i: i - 4, x: number_default(xa, xb) }, { i: i - 2, x: number_default(ya, yb) });
    } else if (xb || yb) {
      s2.push("translate(" + xb + pxComma + yb + pxParen);
    }
  }
  function rotate6(a4, b, s2, q) {
    if (a4 !== b) {
      if (a4 - b > 180)
        b += 360;
      else if (b - a4 > 180)
        a4 += 360;
      q.push({ i: s2.push(pop(s2) + "rotate(", null, degParen) - 2, x: number_default(a4, b) });
    } else if (b) {
      s2.push(pop(s2) + "rotate(" + b + degParen);
    }
  }
  function skewX(a4, b, s2, q) {
    if (a4 !== b) {
      q.push({ i: s2.push(pop(s2) + "skewX(", null, degParen) - 2, x: number_default(a4, b) });
    } else if (b) {
      s2.push(pop(s2) + "skewX(" + b + degParen);
    }
  }
  function scale10(xa, ya, xb, yb, s2, q) {
    if (xa !== xb || ya !== yb) {
      var i = s2.push(pop(s2) + "scale(", null, ",", null, ")");
      q.push({ i: i - 4, x: number_default(xa, xb) }, { i: i - 2, x: number_default(ya, yb) });
    } else if (xb !== 1 || yb !== 1) {
      s2.push(pop(s2) + "scale(" + xb + "," + yb + ")");
    }
  }
  return function(a4, b) {
    var s2 = [], q = [];
    a4 = parse(a4), b = parse(b);
    translate4(a4.translateX, a4.translateY, b.translateX, b.translateY, s2, q);
    rotate6(a4.rotate, b.rotate, s2, q);
    skewX(a4.skewX, b.skewX, s2, q);
    scale10(a4.scaleX, a4.scaleY, b.scaleX, b.scaleY, s2, q);
    a4 = b = null;
    return function(t) {
      var i = -1, n = q.length, o;
      while (++i < n)
        s2[(o = q[i]).i] = o.x(t);
      return s2.join("");
    };
  };
}
var interpolateTransformCss = interpolateTransform(parseCss, "px, ", "px)", "deg)");
var interpolateTransformSvg = interpolateTransform(parseSvg, ", ", ")", ")");

// node_modules/d3-interpolate/src/zoom.js
var epsilon23 = 1e-12;
function cosh(x3) {
  return ((x3 = Math.exp(x3)) + 1 / x3) / 2;
}
function sinh(x3) {
  return ((x3 = Math.exp(x3)) - 1 / x3) / 2;
}
function tanh(x3) {
  return ((x3 = Math.exp(2 * x3)) - 1) / (x3 + 1);
}
var zoom_default = function zoomRho(rho, rho2, rho4) {
  function zoom(p0, p1) {
    var ux0 = p0[0], uy0 = p0[1], w0 = p0[2], ux1 = p1[0], uy1 = p1[1], w1 = p1[2], dx = ux1 - ux0, dy = uy1 - uy0, d2 = dx * dx + dy * dy, i, S;
    if (d2 < epsilon23) {
      S = Math.log(w1 / w0) / rho;
      i = function(t) {
        return [
          ux0 + t * dx,
          uy0 + t * dy,
          w0 * Math.exp(rho * t * S)
        ];
      };
    } else {
      var d1 = Math.sqrt(d2), b0 = (w1 * w1 - w0 * w0 + rho4 * d2) / (2 * w0 * rho2 * d1), b1 = (w1 * w1 - w0 * w0 - rho4 * d2) / (2 * w1 * rho2 * d1), r0 = Math.log(Math.sqrt(b0 * b0 + 1) - b0), r1 = Math.log(Math.sqrt(b1 * b1 + 1) - b1);
      S = (r1 - r0) / rho;
      i = function(t) {
        var s2 = t * S, coshr0 = cosh(r0), u = w0 / (rho2 * d1) * (coshr0 * tanh(rho * s2 + r0) - sinh(r0));
        return [
          ux0 + u * dx,
          uy0 + u * dy,
          w0 * coshr0 / cosh(rho * s2 + r0)
        ];
      };
    }
    i.duration = S * 1e3 * rho / Math.SQRT2;
    return i;
  }
  zoom.rho = function(_2) {
    var _1 = Math.max(1e-3, +_2), _22 = _1 * _1, _4 = _22 * _22;
    return zoomRho(_1, _22, _4);
  };
  return zoom;
}(Math.SQRT2, 2, 4);

// node_modules/d3-interpolate/src/hsl.js
function hsl2(hue2) {
  return function(start, end) {
    var h = hue2((start = hsl(start)).h, (end = hsl(end)).h), s2 = nogamma(start.s, end.s), l = nogamma(start.l, end.l), opacity = nogamma(start.opacity, end.opacity);
    return function(t) {
      start.h = h(t);
      start.s = s2(t);
      start.l = l(t);
      start.opacity = opacity(t);
      return start + "";
    };
  };
}
var hsl_default = hsl2(hue);
var hslLong = hsl2(nogamma);

// node_modules/d3-interpolate/src/hcl.js
function hcl2(hue2) {
  return function(start, end) {
    var h = hue2((start = hcl(start)).h, (end = hcl(end)).h), c5 = nogamma(start.c, end.c), l = nogamma(start.l, end.l), opacity = nogamma(start.opacity, end.opacity);
    return function(t) {
      start.h = h(t);
      start.c = c5(t);
      start.l = l(t);
      start.opacity = opacity(t);
      return start + "";
    };
  };
}
var hcl_default = hcl2(hue);
var hclLong = hcl2(nogamma);

// node_modules/d3-interpolate/src/cubehelix.js
function cubehelix2(hue2) {
  return function cubehelixGamma(y3) {
    y3 = +y3;
    function cubehelix3(start, end) {
      var h = hue2((start = cubehelix(start)).h, (end = cubehelix(end)).h), s2 = nogamma(start.s, end.s), l = nogamma(start.l, end.l), opacity = nogamma(start.opacity, end.opacity);
      return function(t) {
        start.h = h(t);
        start.s = s2(t);
        start.l = l(Math.pow(t, y3));
        start.opacity = opacity(t);
        return start + "";
      };
    }
    cubehelix3.gamma = cubehelixGamma;
    return cubehelix3;
  }(1);
}
var cubehelix_default = cubehelix2(hue);
var cubehelixLong = cubehelix2(nogamma);

// node_modules/d3-scale-chromatic/src/ramp.js
var ramp_default = (scheme28) => rgbBasis(scheme28[scheme28.length - 1]);

// node_modules/d3-scale-chromatic/src/diverging/BrBG.js
var scheme = new Array(3).concat(
  "d8b365f5f5f55ab4ac",
  "a6611adfc27d80cdc1018571",
  "a6611adfc27df5f5f580cdc1018571",
  "8c510ad8b365f6e8c3c7eae55ab4ac01665e",
  "8c510ad8b365f6e8c3f5f5f5c7eae55ab4ac01665e",
  "8c510abf812ddfc27df6e8c3c7eae580cdc135978f01665e",
  "8c510abf812ddfc27df6e8c3f5f5f5c7eae580cdc135978f01665e",
  "5430058c510abf812ddfc27df6e8c3c7eae580cdc135978f01665e003c30",
  "5430058c510abf812ddfc27df6e8c3f5f5f5c7eae580cdc135978f01665e003c30"
).map(colors_default);
var BrBG_default = ramp_default(scheme);

// node_modules/d3-scale-chromatic/src/diverging/PRGn.js
var scheme2 = new Array(3).concat(
  "af8dc3f7f7f77fbf7b",
  "7b3294c2a5cfa6dba0008837",
  "7b3294c2a5cff7f7f7a6dba0008837",
  "762a83af8dc3e7d4e8d9f0d37fbf7b1b7837",
  "762a83af8dc3e7d4e8f7f7f7d9f0d37fbf7b1b7837",
  "762a839970abc2a5cfe7d4e8d9f0d3a6dba05aae611b7837",
  "762a839970abc2a5cfe7d4e8f7f7f7d9f0d3a6dba05aae611b7837",
  "40004b762a839970abc2a5cfe7d4e8d9f0d3a6dba05aae611b783700441b",
  "40004b762a839970abc2a5cfe7d4e8f7f7f7d9f0d3a6dba05aae611b783700441b"
).map(colors_default);
var PRGn_default = ramp_default(scheme2);

// node_modules/d3-scale-chromatic/src/diverging/PiYG.js
var scheme3 = new Array(3).concat(
  "e9a3c9f7f7f7a1d76a",
  "d01c8bf1b6dab8e1864dac26",
  "d01c8bf1b6daf7f7f7b8e1864dac26",
  "c51b7de9a3c9fde0efe6f5d0a1d76a4d9221",
  "c51b7de9a3c9fde0eff7f7f7e6f5d0a1d76a4d9221",
  "c51b7dde77aef1b6dafde0efe6f5d0b8e1867fbc414d9221",
  "c51b7dde77aef1b6dafde0eff7f7f7e6f5d0b8e1867fbc414d9221",
  "8e0152c51b7dde77aef1b6dafde0efe6f5d0b8e1867fbc414d9221276419",
  "8e0152c51b7dde77aef1b6dafde0eff7f7f7e6f5d0b8e1867fbc414d9221276419"
).map(colors_default);
var PiYG_default = ramp_default(scheme3);

// node_modules/d3-scale-chromatic/src/diverging/PuOr.js
var scheme4 = new Array(3).concat(
  "998ec3f7f7f7f1a340",
  "5e3c99b2abd2fdb863e66101",
  "5e3c99b2abd2f7f7f7fdb863e66101",
  "542788998ec3d8daebfee0b6f1a340b35806",
  "542788998ec3d8daebf7f7f7fee0b6f1a340b35806",
  "5427888073acb2abd2d8daebfee0b6fdb863e08214b35806",
  "5427888073acb2abd2d8daebf7f7f7fee0b6fdb863e08214b35806",
  "2d004b5427888073acb2abd2d8daebfee0b6fdb863e08214b358067f3b08",
  "2d004b5427888073acb2abd2d8daebf7f7f7fee0b6fdb863e08214b358067f3b08"
).map(colors_default);
var PuOr_default = ramp_default(scheme4);

// node_modules/d3-scale-chromatic/src/diverging/RdBu.js
var scheme5 = new Array(3).concat(
  "ef8a62f7f7f767a9cf",
  "ca0020f4a58292c5de0571b0",
  "ca0020f4a582f7f7f792c5de0571b0",
  "b2182bef8a62fddbc7d1e5f067a9cf2166ac",
  "b2182bef8a62fddbc7f7f7f7d1e5f067a9cf2166ac",
  "b2182bd6604df4a582fddbc7d1e5f092c5de4393c32166ac",
  "b2182bd6604df4a582fddbc7f7f7f7d1e5f092c5de4393c32166ac",
  "67001fb2182bd6604df4a582fddbc7d1e5f092c5de4393c32166ac053061",
  "67001fb2182bd6604df4a582fddbc7f7f7f7d1e5f092c5de4393c32166ac053061"
).map(colors_default);
var RdBu_default = ramp_default(scheme5);

// node_modules/d3-scale-chromatic/src/diverging/RdGy.js
var scheme6 = new Array(3).concat(
  "ef8a62ffffff999999",
  "ca0020f4a582bababa404040",
  "ca0020f4a582ffffffbababa404040",
  "b2182bef8a62fddbc7e0e0e09999994d4d4d",
  "b2182bef8a62fddbc7ffffffe0e0e09999994d4d4d",
  "b2182bd6604df4a582fddbc7e0e0e0bababa8787874d4d4d",
  "b2182bd6604df4a582fddbc7ffffffe0e0e0bababa8787874d4d4d",
  "67001fb2182bd6604df4a582fddbc7e0e0e0bababa8787874d4d4d1a1a1a",
  "67001fb2182bd6604df4a582fddbc7ffffffe0e0e0bababa8787874d4d4d1a1a1a"
).map(colors_default);
var RdGy_default = ramp_default(scheme6);

// node_modules/d3-scale-chromatic/src/diverging/RdYlBu.js
var scheme7 = new Array(3).concat(
  "fc8d59ffffbf91bfdb",
  "d7191cfdae61abd9e92c7bb6",
  "d7191cfdae61ffffbfabd9e92c7bb6",
  "d73027fc8d59fee090e0f3f891bfdb4575b4",
  "d73027fc8d59fee090ffffbfe0f3f891bfdb4575b4",
  "d73027f46d43fdae61fee090e0f3f8abd9e974add14575b4",
  "d73027f46d43fdae61fee090ffffbfe0f3f8abd9e974add14575b4",
  "a50026d73027f46d43fdae61fee090e0f3f8abd9e974add14575b4313695",
  "a50026d73027f46d43fdae61fee090ffffbfe0f3f8abd9e974add14575b4313695"
).map(colors_default);
var RdYlBu_default = ramp_default(scheme7);

// node_modules/d3-scale-chromatic/src/diverging/RdYlGn.js
var scheme8 = new Array(3).concat(
  "fc8d59ffffbf91cf60",
  "d7191cfdae61a6d96a1a9641",
  "d7191cfdae61ffffbfa6d96a1a9641",
  "d73027fc8d59fee08bd9ef8b91cf601a9850",
  "d73027fc8d59fee08bffffbfd9ef8b91cf601a9850",
  "d73027f46d43fdae61fee08bd9ef8ba6d96a66bd631a9850",
  "d73027f46d43fdae61fee08bffffbfd9ef8ba6d96a66bd631a9850",
  "a50026d73027f46d43fdae61fee08bd9ef8ba6d96a66bd631a9850006837",
  "a50026d73027f46d43fdae61fee08bffffbfd9ef8ba6d96a66bd631a9850006837"
).map(colors_default);
var RdYlGn_default = ramp_default(scheme8);

// node_modules/d3-scale-chromatic/src/diverging/Spectral.js
var scheme9 = new Array(3).concat(
  "fc8d59ffffbf99d594",
  "d7191cfdae61abdda42b83ba",
  "d7191cfdae61ffffbfabdda42b83ba",
  "d53e4ffc8d59fee08be6f59899d5943288bd",
  "d53e4ffc8d59fee08bffffbfe6f59899d5943288bd",
  "d53e4ff46d43fdae61fee08be6f598abdda466c2a53288bd",
  "d53e4ff46d43fdae61fee08bffffbfe6f598abdda466c2a53288bd",
  "9e0142d53e4ff46d43fdae61fee08be6f598abdda466c2a53288bd5e4fa2",
  "9e0142d53e4ff46d43fdae61fee08bffffbfe6f598abdda466c2a53288bd5e4fa2"
).map(colors_default);
var Spectral_default = ramp_default(scheme9);

// node_modules/d3-scale-chromatic/src/sequential-multi/BuGn.js
var scheme10 = new Array(3).concat(
  "e5f5f999d8c92ca25f",
  "edf8fbb2e2e266c2a4238b45",
  "edf8fbb2e2e266c2a42ca25f006d2c",
  "edf8fbccece699d8c966c2a42ca25f006d2c",
  "edf8fbccece699d8c966c2a441ae76238b45005824",
  "f7fcfde5f5f9ccece699d8c966c2a441ae76238b45005824",
  "f7fcfde5f5f9ccece699d8c966c2a441ae76238b45006d2c00441b"
).map(colors_default);
var BuGn_default = ramp_default(scheme10);

// node_modules/d3-scale-chromatic/src/sequential-multi/BuPu.js
var scheme11 = new Array(3).concat(
  "e0ecf49ebcda8856a7",
  "edf8fbb3cde38c96c688419d",
  "edf8fbb3cde38c96c68856a7810f7c",
  "edf8fbbfd3e69ebcda8c96c68856a7810f7c",
  "edf8fbbfd3e69ebcda8c96c68c6bb188419d6e016b",
  "f7fcfde0ecf4bfd3e69ebcda8c96c68c6bb188419d6e016b",
  "f7fcfde0ecf4bfd3e69ebcda8c96c68c6bb188419d810f7c4d004b"
).map(colors_default);
var BuPu_default = ramp_default(scheme11);

// node_modules/d3-scale-chromatic/src/sequential-multi/GnBu.js
var scheme12 = new Array(3).concat(
  "e0f3dba8ddb543a2ca",
  "f0f9e8bae4bc7bccc42b8cbe",
  "f0f9e8bae4bc7bccc443a2ca0868ac",
  "f0f9e8ccebc5a8ddb57bccc443a2ca0868ac",
  "f0f9e8ccebc5a8ddb57bccc44eb3d32b8cbe08589e",
  "f7fcf0e0f3dbccebc5a8ddb57bccc44eb3d32b8cbe08589e",
  "f7fcf0e0f3dbccebc5a8ddb57bccc44eb3d32b8cbe0868ac084081"
).map(colors_default);
var GnBu_default = ramp_default(scheme12);

// node_modules/d3-scale-chromatic/src/sequential-multi/OrRd.js
var scheme13 = new Array(3).concat(
  "fee8c8fdbb84e34a33",
  "fef0d9fdcc8afc8d59d7301f",
  "fef0d9fdcc8afc8d59e34a33b30000",
  "fef0d9fdd49efdbb84fc8d59e34a33b30000",
  "fef0d9fdd49efdbb84fc8d59ef6548d7301f990000",
  "fff7ecfee8c8fdd49efdbb84fc8d59ef6548d7301f990000",
  "fff7ecfee8c8fdd49efdbb84fc8d59ef6548d7301fb300007f0000"
).map(colors_default);
var OrRd_default = ramp_default(scheme13);

// node_modules/d3-scale-chromatic/src/sequential-multi/PuBuGn.js
var scheme14 = new Array(3).concat(
  "ece2f0a6bddb1c9099",
  "f6eff7bdc9e167a9cf02818a",
  "f6eff7bdc9e167a9cf1c9099016c59",
  "f6eff7d0d1e6a6bddb67a9cf1c9099016c59",
  "f6eff7d0d1e6a6bddb67a9cf3690c002818a016450",
  "fff7fbece2f0d0d1e6a6bddb67a9cf3690c002818a016450",
  "fff7fbece2f0d0d1e6a6bddb67a9cf3690c002818a016c59014636"
).map(colors_default);
var PuBuGn_default = ramp_default(scheme14);

// node_modules/d3-scale-chromatic/src/sequential-multi/PuBu.js
var scheme15 = new Array(3).concat(
  "ece7f2a6bddb2b8cbe",
  "f1eef6bdc9e174a9cf0570b0",
  "f1eef6bdc9e174a9cf2b8cbe045a8d",
  "f1eef6d0d1e6a6bddb74a9cf2b8cbe045a8d",
  "f1eef6d0d1e6a6bddb74a9cf3690c00570b0034e7b",
  "fff7fbece7f2d0d1e6a6bddb74a9cf3690c00570b0034e7b",
  "fff7fbece7f2d0d1e6a6bddb74a9cf3690c00570b0045a8d023858"
).map(colors_default);
var PuBu_default = ramp_default(scheme15);

// node_modules/d3-scale-chromatic/src/sequential-multi/PuRd.js
var scheme16 = new Array(3).concat(
  "e7e1efc994c7dd1c77",
  "f1eef6d7b5d8df65b0ce1256",
  "f1eef6d7b5d8df65b0dd1c77980043",
  "f1eef6d4b9dac994c7df65b0dd1c77980043",
  "f1eef6d4b9dac994c7df65b0e7298ace125691003f",
  "f7f4f9e7e1efd4b9dac994c7df65b0e7298ace125691003f",
  "f7f4f9e7e1efd4b9dac994c7df65b0e7298ace125698004367001f"
).map(colors_default);
var PuRd_default = ramp_default(scheme16);

// node_modules/d3-scale-chromatic/src/sequential-multi/RdPu.js
var scheme17 = new Array(3).concat(
  "fde0ddfa9fb5c51b8a",
  "feebe2fbb4b9f768a1ae017e",
  "feebe2fbb4b9f768a1c51b8a7a0177",
  "feebe2fcc5c0fa9fb5f768a1c51b8a7a0177",
  "feebe2fcc5c0fa9fb5f768a1dd3497ae017e7a0177",
  "fff7f3fde0ddfcc5c0fa9fb5f768a1dd3497ae017e7a0177",
  "fff7f3fde0ddfcc5c0fa9fb5f768a1dd3497ae017e7a017749006a"
).map(colors_default);
var RdPu_default = ramp_default(scheme17);

// node_modules/d3-scale-chromatic/src/sequential-multi/YlGnBu.js
var scheme18 = new Array(3).concat(
  "edf8b17fcdbb2c7fb8",
  "ffffcca1dab441b6c4225ea8",
  "ffffcca1dab441b6c42c7fb8253494",
  "ffffccc7e9b47fcdbb41b6c42c7fb8253494",
  "ffffccc7e9b47fcdbb41b6c41d91c0225ea80c2c84",
  "ffffd9edf8b1c7e9b47fcdbb41b6c41d91c0225ea80c2c84",
  "ffffd9edf8b1c7e9b47fcdbb41b6c41d91c0225ea8253494081d58"
).map(colors_default);
var YlGnBu_default = ramp_default(scheme18);

// node_modules/d3-scale-chromatic/src/sequential-multi/YlGn.js
var scheme19 = new Array(3).concat(
  "f7fcb9addd8e31a354",
  "ffffccc2e69978c679238443",
  "ffffccc2e69978c67931a354006837",
  "ffffccd9f0a3addd8e78c67931a354006837",
  "ffffccd9f0a3addd8e78c67941ab5d238443005a32",
  "ffffe5f7fcb9d9f0a3addd8e78c67941ab5d238443005a32",
  "ffffe5f7fcb9d9f0a3addd8e78c67941ab5d238443006837004529"
).map(colors_default);
var YlGn_default = ramp_default(scheme19);

// node_modules/d3-scale-chromatic/src/sequential-multi/YlOrBr.js
var scheme20 = new Array(3).concat(
  "fff7bcfec44fd95f0e",
  "ffffd4fed98efe9929cc4c02",
  "ffffd4fed98efe9929d95f0e993404",
  "ffffd4fee391fec44ffe9929d95f0e993404",
  "ffffd4fee391fec44ffe9929ec7014cc4c028c2d04",
  "ffffe5fff7bcfee391fec44ffe9929ec7014cc4c028c2d04",
  "ffffe5fff7bcfee391fec44ffe9929ec7014cc4c02993404662506"
).map(colors_default);
var YlOrBr_default = ramp_default(scheme20);

// node_modules/d3-scale-chromatic/src/sequential-multi/YlOrRd.js
var scheme21 = new Array(3).concat(
  "ffeda0feb24cf03b20",
  "ffffb2fecc5cfd8d3ce31a1c",
  "ffffb2fecc5cfd8d3cf03b20bd0026",
  "ffffb2fed976feb24cfd8d3cf03b20bd0026",
  "ffffb2fed976feb24cfd8d3cfc4e2ae31a1cb10026",
  "ffffccffeda0fed976feb24cfd8d3cfc4e2ae31a1cb10026",
  "ffffccffeda0fed976feb24cfd8d3cfc4e2ae31a1cbd0026800026"
).map(colors_default);
var YlOrRd_default = ramp_default(scheme21);

// node_modules/d3-scale-chromatic/src/sequential-single/Blues.js
var scheme22 = new Array(3).concat(
  "deebf79ecae13182bd",
  "eff3ffbdd7e76baed62171b5",
  "eff3ffbdd7e76baed63182bd08519c",
  "eff3ffc6dbef9ecae16baed63182bd08519c",
  "eff3ffc6dbef9ecae16baed64292c62171b5084594",
  "f7fbffdeebf7c6dbef9ecae16baed64292c62171b5084594",
  "f7fbffdeebf7c6dbef9ecae16baed64292c62171b508519c08306b"
).map(colors_default);
var Blues_default = ramp_default(scheme22);

// node_modules/d3-scale-chromatic/src/sequential-single/Greens.js
var scheme23 = new Array(3).concat(
  "e5f5e0a1d99b31a354",
  "edf8e9bae4b374c476238b45",
  "edf8e9bae4b374c47631a354006d2c",
  "edf8e9c7e9c0a1d99b74c47631a354006d2c",
  "edf8e9c7e9c0a1d99b74c47641ab5d238b45005a32",
  "f7fcf5e5f5e0c7e9c0a1d99b74c47641ab5d238b45005a32",
  "f7fcf5e5f5e0c7e9c0a1d99b74c47641ab5d238b45006d2c00441b"
).map(colors_default);
var Greens_default = ramp_default(scheme23);

// node_modules/d3-scale-chromatic/src/sequential-single/Greys.js
var scheme24 = new Array(3).concat(
  "f0f0f0bdbdbd636363",
  "f7f7f7cccccc969696525252",
  "f7f7f7cccccc969696636363252525",
  "f7f7f7d9d9d9bdbdbd969696636363252525",
  "f7f7f7d9d9d9bdbdbd969696737373525252252525",
  "fffffff0f0f0d9d9d9bdbdbd969696737373525252252525",
  "fffffff0f0f0d9d9d9bdbdbd969696737373525252252525000000"
).map(colors_default);
var Greys_default = ramp_default(scheme24);

// node_modules/d3-scale-chromatic/src/sequential-single/Purples.js
var scheme25 = new Array(3).concat(
  "efedf5bcbddc756bb1",
  "f2f0f7cbc9e29e9ac86a51a3",
  "f2f0f7cbc9e29e9ac8756bb154278f",
  "f2f0f7dadaebbcbddc9e9ac8756bb154278f",
  "f2f0f7dadaebbcbddc9e9ac8807dba6a51a34a1486",
  "fcfbfdefedf5dadaebbcbddc9e9ac8807dba6a51a34a1486",
  "fcfbfdefedf5dadaebbcbddc9e9ac8807dba6a51a354278f3f007d"
).map(colors_default);
var Purples_default = ramp_default(scheme25);

// node_modules/d3-scale-chromatic/src/sequential-single/Reds.js
var scheme26 = new Array(3).concat(
  "fee0d2fc9272de2d26",
  "fee5d9fcae91fb6a4acb181d",
  "fee5d9fcae91fb6a4ade2d26a50f15",
  "fee5d9fcbba1fc9272fb6a4ade2d26a50f15",
  "fee5d9fcbba1fc9272fb6a4aef3b2ccb181d99000d",
  "fff5f0fee0d2fcbba1fc9272fb6a4aef3b2ccb181d99000d",
  "fff5f0fee0d2fcbba1fc9272fb6a4aef3b2ccb181da50f1567000d"
).map(colors_default);
var Reds_default = ramp_default(scheme26);

// node_modules/d3-scale-chromatic/src/sequential-single/Oranges.js
var scheme27 = new Array(3).concat(
  "fee6cefdae6be6550d",
  "feeddefdbe85fd8d3cd94701",
  "feeddefdbe85fd8d3ce6550da63603",
  "feeddefdd0a2fdae6bfd8d3ce6550da63603",
  "feeddefdd0a2fdae6bfd8d3cf16913d948018c2d04",
  "fff5ebfee6cefdd0a2fdae6bfd8d3cf16913d948018c2d04",
  "fff5ebfee6cefdd0a2fdae6bfd8d3cf16913d94801a636037f2704"
).map(colors_default);
var Oranges_default = ramp_default(scheme27);

// node_modules/d3-scale-chromatic/src/sequential-multi/cividis.js
function cividis_default(t) {
  t = Math.max(0, Math.min(1, t));
  return "rgb(" + Math.max(0, Math.min(255, Math.round(-4.54 - t * (35.34 - t * (2381.73 - t * (6402.7 - t * (7024.72 - t * 2710.57))))))) + ", " + Math.max(0, Math.min(255, Math.round(32.49 + t * (170.73 + t * (52.82 - t * (131.46 - t * (176.58 - t * 67.37))))))) + ", " + Math.max(0, Math.min(255, Math.round(81.24 + t * (442.36 - t * (2482.43 - t * (6167.24 - t * (6614.94 - t * 2475.67))))))) + ")";
}

// node_modules/d3-scale-chromatic/src/sequential-multi/cubehelix.js
var cubehelix_default2 = cubehelixLong(cubehelix(300, 0.5, 0), cubehelix(-240, 0.5, 1));

// node_modules/d3-scale-chromatic/src/sequential-multi/rainbow.js
var warm = cubehelixLong(cubehelix(-100, 0.75, 0.35), cubehelix(80, 1.5, 0.8));
var cool = cubehelixLong(cubehelix(260, 0.75, 0.35), cubehelix(80, 1.5, 0.8));
var c3 = cubehelix();
function rainbow_default(t) {
  if (t < 0 || t > 1)
    t -= Math.floor(t);
  var ts = Math.abs(t - 0.5);
  c3.h = 360 * t - 100;
  c3.s = 1.5 - 1.5 * ts;
  c3.l = 0.8 - 0.9 * ts;
  return c3 + "";
}

// node_modules/d3-scale-chromatic/src/sequential-multi/sinebow.js
var c4 = rgb();
var pi_1_3 = Math.PI / 3;
var pi_2_3 = Math.PI * 2 / 3;
function sinebow_default(t) {
  var x3;
  t = (0.5 - t) * Math.PI;
  c4.r = 255 * (x3 = Math.sin(t)) * x3;
  c4.g = 255 * (x3 = Math.sin(t + pi_1_3)) * x3;
  c4.b = 255 * (x3 = Math.sin(t + pi_2_3)) * x3;
  return c4 + "";
}

// node_modules/d3-scale-chromatic/src/sequential-multi/turbo.js
function turbo_default(t) {
  t = Math.max(0, Math.min(1, t));
  return "rgb(" + Math.max(0, Math.min(255, Math.round(34.61 + t * (1172.33 - t * (10793.56 - t * (33300.12 - t * (38394.49 - t * 14825.05))))))) + ", " + Math.max(0, Math.min(255, Math.round(23.31 + t * (557.33 + t * (1225.33 - t * (3574.96 - t * (1073.77 + t * 707.56))))))) + ", " + Math.max(0, Math.min(255, Math.round(27.2 + t * (3211.1 - t * (15327.97 - t * (27814 - t * (22569.18 - t * 6838.66))))))) + ")";
}

// node_modules/d3-scale-chromatic/src/sequential-multi/viridis.js
function ramp(range4) {
  var n = range4.length;
  return function(t) {
    return range4[Math.max(0, Math.min(n - 1, Math.floor(t * n)))];
  };
}
var viridis_default = ramp(colors_default("44015444025645045745055946075a46085c460a5d460b5e470d60470e6147106347116447136548146748166848176948186a481a6c481b6d481c6e481d6f481f70482071482173482374482475482576482677482878482979472a7a472c7a472d7b472e7c472f7d46307e46327e46337f463480453581453781453882443983443a83443b84433d84433e85423f854240864241864142874144874045884046883f47883f48893e49893e4a893e4c8a3d4d8a3d4e8a3c4f8a3c508b3b518b3b528b3a538b3a548c39558c39568c38588c38598c375a8c375b8d365c8d365d8d355e8d355f8d34608d34618d33628d33638d32648e32658e31668e31678e31688e30698e306a8e2f6b8e2f6c8e2e6d8e2e6e8e2e6f8e2d708e2d718e2c718e2c728e2c738e2b748e2b758e2a768e2a778e2a788e29798e297a8e297b8e287c8e287d8e277e8e277f8e27808e26818e26828e26828e25838e25848e25858e24868e24878e23888e23898e238a8d228b8d228c8d228d8d218e8d218f8d21908d21918c20928c20928c20938c1f948c1f958b1f968b1f978b1f988b1f998a1f9a8a1e9b8a1e9c891e9d891f9e891f9f881fa0881fa1881fa1871fa28720a38620a48621a58521a68522a78522a88423a98324aa8325ab8225ac8226ad8127ad8128ae8029af7f2ab07f2cb17e2db27d2eb37c2fb47c31b57b32b67a34b67935b77937b87838b9773aba763bbb753dbc743fbc7340bd7242be7144bf7046c06f48c16e4ac16d4cc26c4ec36b50c46a52c56954c56856c66758c7655ac8645cc8635ec96260ca6063cb5f65cb5e67cc5c69cd5b6ccd5a6ece5870cf5773d05675d05477d1537ad1517cd2507fd34e81d34d84d44b86d54989d5488bd6468ed64590d74393d74195d84098d83e9bd93c9dd93ba0da39a2da37a5db36a8db34aadc32addc30b0dd2fb2dd2db5de2bb8de29bade28bddf26c0df25c2df23c5e021c8e020cae11fcde11dd0e11cd2e21bd5e21ad8e219dae319dde318dfe318e2e418e5e419e7e419eae51aece51befe51cf1e51df4e61ef6e620f8e621fbe723fde725"));
var magma = ramp(colors_default("00000401000501010601010802010902020b02020d03030f03031204041405041606051806051a07061c08071e0907200a08220b09240c09260d0a290e0b2b100b2d110c2f120d31130d34140e36150e38160f3b180f3d19103f1a10421c10441d11471e114920114b21114e22115024125325125527125829115a2a115c2c115f2d11612f116331116533106734106936106b38106c390f6e3b0f703d0f713f0f72400f74420f75440f764510774710784910784a10794c117a4e117b4f127b51127c52137c54137d56147d57157e59157e5a167e5c167f5d177f5f187f601880621980641a80651a80671b80681c816a1c816b1d816d1d816e1e81701f81721f817320817521817621817822817922827b23827c23827e24828025828125818326818426818627818827818928818b29818c29818e2a81902a81912b81932b80942c80962c80982d80992d809b2e7f9c2e7f9e2f7fa02f7fa1307ea3307ea5317ea6317da8327daa337dab337cad347cae347bb0357bb2357bb3367ab5367ab73779b83779ba3878bc3978bd3977bf3a77c03a76c23b75c43c75c53c74c73d73c83e73ca3e72cc3f71cd4071cf4070d0416fd2426fd3436ed5446dd6456cd8456cd9466bdb476adc4869de4968df4a68e04c67e24d66e34e65e44f64e55064e75263e85362e95462ea5661eb5760ec5860ed5a5fee5b5eef5d5ef05f5ef1605df2625df2645cf3655cf4675cf4695cf56b5cf66c5cf66e5cf7705cf7725cf8745cf8765cf9785df9795df97b5dfa7d5efa7f5efa815ffb835ffb8560fb8761fc8961fc8a62fc8c63fc8e64fc9065fd9266fd9467fd9668fd9869fd9a6afd9b6bfe9d6cfe9f6dfea16efea36ffea571fea772fea973feaa74feac76feae77feb078feb27afeb47bfeb67cfeb77efeb97ffebb81febd82febf84fec185fec287fec488fec68afec88cfeca8dfecc8ffecd90fecf92fed194fed395fed597fed799fed89afdda9cfddc9efddea0fde0a1fde2a3fde3a5fde5a7fde7a9fde9aafdebacfcecaefceeb0fcf0b2fcf2b4fcf4b6fcf6b8fcf7b9fcf9bbfcfbbdfcfdbf"));
var inferno = ramp(colors_default("00000401000501010601010802010a02020c02020e03021004031204031405041706041907051b08051d09061f0a07220b07240c08260d08290e092b10092d110a30120a32140b34150b37160b39180c3c190c3e1b0c411c0c431e0c451f0c48210c4a230c4c240c4f260c51280b53290b552b0b572d0b592f0a5b310a5c320a5e340a5f3609613809623909633b09643d09653e0966400a67420a68440a68450a69470b6a490b6a4a0c6b4c0c6b4d0d6c4f0d6c510e6c520e6d540f6d550f6d57106e59106e5a116e5c126e5d126e5f136e61136e62146e64156e65156e67166e69166e6a176e6c186e6d186e6f196e71196e721a6e741a6e751b6e771c6d781c6d7a1d6d7c1d6d7d1e6d7f1e6c801f6c82206c84206b85216b87216b88226a8a226a8c23698d23698f24699025689225689326679526679727669827669a28659b29649d29649f2a63a02a63a22b62a32c61a52c60a62d60a82e5fa92e5eab2f5ead305dae305cb0315bb1325ab3325ab43359b63458b73557b93556ba3655bc3754bd3853bf3952c03a51c13a50c33b4fc43c4ec63d4dc73e4cc83f4bca404acb4149cc4248ce4347cf4446d04545d24644d34743d44842d54a41d74b3fd84c3ed94d3dda4e3cdb503bdd513ade5238df5337e05536e15635e25734e35933e45a31e55c30e65d2fe75e2ee8602de9612bea632aeb6429eb6628ec6726ed6925ee6a24ef6c23ef6e21f06f20f1711ff1731df2741cf3761bf37819f47918f57b17f57d15f67e14f68013f78212f78410f8850ff8870ef8890cf98b0bf98c0af98e09fa9008fa9207fa9407fb9606fb9706fb9906fb9b06fb9d07fc9f07fca108fca309fca50afca60cfca80dfcaa0ffcac11fcae12fcb014fcb216fcb418fbb61afbb81dfbba1ffbbc21fbbe23fac026fac228fac42afac62df9c72ff9c932f9cb35f8cd37f8cf3af7d13df7d340f6d543f6d746f5d949f5db4cf4dd4ff4df53f4e156f3e35af3e55df2e661f2e865f2ea69f1ec6df1ed71f1ef75f1f179f2f27df2f482f3f586f3f68af4f88ef5f992f6fa96f8fb9af9fc9dfafda1fcffa4"));
var plasma = ramp(colors_default("0d088710078813078916078a19068c1b068d1d068e20068f2206902406912605912805922a05932c05942e05952f059631059733059735049837049938049a3a049a3c049b3e049c3f049c41049d43039e44039e46039f48039f4903a04b03a14c02a14e02a25002a25102a35302a35502a45601a45801a45901a55b01a55c01a65e01a66001a66100a76300a76400a76600a76700a86900a86a00a86c00a86e00a86f00a87100a87201a87401a87501a87701a87801a87a02a87b02a87d03a87e03a88004a88104a78305a78405a78606a68707a68808a68a09a58b0aa58d0ba58e0ca48f0da4910ea3920fa39410a29511a19613a19814a099159f9a169f9c179e9d189d9e199da01a9ca11b9ba21d9aa31e9aa51f99a62098a72197a82296aa2395ab2494ac2694ad2793ae2892b02991b12a90b22b8fb32c8eb42e8db52f8cb6308bb7318ab83289ba3388bb3488bc3587bd3786be3885bf3984c03a83c13b82c23c81c33d80c43e7fc5407ec6417dc7427cc8437bc9447aca457acb4679cc4778cc4977cd4a76ce4b75cf4c74d04d73d14e72d24f71d35171d45270d5536fd5546ed6556dd7566cd8576bd9586ada5a6ada5b69db5c68dc5d67dd5e66de5f65de6164df6263e06363e16462e26561e26660e3685fe4695ee56a5de56b5de66c5ce76e5be76f5ae87059e97158e97257ea7457eb7556eb7655ec7754ed7953ed7a52ee7b51ef7c51ef7e50f07f4ff0804ef1814df1834cf2844bf3854bf3874af48849f48948f58b47f58c46f68d45f68f44f79044f79143f79342f89441f89540f9973ff9983ef99a3efa9b3dfa9c3cfa9e3bfb9f3afba139fba238fca338fca537fca636fca835fca934fdab33fdac33fdae32fdaf31fdb130fdb22ffdb42ffdb52efeb72dfeb82cfeba2cfebb2bfebd2afebe2afec029fdc229fdc328fdc527fdc627fdc827fdca26fdcb26fccd25fcce25fcd025fcd225fbd324fbd524fbd724fad824fada24f9dc24f9dd25f8df25f8e125f7e225f7e425f6e626f6e826f5e926f5eb27f4ed27f3ee27f3f027f2f227f1f426f1f525f0f724f0f921"));

// node_modules/@antv/g2/esm/runtime/scale.js
function inferScale(name2, values4, options, coordinates, theme, library3) {
  const { guide = {} } = options;
  const type = inferScaleType(name2, values4, options);
  if (typeof type !== "string")
    return options;
  const expectedDomain = inferScaleDomain(type, name2, values4, options);
  const actualDomain = maybeRatio(type, expectedDomain, options);
  return Object.assign(Object.assign(Object.assign({}, options), inferScaleOptions(type, name2, values4, options, coordinates)), {
    domain: actualDomain,
    range: inferScaleRange(type, name2, values4, options, actualDomain, theme, library3),
    expectedDomain,
    guide,
    name: name2,
    type
  });
}
function applyScale(channels, scale10) {
  const scaledValue = {};
  for (const channel of channels) {
    const { values: values4, name: scaleName } = channel;
    const scaleInstance = scale10[scaleName];
    for (const value2 of values4) {
      const { name: name2, value: V } = value2;
      scaledValue[name2] = V.map((d2) => scaleInstance.map(d2));
    }
  }
  return scaledValue;
}
function collectScales(states, options) {
  var _a2;
  const { components = [] } = options;
  const NONE_STATIC_KEYS = [
    "scale",
    "encode",
    "axis",
    "legend",
    "data",
    "transform"
  ];
  const scales = Array.from(new Set(states.flatMap((d2) => d2.channels.map((d3) => d3.scale))));
  const nameScale = new Map(scales.map((scale10) => [scale10.name, scale10]));
  for (const component of components) {
    const channels = inferChannelsForComponent(component);
    for (const channel of channels) {
      const scale10 = nameScale.get(channel);
      const staticScale = ((_a2 = component.scale) === null || _a2 === void 0 ? void 0 : _a2[channel]) || {};
      const { independent = false } = staticScale;
      if (scale10 && !independent) {
        const { guide } = scale10;
        const guide1 = typeof guide === "boolean" ? {} : guide;
        scale10.guide = deep_mix_default({}, guide1, component);
        Object.assign(scale10, staticScale);
      } else {
        const options1 = Object.assign(Object.assign({}, staticScale), { expectedDomain: staticScale.domain, name: channel, guide: omit_default(component, NONE_STATIC_KEYS) });
        scales.push(options1);
      }
    }
  }
  return scales;
}
function useRelation(relations) {
  if (!relations || !Array.isArray(relations))
    return [identity5, identity5];
  let map5;
  let invert6;
  const conditionalize = (scale10) => {
    var _a2;
    map5 = scale10.map.bind(scale10);
    invert6 = (_a2 = scale10.invert) === null || _a2 === void 0 ? void 0 : _a2.bind(scale10);
    const funcRelations = relations.filter(([v]) => typeof v === "function");
    const valueRelations = relations.filter(([v]) => typeof v !== "function");
    const valueOutput = new Map(valueRelations);
    scale10.map = (x3) => {
      for (const [verify, value2] of funcRelations) {
        if (verify(x3))
          return value2;
      }
      if (valueOutput.has(x3))
        return valueOutput.get(x3);
      return map5(x3);
    };
    if (!invert6)
      return scale10;
    const outputValue = new Map(valueRelations.map(([a4, b]) => [b, a4]));
    const outputFunc = new Map(funcRelations.map(([a4, b]) => [b, a4]));
    scale10.invert = (x3) => {
      if (outputFunc.has(x3))
        return x3;
      if (outputValue.has(x3))
        return outputValue.get(x3);
      return invert6(x3);
    };
    return scale10;
  };
  const deconditionalize = (scale10) => {
    if (map5 !== null)
      scale10.map = map5;
    if (invert6 !== null)
      scale10.invert = invert6;
    return scale10;
  };
  return [conditionalize, deconditionalize];
}
function assignScale(target, source) {
  const keys3 = Object.keys(target);
  for (const scale10 of Object.values(source)) {
    const { name: name2 } = scale10.getOptions();
    if (!(name2 in target))
      target[name2] = scale10;
    else {
      const I = keys3.filter((d2) => d2.startsWith(name2)).map((d2) => +(d2.replace(name2, "") || 0));
      const index3 = max4(I) + 1;
      const newKey = `${name2}${index3}`;
      target[newKey] = scale10;
      scale10.getOptions().key = newKey;
    }
  }
  return target;
}
function useRelationScale(options, library3) {
  const [useScale] = useLibrary("scale", library3);
  const { relations } = options;
  const [conditionalize] = useRelation(relations);
  const scale10 = useScale(options);
  return conditionalize(scale10);
}
function syncFacetsScales(states) {
  const scales = states.flatMap((d2) => Array.from(d2.values())).flatMap((d2) => d2.channels.map((d3) => d3.scale));
  syncFacetsScaleByChannel(scales, "x");
  syncFacetsScaleByChannel(scales, "y");
}
function inferChannelsForComponent(component) {
  const { channels = [], type, scale: scale10 = {} } = component;
  const L = ["shape", "color", "opacity", "size"];
  if (channels.length !== 0)
    return channels;
  if (type === "axisX")
    return ["x"];
  if (type === "axisY")
    return ["y"];
  if (type === "legends")
    return Object.keys(scale10).filter((d2) => L.includes(d2));
  return [];
}
function syncFacetsScaleByChannel(scales, channel) {
  const S = scales.filter(({ name: name2, facet = true }) => facet && name2 === channel);
  const D2 = S.flatMap((d2) => d2.domain);
  const syncedD = S.every(isQuantitativeScale) ? extent(D2) : S.every(isDiscreteScale) ? Array.from(new Set(D2)) : null;
  if (syncedD === null)
    return;
  for (const scale10 of S) {
    scale10.domain = syncedD;
  }
}
function maybeRatio(type, domain, options) {
  const { ratio } = options;
  if (ratio === void 0 || ratio === null)
    return domain;
  if (isQuantitativeScale({ type })) {
    return clampQuantitativeScale(domain, ratio, type);
  }
  if (isDiscreteScale({ type }))
    return clampDiscreteScale(domain, ratio);
  return domain;
}
function clampQuantitativeScale(domain, ratio, type) {
  const D2 = domain.map(Number);
  const scale10 = new Linear({
    domain: D2,
    range: [D2[0], D2[0] + (D2[D2.length - 1] - D2[0]) * ratio]
  });
  if (type === "time")
    return domain.map((d2) => new Date(scale10.map(d2)));
  return domain.map((d2) => scale10.map(d2));
}
function clampDiscreteScale(domain, ratio) {
  const index3 = Math.round(domain.length * ratio);
  return domain.slice(0, index3);
}
function isQuantitativeScale(scale10) {
  const { type } = scale10;
  if (typeof type !== "string")
    return false;
  const names = ["linear", "log", "pow", "time"];
  return names.includes(type);
}
function isDiscreteScale(scale10) {
  const { type } = scale10;
  if (typeof type !== "string")
    return false;
  const names = ["band", "point", "ordinal"];
  return names.includes(type);
}
function inferScaleType(name2, values4, options) {
  const { type, domain, range: range4, quantitative, ordinal } = options;
  if (type !== void 0)
    return type;
  if (isObject2(values4))
    return "identity";
  if (typeof range4 === "string")
    return "linear";
  if ((domain || range4 || []).length > 2)
    return asOrdinalType(name2, ordinal);
  if (domain !== void 0) {
    if (isOrdinal([domain]))
      return asOrdinalType(name2, ordinal);
    if (isTemporal(values4))
      return "time";
    return asQuantitativeType(name2, range4, quantitative);
  }
  if (isOrdinal(values4))
    return asOrdinalType(name2, ordinal);
  if (isTemporal(values4))
    return "time";
  return asQuantitativeType(name2, range4, quantitative);
}
function inferScaleDomain(type, name2, values4, options) {
  const { domain } = options;
  if (domain !== void 0)
    return domain;
  switch (type) {
    case "linear":
    case "time":
    case "log":
    case "pow":
    case "sqrt":
    case "quantize":
    case "threshold":
      return maybeMinMax(inferDomainQ(values4, options), options);
    case "band":
    case "ordinal":
    case "point":
      return inferDomainC(values4);
    case "quantile":
      return inferDomainO(values4);
    case "sequential":
      return maybeMinMax(inferDomainS(values4), options);
    default:
      return [];
  }
}
function inferScaleRange(type, name2, values4, options, domain, theme, library3) {
  const { range: range4 } = options;
  if (typeof range4 === "string")
    return gradientColors(range4);
  if (range4 !== void 0)
    return range4;
  const { rangeMin, rangeMax } = options;
  switch (type) {
    case "linear":
    case "time":
    case "log":
    case "pow":
    case "sqrt": {
      const colors = categoricalColors(values4, options, domain, theme, library3);
      const [r0, r1] = inferRangeQ(name2, colors);
      return [rangeMin || r0, rangeMax || r1];
    }
    case "band":
    case "point": {
      const min11 = name2 === "size" ? 5 : 0;
      const max11 = name2 === "size" ? 10 : 1;
      return [rangeMin || min11, rangeMax || max11];
    }
    case "ordinal": {
      return categoricalColors(values4, options, domain, theme, library3);
    }
    case "sequential":
      return void 0;
    case "constant":
      return [values4[0][0]];
    default:
      return [];
  }
}
function inferScaleOptions(type, name2, values4, options, coordinates) {
  switch (type) {
    case "linear":
    case "time":
    case "log":
    case "pow":
    case "sqrt":
      return inferOptionsQ(coordinates, options);
    case "band":
    case "point":
      return inferOptionsC(type, name2, coordinates, options);
    case "sequential":
      return inferOptionsS(options);
    default:
      return options;
  }
}
function categoricalColors(values4, options, domain, theme, library3) {
  const [usePalette] = useLibrary("palette", library3);
  const { category10: c10, category20: c20 } = theme;
  const defaultPalette = unique(values4.flat()).length <= c10.length ? c10 : c20;
  const { palette = defaultPalette, offset: offset2 } = options;
  if (Array.isArray(palette))
    return palette;
  try {
    return usePalette({ type: palette });
  } catch (e) {
    const colors = interpolatedColors(palette, domain, offset2);
    if (colors)
      return colors;
    throw new Error(`Unknown Component: ${palette} `);
  }
}
function gradientColors(range4) {
  return range4.split("-");
}
function interpolatedColors(palette, domain, offset2 = (d2) => d2) {
  if (!palette)
    return null;
  const fullName = upper_first_default(palette);
  const scheme28 = src_exports2[`scheme${fullName}`];
  const interpolator = src_exports2[`interpolate${fullName}`];
  if (!scheme28 && !interpolator)
    return null;
  if (scheme28) {
    if (!scheme28.some(Array.isArray))
      return scheme28;
    const schemeColors = scheme28[domain.length];
    if (schemeColors)
      return schemeColors;
  }
  return domain.map((_2, i) => interpolator(offset2(i / domain.length)));
}
function inferOptionsS(options) {
  const { palette = "ylGnBu", offset: offset2 } = options;
  const name2 = upper_first_default(palette);
  const interpolator = src_exports2[`interpolate${name2}`];
  if (!interpolator)
    throw new Error(`Unknown palette: ${name2}`);
  return {
    interpolator: offset2 ? (x3) => interpolator(offset2(x3)) : interpolator
  };
}
function inferOptionsQ(coordinates, options) {
  const { interpolate: interpolate4 = createInterpolateValue, nice: nice2 = false, tickCount = 5 } = options;
  return Object.assign(Object.assign({}, options), { interpolate: interpolate4, nice: nice2, tickCount });
}
function inferOptionsC(type, name2, coordinates, options) {
  if (options.padding !== void 0 || options.paddingInner !== void 0 || options.paddingOuter !== void 0) {
    return Object.assign(Object.assign({}, options), { unknown: NaN });
  }
  const padding = inferPadding(type, name2, coordinates);
  const { paddingInner = padding, paddingOuter = padding } = options;
  return Object.assign(Object.assign({}, options), {
    paddingInner,
    paddingOuter,
    padding,
    unknown: NaN
  });
}
function inferPadding(type, name2, coordinates) {
  if (name2 === "enterDelay" || name2 === "enterDuration")
    return 0;
  if (name2 === "size")
    return 0;
  if (type === "band")
    return isTheta2(coordinates) ? 0 : 0.1;
  if (type === "point")
    return 0.5;
  return 0;
}
function asOrdinalType(name2, defaults5) {
  if (defaults5)
    return defaults5;
  return isQuantitative(name2) ? "point" : "ordinal";
}
function asQuantitativeType(name2, range4, defaults5) {
  if (defaults5)
    return defaults5;
  if (name2 !== "color")
    return "linear";
  return range4 ? "linear" : "sequential";
}
function maybeMinMax(domain, options) {
  if (domain.length === 0)
    return domain;
  const { domainMin, domainMax } = options;
  const [d0, d1] = domain;
  return [domainMin !== null && domainMin !== void 0 ? domainMin : d0, domainMax !== null && domainMax !== void 0 ? domainMax : d1];
}
function inferDomainQ(values4, options) {
  const { zero: zero5 = false } = options;
  let min11 = Infinity;
  let max11 = -Infinity;
  for (const value2 of values4) {
    for (const d2 of value2) {
      if (defined(d2)) {
        min11 = Math.min(min11, +d2);
        max11 = Math.max(max11, +d2);
      }
    }
  }
  if (min11 === Infinity)
    return [];
  return zero5 ? [Math.min(0, min11), max11] : [min11, max11];
}
function inferDomainC(values4) {
  return Array.from(new Set(values4.flat()));
}
function inferDomainO(values4) {
  return inferDomainC(values4).sort();
}
function inferDomainS(values4) {
  let min11 = Infinity;
  let max11 = -Infinity;
  for (const value2 of values4) {
    for (const d2 of value2) {
      if (defined(d2)) {
        min11 = Math.min(min11, +d2);
        max11 = Math.max(max11, +d2);
      }
    }
  }
  if (min11 === Infinity)
    return [];
  return [min11 < 0 ? -max11 : min11, max11];
}
function inferRangeQ(name2, palette) {
  if (name2 === "enterDelay")
    return [0, 1e3];
  if (name2 == "enterDuration")
    return [300, 1e3];
  if (name2.startsWith("y") || name2.startsWith("position"))
    return [1, 0];
  if (name2 === "color")
    return [firstOf(palette), lastOf(palette)];
  if (name2 === "opacity")
    return [0, 1];
  if (name2 === "size")
    return [1, 10];
  return [0, 1];
}
function isOrdinal(values4) {
  return some2(values4, (d2) => {
    const type = typeof d2;
    return type === "string" || type === "boolean";
  });
}
function isTemporal(values4) {
  return some2(values4, (d2) => d2 instanceof Date);
}
function isObject2(values4) {
  return some2(values4, isStrictObject);
}
function some2(values4, callback) {
  for (const V of values4) {
    if (V.some(callback))
      return true;
  }
  return false;
}
function isQuantitative(name2) {
  return name2.startsWith("x") || name2.startsWith("y") || name2.startsWith("position") || name2.startsWith("size");
}
function isPosition(name2) {
  return name2.startsWith("x") || name2.startsWith("y") || name2.startsWith("position") || name2 === "enterDelay" || name2 === "enterDuration" || name2 === "updateDelay" || name2 === "updateDuration" || name2 === "exitDelay" || name2 === "exitDuration";
}
function isValidScale(scale10) {
  if (!scale10 || !scale10.type)
    return false;
  if (typeof scale10.type === "function")
    return true;
  const { type, domain, range: range4, interpolator } = scale10;
  const isValidDomain = domain && domain.length > 0;
  const isValidRange = range4 && range4.length > 0;
  if ([
    "linear",
    "sqrt",
    "log",
    "time",
    "pow",
    "threshold",
    "quantize",
    "quantile",
    "ordinal",
    "band",
    "point"
  ].includes(type) && isValidDomain && isValidRange) {
    return true;
  }
  if (["sequential"].includes(type) && isValidDomain && (isValidRange || interpolator)) {
    return true;
  }
  if (["constant", "identity"].includes(type) && isValidRange)
    return true;
  return false;
}

// node_modules/@antv/g2/esm/runtime/types/scale.js
var ContinuousScale = {
  linear: "linear",
  identity: "identity",
  log: "log",
  pow: "pow",
  sqrt: "sqrt",
  sequential: "sequential"
};
var DistributionScale = {
  threshold: "threshold",
  quantize: "quantize",
  quantile: "quantile"
};
var DiscreteScale = {
  ordinal: "ordinal",
  band: "band",
  point: "point"
};
var ConstantScale = {
  constant: "constant"
};

// node_modules/@antv/g2/esm/runtime/component.js
var __rest73 = function(s2, e) {
  var t = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
      t[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t[p2[i]] = s2[p2[i]];
    }
  return t;
};
function inferComponent(scales, partialOptions, library3) {
  const { coordinates = [], title } = partialOptions;
  const [, createGuideComponent] = useLibrary("component", library3);
  const displayedScales = scales.filter(({ guide }) => {
    if (guide === null)
      return false;
    return true;
  });
  const components = [];
  const sliders = inferScrollableComponents(partialOptions, scales, library3);
  components.push(...sliders);
  if (title) {
    const { props } = createGuideComponent("title");
    const { defaultPosition, defaultOrientation, defaultOrder, defaultSize, defaultCrossPadding } = props;
    const titleOptions = typeof title === "string" ? { title } : title;
    components.push(Object.assign({ type: "title", position: defaultPosition, orientation: defaultOrientation, order: defaultOrder, crossPadding: defaultCrossPadding[0], defaultSize }, titleOptions));
  }
  const inferredComponents = inferComponentsType(displayedScales, coordinates);
  inferredComponents.forEach(([type, relativeScales]) => {
    const { props } = createGuideComponent(type);
    const { defaultPosition, defaultPlane = "xy", defaultOrientation, defaultSize, defaultOrder, defaultLength, defaultPadding: DP = [0, 0], defaultCrossPadding: DCP = [0, 0] } = props;
    const scale10 = deep_mix_default({}, ...relativeScales);
    const { guide: guideOptions, field: field3 } = scale10;
    const guides = Array.isArray(guideOptions) ? guideOptions : [guideOptions];
    for (const partialGuide of guides) {
      const [position, orientation] = inferComponentPositionAndOrientation(type, defaultPosition, defaultOrientation, partialGuide, relativeScales, displayedScales, coordinates);
      if (!position && !orientation)
        continue;
      const isVertical2 = position === "left" || position === "right";
      const defaultPadding = isVertical2 ? DP[1] : DP[0];
      const defaultCrossPadding = isVertical2 ? DCP[1] : DCP[0];
      const { size: size5, order = defaultOrder, length: length5 = defaultLength, padding = defaultPadding, crossPadding = defaultCrossPadding } = partialGuide;
      components.push(Object.assign(Object.assign({ title: field3 }, partialGuide), {
        defaultSize,
        length: length5,
        position,
        plane: defaultPlane,
        orientation,
        padding,
        order,
        crossPadding,
        size: size5,
        type,
        scales: relativeScales
      }));
    }
  });
  return components;
}
function renderComponent(component, coordinate2, theme, library3, markState) {
  const [useGuideComponent] = useLibrary("component", library3);
  const { scaleInstances: scales, scale: scale10, bbox } = component, options = __rest73(component, ["scaleInstances", "scale", "bbox"]);
  const value2 = { bbox, library: library3 };
  const render3 = useGuideComponent(options);
  return render3({
    coordinate: coordinate2,
    library: library3,
    markState,
    scales,
    theme,
    value: value2,
    scale: scale10
  });
}
function normalizeComponents(components) {
  return components.map((d2) => {
    const component = deep_mix_default(d2, d2.style);
    delete component.style;
    return component;
  });
}
function groupComponents(components, crossSize) {
  const P = ["left", "right", "bottom", "top"];
  const key = ({ type, position, group: group3 }) => {
    if (!P.includes(position))
      return Symbol("independent");
    if (group3 === void 0) {
      if (type.startsWith("legend"))
        return `legend-${position}`;
      return Symbol("independent");
    }
    if (group3 === "independent")
      return Symbol("independent");
    return group3;
  };
  const grouped = groups(components, key);
  return grouped.flatMap(([, components2]) => {
    if (components2.length === 1)
      return components2[0];
    if (crossSize !== void 0) {
      const DL = components2.filter((d2) => d2.length !== void 0).map((d2) => d2.length);
      const totalLength = sum(DL);
      if (totalLength > crossSize) {
        components2.forEach((d2) => d2.group = Symbol("independent"));
        return components2;
      }
      const emptyLength = crossSize - totalLength;
      const emptyCount = components2.length - DL.length;
      const length5 = emptyLength / emptyCount;
      components2.forEach((d2) => {
        if (d2.length !== void 0)
          return;
        d2.length = length5;
      });
    }
    const size5 = max4(components2, (d2) => d2.size);
    const order = max4(components2, (d2) => d2.order);
    const crossPadding = max4(components2, (d2) => d2.crossPadding);
    const position = components2[0].position;
    return {
      type: "group",
      size: size5,
      order,
      position,
      children: components2,
      crossPadding
    };
  });
}
function inferLegendComponentType(scales, coordinates) {
  const channels = ["shape", "size", "color", "opacity"];
  const isConstantSize = (type, name2) => type === "constant" && name2 === "size";
  const accepts = scales.filter(({ type, name: name2 }) => typeof type === "string" && channels.includes(name2) && !isConstantSize(type, name2));
  const constants = accepts.filter(({ type }) => type === "constant");
  const nonConstants = accepts.filter(({ type }) => type !== "constant");
  const groupKey = (d2) => d2.field ? d2.field : Symbol("independent");
  const fieldScales = groups(nonConstants, groupKey).map(([key, scales2]) => [key, [...scales2, ...constants]]).filter(([, scales2]) => scales2.some((scale10) => scale10.type !== "constant"));
  const scalesByField = new Map(fieldScales);
  if (scalesByField.size === 0)
    return [];
  const sort2 = (arr) => arr.sort(([a4], [b]) => a4.localeCompare(b));
  const components = Array.from(scalesByField).map(([, scs]) => {
    const combinations = combine(scs).sort((a4, b) => b.length - a4.length);
    const options = combinations.map((combination) => ({
      combination,
      option: combination.map((scale10) => [scale10.name, getScaleType(scale10)])
    }));
    for (const { option, combination } of options) {
      if (option.every((d2) => d2[1] === "constant"))
        continue;
      if (option.every((d2) => d2[1] === "discrete" || d2[1] === "constant")) {
        return ["legendCategory", combination];
      }
    }
    for (const [componentType, accords] of LEGEND_INFER_STRATEGIES) {
      for (const { option, combination } of options) {
        if (accords.some((accord) => is_equal_default(sort2(accord), sort2(option)))) {
          return [componentType, combination];
        }
      }
    }
    return null;
  }).filter(defined);
  return components;
}
function getScaleType(scale10) {
  const { type } = scale10;
  if (typeof type !== "string")
    return null;
  if (type in ContinuousScale)
    return "continuous";
  if (type in DiscreteScale)
    return "discrete";
  if (type in DistributionScale)
    return "distribution";
  if (type in ConstantScale)
    return "constant";
  return null;
}
function inferAxisComponentType(scales, coordinates) {
  return scales.map((scale10) => {
    const { name: name2 } = scale10;
    if (isHelix2(coordinates) || isTheta2(coordinates))
      return null;
    if (isTranspose2(coordinates) && (isPolar2(coordinates) || isRadial2(coordinates)))
      return null;
    if (name2.startsWith("x")) {
      if (isPolar2(coordinates))
        return ["axisArc", [scale10]];
      if (isRadial2(coordinates))
        return ["axisLinear", [scale10]];
      return [isTranspose2(coordinates) ? "axisY" : "axisX", [scale10]];
    }
    if (name2.startsWith("y")) {
      if (isPolar2(coordinates))
        return ["axisLinear", [scale10]];
      if (isRadial2(coordinates))
        return ["axisArc", [scale10]];
      return [isTranspose2(coordinates) ? "axisX" : "axisY", [scale10]];
    }
    if (name2.startsWith("z")) {
      return ["axisZ", [scale10]];
    }
    if (name2.startsWith("position")) {
      if (isRadar2(coordinates))
        return ["axisRadar", [scale10]];
      if (!isPolar2(coordinates))
        return ["axisY", [scale10]];
    }
    return null;
  }).filter(defined);
}
function inferComponentsType(scales, coordinates) {
  const availableScales = scales.filter((scale10) => isValidScale(scale10));
  return [
    ...inferLegendComponentType(availableScales, coordinates),
    ...inferAxisComponentType(availableScales, coordinates)
  ];
}
function angleOf3(coordinates) {
  const polar2 = coordOf(coordinates, "polar");
  if (polar2.length) {
    const lastPolar = polar2[polar2.length - 1];
    const { startAngle, endAngle } = getPolarOptions(lastPolar);
    return [startAngle, endAngle];
  }
  const radial = coordOf(coordinates, "radial");
  if (radial.length) {
    const lastRadial = radial[radial.length - 1];
    const { startAngle, endAngle } = getRadialOptions(lastRadial);
    return [startAngle, endAngle];
  }
  return [-Math.PI / 2, Math.PI / 2 * 3];
}
function matchPosition(name2) {
  const match = /position(\d*)/g.exec(name2);
  if (!match)
    return null;
  return +match[1];
}
function inferAxisPositionAndOrientation(type, ordinalPosition, relativeScales, scales, coordinates) {
  const { name: name2 } = relativeScales[0];
  if (type === "axisRadar") {
    const positions = scales.filter((scale10) => scale10.name.startsWith("position"));
    const index3 = matchPosition(name2);
    if (name2 === positions.slice(-1)[0].name || index3 === null)
      return [null, null];
    const [startAngle, endAngle] = angleOf3(coordinates);
    const angle4 = (endAngle - startAngle) / (positions.length - 1) * index3 + startAngle;
    return ["center", angle4];
  }
  if (type === "axisY" && isParallel2(coordinates)) {
    return isTranspose2(coordinates) ? ["center", "horizontal"] : ["center", "vertical"];
  }
  if (type === "axisLinear") {
    const [startAngle] = angleOf3(coordinates);
    return ["center", startAngle];
  }
  if (type === "axisArc") {
    if (ordinalPosition[0] === "inner")
      return ["inner", null];
    return ["outer", null];
  }
  if (isPolar2(coordinates))
    return ["center", null];
  if (isRadial2(coordinates))
    return ["center", null];
  if (type === "axisX" && isReflect(coordinates) || type === "axisX" && isReflectY(coordinates)) {
    return ["top", null];
  }
  return ordinalPosition;
}
function inferComponentPositionAndOrientation(type, defaultPosition, defaultOrientation, guide, relativeScales, scales, coordinates) {
  const [startAngle] = angleOf3(coordinates);
  const ordinalPositionAndOrientation = [
    guide.position || defaultPosition,
    startAngle !== null && startAngle !== void 0 ? startAngle : defaultOrientation
  ];
  if (typeof type === "string" && type.startsWith("axis")) {
    return inferAxisPositionAndOrientation(type, ordinalPositionAndOrientation, relativeScales, scales, coordinates);
  }
  if (typeof type === "string" && type.startsWith("legend") && isPolar2(coordinates)) {
    if (guide.position === "center")
      return ["center", "vertical"];
  }
  return ordinalPositionAndOrientation;
}
function inferScrollableType(name2, type, coordinates = []) {
  if (name2 === "x")
    return isTranspose2(coordinates) ? `${type}Y` : `${type}X`;
  if (name2 === "y")
    return isTranspose2(coordinates) ? `${type}X` : `${type}Y`;
  return null;
}
function inferScrollableComponents(partialOptions, scales, library3) {
  const [, createGuideComponent] = useLibrary("component", library3);
  const { coordinates } = partialOptions;
  function normalized(type, channelName, scale10, options) {
    const componentType = inferScrollableType(channelName, type, coordinates);
    if (!options || !componentType)
      return;
    const { props } = createGuideComponent(componentType);
    const { defaultPosition, defaultSize, defaultOrder, defaultCrossPadding: [crossPadding] } = props;
    return Object.assign(Object.assign({ position: defaultPosition, defaultSize, order: defaultOrder, type: componentType, crossPadding }, options), { scales: [scale10] });
  }
  return scales.filter((d2) => d2.slider || d2.scrollbar).flatMap((scale10) => {
    const { slider, scrollbar, name: channelName } = scale10;
    return [
      normalized("slider", channelName, scale10, slider),
      normalized("scrollbar", channelName, scale10, scrollbar)
    ];
  }).filter((d2) => !!d2);
}
function computeComponentSize(component, crossSize, crossPadding, position, theme, library3) {
  const { type } = component;
  const paddingAreas = ["left", "right", "bottom", "top"];
  if (!paddingAreas.includes(position))
    return;
  if (typeof type !== "string")
    return;
  const t = type;
  const createCompute = () => {
    if (t.startsWith("axis"))
      return computeAxisSize;
    if (t.startsWith("group"))
      return computeGroupSize;
    if (t.startsWith("legendContinuous"))
      return computeContinuousLegendSize;
    if (t === "legendCategory")
      return computeCategoryLegendSize;
    if (t.startsWith("slider"))
      return computeSliderSize;
    if (t === "title")
      return computeTitleSize;
    if (t.startsWith("scrollbar"))
      return computeScrollbarSize;
    return () => {
    };
  };
  return createCompute()(component, crossSize, crossPadding, position, theme, library3);
}
function computeGroupSize(component, crossSize, crossPadding, position, theme, library3) {
  const { children } = component;
  const maxCrossPadding = max4(children, (d2) => d2.crossPadding);
  children.forEach((d2) => d2.crossPadding = maxCrossPadding);
  children.forEach((child) => computeComponentSize(child, crossSize, crossPadding, position, theme, library3));
  const maxSize = max4(children, (d2) => d2.size);
  component.size = maxSize;
  children.forEach((d2) => d2.size = maxSize);
}
function computeScrollbarSize(component, crossSize, crossPadding, position, theme, library3) {
  const { trackSize = 6 } = deep_mix_default({}, theme.scrollbar, component);
  component.size = trackSize;
}
function computeTitleSize(component, crossSize, crossPadding, position, theme, library3) {
  const _a2 = deep_mix_default({}, theme.title, component), { title, subtitle, spacing = 0 } = _a2, style = __rest73(_a2, ["title", "subtitle", "spacing"]);
  if (title) {
    const titleStyle = subObject(style, "title");
    const titleBBox = computeLabelSize(title, titleStyle);
    component.size = titleBBox.height;
  }
  if (subtitle) {
    const subtitleStyle = subObject(style, "subtitle");
    const subtitleBBox = computeLabelSize(subtitle, subtitleStyle);
    component.size += spacing + subtitleBBox.height;
  }
}
function computeSliderSize(component, crossSize, crossPadding, position, theme, library3) {
  const styleOf2 = () => {
    const { slider } = theme;
    return deep_mix_default({}, slider, component);
  };
  const { trackSize, handleIconSize } = styleOf2();
  const size5 = Math.max(trackSize, handleIconSize * 2.4);
  component.size = size5;
}
function computeAxisSize(component, crossSize, crossPadding, position, theme, library3) {
  component.transform = component.transform || [{ type: "hide" }];
  const isVertical2 = position === "left" || position === "right";
  const style = styleOf(component, position, theme);
  const { tickLength = 0, labelSpacing = 0, titleSpacing = 0, labelAutoRotate } = style, rest2 = __rest73(style, ["tickLength", "labelSpacing", "titleSpacing", "labelAutoRotate"]);
  const scale10 = createScale(component, library3);
  const labelBBoxes = computeLabelsBBox(rest2, scale10);
  const paddingTick = tickLength + labelSpacing;
  if (labelBBoxes && labelBBoxes.length) {
    const maxLabelWidth = max4(labelBBoxes, (d2) => d2.width);
    const maxLabelHeight = max4(labelBBoxes, (d2) => d2.height);
    if (isVertical2) {
      component.size = maxLabelWidth + paddingTick;
    } else {
      const { tickFilter, labelTransform } = component;
      if (overflowX(scale10, labelBBoxes, crossSize, crossPadding, tickFilter) && !labelTransform && labelAutoRotate !== false && labelAutoRotate !== null) {
        component.labelTransform = "rotate(90)";
        component.size = maxLabelWidth + paddingTick;
      } else {
        component.size = maxLabelHeight + paddingTick;
      }
    }
  } else {
    component.size = tickLength;
  }
  const titleBBox = computeTitleBBox(rest2);
  if (titleBBox) {
    if (isVertical2) {
      component.size += titleSpacing + titleBBox.width;
    } else {
      component.size += titleSpacing + titleBBox.height;
    }
  }
}
function computeContinuousLegendSize(component, crossSize, crossPadding, position, theme, library3) {
  const styleOf2 = () => {
    const { legendContinuous } = theme;
    return deep_mix_default({}, legendContinuous, component);
  };
  const _a2 = styleOf2(), { labelSpacing = 0, titleSpacing = 0 } = _a2, rest2 = __rest73(_a2, ["labelSpacing", "titleSpacing"]);
  const isVertical2 = position === "left" || position === "right";
  const ribbonStyles = subObject(rest2, "ribbon");
  const { size: ribbonSize } = ribbonStyles;
  const handleIconStyles = subObject(rest2, "handleIcon");
  const { size: handleIconSize } = handleIconStyles;
  const mainSize = Math.max(ribbonSize, handleIconSize * 2.4);
  component.size = mainSize;
  const scale10 = createScale(component, library3);
  const labelBBoxes = computeLabelsBBox(rest2, scale10);
  if (labelBBoxes) {
    const key = isVertical2 ? "width" : "height";
    const size5 = max4(labelBBoxes, (d2) => d2[key]);
    component.size += size5 + labelSpacing;
  }
  const titleBBox = computeTitleBBox(rest2);
  if (titleBBox) {
    if (isVertical2) {
      component.size = Math.max(component.size, titleBBox.width);
    } else {
      component.size += titleSpacing + titleBBox.height;
    }
  }
}
function computeCategoryLegendSize(component, crossSize0, crossPadding, position, theme, library3) {
  const styleOf2 = () => {
    const { legendCategory } = theme;
    const { title } = component;
    const [defaultTitle, specifiedTitle] = Array.isArray(title) ? [title, void 0] : [void 0, title];
    return deep_mix_default({ title: defaultTitle }, legendCategory, Object.assign(Object.assign({}, component), { title: specifiedTitle }));
  };
  const _a2 = styleOf2(), { itemSpacing, itemMarkerSize, titleSpacing, rowPadding, colPadding, maxCols = Infinity, maxRows = Infinity } = _a2, rest2 = __rest73(_a2, ["itemSpacing", "itemMarkerSize", "titleSpacing", "rowPadding", "colPadding", "maxCols", "maxRows"]);
  const { cols, length: length5 } = component;
  const getRows = (rows) => Math.min(rows, maxRows);
  const getCols = (cols2) => Math.min(cols2, maxCols);
  const isVertical2 = position === "left" || position === "right";
  const crossSize = length5 === void 0 ? crossSize0 + (isVertical2 ? 0 : crossPadding[0] + crossPadding[1]) : length5;
  const titleBBox = computeTitleBBox(rest2);
  const scale10 = createScale(component, library3);
  const labelBBoxes = computeLabelsBBox(rest2, scale10, "itemLabel");
  const height = Math.max(labelBBoxes[0].height, itemMarkerSize) + rowPadding;
  const widthOf = (w, padding = 0) => itemMarkerSize + w + itemSpacing[0] + padding;
  const computeVerticalSize = () => {
    let maxSize = -Infinity;
    let pos = 0;
    let cols2 = 1;
    let rows = 0;
    let maxRows2 = -Infinity;
    let maxPos = -Infinity;
    const titleHeight = titleBBox ? titleBBox.height : 0;
    const maxHeight = crossSize - titleHeight;
    for (const { width } of labelBBoxes) {
      const w = widthOf(width, colPadding);
      maxSize = Math.max(maxSize, w);
      if (pos + height > maxHeight) {
        cols2++;
        maxRows2 = Math.max(maxRows2, rows);
        maxPos = Math.max(maxPos, pos);
        rows = 1;
        pos = height;
      } else {
        pos += height;
        rows++;
      }
    }
    if (cols2 <= 1) {
      maxRows2 = rows;
      maxPos = pos;
    }
    component.size = maxSize * getCols(cols2);
    component.length = maxPos + titleHeight;
    deep_mix_default(component, { cols: getCols(cols2), gridRow: maxRows2 });
  };
  const computeHorizontalGrid = () => {
    const rows = Math.ceil(labelBBoxes.length / cols);
    const maxWidth = max4(labelBBoxes, (d2) => widthOf(d2.width)) * cols;
    component.size = height * getRows(rows) - rowPadding;
    component.length = Math.min(maxWidth, crossSize);
  };
  const computeHorizontalFlex = () => {
    let rows = 1;
    let pos = 0;
    let maxPos = -Infinity;
    for (const { width } of labelBBoxes) {
      const w = widthOf(width, colPadding);
      if (pos + w > crossSize) {
        maxPos = Math.max(maxPos, pos);
        pos = w;
        rows++;
      } else {
        pos += w;
      }
    }
    if (rows === 1)
      maxPos = pos;
    component.size = height * getRows(rows) - rowPadding;
    component.length = maxPos;
  };
  if (isVertical2)
    computeVerticalSize();
  else if (typeof cols === "number")
    computeHorizontalGrid();
  else
    computeHorizontalFlex();
  if (titleBBox) {
    if (isVertical2) {
      component.size = Math.max(component.size, titleBBox.width);
    } else {
      component.size += titleSpacing + titleBBox.height;
    }
  }
}
function createScale(component, library3) {
  const [useScale] = useLibrary("scale", library3);
  const { scales, tickCount, tickMethod } = component;
  const scaleOptions = scales.find((d2) => d2.type !== "constant" && d2.type !== "identity");
  if (tickCount !== void 0)
    scaleOptions.tickCount = tickCount;
  if (tickMethod !== void 0)
    scaleOptions.tickMethod = tickMethod;
  return useScale(scaleOptions);
}
function computeLabelsBBox(component, scale10, key = "label") {
  const { labelFormatter: labelFormatter2, tickFilter, label = true } = component, style = __rest73(component, ["labelFormatter", "tickFilter", "label"]);
  if (!label)
    return null;
  const labels = labelsOf(scale10, labelFormatter2, tickFilter);
  const labelStyle = subObject(style, key);
  const labelStyles = labels.map((d2, i) => Object.fromEntries(Object.entries(labelStyle).map(([key2, value2]) => [
    key2,
    typeof value2 === "function" ? value2(d2, i) : value2
  ])));
  const labelBBoxes = labels.map((d2, i) => {
    const normalizeStyle = labelStyles[i];
    return computeLabelSize(d2, normalizeStyle);
  });
  const hasTransform = labelStyles.some((d2) => d2.transform);
  if (!hasTransform) {
    const I = labels.map((_2, i) => i);
    component.indexBBox = new Map(I.map((i) => [i, [labels[i], labelBBoxes[i]]]));
  }
  return labelBBoxes;
}
function computeTitleBBox(component) {
  const isFalsy = (x3) => x3 === false || x3 === null;
  const { title } = component, style = __rest73(component, ["title"]);
  if (isFalsy(title) || title === void 0)
    return null;
  const titleStyle = subObject(style, "title");
  const { direction: direction3, transform: transform3 } = titleStyle;
  const titleText = Array.isArray(title) ? title.join(",") : title;
  if (typeof titleText !== "string")
    return null;
  const titleBBox = computeLabelSize(titleText, Object.assign(Object.assign({}, titleStyle), { transform: transform3 || (direction3 === "vertical" ? "rotate(-90)" : "") }));
  return titleBBox;
}
function styleOf(axis, position, theme) {
  const { title } = axis;
  const [defaultTitle, specifiedTitle] = Array.isArray(title) ? [title, void 0] : [void 0, title];
  const {
    axis: baseStyle,
    // @ts-ignore
    [`axis${capitalizeFirst(position)}`]: positionStyle
  } = theme;
  return deep_mix_default({ title: defaultTitle }, baseStyle, positionStyle, Object.assign(Object.assign({}, axis), { title: specifiedTitle }));
}
function ticksOf2(scale10, tickFilter) {
  const ticks2 = scale10.getTicks ? scale10.getTicks() : scale10.getOptions().domain;
  if (!tickFilter)
    return ticks2;
  return ticks2.filter(tickFilter);
}
function labelsOf(scale10, labelFormatter2, tickFilter) {
  const T = ticksOf2(scale10, tickFilter);
  const ticks2 = T.map((d2) => typeof d2 === "number" ? prettyNumber2(d2) : d2);
  const formatter2 = labelFormatter2 ? typeof labelFormatter2 === "string" ? format2(labelFormatter2) : labelFormatter2 : scale10.getFormatter ? scale10.getFormatter() : (d2) => `${d2}`;
  return ticks2.map(formatter2);
}
function offsetOf(scale10, d2) {
  if (!scale10.getBandWidth)
    return 0;
  const offset2 = scale10.getBandWidth(d2) / 2;
  return offset2;
}
function overflowX(scale10, labelBBoxes, crossSize, crossPadding, tickFilter) {
  const totalSize = sum(labelBBoxes, (d2) => d2.width);
  if (totalSize > crossSize)
    return true;
  const scaleX = scale10.clone();
  scaleX.update({ range: [0, crossSize] });
  const ticks2 = ticksOf2(scale10, tickFilter);
  const X = ticks2.map((d2) => scaleX.map(d2) + offsetOf(scaleX, d2));
  const I = ticks2.map((_2, i) => i);
  const startX = -crossPadding[0];
  const endX = crossSize + crossPadding[1];
  const extent2 = (x3, bbox) => {
    const { width } = bbox;
    return [x3 - width / 2, x3 + width / 2];
  };
  for (let i = 0; i < I.length; i++) {
    const x3 = X[i];
    const [x05, x12] = extent2(x3, labelBBoxes[i]);
    if (x05 < startX || x12 > endX)
      return true;
    const y3 = X[i + 1];
    if (y3) {
      const [y05] = extent2(y3, labelBBoxes[i + 1]);
      if (x12 > y05)
        return true;
    }
  }
  return false;
}
function computeLabelSize(d2, style) {
  const shape23 = normalizeLabel(d2);
  const { filter: filter4 } = style, rest2 = __rest73(style, ["filter"]);
  shape23.attr(Object.assign(Object.assign({}, rest2), { visibility: "none" }));
  const bbox = shape23.getBBox();
  return bbox;
}
function normalizeLabel(d2) {
  if (d2 instanceof DisplayObject)
    return d2;
  return new Text({ style: { text: `${d2}` } });
}

// node_modules/@antv/g2/esm/runtime/layout.js
function processAxisZ(components) {
  const axisZ = components.find(({ type }) => type === "axisZ");
  if (axisZ) {
    const axisX = components.find(({ type }) => type === "axisX");
    axisX.plane = "xy";
    const axisY = components.find(({ type }) => type === "axisY");
    axisY.plane = "xy";
    axisZ.plane = "yz";
    axisZ.origin = [axisX.bbox.x, axisX.bbox.y, 0];
    axisZ.eulerAngles = [0, -90, 0];
    axisZ.bbox.x = axisX.bbox.x;
    axisZ.bbox.y = axisX.bbox.y;
    components.push(Object.assign(Object.assign({}, axisX), { plane: "xz", showLabel: false, showTitle: false, origin: [axisX.bbox.x, axisX.bbox.y, 0], eulerAngles: [-90, 0, 0] }));
    components.push(Object.assign(Object.assign({}, axisY), { plane: "yz", showLabel: false, showTitle: false, origin: [axisY.bbox.x + axisY.bbox.width, axisY.bbox.y, 0], eulerAngles: [0, -90, 0] }));
    components.push(Object.assign(Object.assign({}, axisZ), { plane: "xz", actualPosition: "left", showLabel: false, showTitle: false, eulerAngles: [90, -90, 0] }));
  }
}
function computeLayout(components, options, theme, library3) {
  var _a2, _b;
  const { width, height, depth, x: x3 = 0, y: y3 = 0, z = 0, inset = (_a2 = theme.inset) !== null && _a2 !== void 0 ? _a2 : 0, insetLeft = inset, insetTop = inset, insetBottom = inset, insetRight = inset, margin = (_b = theme.margin) !== null && _b !== void 0 ? _b : 0, marginLeft = margin, marginBottom = margin, marginTop = margin, marginRight = margin, padding = theme.padding, paddingBottom = padding, paddingLeft = padding, paddingRight = padding, paddingTop = padding } = computeInset(components, options, theme, library3);
  const MIN_CONTENT_RATIO = 1 / 4;
  const maybeClamp = (viewWidth2, paddingLeft2, paddingRight2, pl02, pr02) => {
    const { marks } = options;
    if (marks.length === 0)
      return [pl02, pr02];
    const contentSize = viewWidth2 - pl02 - pr02;
    const diff = contentSize - viewWidth2 * MIN_CONTENT_RATIO;
    if (diff > 0)
      return [pl02, pr02];
    const shrinkSize = viewWidth2 * (1 - MIN_CONTENT_RATIO);
    return [
      paddingLeft2 === "auto" ? shrinkSize * pl02 / (pl02 + pr02) : pl02,
      paddingRight2 === "auto" ? shrinkSize * pr02 / (pl02 + pr02) : pr02
    ];
  };
  const roughPadding = (padding2) => padding2 === "auto" ? 20 : padding2 !== null && padding2 !== void 0 ? padding2 : 20;
  const rpt = roughPadding(paddingTop);
  const rpb = roughPadding(paddingBottom);
  const horizontalPadding = computePadding(components, height - rpt - rpb, [rpt + marginTop, rpb + marginBottom], ["left", "right"], options, theme, library3);
  const { paddingLeft: pl0, paddingRight: pr0 } = horizontalPadding;
  const viewWidth = width - marginLeft - marginRight;
  const [pl, pr] = maybeClamp(viewWidth, paddingLeft, paddingRight, pl0, pr0);
  const iw = viewWidth - pl - pr;
  const verticalPadding = computePadding(components, iw, [pl + marginLeft, pr + marginRight], ["bottom", "top"], options, theme, library3);
  const { paddingTop: pt0, paddingBottom: pb0 } = verticalPadding;
  const viewHeight = height - marginBottom - marginTop;
  const [pb, pt] = maybeClamp(viewHeight, paddingBottom, paddingTop, pb0, pt0);
  const ih = viewHeight - pb - pt;
  return {
    width,
    height,
    depth,
    insetLeft,
    insetTop,
    insetBottom,
    insetRight,
    innerWidth: iw,
    innerHeight: ih,
    paddingLeft: pl,
    paddingRight: pr,
    paddingTop: pt,
    paddingBottom: pb,
    marginLeft,
    marginBottom,
    marginTop,
    marginRight,
    x: x3,
    y: y3,
    z
  };
}
function computeRoughPlotSize(options) {
  const { height, width, padding = 0, paddingLeft = padding, paddingRight = padding, paddingTop = padding, paddingBottom = padding, margin = 16, marginLeft = margin, marginRight = margin, marginTop = margin, marginBottom = margin, inset = 0, insetLeft = inset, insetRight = inset, insetTop = inset, insetBottom = inset } = options;
  const maybeAuto = (padding2) => padding2 === "auto" ? 20 : padding2;
  const finalWidth = width - maybeAuto(paddingLeft) - maybeAuto(paddingRight) - marginLeft - marginRight - insetLeft - insetRight;
  const finalHeight = height - maybeAuto(paddingTop) - maybeAuto(paddingBottom) - marginTop - marginBottom - insetTop - insetBottom;
  return { width: finalWidth, height: finalHeight };
}
function computeInset(components, options, theme, library3) {
  const { coordinates } = options;
  if (!isPolar2(coordinates) && !isRadial2(coordinates)) {
    return options;
  }
  const axes = components.filter((d2) => typeof d2.type === "string" && d2.type.startsWith("axis"));
  if (axes.length === 0)
    return options;
  const styles = axes.map((component) => {
    const key = component.type === "axisArc" ? "arc" : "linear";
    return styleOf(component, key, theme);
  });
  const maxLabelSpacing = max4(styles, (d2) => {
    var _a2;
    return (_a2 = d2.labelSpacing) !== null && _a2 !== void 0 ? _a2 : 0;
  });
  const labelBBoxes = axes.flatMap((component, i) => {
    const style = styles[i];
    const scale10 = createScale(component, library3);
    const labels = computeLabelsBBox(style, scale10);
    return labels;
  }).filter(defined);
  const size5 = max4(labelBBoxes, (d2) => d2.height) + maxLabelSpacing;
  const titleBBoxes = axes.flatMap((_2, i) => {
    const style = styles[i];
    return computeTitleBBox(style);
  }).filter((d2) => d2 !== null);
  const titleSize = titleBBoxes.length === 0 ? 0 : max4(titleBBoxes, (d2) => d2.height);
  const { inset = size5, insetLeft = inset, insetBottom = inset, insetTop = inset + titleSize, insetRight = inset } = options;
  return Object.assign(Object.assign({}, options), { insetLeft, insetBottom, insetTop, insetRight });
}
function computePadding(components, crossSize, crossPadding, positions, options, theme, library3) {
  const positionComponents = group(components, (d2) => d2.position);
  const { padding = theme.padding, paddingLeft = padding, paddingRight = padding, paddingBottom = padding, paddingTop = padding } = options;
  const layout = {
    paddingBottom,
    paddingLeft,
    paddingTop,
    paddingRight
  };
  for (const position of positions) {
    const key = `padding${capitalizeFirst(camelCase2(position))}`;
    const components2 = positionComponents.get(position) || [];
    const value2 = layout[key];
    const defaultSizeOf = (d2) => {
      if (d2.size === void 0)
        d2.size = d2.defaultSize;
    };
    const sizeOf3 = (d2) => {
      if (d2.type === "group") {
        d2.children.forEach(defaultSizeOf);
        d2.size = max4(d2.children, (d3) => d3.size);
      } else {
        d2.size = d2.defaultSize;
      }
    };
    const autoSizeOf = (d2) => {
      if (d2.size)
        return;
      if (value2 !== "auto")
        sizeOf3(d2);
      else {
        computeComponentSize(d2, crossSize, crossPadding, position, theme, library3);
        defaultSizeOf(d2);
      }
    };
    const maybeHide = (d2) => {
      if (!d2.type.startsWith("axis"))
        return;
      if (d2.labelAutoHide === void 0)
        d2.labelAutoHide = true;
    };
    const isHorizontal3 = position === "bottom" || position === "top";
    const minOrder = min4(components2, (d2) => d2.order);
    const axes = components2.filter((d2) => d2.type.startsWith("axis") && d2.order == minOrder);
    if (axes.length)
      axes[0].crossPadding = 0;
    if (typeof value2 === "number") {
      components2.forEach(defaultSizeOf);
      components2.forEach(maybeHide);
    } else {
      if (components2.length === 0) {
        layout[key] = 0;
      } else {
        const size5 = isHorizontal3 ? crossSize + crossPadding[0] + crossPadding[1] : crossSize;
        const grouped = groupComponents(components2, size5);
        grouped.forEach(autoSizeOf);
        const totalSize = grouped.reduce((sum5, { size: size6, crossPadding: crossPadding2 = 12 }) => sum5 + size6 + crossPadding2, 0);
        layout[key] = totalSize;
      }
    }
  }
  return layout;
}
function placeComponents(components, coordinate2, layout) {
  const positionComponents = group(components, (d2) => `${d2.plane || "xy"}-${d2.position}`);
  const { paddingLeft, paddingRight, paddingTop, paddingBottom, marginLeft, marginTop, marginBottom, marginRight, innerHeight, innerWidth, insetBottom, insetLeft, insetRight, insetTop, height, width, depth } = layout;
  const planes = {
    xy: createSection({
      width,
      height,
      paddingLeft,
      paddingRight,
      paddingTop,
      paddingBottom,
      marginLeft,
      marginTop,
      marginBottom,
      marginRight,
      innerHeight,
      innerWidth,
      insetBottom,
      insetLeft,
      insetRight,
      insetTop
    }),
    yz: createSection({
      width: depth,
      height,
      paddingLeft: 0,
      paddingRight: 0,
      paddingTop: 0,
      paddingBottom: 0,
      marginLeft: 0,
      marginTop: 0,
      marginBottom: 0,
      marginRight: 0,
      innerWidth: depth,
      innerHeight: height,
      insetBottom: 0,
      insetLeft: 0,
      insetRight: 0,
      insetTop: 0
    }),
    xz: createSection({
      width,
      height: depth,
      paddingLeft: 0,
      paddingRight: 0,
      paddingTop: 0,
      paddingBottom: 0,
      marginLeft: 0,
      marginTop: 0,
      marginBottom: 0,
      marginRight: 0,
      innerWidth: width,
      innerHeight: depth,
      insetBottom: 0,
      insetLeft: 0,
      insetRight: 0,
      insetTop: 0
    })
  };
  for (const [key, components2] of positionComponents.entries()) {
    const [plane, position] = key.split("-");
    const area2 = planes[plane][position];
    const [nonEntityComponents, entityComponents] = divide4(components2, (component) => {
      if (typeof component.type !== "string")
        return false;
      if (position === "center")
        return true;
      if (component.type.startsWith("axis") && ["inner", "outer"].includes(position)) {
        return true;
      }
      return false;
    });
    if (nonEntityComponents.length) {
      placeNonEntityComponents(nonEntityComponents, coordinate2, area2, position);
    }
    if (entityComponents.length) {
      placePaddingArea(components2, coordinate2, area2);
    }
  }
}
function createSection({ width, height, paddingLeft, paddingRight, paddingTop, paddingBottom, marginLeft, marginTop, marginBottom, marginRight, innerHeight, innerWidth, insetBottom, insetLeft, insetRight, insetTop }) {
  const pl = paddingLeft + marginLeft;
  const pt = paddingTop + marginTop;
  const pr = paddingRight + marginRight;
  const pb = paddingBottom + marginBottom;
  const plotWidth = width - marginLeft - marginRight;
  const centerSection = [
    pl + insetLeft,
    pt + insetTop,
    innerWidth - insetLeft - insetRight,
    innerHeight - insetTop - insetBottom,
    "center",
    null,
    null
  ];
  const xySection = {
    top: [
      pl,
      0,
      innerWidth,
      pt,
      "vertical",
      true,
      ascending,
      marginLeft,
      plotWidth
    ],
    right: [width - pr, pt, pr, innerHeight, "horizontal", false, ascending],
    bottom: [
      pl,
      height - pb,
      innerWidth,
      pb,
      "vertical",
      false,
      ascending,
      marginLeft,
      plotWidth
    ],
    left: [0, pt, pl, innerHeight, "horizontal", true, ascending],
    "top-left": [pl, 0, innerWidth, pt, "vertical", true, ascending],
    "top-right": [pl, 0, innerWidth, pt, "vertical", true, ascending],
    "bottom-left": [
      pl,
      height - pb,
      innerWidth,
      pb,
      "vertical",
      false,
      ascending
    ],
    "bottom-right": [
      pl,
      height - pb,
      innerWidth,
      pb,
      "vertical",
      false,
      ascending
    ],
    center: centerSection,
    inner: centerSection,
    outer: centerSection
  };
  return xySection;
}
function placeNonEntityComponents(components, coordinate2, area2, position) {
  const [axisComponents, nonAxisComponents] = divide4(components, (component) => {
    if (typeof component.type === "string" && component.type.startsWith("axis")) {
      return true;
    }
    return false;
  });
  placeNonEntityAxis(axisComponents, coordinate2, area2, position);
  placeCenter(nonAxisComponents, coordinate2, area2);
}
function placeNonEntityAxis(components, coordinate2, area2, position) {
  if (position === "center") {
    if (isRadar(coordinate2)) {
      placeAxisRadar(components, coordinate2, area2, position);
    } else if (isPolar(coordinate2)) {
      placeArcLinear(components, coordinate2, area2);
    } else if (isParallel(coordinate2)) {
      placeAxisParallel(components, coordinate2, area2, components[0].orientation);
    }
  } else if (position === "inner") {
    placeAxisArcInner(components, coordinate2, area2);
  } else if (position === "outer") {
    placeAxisArcOuter(components, coordinate2, area2);
  }
}
function placeAxisArcInner(components, coordinate2, area2) {
  const [x3, y3, , height] = area2;
  const [cx, cy] = coordinate2.getCenter();
  const [innerRadius] = radiusOf(coordinate2);
  const r = height / 2;
  const size5 = innerRadius * r;
  const x05 = cx - size5;
  const y05 = cy - size5;
  for (let i = 0; i < components.length; i++) {
    const component = components[i];
    component.bbox = {
      x: x3 + x05,
      y: y3 + y05,
      width: size5 * 2,
      height: size5 * 2
    };
  }
}
function placeAxisArcOuter(components, coordinate2, area2) {
  const [x3, y3, width, height] = area2;
  for (const component of components) {
    component.bbox = { x: x3, y: y3, width, height };
  }
}
function placeArcLinear(components, coordinate2, area2) {
  const [x3, y3, width, height] = area2;
  for (const component of components) {
    component.bbox = { x: x3, y: y3, width, height };
  }
}
function placeAxisParallel(components, coordinate2, area2, orientation) {
  if (orientation === "horizontal") {
    placeAxisParallelHorizontal(components, coordinate2, area2);
  } else if (orientation === "vertical") {
    placeAxisParallelVertical(components, coordinate2, area2);
  }
}
function placeAxisParallelVertical(components, coordinate2, area2) {
  const [x3, y3, , height] = area2;
  const vector = new Array(components.length).fill(0);
  const points = coordinate2.map(vector);
  const X = points.filter((_2, i) => i % 2 === 0).map((d2) => d2 + x3);
  for (let i = 0; i < components.length; i++) {
    const component = components[i];
    const x4 = X[i];
    const width = X[i + 1] - x4;
    component.bbox = { x: x4, y: y3, width, height };
  }
}
function placeAxisParallelHorizontal(components, coordinate2, area2) {
  const [x3, y3, width] = area2;
  const vector = new Array(components.length).fill(0);
  const points = coordinate2.map(vector);
  const Y = points.filter((_2, i) => i % 2 === 1).map((d2) => d2 + y3);
  for (let i = 0; i < components.length; i++) {
    const component = components[i];
    const y4 = Y[i];
    const height = Y[i + 1] - y4;
    component.bbox = { x: x3, y: y4, width, height };
  }
}
function placeAxisRadar(components, coordinate2, area2, position) {
  const [x3, y3, width, height] = area2;
  for (const component of components) {
    component.bbox = { x: x3, y: y3, width, height };
    component.radar = {
      index: components.indexOf(component),
      count: components.length
    };
  }
}
function placePaddingArea(components, coordinate2, area2) {
  const [x3, y3, width, height, direction3, reverse3, comparator, minX, totalSize] = area2;
  const [mainStartKey, mainStartValue, crossStartKey, crossStartValue, mainSizeKey, mainSizeValue, crossSizeKey, crossSizeValue] = direction3 === "vertical" ? ["y", y3, "x", x3, "height", height, "width", width] : ["x", x3, "y", y3, "width", width, "height", height];
  components.sort((a4, b) => comparator === null || comparator === void 0 ? void 0 : comparator(a4.order, b.order));
  const isLarge = (type) => type === "title" || type === "group" || type.startsWith("legend");
  const crossSizeOf = (type, small, bigger) => {
    if (bigger === void 0)
      return small;
    if (isLarge(type))
      return bigger;
    return small;
  };
  const crossStartOf = (type, x4, minX2) => {
    if (minX2 === void 0)
      return x4;
    if (isLarge(type))
      return minX2;
    return x4;
  };
  const startValue = reverse3 ? mainStartValue + mainSizeValue : mainStartValue;
  for (let i = 0, start = startValue; i < components.length; i++) {
    const component = components[i];
    const { crossPadding = 0, type } = component;
    const { size: size5 } = component;
    component.bbox = {
      [mainStartKey]: reverse3 ? start - size5 - crossPadding : start + crossPadding,
      [crossStartKey]: crossStartOf(type, crossStartValue, minX),
      [mainSizeKey]: size5,
      [crossSizeKey]: crossSizeOf(type, crossSizeValue, totalSize)
    };
    start += (size5 + crossPadding) * (reverse3 ? -1 : 1);
  }
  const groupComponents2 = components.filter((d2) => d2.type === "group");
  for (const group3 of groupComponents2) {
    const { bbox, children } = group3;
    const size5 = bbox[crossSizeKey];
    const step2 = size5 / children.length;
    const justifyContent = children.reduce((j, child) => {
      var _a2;
      const j0 = (_a2 = child.layout) === null || _a2 === void 0 ? void 0 : _a2.justifyContent;
      return j0 ? j0 : j;
    }, "flex-start");
    const L = children.map((d2, i) => {
      const { length: length5 = step2, padding = 0 } = d2;
      return length5 + (i === children.length - 1 ? 0 : padding);
    });
    const totalLength = sum(L);
    const diff = size5 - totalLength;
    const offset2 = justifyContent === "flex-start" ? 0 : justifyContent === "center" ? diff / 2 : diff;
    for (let i = 0, start = bbox[crossStartKey] + offset2; i < children.length; i++) {
      const component = children[i];
      const { padding = 0 } = component;
      const interval2 = i === children.length - 1 ? 0 : padding;
      component.bbox = {
        [mainSizeKey]: bbox[mainSizeKey],
        [mainStartKey]: bbox[mainStartKey],
        [crossStartKey]: start,
        [crossSizeKey]: L[i] - interval2
      };
      deep_mix_default(component, { layout: { justifyContent } });
      start += L[i];
    }
  }
}
function placeCenter(components, coordinate2, area2) {
  if (components.length === 0)
    return;
  const [x3, y3, width, height] = area2;
  const [innerRadius] = radiusOf(coordinate2);
  const r = height / 2 * innerRadius / Math.sqrt(2);
  const cx = x3 + width / 2;
  const cy = y3 + height / 2;
  for (let i = 0; i < components.length; i++) {
    const component = components[i];
    component.bbox = { x: cx - r, y: cy - r, width: r * 2, height: r * 2 };
  }
}

// node_modules/@antv/g2/esm/runtime/transform.js
var __awaiter7 = function(thisArg, _arguments, P, generator) {
  function adopt(value2) {
    return value2 instanceof P ? value2 : new P(function(resolve) {
      resolve(value2);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject2) {
    function fulfilled(value2) {
      try {
        step2(generator.next(value2));
      } catch (e) {
        reject2(e);
      }
    }
    function rejected(value2) {
      try {
        step2(generator["throw"](value2));
      } catch (e) {
        reject2(e);
      }
    }
    function step2(result2) {
      result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
    }
    step2((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __rest74 = function(s2, e) {
  var t = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
      t[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t[p2[i]] = s2[p2[i]];
    }
  return t;
};
function applyDefaults(I, mark2, context) {
  const { encode = {}, scale: scale10 = {}, transform: transform3 = [] } = mark2, rest2 = __rest74(mark2, ["encode", "scale", "transform"]);
  return [I, Object.assign(Object.assign({}, rest2), { encode, scale: scale10, transform: transform3 })];
}
function applyDataTransform(I, mark2, context) {
  return __awaiter7(this, void 0, void 0, function* () {
    const { library: library3 } = context;
    const { data: data2 } = mark2;
    const [useData] = useLibrary("data", library3);
    const descriptor = normalizedDataSource(data2);
    const { transform: T = [] } = descriptor, connector = __rest74(descriptor, ["transform"]);
    const transform3 = [connector, ...T];
    const transformFunctions2 = transform3.map(useData);
    const transformedData = yield composeAsync(transformFunctions2)(data2);
    const newData = data2 && !Array.isArray(data2) && !Array.isArray(transformedData) ? { value: transformedData } : transformedData;
    return [
      Array.isArray(transformedData) ? indexOf2(transformedData) : [],
      Object.assign(Object.assign({}, mark2), { data: newData })
    ];
  });
}
function flatEncode(I, mark2, context) {
  const { encode } = mark2;
  if (!encode)
    return [I, mark2];
  const flattenEncode = {};
  for (const [key, value2] of Object.entries(encode)) {
    if (Array.isArray(value2)) {
      for (let i = 0; i < value2.length; i++) {
        const name2 = `${key}${i === 0 ? "" : i}`;
        flattenEncode[name2] = value2[i];
      }
    } else {
      flattenEncode[key] = value2;
    }
  }
  return [I, Object.assign(Object.assign({}, mark2), { encode: flattenEncode })];
}
function inferChannelsType(I, mark2, context) {
  const { encode, data: data2 } = mark2;
  if (!encode)
    return [I, mark2];
  const typedEncode = mapObject(encode, (channel) => {
    if (isTypedChannel(channel))
      return channel;
    const type = inferChannelType(data2, channel);
    return { type, value: channel };
  });
  return [I, Object.assign(Object.assign({}, mark2), { encode: typedEncode })];
}
function maybeVisualChannel(I, mark2, context) {
  const { encode } = mark2;
  if (!encode)
    return [I, mark2];
  const newEncode = mapObject(encode, (channel, name2) => {
    const { type } = channel;
    if (type !== "constant" || isPosition(name2))
      return channel;
    return Object.assign(Object.assign({}, channel), { constant: true });
  });
  return [I, Object.assign(Object.assign({}, mark2), { encode: newEncode })];
}
function extractColumns(I, mark2, context) {
  const { encode, data: data2 } = mark2;
  if (!encode)
    return [I, mark2];
  const { library: library3 } = context;
  const columnOf2 = createColumnOf(library3);
  const valuedEncode = mapObject(encode, (channel) => columnOf2(data2, channel));
  return [I, Object.assign(Object.assign({}, mark2), { encode: valuedEncode })];
}
function normalizeTooltip(I, mark2, context) {
  const { tooltip: tooltip2 = {} } = mark2;
  if (isUnset(tooltip2))
    return [I, mark2];
  if (Array.isArray(tooltip2)) {
    return [I, Object.assign(Object.assign({}, mark2), { tooltip: { items: tooltip2 } })];
  }
  if (isStrictObject(tooltip2) && isFullTooltip(tooltip2)) {
    return [I, Object.assign(Object.assign({}, mark2), { tooltip: tooltip2 })];
  }
  return [I, Object.assign(Object.assign({}, mark2), { tooltip: { items: [tooltip2] } })];
}
function extractTooltip(I, mark2, context) {
  const { data: data2, encode, tooltip: tooltip2 = {} } = mark2;
  if (isUnset(tooltip2))
    return [I, mark2];
  const valueOf4 = (item) => {
    if (!item)
      return item;
    if (typeof item === "string") {
      return I.map((i) => ({ name: item, value: data2[i][item] }));
    }
    if (isStrictObject(item)) {
      const { field: field3, channel, color: color2, name: name2 = field3, valueFormatter = (d2) => d2 } = item;
      const normalizedValueFormatter = typeof valueFormatter === "string" ? format2(valueFormatter) : valueFormatter;
      const definedChannel = channel && encode[channel];
      const channelField = definedChannel && encode[channel].field;
      const name1 = name2 || channelField || channel;
      const values4 = [];
      for (const i of I) {
        const value1 = field3 ? data2[i][field3] : definedChannel ? encode[channel].value[i] : null;
        values4[i] = {
          name: name1,
          color: color2,
          value: normalizedValueFormatter(value1)
        };
      }
      return values4;
    }
    if (typeof item === "function") {
      const values4 = [];
      for (const i of I) {
        const v = item(data2[i], i, data2, encode);
        if (isStrictObject(v))
          values4[i] = v;
        else
          values4[i] = { value: v };
      }
      return values4;
    }
    return item;
  };
  const { title, items = [] } = tooltip2, rest2 = __rest74(tooltip2, ["title", "items"]);
  const newTooltip = Object.assign({ title: valueOf4(title), items: Array.isArray(items) ? items.map(valueOf4) : [] }, rest2);
  return [I, Object.assign(Object.assign({}, mark2), { tooltip: newTooltip })];
}
function maybeArrayField(I, mark2, context) {
  const { encode } = mark2, rest2 = __rest74(mark2, ["encode"]);
  if (!encode)
    return [I, mark2];
  const columns = Object.entries(encode);
  const arrayColumns = columns.filter(([, channel]) => {
    const { value: V } = channel;
    return Array.isArray(V[0]);
  }).flatMap(([key, V]) => {
    const columns2 = [[key, new Array(I.length).fill(void 0)]];
    const { value: rows } = V, rest3 = __rest74(V, ["value"]);
    for (let i = 0; i < rows.length; i++) {
      const row2 = rows[i];
      if (Array.isArray(row2)) {
        for (let j = 0; j < row2.length; j++) {
          const column2 = columns2[j] || [
            `${key}${j}`,
            new Array(I).fill(void 0)
          ];
          column2[1][i] = row2[j];
          columns2[j] = column2;
        }
      }
    }
    return columns2.map(([key2, value2]) => [
      key2,
      Object.assign({ type: "column", value: value2 }, rest3)
    ]);
  });
  const newEncode = Object.fromEntries([...columns, ...arrayColumns]);
  return [I, Object.assign(Object.assign({}, rest2), { encode: newEncode })];
}
function addGuideToScale(I, mark2, context) {
  const { axis = {}, legend = {}, slider = {}, scrollbar = {} } = mark2;
  const normalize10 = (guide, channel) => {
    if (typeof guide === "boolean")
      return guide ? {} : null;
    const eachGuide = guide[channel];
    return eachGuide === void 0 || eachGuide ? eachGuide : null;
  };
  const axisChannels = typeof axis === "object" ? Array.from(/* @__PURE__ */ new Set(["x", "y", ...Object.keys(axis)])) : ["x", "y"];
  deep_mix_default(mark2, {
    scale: Object.assign(Object.assign({}, Object.fromEntries(axisChannels.map((channel) => {
      const scrollbarOptions = normalize10(scrollbar, channel);
      return [
        channel,
        Object.assign({ guide: normalize10(axis, channel), slider: normalize10(slider, channel), scrollbar: scrollbarOptions }, scrollbarOptions && {
          ratio: scrollbarOptions.ratio === void 0 ? 0.5 : scrollbarOptions.ratio
        })
      ];
    }))), {
      color: { guide: normalize10(legend, "color") },
      size: { guide: normalize10(legend, "size") },
      shape: { guide: normalize10(legend, "shape") },
      // fixme: opacity is conflict with DisplayObject.opacity
      // to be confirm.
      opacity: { guide: normalize10(legend, "opacity") }
    })
  });
  return [I, mark2];
}
function maybeNonAnimate(I, mark2, context) {
  const { animate: animate2 } = mark2;
  if (animate2 || animate2 === void 0)
    return [I, mark2];
  deep_mix_default(mark2, {
    animate: {
      enter: { type: null },
      exit: { type: null },
      update: { type: null }
    }
  });
  return [I, mark2];
}
function isTypedChannel(channel) {
  if (typeof channel !== "object" || channel instanceof Date || channel === null) {
    return false;
  }
  const { type } = channel;
  return defined(type);
}
function inferChannelType(data2, channel) {
  if (typeof channel === "function")
    return "transform";
  if (typeof channel === "string" && isField(data2, channel))
    return "field";
  return "constant";
}
function isField(data2, value2) {
  if (!Array.isArray(data2))
    return false;
  return data2.some((d2) => d2[value2] !== void 0);
}
function normalizedDataSource(data2) {
  if (is_number_default(data2))
    return { type: "inline", value: data2 };
  if (!data2)
    return { type: "inline", value: null };
  if (Array.isArray(data2))
    return { type: "inline", value: data2 };
  const { type = "inline" } = data2, rest2 = __rest74(data2, ["type"]);
  return Object.assign(Object.assign({}, rest2), { type });
}

// node_modules/@antv/g2/esm/runtime/mark.js
var __awaiter8 = function(thisArg, _arguments, P, generator) {
  function adopt(value2) {
    return value2 instanceof P ? value2 : new P(function(resolve) {
      resolve(value2);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject2) {
    function fulfilled(value2) {
      try {
        step2(generator.next(value2));
      } catch (e) {
        reject2(e);
      }
    }
    function rejected(value2) {
      try {
        step2(generator["throw"](value2));
      } catch (e) {
        reject2(e);
      }
    }
    function step2(result2) {
      result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
    }
    step2((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __rest75 = function(s2, e) {
  var t = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
      t[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t[p2[i]] = s2[p2[i]];
    }
  return t;
};
function initializeMark(partialMark, partialProps, library3) {
  return __awaiter8(this, void 0, void 0, function* () {
    const context = { library: library3 };
    const [I, transformedMark] = yield applyMarkTransform(partialMark, partialProps, context);
    const { encode, scale: scale10, data: data2, tooltip: tooltip2 } = transformedMark;
    if (Array.isArray(data2) === false) {
      return null;
    }
    const { channels: channelDescriptors } = partialProps;
    const nameChannels = rollups(Object.entries(encode).filter(([, value2]) => defined(value2)), (values4) => values4.map(([key, options]) => Object.assign({ name: key }, options)), ([key]) => {
      var _a2;
      const prefix = (_a2 = /([^\d]+)\d*$/.exec(key)) === null || _a2 === void 0 ? void 0 : _a2[1];
      const descriptor = channelDescriptors.find((d2) => d2.name === prefix);
      if (descriptor === null || descriptor === void 0 ? void 0 : descriptor.independent)
        return key;
      return prefix;
    });
    const channels = channelDescriptors.filter((descriptor) => {
      const { name: name2, required: required2 } = descriptor;
      if (nameChannels.find(([d2]) => d2 === name2))
        return true;
      if (required2)
        throw new Error(`Missing encoding for channel: ${name2}.`);
      return false;
    }).flatMap((descriptor) => {
      const { name: name2, scale: scaleType, scaleKey, range: range4, quantitative, ordinal } = descriptor;
      const valuesArray = nameChannels.filter(([channel]) => channel.startsWith(name2));
      return valuesArray.map(([channel, values4], i) => {
        const visual = values4.some((d2) => d2.visual);
        const constant5 = values4.some((d2) => d2.constant);
        const _a2 = scale10[channel] || {}, {
          independent = false,
          // Use channel name as default scale key.
          key = scaleKey || channel,
          // Visual channel use identity scale.
          type = constant5 ? "constant" : visual ? "identity" : scaleType
        } = _a2, scaleOptions = __rest75(_a2, ["independent", "key", "type"]);
        const isConstant = type === "constant";
        const finalRange = isConstant ? void 0 : range4;
        return {
          name: channel,
          values: values4,
          // Generate a unique key for independent channel,
          // which will not group with any other channels.
          scaleKey: independent || isConstant ? Symbol("independent") : key,
          scale: Object.assign(Object.assign({ type, range: finalRange }, scaleOptions), {
            quantitative,
            ordinal
          })
        };
      });
    });
    return [transformedMark, Object.assign(Object.assign({}, partialProps), { index: I, channels, tooltip: tooltip2 })];
  });
}
function createColumnOf(library3) {
  const [useEncode] = useLibrary("encode", library3);
  return (data2, encode) => {
    if (encode === void 0)
      return null;
    if (data2 === void 0)
      return null;
    return Object.assign(Object.assign({}, encode), { type: "column", value: useEncode(encode)(data2), field: fieldOf(encode) });
  };
}
function applyMarkTransform(mark2, props, context) {
  return __awaiter8(this, void 0, void 0, function* () {
    const { library: library3 } = context;
    const [useTransform] = useLibrary("transform", library3);
    const { preInference = [], postInference = [] } = props;
    const { transform: transform3 = [] } = mark2;
    const transforms = [
      applyDefaults,
      applyDataTransform,
      flatEncode,
      inferChannelsType,
      maybeVisualChannel,
      extractColumns,
      maybeArrayField,
      maybeNonAnimate,
      addGuideToScale,
      normalizeTooltip,
      ...preInference.map(useTransform),
      ...transform3.map(useTransform),
      ...postInference.map(useTransform),
      extractTooltip
    ];
    let index3 = [];
    let transformedMark = mark2;
    for (const t of transforms) {
      [index3, transformedMark] = yield t(index3, transformedMark, context);
    }
    return [index3, transformedMark];
  });
}
function fieldOf(encode) {
  const { type, value: value2 } = encode;
  if (type === "field" && typeof value2 === "string")
    return value2;
  return null;
}

// node_modules/@antv/g2/esm/runtime/plot.js
var __awaiter9 = function(thisArg, _arguments, P, generator) {
  function adopt(value2) {
    return value2 instanceof P ? value2 : new P(function(resolve) {
      resolve(value2);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject2) {
    function fulfilled(value2) {
      try {
        step2(generator.next(value2));
      } catch (e) {
        reject2(e);
      }
    }
    function rejected(value2) {
      try {
        step2(generator["throw"](value2));
      } catch (e) {
        reject2(e);
      }
    }
    function step2(result2) {
      result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
    }
    step2((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __rest76 = function(s2, e) {
  var t = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
      t[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t[p2[i]] = s2[p2[i]];
    }
  return t;
};
function plot(options, selection, library3, context) {
  var _a2, _b;
  return __awaiter9(this, void 0, void 0, function* () {
    const [useComposition] = useLibrary("composition", library3);
    const [useInteraction] = useLibrary("interaction", library3);
    const marks = new Set(Object.keys(library3).map((d2) => {
      var _a3;
      return (_a3 = /mark\.(.*)/.exec(d2)) === null || _a3 === void 0 ? void 0 : _a3[1];
    }).filter(defined));
    const staticMarks = new Set(Object.keys(library3).map((d2) => {
      var _a3;
      return (_a3 = /component\.(.*)/.exec(d2)) === null || _a3 === void 0 ? void 0 : _a3[1];
    }).filter(defined));
    const typeOf = (node) => {
      const { type } = node;
      if (typeof type === "function") {
        const { props = {} } = type;
        const { composite = true } = props;
        if (composite)
          return "mark";
      }
      if (typeof type !== "string")
        return type;
      if (marks.has(type) || staticMarks.has(type))
        return "mark";
      return type;
    };
    const isMark2 = (node) => typeOf(node) === "mark";
    const isStandardView = (node) => typeOf(node) === "standardView";
    const isStaticMark = (node) => {
      const { type } = node;
      if (typeof type !== "string")
        return false;
      if (staticMarks.has(type))
        return true;
      return false;
    };
    const transform3 = (node) => {
      if (isStandardView(node))
        return [node];
      const type = typeOf(node);
      const composition = useComposition({ type, static: isStaticMark(node) });
      return composition(node);
    };
    const views = [];
    const viewNode = /* @__PURE__ */ new Map();
    const nodeState = /* @__PURE__ */ new Map();
    const discovered = [options];
    const nodeGenerators = [];
    while (discovered.length) {
      const node = discovered.shift();
      if (isStandardView(node)) {
        const state = nodeState.get(node);
        const [view, children] = state ? initializeState(state, node, library3) : yield initializeView(node, library3);
        viewNode.set(view, node);
        views.push(view);
        const transformedNodes = children.flatMap(transform3).map((d2) => coordinate2Transform(d2, library3));
        discovered.push(...transformedNodes);
        if (transformedNodes.every(isStandardView)) {
          const states = yield Promise.all(transformedNodes.map((d2) => initializeMarks(d2, library3)));
          syncFacetsScales(states);
          for (let i = 0; i < transformedNodes.length; i++) {
            const nodeT = transformedNodes[i];
            const state2 = states[i];
            nodeState.set(nodeT, state2);
          }
        }
      } else {
        const n = isMark2(node) ? node : yield applyTransform(node, library3);
        const N = transform3(n);
        if (Array.isArray(N))
          discovered.push(...N);
        else if (typeof N === "function")
          nodeGenerators.push(N());
      }
    }
    context.emitter.emit(ChartEvent.BEFORE_PAINT);
    const enterContainer = /* @__PURE__ */ new Map();
    const updateContainer = /* @__PURE__ */ new Map();
    const transitions = [];
    selection.selectAll(className(VIEW_CLASS_NAME)).data(views, (d2) => d2.key).join((enter) => enter.append("g").attr("className", VIEW_CLASS_NAME).attr("id", (view) => view.key).call(applyTranslate).each(function(view, i, element) {
      plotView(view, select(element), transitions, library3, context);
      enterContainer.set(view, element);
    }), (update3) => update3.call(applyTranslate).each(function(view, i, element) {
      plotView(view, select(element), transitions, library3, context);
      updateContainer.set(view, element);
    }), (exit) => exit.each(function(d2, i, element) {
      const interactions = element["nameInteraction"].values();
      for (const interaction of interactions) {
        interaction.destroy();
      }
    }).remove());
    const viewInstanceof = (viewContainer) => {
      return Array.from(viewContainer.entries()).map(([view, container]) => {
        const store = /* @__PURE__ */ new Map();
        const setState = (key, reducer = (x3) => x3) => store.set(key, reducer);
        const options2 = viewNode.get(view);
        const update3 = createUpdateView(select(container), options2, library3, context);
        return {
          view,
          container,
          options: options2,
          setState,
          update: (from) => __awaiter9(this, void 0, void 0, function* () {
            const reducer = compose(Array.from(store.values()));
            const newOptions = reducer(options2);
            return yield update3(newOptions, from);
          })
        };
      });
    };
    const enterViewInstances = viewInstanceof(enterContainer);
    for (const target of enterViewInstances) {
      const { options: options2 } = target;
      const nameInteraction = /* @__PURE__ */ new Map();
      target.container["nameInteraction"] = nameInteraction;
      for (const typeOption of inferInteraction(options2)) {
        const [type, option] = typeOption;
        if (option) {
          const interaction = useThemeInteraction(target.view, type, option, useInteraction);
          const destroy2 = interaction(target, enterViewInstances, context.emitter);
          nameInteraction.set(type, { destroy: destroy2 });
        }
      }
    }
    const updateViewInstances = viewInstanceof(updateContainer);
    for (const target of updateViewInstances) {
      const { options: options2, container } = target;
      const nameInteraction = container["nameInteraction"];
      for (const typeOption of inferInteraction(options2)) {
        const [type, option] = typeOption;
        const prevInteraction = nameInteraction.get(type);
        if (prevInteraction)
          (_a2 = prevInteraction.destroy) === null || _a2 === void 0 ? void 0 : _a2.call(prevInteraction);
        if (option) {
          const interaction = useThemeInteraction(target.view, type, option, useInteraction);
          const destroy2 = interaction(target, updateViewInstances, context.emitter);
          nameInteraction.set(type, { destroy: destroy2 });
        }
      }
    }
    const { width, height } = options;
    const keyframes = [];
    for (const nodeGenerator of nodeGenerators) {
      const keyframe = new Promise((resolve) => __awaiter9(this, void 0, void 0, function* () {
        for (const node of nodeGenerator) {
          const sizedNode = Object.assign({ width, height }, node);
          yield plot(sizedNode, selection, library3, context);
        }
        resolve();
      }));
      keyframes.push(keyframe);
    }
    context.views = views;
    (_b = context.animations) === null || _b === void 0 ? void 0 : _b.forEach((animation) => animation === null || animation === void 0 ? void 0 : animation.cancel());
    context.animations = transitions;
    context.emitter.emit(ChartEvent.AFTER_PAINT);
    const finished = transitions.filter(defined).map(cancel).map((d2) => d2.finished);
    return Promise.all([...finished, ...keyframes]);
  });
}
function applyTranslate(selection) {
  selection.style("transform", (d2) => `translate(${d2.layout.x}, ${d2.layout.y})`);
}
function definedInteraction(library3) {
  const [, createInteraction] = useLibrary("interaction", library3);
  return (d2) => {
    const [name2, options] = d2;
    try {
      return [name2, createInteraction(name2)];
    } catch (_a2) {
      return [name2, options.type];
    }
  };
}
function createUpdateView(selection, options, library3, context) {
  const createDefinedInteraction = definedInteraction(library3);
  const filter4 = (d2) => d2[1] && d2[1].props && d2[1].props.reapplyWhenUpdate;
  const interactions = inferInteraction(options);
  const updates = interactions.map(createDefinedInteraction).filter(filter4).map((d2) => d2[0]);
  return (newOptions, source) => __awaiter9(this, void 0, void 0, function* () {
    const transitions = [];
    const [newView, newChildren] = yield initializeView(newOptions, library3);
    plotView(newView, selection, transitions, library3, context);
    for (const name2 of updates.filter((d2) => d2 !== source)) {
      updateInteraction(name2, selection, newOptions, newView, library3, context);
    }
    for (const child of newChildren) {
      plot(child, selection, library3, context);
    }
    return { options: newOptions, view: newView };
  });
}
function updateInteraction(name2, selection, options, view, library3, context) {
  var _a2;
  const [useInteraction] = useLibrary("interaction", library3);
  const container = selection.node();
  const nameInteraction = container["nameInteraction"];
  const interactionOptions = inferInteraction(options).find(([d2]) => d2 === name2);
  const interaction = nameInteraction.get(name2);
  if (!interaction)
    return;
  (_a2 = interaction.destroy) === null || _a2 === void 0 ? void 0 : _a2.call(interaction);
  if (!interactionOptions[1])
    return;
  const applyInteraction = useThemeInteraction(view, name2, interactionOptions[1], useInteraction);
  const target = {
    options,
    view,
    container: selection.node(),
    update: (options2) => Promise.resolve(options2)
  };
  const destroy2 = applyInteraction(target, [], context.emitter);
  nameInteraction.set(name2, { destroy: destroy2 });
}
function initializeView(options, library3) {
  return __awaiter9(this, void 0, void 0, function* () {
    const flattenOptions = yield transformMarks(options, library3);
    const mergedOptions = bubbleOptions(flattenOptions);
    options.interaction = mergedOptions.interaction;
    options.coordinate = mergedOptions.coordinate;
    options.marks = [...mergedOptions.marks, ...mergedOptions.components];
    const transformedOptions = coordinate2Transform(mergedOptions, library3);
    const state = yield initializeMarks(transformedOptions, library3);
    return initializeState(state, transformedOptions, library3);
  });
}
function bubbleOptions(options) {
  const { coordinate: viewCoordinate = {}, interaction: viewInteraction = {}, style: viewStyle = {}, marks } = options, rest2 = __rest76(options, ["coordinate", "interaction", "style", "marks"]);
  const markCoordinates = marks.map((d2) => d2.coordinate || {});
  const markInteractions = marks.map((d2) => d2.interaction || {});
  const markViewStyles = marks.map((d2) => d2.viewStyle || {});
  const newCoordinate = [...markCoordinates, viewCoordinate].reduceRight((prev, cur) => deep_mix_default(prev, cur), {});
  const newInteraction = [viewInteraction, ...markInteractions].reduce((prev, cur) => deep_mix_default(prev, cur), {});
  const newStyle = [...markViewStyles, viewStyle].reduce((prev, cur) => deep_mix_default(prev, cur), {});
  return Object.assign(Object.assign({}, rest2), { marks, coordinate: newCoordinate, interaction: newInteraction, style: newStyle });
}
function transformMarks(options, library3) {
  return __awaiter9(this, void 0, void 0, function* () {
    const [useMark, createMark] = useLibrary("mark", library3);
    const staticMarks = new Set(Object.keys(library3).map((d2) => {
      var _a2;
      return (_a2 = /component\.(.*)/.exec(d2)) === null || _a2 === void 0 ? void 0 : _a2[1];
    }).filter(defined));
    const { marks } = options;
    const flattenMarks = [];
    const components = [];
    const discovered = [...marks];
    const { width, height } = computeRoughPlotSize(options);
    const context = { options, width, height };
    while (discovered.length) {
      const [node] = discovered.splice(0, 1);
      const mark2 = yield applyTransform(node, library3);
      const { type = error("G2Mark type is required."), key } = mark2;
      if (staticMarks.has(type))
        components.push(mark2);
      else {
        const { props = {} } = createMark(type);
        const { composite = true } = props;
        if (!composite)
          flattenMarks.push(mark2);
        else {
          const { data: data2 } = mark2;
          const newMark = Object.assign(Object.assign({}, mark2), { data: data2 ? Array.isArray(data2) ? data2 : data2.value : data2 });
          const marks2 = yield useMark(newMark, context);
          const M2 = Array.isArray(marks2) ? marks2 : [marks2];
          discovered.unshift(...M2.map((d2, i) => Object.assign(Object.assign({}, d2), { key: `${key}-${i}` })));
        }
      }
    }
    return Object.assign(Object.assign({}, options), { marks: flattenMarks, components });
  });
}
function initializeMarks(options, library3) {
  return __awaiter9(this, void 0, void 0, function* () {
    const [useTheme] = useLibrary("theme", library3);
    const [, createMark] = useLibrary("mark", library3);
    const { theme: partialTheme, marks: partialMarks, coordinates = [] } = options;
    const theme = useTheme(inferTheme(partialTheme));
    const markState = /* @__PURE__ */ new Map();
    for (const markOptions of partialMarks) {
      const { type } = markOptions;
      const { props = {} } = createMark(type);
      const markAndState = yield initializeMark(markOptions, props, library3);
      if (markAndState) {
        const [initializedMark, state] = markAndState;
        markState.set(initializedMark, state);
      }
    }
    const scaleChannels = group(Array.from(markState.values()).flatMap((d2) => d2.channels), ({ scaleKey }) => scaleKey);
    for (const channels of scaleChannels.values()) {
      const scaleOptions = channels.reduce((total, { scale: scale11 }) => deep_mix_default(total, scale11), {});
      const { scaleKey } = channels[0];
      const { values: FV } = channels[0];
      const fields = Array.from(new Set(FV.map((d2) => d2.field).filter(defined)));
      const options2 = deep_mix_default({
        guide: { title: fields.length === 0 ? void 0 : fields },
        field: fields[0]
      }, scaleOptions);
      const { name: name2 } = channels[0];
      const values4 = channels.flatMap(({ values: values5 }) => values5.map((d2) => d2.value));
      const scale10 = Object.assign(Object.assign({}, inferScale(name2, values4, options2, coordinates, theme, library3)), { key: scaleKey });
      channels.forEach((channel) => channel.scale = scale10);
    }
    return markState;
  });
}
function useThemeInteraction(view, type, option, useInteraction) {
  const theme = view.theme;
  const defaults5 = typeof type === "string" ? theme[type] || {} : {};
  const interaction = useInteraction(deep_mix_default(defaults5, Object.assign({ type }, option)));
  return interaction;
}
function initializeState(markState, options, library3) {
  const [useMark] = useLibrary("mark", library3);
  const [useTheme] = useLibrary("theme", library3);
  const [useLabelTransform] = useLibrary("labelTransform", library3);
  const { key, frame: frame2 = false, theme: partialTheme, clip, style = {}, labelTransform = [] } = options;
  const theme = useTheme(inferTheme(partialTheme));
  const states = Array.from(markState.values());
  const scales = collectScales(states, options);
  const components = normalizeComponents(inferComponent(inferComponentScales(Array.from(scales), states, markState), options, library3));
  const layout = computeLayout(components, options, theme, library3);
  const coordinate2 = createCoordinate(layout, options, library3);
  const framedStyle = frame2 ? deep_mix_default({ mainLineWidth: 1, mainStroke: "#000" }, style) : style;
  placeComponents(groupComponents(components), coordinate2, layout);
  processAxisZ(components);
  const scaleInstance = {};
  for (const component of components) {
    const { scales: scaleDescriptors = [] } = component;
    const scales2 = [];
    for (const descriptor of scaleDescriptors) {
      const { name: name2 } = descriptor;
      const scale10 = useRelationScale(descriptor, library3);
      scales2.push(scale10);
      assignScale(scaleInstance, { [name2]: scale10 });
    }
    component.scaleInstances = scales2;
  }
  const children = [];
  for (const [mark2, state] of markState.entries()) {
    const {
      // scale,
      // Callback to create children options based on this mark.
      children: createChildren,
      // The total count of data (both show and hide)for this facet.
      // This is for unit visualization to sync data domain.
      dataDomain,
      modifier,
      key: markKey
    } = mark2;
    const { index: index3, channels, tooltip: tooltip2 } = state;
    const scale10 = Object.fromEntries(channels.map(({ name: name2, scale: scale11 }) => [name2, scale11]));
    const markScaleInstance = mapObject(scale10, (options2) => {
      return useRelationScale(options2, library3);
    });
    assignScale(scaleInstance, markScaleInstance);
    const value2 = applyScale(channels, markScaleInstance);
    const calcPoints = useMark(mark2);
    const [I, P, S] = filterValid(calcPoints(index3, markScaleInstance, value2, coordinate2));
    const count4 = dataDomain || I.length;
    const T = modifier ? modifier(P, count4, layout) : [];
    const titleOf = (i) => {
      var _a2, _b;
      return (_b = (_a2 = tooltip2.title) === null || _a2 === void 0 ? void 0 : _a2[i]) === null || _b === void 0 ? void 0 : _b.value;
    };
    const itemsOf2 = (i) => tooltip2.items.map((V) => V[i]);
    const visualData = I.map((d2, i) => {
      const datum = Object.assign({ points: P[i], transform: T[i], index: d2, markKey, viewKey: key }, tooltip2 && {
        title: titleOf(d2),
        items: itemsOf2(d2)
      });
      for (const [k2, V] of Object.entries(value2)) {
        datum[k2] = V[d2];
        if (S)
          datum[`series${upper_first_default(k2)}`] = S[i].map((i2) => V[i2]);
      }
      if (S)
        datum["seriesIndex"] = S[i];
      if (S && tooltip2) {
        datum["seriesItems"] = S[i].map((si) => itemsOf2(si));
        datum["seriesTitle"] = S[i].map((si) => titleOf(si));
      }
      return datum;
    });
    state.data = visualData;
    state.index = I;
    const markChildren = createChildren === null || createChildren === void 0 ? void 0 : createChildren(visualData, markScaleInstance, layout);
    children.push(...markChildren || []);
  }
  const view = {
    layout,
    theme,
    coordinate: coordinate2,
    markState,
    key,
    clip,
    scale: scaleInstance,
    style: framedStyle,
    components,
    labelTransform: compose(labelTransform.map(useLabelTransform))
  };
  return [view, children];
}
function plotView(view, selection, transitions, library3, context) {
  return __awaiter9(this, void 0, void 0, function* () {
    const { components, theme, layout, markState, coordinate: coordinate2, key, style, clip, scale: scale10 } = view;
    const { x: x3, y: y3, width, height } = layout, rest2 = __rest76(layout, ["x", "y", "width", "height"]);
    const areaKeys = ["view", "plot", "main", "content"];
    const I = areaKeys.map((_2, i) => i);
    const sizeKeys = ["a", "margin", "padding", "inset"];
    const areaStyles = areaKeys.map((d2) => maybeSubObject(Object.assign({}, theme.view, style), d2));
    const areaSizes = sizeKeys.map((d2) => subObject(rest2, d2));
    const styleArea = (selection2) => selection2.style("x", (i) => areaLayouts[i].x).style("y", (i) => areaLayouts[i].y).style("width", (i) => areaLayouts[i].width).style("height", (i) => areaLayouts[i].height).each(function(i, d2, element) {
      applyStyle2(select(element), areaStyles[i]);
    });
    let px = 0;
    let py = 0;
    let pw = width;
    let ph = height;
    const areaLayouts = I.map((i) => {
      const size5 = areaSizes[i];
      const { left: left2 = 0, top = 0, bottom = 0, right: right2 = 0 } = size5;
      px += left2;
      py += top;
      pw -= left2 + right2;
      ph -= top + bottom;
      return {
        x: px,
        y: py,
        width: pw,
        height: ph
      };
    });
    selection.selectAll(className(AREA_CLASS_NAME)).data(
      // Only render area with defined style.
      I.filter((i) => defined(areaStyles[i])),
      (i) => areaKeys[i]
    ).join((enter) => enter.append("rect").attr("className", AREA_CLASS_NAME).style("zIndex", -2).call(styleArea), (update3) => update3.call(styleArea), (exit) => exit.remove());
    const animationExtent = computeAnimationExtent(markState);
    const componentAnimateOptions = animationExtent ? { duration: animationExtent[1] } : false;
    for (const [, C3] of groups(components, (d2) => `${d2.type}-${d2.position}`)) {
      C3.forEach((d2, i) => d2.index = i);
    }
    const componentsTransitions = selection.selectAll(className(COMPONENT_CLASS_NAME)).data(components, (d2) => `${d2.type}-${d2.position}-${d2.index}`).join((enter) => enter.append("g").style("zIndex", ({ zIndex }) => zIndex || -1).attr("className", COMPONENT_CLASS_NAME).append((options) => renderComponent(deep_mix_default({ animate: componentAnimateOptions, scale: scale10 }, options), coordinate2, theme, library3, markState)), (update3) => update3.transition(function(options, i, element) {
      const { preserve = false } = options;
      if (preserve)
        return;
      const newComponent = renderComponent(deep_mix_default({ animate: componentAnimateOptions, scale: scale10 }, options), coordinate2, theme, library3, markState);
      const { attributes } = newComponent;
      const [node] = element.childNodes;
      return node.update(attributes, false);
    })).transitions();
    transitions.push(...componentsTransitions.flat().filter(defined));
    const T = selection.selectAll(className(PLOT_CLASS_NAME)).data([layout], () => key).join((enter) => enter.append("rect").style("zIndex", 0).style("fill", "transparent").attr("className", PLOT_CLASS_NAME).call(updateBBox).call(updateLayers, Array.from(markState.keys())).call(applyClip, clip), (update3) => update3.call(updateLayers, Array.from(markState.keys())).call((selection2) => {
      return animationExtent ? animateBBox(selection2, animationExtent) : updateBBox(selection2);
    }).call(applyClip, clip)).transitions();
    transitions.push(...T.flat());
    for (const [mark2, state] of markState.entries()) {
      const { data: data2 } = state;
      const { key: key2, class: cls, type } = mark2;
      const viewNode = selection.select(`#${key2}`);
      const shapeFunction = createMarkShapeFunction(mark2, state, view, library3, context);
      const enterFunction = createEnterFunction(mark2, state, view, library3);
      const updateFunction = createUpdateFunction(mark2, state, view, library3);
      const exitFunction = createExitFunction(mark2, state, view, library3);
      const facetElements = selectFacetElements(selection, viewNode, cls, "element");
      const T2 = viewNode.selectAll(className(ELEMENT_CLASS_NAME)).selectFacetAll(facetElements).data(data2, (d2) => d2.key, (d2) => d2.groupKey).join((enter) => enter.append(shapeFunction).attr("className", ELEMENT_CLASS_NAME).attr("markType", type).transition(function(data3, i, element) {
        return enterFunction(data3, [element]);
      }), (update3) => update3.call((selection2) => {
        const parent2 = selection2.parent();
        const origin = useMemo((node) => {
          const [x4, y4] = node.getBounds().min;
          return [x4, y4];
        });
        selection2.transition(function(data3, index3, element) {
          maybeFacetElement(element, parent2, origin);
          const node = shapeFunction(data3, index3);
          const animation = updateFunction(data3, [element], [node]);
          if (animation !== null)
            return animation;
          if (element.nodeName === node.nodeName && node.nodeName !== "g") {
            copyAttributes(element, node);
          } else {
            element.parentNode.replaceChild(node, element);
            node.className = ELEMENT_CLASS_NAME;
            node.markType = type;
            node.__data__ = element.__data__;
          }
          return animation;
        }).attr("markType", type).attr("className", ELEMENT_CLASS_NAME);
      }), (exit) => {
        return exit.each(function(d2, i, element) {
          element.__removed__ = true;
        }).transition(function(data3, i, element) {
          return exitFunction(data3, [element]);
        }).remove();
      }, (merge3) => merge3.append(shapeFunction).attr("className", ELEMENT_CLASS_NAME).attr("markType", type).transition(function(data3, i, element) {
        const { __fromElements__: fromElements } = element;
        const transition2 = updateFunction(data3, fromElements, [element]);
        const exit = new Selection(fromElements, null, element.parentNode);
        exit.transition(transition2).remove();
        return transition2;
      }), (split2) => split2.transition(function(data3, i, element) {
        const enter = new Selection([], element.__toData__, element.parentNode);
        const toElements = enter.append(shapeFunction).attr("className", ELEMENT_CLASS_NAME).attr("markType", type).nodes();
        return updateFunction(data3, [element], toElements);
      }).remove()).transitions();
      transitions.push(...T2.flat());
    }
    plotLabel(view, selection, transitions, library3, context);
  });
}
function plotLabel(view, selection, transitions, library3, context) {
  const [useLabelTransform] = useLibrary("labelTransform", library3);
  const { markState, labelTransform } = view;
  const labelLayer = selection.select(className(LABEL_LAYER_CLASS_NAME)).node();
  const labelShapeFunction = /* @__PURE__ */ new Map();
  const labelDescriptor = /* @__PURE__ */ new Map();
  const labels = Array.from(markState.entries()).flatMap(([mark2, state]) => {
    const { labels: labelOptions = [], key } = mark2;
    const shapeFunction = createLabelShapeFunction(mark2, state, view, library3, context);
    const elements = selection.select(`#${key}`).selectAll(className(ELEMENT_CLASS_NAME)).nodes().filter((n) => !n.__removed__);
    return labelOptions.flatMap((labelOption, i) => {
      const { transform: transform3 = [] } = labelOption, options = __rest76(labelOption, ["transform"]);
      return elements.flatMap((e) => {
        const L = getLabels(options, i, e);
        L.forEach((l) => {
          labelShapeFunction.set(l, shapeFunction);
          labelDescriptor.set(l, labelOption);
        });
        return L;
      });
    });
  });
  const labelShapes = select(labelLayer).selectAll(className(LABEL_CLASS_NAME)).data(labels, (d2) => d2.key).join((enter) => enter.append((d2) => labelShapeFunction.get(d2)(d2)).attr("className", LABEL_CLASS_NAME), (update3) => update3.each(function(d2, i, element) {
    const shapeFunction = labelShapeFunction.get(d2);
    const node = shapeFunction(d2);
    copyAttributes(element, node);
  }), (exit) => exit.remove()).nodes();
  const labelGroups = group(labelShapes, (d2) => labelDescriptor.get(d2.__data__));
  const { coordinate: coordinate2 } = view;
  for (const [label, shapes] of labelGroups) {
    const { transform: transform3 = [] } = label;
    const transformFunction = compose(transform3.map(useLabelTransform));
    transformFunction(shapes, coordinate2);
  }
  if (labelTransform) {
    labelTransform(labelShapes, coordinate2);
  }
}
function getLabels(label, labelIndex, element) {
  const { seriesIndex: SI, seriesKey, points, key, index: index3 } = element.__data__;
  const bounds = getLocalBounds(element);
  if (!SI) {
    return [
      Object.assign(Object.assign({}, label), {
        key: `${key}-${labelIndex}`,
        bounds,
        index: index3,
        points,
        dependentElement: element
      })
    ];
  }
  const selector = normalizeLabelSelector(label);
  const F = SI.map((index4, i) => Object.assign(Object.assign({}, label), {
    key: `${seriesKey[i]}-${labelIndex}`,
    bounds: [points[i]],
    index: index4,
    points,
    dependentElement: element
  }));
  return selector ? selector(F) : F;
}
function filterValid([I, P, S]) {
  if (S)
    return [I, P, S];
  const definedIndex = [];
  const definedPoints = [];
  for (let i = 0; i < I.length; i++) {
    const d2 = I[i];
    const p2 = P[i];
    if (p2.every(([x3, y3]) => defined(x3) && defined(y3))) {
      definedIndex.push(d2);
      definedPoints.push(p2);
    }
  }
  return [definedIndex, definedPoints];
}
function normalizeLabelSelector(label) {
  const { selector } = label;
  if (!selector)
    return null;
  if (typeof selector === "function")
    return selector;
  if (selector === "first")
    return (I) => [I[0]];
  if (selector === "last")
    return (I) => [I[I.length - 1]];
  throw new Error(`Unknown selector: ${selector}`);
}
function getLocalBounds(element) {
  const cloneElement = element.cloneNode();
  const animations = element.getAnimations();
  cloneElement.style.visibility = "hidden";
  animations.forEach((animation) => {
    const keyframes = animation.effect.getKeyframes();
    cloneElement.attr(keyframes[keyframes.length - 1]);
  });
  element.parentNode.appendChild(cloneElement);
  const bounds = cloneElement.getLocalBounds();
  cloneElement.destroy();
  const { min: min11, max: max11 } = bounds;
  return [min11, max11];
}
function createLabelShapeFunction(mark2, state, view, library3, context) {
  const [useShape] = useLibrary("shape", library3);
  const { data: abstractData } = mark2;
  const { data: visualData, defaultLabelShape } = state;
  const point2d = visualData.map((d2) => d2.points);
  const { theme, coordinate: coordinate2 } = view;
  const shapeContext = Object.assign(Object.assign({}, context), {
    document: documentOf(context),
    theme,
    coordinate: coordinate2
  });
  return (options) => {
    const { index: index3, points } = options;
    const datum = abstractData[index3];
    const { formatter: formatter2 = (d2) => `${d2}`, transform: transform3, style: abstractStyle, render: render3 } = options, abstractOptions = __rest76(options, ["formatter", "transform", "style", "render"]);
    const visualOptions = mapObject(Object.assign(Object.assign({}, abstractOptions), abstractStyle), (d2) => valueOf2(d2, datum, index3, abstractData));
    const { shape: shape23 = defaultLabelShape, text } = visualOptions, style = __rest76(visualOptions, ["shape", "text"]);
    const f = typeof formatter2 === "string" ? format2(formatter2) : formatter2;
    const value2 = Object.assign(Object.assign({}, style), { text: f(text, datum, index3, abstractData), datum });
    const shapeOptions = Object.assign({ type: `label.${shape23}`, render: render3 }, style);
    const shapeFunction = useShape(shapeOptions, shapeContext);
    const defaults5 = getDefaultsStyle(theme, "label", shape23, "label");
    return shapeFunction(points, value2, defaults5, point2d);
  };
}
function valueOf2(value2, datum, i, data2) {
  if (typeof value2 === "function")
    return value2(datum, i, data2);
  if (typeof value2 !== "string")
    return value2;
  if (datum[value2] !== void 0)
    return datum[value2];
  return value2;
}
function computeAnimationExtent(markState) {
  let maxDuration = -Infinity;
  let minDelay = Infinity;
  for (const [mark2, state] of markState) {
    const { animate: animate2 = {} } = mark2;
    const { data: data2 } = state;
    const { enter = {}, update: update3 = {}, exit = {} } = animate2;
    const { type: defaultUpdateType, duration: defaultUpdateDuration = 300, delay: defaultUpdateDelay = 0 } = update3;
    const { type: defaultEnterType, duration: defaultEnterDuration = 300, delay: defaultEnterDelay = 0 } = enter;
    const { type: defaultExitType, duration: defaultExitDuration = 300, delay: defaultExitDelay = 0 } = exit;
    for (const d2 of data2) {
      const { updateType = defaultUpdateType, updateDuration = defaultUpdateDuration, updateDelay = defaultUpdateDelay, enterType = defaultEnterType, enterDuration = defaultEnterDuration, enterDelay = defaultEnterDelay, exitDuration = defaultExitDuration, exitDelay = defaultExitDelay, exitType = defaultExitType } = d2;
      if (updateType === void 0 || updateType) {
        maxDuration = Math.max(maxDuration, updateDuration + updateDelay);
        minDelay = Math.min(minDelay, updateDelay);
      }
      if (exitType === void 0 || exitType) {
        maxDuration = Math.max(maxDuration, exitDuration + exitDelay);
        minDelay = Math.min(minDelay, exitDelay);
      }
      if (enterType === void 0 || enterType) {
        maxDuration = Math.max(maxDuration, enterDuration + enterDelay);
        minDelay = Math.min(minDelay, enterDelay);
      }
    }
  }
  if (maxDuration === -Infinity)
    return null;
  return [minDelay, maxDuration - minDelay];
}
function selectFacetElements(selection, current, facetClassName, elementClassName) {
  const group3 = selection.node().parentElement;
  return group3.findAll((node) => node.style.facet !== void 0 && node.style.facet === facetClassName && node !== current.node()).flatMap((node) => node.getElementsByClassName(elementClassName));
}
function maybeFacetElement(element, parent2, originOf) {
  if (!element.__facet__)
    return;
  const prePlot = element.parentNode.parentNode;
  const newPlot = parent2.parentNode;
  const [px, py] = originOf(prePlot);
  const [x3, y3] = originOf(newPlot);
  const translate4 = `translate(${px - x3}, ${py - y3})`;
  appendTransform(element, translate4);
  parent2.append(element);
}
function createMarkShapeFunction(mark2, state, view, library3, context) {
  const [useShape] = useLibrary("shape", library3);
  const { data: abstractData } = mark2;
  const { defaultShape, data: data2, shape: shapeLibrary } = state;
  const point2d = data2.map((d2) => d2.points);
  const { theme, coordinate: coordinate2 } = view;
  const { type: markType, style = {} } = mark2;
  const shapeContext = Object.assign(Object.assign({}, context), {
    document: documentOf(context),
    coordinate: coordinate2,
    theme
  });
  return (data3) => {
    const { shape: styleShape = defaultShape } = style;
    const { shape: shape23 = styleShape, points, seriesIndex, index: i } = data3, v = __rest76(data3, ["shape", "points", "seriesIndex", "index"]);
    const value2 = Object.assign(Object.assign({}, v), { index: i });
    const abstractDatum = seriesIndex ? seriesIndex.map((i2) => abstractData[i2]) : abstractData[i];
    const I = seriesIndex ? seriesIndex : i;
    const visualStyle = mapObject(style, (d2) => valueOf2(d2, abstractDatum, I, abstractData));
    const shapeFunction = shapeLibrary[shape23] ? shapeLibrary[shape23](visualStyle, shapeContext) : useShape(Object.assign(Object.assign({}, visualStyle), { type: shapeName(mark2, shape23) }), shapeContext);
    const defaults5 = getDefaultsStyle(theme, markType, shape23, defaultShape);
    return shapeFunction(points, value2, defaults5, point2d);
  };
}
function getDefaultsStyle(theme, mark2, shape23, defaultShape) {
  if (typeof mark2 !== "string")
    return;
  const { color: color2 } = theme;
  const markTheme = theme[mark2] || {};
  const shapeTheme = markTheme[shape23] || markTheme[defaultShape];
  return Object.assign({ color: color2 }, shapeTheme);
}
function createAnimationFunction(type, mark2, state, view, library3) {
  var _a2, _b;
  const [, createShape] = useLibrary("shape", library3);
  const [useAnimation] = useLibrary("animation", library3);
  const { defaultShape, shape: shapeLibrary } = state;
  const { theme, coordinate: coordinate2 } = view;
  const upperType = upper_first_default(type);
  const key = `default${upperType}Animation`;
  const { [key]: defaultAnimation } = ((_a2 = shapeLibrary[defaultShape]) === null || _a2 === void 0 ? void 0 : _a2.props) || createShape(shapeName(mark2, defaultShape)).props;
  const { [type]: defaultEffectTiming = {} } = theme;
  const animate2 = ((_b = mark2.animate) === null || _b === void 0 ? void 0 : _b[type]) || {};
  const context = { coordinate: coordinate2 };
  return (data2, from, to) => {
    const { [`${type}Type`]: animation, [`${type}Delay`]: delay2, [`${type}Duration`]: duration, [`${type}Easing`]: easing } = data2;
    const options = Object.assign({ type: animation || defaultAnimation }, animate2);
    if (!options.type)
      return null;
    const animateFunction = useAnimation(options, context);
    const value2 = { delay: delay2, duration, easing };
    const A5 = animateFunction(from, to, deep_mix_default(defaultEffectTiming, value2));
    if (!Array.isArray(A5))
      return [A5];
    return A5;
  };
}
function createEnterFunction(mark2, state, view, library3) {
  return createAnimationFunction("enter", mark2, state, view, library3);
}
function cancel(animation) {
  animation.finished.then(() => {
    animation.cancel();
  });
  return animation;
}
function createUpdateFunction(mark2, state, view, library3) {
  return createAnimationFunction("update", mark2, state, view, library3);
}
function createExitFunction(mark2, state, view, library3) {
  return createAnimationFunction("exit", mark2, state, view, library3);
}
function inferTheme(theme = {}) {
  if (typeof theme === "string")
    return { type: theme };
  const { type = "light" } = theme, rest2 = __rest76(theme, ["type"]);
  return Object.assign(Object.assign({}, rest2), { type });
}
function inferInteraction(view) {
  const defaults5 = {
    event: true,
    tooltip: true,
    // @todo Inferred by slider self.
    sliderFilter: true,
    legendFilter: true,
    scrollbarFilter: true
  };
  const { interaction = {} } = view;
  return Object.entries(deep_mix_default(defaults5, interaction)).reverse();
}
function applyTransform(node, library3) {
  return __awaiter9(this, void 0, void 0, function* () {
    const context = { library: library3 };
    const { data: data2 } = node, rest2 = __rest76(node, ["data"]);
    if (data2 == void 0)
      return node;
    const [, { data: newData }] = yield applyDataTransform([], { data: data2 }, context);
    return Object.assign({ data: newData }, rest2);
  });
}
function updateBBox(selection) {
  selection.style("x", (d2) => d2.paddingLeft + d2.marginLeft).style("y", (d2) => d2.paddingTop + d2.marginTop).style("width", (d2) => d2.innerWidth).style("height", (d2) => d2.innerHeight);
}
function animateBBox(selection, extent2) {
  const [delay2, duration] = extent2;
  selection.transition(function(data2, i, element) {
    const { x: x3, y: y3, width, height } = element.style;
    const { paddingLeft, paddingTop, innerWidth, innerHeight, marginLeft, marginTop } = data2;
    const keyframes = [
      {
        x: x3,
        y: y3,
        width,
        height
      },
      {
        x: paddingLeft + marginLeft,
        y: paddingTop + marginTop,
        width: innerWidth,
        height: innerHeight
      }
    ];
    return element.animate(keyframes, { delay: delay2, duration, fill: "both" });
  });
}
function shapeName(mark2, name2) {
  const { type } = mark2;
  if (typeof name2 === "string")
    return `${type}.${name2}`;
  return name2;
}
function updateLayers(selection, marks) {
  const facet = (d2) => d2.class !== void 0 ? `${d2.class}` : "";
  const nodes = selection.nodes();
  if (nodes.length === 0)
    return;
  selection.selectAll(className(MAIN_LAYER_CLASS_NAME)).data(marks, (d2) => d2.key).join((enter) => enter.append("g").attr("className", MAIN_LAYER_CLASS_NAME).attr("id", (d2) => d2.key).style("facet", facet).style("fill", "transparent").style("zIndex", (d2) => {
    var _a2;
    return (_a2 = d2.zIndex) !== null && _a2 !== void 0 ? _a2 : 0;
  }), (update3) => update3.style("facet", facet).style("fill", "transparent").style("zIndex", (d2) => {
    var _a2;
    return (_a2 = d2.zIndex) !== null && _a2 !== void 0 ? _a2 : 0;
  }), (exit) => exit.remove());
  const labelLayer = selection.select(className(LABEL_LAYER_CLASS_NAME)).node();
  if (labelLayer)
    return;
  selection.append("g").attr("className", LABEL_LAYER_CLASS_NAME).style("zIndex", 0);
}
function className(...names) {
  return names.map((d2) => `.${d2}`).join("");
}
function applyClip(selection, clip) {
  if (!selection.node())
    return;
  selection.style("clipPath", (data2) => {
    if (!clip)
      return null;
    const { paddingTop: y3, paddingLeft: x3, marginLeft: x12, marginTop: y12, innerWidth: width, innerHeight: height } = data2;
    return new Rect({ style: { x: x3 + x12, y: y3 + y12, width, height } });
  });
}
function inferComponentScales(scales, states, markState) {
  var _a2;
  for (const [key] of markState.entries()) {
    if (key.type === "cell") {
      return scales.filter((scale10) => scale10.name !== "shape");
    }
  }
  if (states.length !== 1 || scales.some((scale10) => scale10.name === "shape")) {
    return scales;
  }
  const { defaultShape: shape23 } = states[0];
  const acceptMarkTypes = ["point", "line", "rect", "hollow"];
  if (!acceptMarkTypes.includes(shape23))
    return scales;
  const shapeMap = {
    point: "point",
    line: "hyphen",
    rect: "square",
    hollow: "hollow"
  };
  const field3 = ((_a2 = scales.find((scale10) => scale10.name === "color")) === null || _a2 === void 0 ? void 0 : _a2.field) || null;
  const shapeScale = {
    field: field3,
    name: "shape",
    type: "constant",
    domain: [],
    range: [shapeMap[shape23]]
  };
  return [...scales, shapeScale];
}
function applyStyle2(selection, style) {
  for (const [key, value2] of Object.entries(style)) {
    selection.style(key, value2);
  }
}

// node_modules/@antv/g2/esm/runtime/render.js
function inferKeys(options) {
  const root3 = deep_mix_default({}, options);
  const nodeParent = /* @__PURE__ */ new Map([[root3, null]]);
  const nodeIndex = /* @__PURE__ */ new Map([[null, -1]]);
  const discovered = [root3];
  while (discovered.length) {
    const node = discovered.shift();
    if (node.key === void 0) {
      const parent2 = nodeParent.get(node);
      const index3 = nodeIndex.get(node);
      const key = parent2 === null ? `${0}` : `${parent2.key}-${index3}`;
      node.key = key;
    }
    const { children = [] } = node;
    if (Array.isArray(children)) {
      for (let i = 0; i < children.length; i++) {
        const child = deep_mix_default({}, children[i]);
        children[i] = child;
        nodeParent.set(child, node);
        nodeIndex.set(child, i);
        discovered.push(child);
      }
    }
  }
  return root3;
}
function Canvas2(width, height) {
  const renderer = new Renderer();
  renderer.registerPlugin(new Plugin7());
  return new Canvas({
    width,
    height,
    container: document.createElement("div"),
    renderer
  });
}
function render(options, context = {}, resolve = () => {
}, reject2 = (e) => {
  throw e;
}) {
  const { width = 640, height = 480, depth = 0 } = options;
  const keyed2 = inferKeys(options);
  const { canvas = Canvas2(width, height), emitter = new esm_default(), library: library3 } = context;
  context.canvas = canvas;
  context.emitter = emitter;
  const { width: prevWidth, height: prevHeight } = canvas.getConfig();
  if (prevWidth !== width || prevHeight !== height) {
    canvas.resize(width, height);
  }
  emitter.emit(ChartEvent.BEFORE_RENDER);
  const selection = select(canvas.document.documentElement);
  canvas.ready.then(() => plot(Object.assign(Object.assign({}, keyed2), { width, height, depth }), selection, library3, context)).then(() => {
    if (depth) {
      const [x3, y3] = canvas.document.documentElement.getPosition();
      canvas.document.documentElement.setPosition(x3, y3, -depth / 2);
    }
    canvas.requestAnimationFrame(() => {
      emitter.emit(ChartEvent.AFTER_RENDER);
      resolve === null || resolve === void 0 ? void 0 : resolve();
    });
  }).catch((e) => {
    reject2 === null || reject2 === void 0 ? void 0 : reject2(e);
  });
  return normalizeContainer(canvas.getConfig().container);
}
function renderToMountedElement(options, context = {}, resolve = () => {
}, reject2 = (e) => {
  throw e;
}) {
  var _a2;
  const { width = 640, height = 480 } = options;
  const keyed2 = inferKeys(options);
  const { group: group3 = new Group2(), emitter = new esm_default(), library: library3 } = context;
  if (!(group3 === null || group3 === void 0 ? void 0 : group3.parentElement)) {
    error(`renderToMountedElement can't render chart to unmounted group.`);
  }
  const selection = select(group3);
  context.group = group3;
  context.emitter = emitter;
  context.canvas = context.canvas || ((_a2 = group3 === null || group3 === void 0 ? void 0 : group3.ownerDocument) === null || _a2 === void 0 ? void 0 : _a2.defaultView);
  emitter.emit(ChartEvent.BEFORE_RENDER);
  plot(Object.assign(Object.assign({}, keyed2), { width, height }), selection, library3, context).then(() => {
    var _a3;
    (_a3 = context.canvas) === null || _a3 === void 0 ? void 0 : _a3.requestAnimationFrame(() => {
      emitter.emit(ChartEvent.AFTER_RENDER);
      resolve === null || resolve === void 0 ? void 0 : resolve();
    });
  }).catch((e) => {
    reject2 === null || reject2 === void 0 ? void 0 : reject2(e);
  });
  return group3;
}
function destroy(options, context = {}, isDestroyCanvas = false) {
  const { canvas, emitter } = context;
  if (canvas) {
    destroyAllInteractions(canvas);
    isDestroyCanvas ? canvas.destroy() : canvas.destroyChildren();
  }
  emitter.off();
}
function destroyAllInteractions(canvas) {
  const viewGroups = canvas.getRoot().querySelectorAll(`.${VIEW_CLASS_NAME}`);
  viewGroups === null || viewGroups === void 0 ? void 0 : viewGroups.forEach((group3) => {
    const { nameInteraction = /* @__PURE__ */ new Map() } = group3;
    if ((nameInteraction === null || nameInteraction === void 0 ? void 0 : nameInteraction.size) > 0) {
      Array.from(nameInteraction === null || nameInteraction === void 0 ? void 0 : nameInteraction.values()).forEach((value2) => {
        value2 === null || value2 === void 0 ? void 0 : value2.destroy();
      });
    }
  });
}
function normalizeContainer(container) {
  return typeof container === "string" ? document.getElementById(container) : container;
}

// node_modules/@antv/g2/esm/utils/style.js
var defaultStyle = {
  visibility: "visible",
  opacity: 1,
  fillOpacity: 1,
  strokeOpacity: 1
};
function getStyle2(element, key) {
  var _a2;
  return (_a2 = element.style[key]) !== null && _a2 !== void 0 ? _a2 : defaultStyle[key];
}
function setStyle2(element, key, value2, recursive) {
  element.style[key] = value2;
  if (recursive) {
    element.children.forEach((child) => setStyle2(child, key, value2, recursive));
  }
}
function hide2(element) {
  setStyle2(element, "visibility", "hidden", true);
}
function show2(element) {
  setStyle2(element, "visibility", "visible", true);
}

// node_modules/@antv/g2/esm/interaction/utils.js
var __rest77 = function(s2, e) {
  var t = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
      t[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t[p2[i]] = s2[p2[i]];
    }
  return t;
};
function selectG2Elements(root3) {
  return select(root3).selectAll(`.${ELEMENT_CLASS_NAME}`).nodes().filter((d2) => !d2.__removed__);
}
function selectFacetG2Elements(target, viewInstances) {
  return selectFacetViews(target, viewInstances).flatMap(({ container }) => selectG2Elements(container));
}
function selectFacetViews(target, viewInstances) {
  return viewInstances.filter((d2) => d2 !== target && d2.options.parentKey === target.options.key);
}
function selectPlotArea(root3) {
  return select(root3).select(`.${PLOT_CLASS_NAME}`).node();
}
function bboxOf(node) {
  if (node.nodeName !== "rect")
    return node.getRenderBounds();
  const { x: x3, y: y3, width, height } = node.style;
  return { min: [x3, y3], max: [x3 + width, y3 + height] };
}
function mousePosition(target, event) {
  const { offsetX, offsetY } = event;
  const bbox = bboxOf(target);
  const { min: [x3, y3], max: [x12, y12] } = bbox;
  const isOutX = offsetX < x3 || offsetX > x12;
  const isOutY = offsetY < y3 || offsetY > y12;
  if (isOutX || isOutY)
    return null;
  return [offsetX - x3, offsetY - y3];
}
function brushMousePosition(target, event) {
  const { offsetX, offsetY } = event;
  const [x3, y3, x12, y12] = boundsOfBrushArea(target);
  return [
    Math.min(x12, Math.max(x3, offsetX)) - x3,
    Math.min(y12, Math.max(y3, offsetY)) - y3
  ];
}
function boundsOfBrushArea(target) {
  const bbox = target.getRenderBounds();
  const { min: [x05, y05], max: [x12, y12] } = bbox;
  return [x05, y05, x12, y12];
}
function createColorKey(view) {
  return (element) => element.__data__.color;
}
function createXKey(view) {
  return (element) => element.__data__.x;
}
function createDatumof(view) {
  const views = Array.isArray(view) ? view : [view];
  const keyData = new Map(views.flatMap((view2) => {
    const marks = Array.from(view2.markState.keys());
    return marks.map((mark2) => [keyed(view2.key, mark2.key), mark2.data]);
  }));
  return (element) => {
    const { index: index3, markKey, viewKey } = element.__data__;
    const data2 = keyData.get(keyed(viewKey, markKey));
    return data2[index3];
  };
}
function useState(style, valueof2 = (d2, element) => d2, setAttribute = (element, key, v) => element.setAttribute(key, v)) {
  const STATES = "__states__";
  const ORIGINAL = "__ordinal__";
  const updateState = (element) => {
    const { [STATES]: states = [], [ORIGINAL]: original = {} } = element;
    const stateStyle = states.reduce((mixedStyle, state) => Object.assign(Object.assign({}, mixedStyle), style[state]), original);
    if (Object.keys(stateStyle).length === 0)
      return;
    for (const [key, value2] of Object.entries(stateStyle)) {
      const currentValue = getStyle2(element, key);
      const v = valueof2(value2, element);
      setAttribute(element, key, v);
      if (!(key in original))
        original[key] = currentValue;
    }
    element[ORIGINAL] = original;
  };
  const initState = (element) => {
    if (element[STATES])
      return;
    element[STATES] = [];
    return;
  };
  const setState = (element, ...states) => {
    initState(element);
    element[STATES] = [...states];
    updateState(element);
  };
  const removeState = (element, ...states) => {
    initState(element);
    for (const state of states) {
      const index3 = element[STATES].indexOf(state);
      if (index3 !== -1) {
        element[STATES].splice(index3, 1);
      }
    }
    updateState(element);
  };
  const hasState = (element, state) => {
    initState(element);
    return element[STATES].indexOf(state) !== -1;
  };
  return {
    setState,
    removeState,
    hasState
  };
}
function isEmptyObject(obj) {
  if (obj === void 0)
    return true;
  if (typeof obj !== "object")
    return false;
  return Object.keys(obj).length === 0;
}
function keyed(viewKey, markKey) {
  return `${viewKey},${markKey}`;
}
function mergeState(options, states) {
  const views = Array.isArray(options) ? options : [options];
  const markState = views.flatMap((view) => view.marks.map((mark2) => [keyed(view.key, mark2.key), mark2.state]));
  const state = {};
  for (const descriptor of states) {
    const [key, defaults5] = Array.isArray(descriptor) ? descriptor : [descriptor, {}];
    state[key] = markState.reduce((merged, mark2) => {
      const [markKey, markState2 = {}] = mark2;
      const selectedState = isEmptyObject(markState2[key]) ? defaults5 : markState2[key];
      for (const [attr2, value2] of Object.entries(selectedState)) {
        const oldValue = merged[attr2];
        const newValue = (data2, index3, array2, element) => {
          const k2 = keyed(element.__data__.viewKey, element.__data__.markKey);
          if (markKey !== k2)
            return oldValue === null || oldValue === void 0 ? void 0 : oldValue(data2, index3, array2, element);
          if (typeof value2 !== "function")
            return value2;
          return value2(data2, index3, array2, element);
        };
        merged[attr2] = newValue;
      }
      return merged;
    }, {});
  }
  return state;
}
function createValueof(elements, datum) {
  const elementIndex = new Map(elements.map((d2, i) => [d2, i]));
  const fa = datum ? elements.map(datum) : elements;
  return (d2, e) => {
    if (typeof d2 !== "function")
      return d2;
    const i = elementIndex.get(e);
    const fe = datum ? datum(e) : e;
    return d2(fe, i, fa, e);
  };
}
function renderLink(_a2) {
  var { link: link3 = false, valueof: valueof2 = (d2, element) => d2, coordinate: coordinate2 } = _a2, style = __rest77(_a2, ["link", "valueof", "coordinate"]);
  const LINK_CLASS_NAME = "element-link";
  if (!link3)
    return [() => {
    }, () => {
    }];
  const pointsOf = (element) => element.__data__.points;
  const pathPointsOf = (P0, P1) => {
    const [, p1, p2] = P0;
    const [p0, , , p3] = P1;
    const P = [p1, p0, p3, p2];
    return P;
  };
  const append3 = (elements) => {
    var _a3;
    if (elements.length <= 1)
      return;
    const sortedElements = sort(elements, (e0, e1) => {
      const { x: x05 } = e0.__data__;
      const { x: x12 } = e1.__data__;
      const dx = x05 - x12;
      return dx;
    });
    for (let i = 1; i < sortedElements.length; i++) {
      const p2 = path();
      const e0 = sortedElements[i - 1];
      const e1 = sortedElements[i];
      const [p0, p1, p22, p3] = pathPointsOf(pointsOf(e0), pointsOf(e1));
      p2.moveTo(...p0);
      p2.lineTo(...p1);
      p2.lineTo(...p22);
      p2.lineTo(...p3);
      p2.closePath();
      const _b = mapObject(style, (d2) => valueof2(d2, e0)), { fill: fill2 = e0.getAttribute("fill") } = _b, rest2 = __rest77(_b, ["fill"]);
      const link4 = new Path2({
        className: LINK_CLASS_NAME,
        style: Object.assign({ d: p2.toString(), fill: fill2, zIndex: -2 }, rest2)
      });
      (_a3 = e0.link) === null || _a3 === void 0 ? void 0 : _a3.remove();
      e0.parentNode.appendChild(link4);
      e0.link = link4;
    }
  };
  const remove2 = (element) => {
    var _a3;
    (_a3 = element.link) === null || _a3 === void 0 ? void 0 : _a3.remove();
    element.link = null;
  };
  return [append3, remove2];
}
function offsetTransform(element, offset2, coordinate2) {
  const append3 = (t) => {
    const { transform: transform3 } = element.style;
    return transform3 ? `${transform3} ${t}` : t;
  };
  if (isPolar(coordinate2)) {
    const { points } = element.__data__;
    const [p0, p1] = isTranspose(coordinate2) ? reorder(points) : points;
    const center2 = coordinate2.getCenter();
    const v0 = sub6(p0, center2);
    const v1 = sub6(p1, center2);
    const a0 = angle3(v0);
    const da = angleBetween2(v0, v1);
    const amid = a0 + da / 2;
    const dx = offset2 * Math.cos(amid);
    const dy = offset2 * Math.sin(amid);
    return append3(`translate(${dx}, ${dy})`);
  }
  if (isTranspose(coordinate2))
    return append3(`translate(${offset2}, 0)`);
  return append3(`translate(0, ${-offset2})`);
}
function renderBackground(_a2) {
  var { document: document2, background, scale: scale10, coordinate: coordinate2, valueof: valueof2 } = _a2, rest2 = __rest77(_a2, ["document", "background", "scale", "coordinate", "valueof"]);
  const BACKGROUND_CLASS_NAME = "element-background";
  if (!background)
    return [() => {
    }, () => {
    }];
  const extentOf2 = (scale11, x3, padding) => {
    const ax = scale11.invert(x3);
    const mid2 = x3 + scale11.getBandWidth(ax) / 2;
    const half = scale11.getStep(ax) / 2;
    const offset2 = half * padding;
    return [mid2 - half + offset2, mid2 + half - offset2];
  };
  const sizeXOf = (element, padding) => {
    const { x: scaleX } = scale10;
    if (!isOrdinalScale(scaleX))
      return [0, 1];
    const { __data__: data2 } = element;
    const { x: x3 } = data2;
    const [e1, e23] = extentOf2(scaleX, x3, padding);
    return [e1, e23];
  };
  const sizeYOf = (element, padding) => {
    const { y: scaleY } = scale10;
    if (!isOrdinalScale(scaleY))
      return [0, 1];
    const { __data__: data2 } = element;
    const { y: y3 } = data2;
    const [e1, e23] = extentOf2(scaleY, y3, padding);
    return [e1, e23];
  };
  const bandShapeOf = (element, style) => {
    const { padding } = style;
    const [x12, x22] = sizeXOf(element, padding);
    const [y12, y22] = sizeYOf(element, padding);
    const points = [
      [x12, y12],
      [x22, y12],
      [x22, y22],
      [x12, y22]
    ].map((d2) => coordinate2.map(d2));
    const { __data__: data2 } = element;
    const { y: dy, y1: dy1 } = data2;
    return rect(document2, points, { y: dy, y1: dy1 }, coordinate2, style);
  };
  const cloneShapeOf = (element, style) => {
    const { transform: transform3 = "scale(1.2, 1.2)", transformOrigin = "center center", stroke: stroke2 = "" } = style, rest3 = __rest77(style, ["transform", "transformOrigin", "stroke"]);
    const finalStyle = Object.assign({ transform: transform3, transformOrigin, stroke: stroke2 }, rest3);
    const shape23 = element.cloneNode(true);
    for (const [key, value2] of Object.entries(finalStyle)) {
      shape23.style[key] = value2;
    }
    return shape23;
  };
  const isOrdinalShape = () => {
    const { x: x3, y: y3 } = scale10;
    return [x3, y3].some(isOrdinalScale);
  };
  const append3 = (element) => {
    if (element.background)
      element.background.remove();
    const _a3 = mapObject(rest2, (d2) => valueof2(d2, element)), { fill: fill2 = "#CCD6EC", fillOpacity = 0.3, zIndex = -2, padding = 1e-3, strokeWidth = 0 } = _a3, style = __rest77(_a3, ["fill", "fillOpacity", "zIndex", "padding", "strokeWidth"]);
    const finalStyle = Object.assign(Object.assign({}, style), {
      fill: fill2,
      fillOpacity,
      zIndex,
      padding,
      strokeWidth
    });
    const shapeOf = isOrdinalShape() ? bandShapeOf : cloneShapeOf;
    const shape23 = shapeOf(element, finalStyle);
    shape23.className = BACKGROUND_CLASS_NAME;
    element.parentNode.parentNode.appendChild(shape23);
    element.background = shape23;
  };
  const remove2 = (element) => {
    var _a3;
    (_a3 = element.background) === null || _a3 === void 0 ? void 0 : _a3.remove();
    element.background = null;
  };
  const is = (element) => {
    return element.className === BACKGROUND_CLASS_NAME;
  };
  return [append3, remove2, is];
}
function setCursor(root3, cursor) {
  const canvas = root3.getRootNode().defaultView;
  const dom2 = canvas.getContextService().getDomElement();
  if (dom2 === null || dom2 === void 0 ? void 0 : dom2.style) {
    root3.cursor = dom2.style.cursor;
    dom2.style.cursor = cursor;
  }
}
function restoreCursor(root3) {
  setCursor(root3, root3.cursor);
}
function selectElementByData(elements, data2, datum) {
  return elements.find((d2) => Object.entries(data2).every(([key, value2]) => datum(d2)[key] === value2));
}

// node_modules/@antv/g2/esm/interaction/elementHighlight.js
var __rest78 = function(s2, e) {
  var t = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
      t[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t[p2[i]] = s2[p2[i]];
    }
  return t;
};
function elementHighlight(root3, {
  elements: elementsof,
  // given the root of chart returns elements to be manipulated
  datum,
  // given each element returns the datum of it
  groupKey = (d2) => d2,
  // group elements by specified key
  link: link3 = false,
  // draw link or not
  background = false,
  // draw background or not
  delay: delay2 = 60,
  // delay to unhighlighted element
  scale: scale10,
  coordinate: coordinate2,
  emitter,
  state = {}
}) {
  var _a2;
  const elements = elementsof(root3);
  const elementSet = new Set(elements);
  const keyGroup = group(elements, groupKey);
  const valueof2 = createValueof(elements, datum);
  const [appendLink, removeLink] = renderLink(Object.assign({
    elements,
    valueof: valueof2,
    link: link3,
    coordinate: coordinate2
  }, subObject(state.active, "link")));
  const [appendBackground, removeBackground, isBackground] = renderBackground(Object.assign({
    document: root3.ownerDocument,
    scale: scale10,
    coordinate: coordinate2,
    background,
    valueof: valueof2
  }, subObject(state.active, "background")));
  const elementStyle = deep_mix_default(state, {
    active: Object.assign({}, ((_a2 = state.active) === null || _a2 === void 0 ? void 0 : _a2.offset) && {
      //Apply translate to mock slice out.
      transform: (...params) => {
        const value2 = state.active.offset(...params);
        const [, i] = params;
        return offsetTransform(elements[i], value2, coordinate2);
      }
    })
  });
  const { setState, removeState, hasState } = useState(elementStyle, valueof2);
  let out;
  const pointerover = (event) => {
    const { target: element, nativeEvent = true } = event;
    if (!elementSet.has(element))
      return;
    if (out)
      clearTimeout(out);
    const k2 = groupKey(element);
    const group3 = keyGroup.get(k2);
    const groupSet = new Set(group3);
    for (const e of elements) {
      if (groupSet.has(e)) {
        if (!hasState(e, "active"))
          setState(e, "active");
      } else {
        setState(e, "inactive");
        removeLink(e);
      }
      if (e !== element)
        removeBackground(e);
    }
    appendBackground(element);
    appendLink(group3);
    if (!nativeEvent)
      return;
    emitter.emit("element:highlight", {
      nativeEvent,
      data: {
        data: datum(element),
        group: group3.map(datum)
      }
    });
  };
  const delayUnhighlighted = () => {
    if (out)
      clearTimeout(out);
    out = setTimeout(() => {
      unhighlighted();
      out = null;
    }, delay2);
  };
  const unhighlighted = (nativeEvent = true) => {
    for (const e of elements) {
      removeState(e, "active", "inactive");
      removeBackground(e);
      removeLink(e);
    }
    if (nativeEvent) {
      emitter.emit("element:unhighlight", { nativeEvent });
    }
  };
  const pointerout = (event) => {
    const { target: element } = event;
    if (background && !isBackground(element))
      return;
    if (!background && !elementSet.has(element))
      return;
    if (delay2 > 0)
      delayUnhighlighted();
    else
      unhighlighted();
  };
  const pointerleave = () => {
    unhighlighted();
  };
  root3.addEventListener("pointerover", pointerover);
  root3.addEventListener("pointerout", pointerout);
  root3.addEventListener("pointerleave", pointerleave);
  const onRest = (e) => {
    const { nativeEvent } = e;
    if (nativeEvent)
      return;
    unhighlighted(false);
  };
  const onHighlight = (e) => {
    const { nativeEvent } = e;
    if (nativeEvent)
      return;
    const { data: data2 } = e.data;
    const element = selectElementByData(elements, data2, datum);
    if (!element)
      return;
    pointerover({ target: element, nativeEvent: false });
  };
  emitter.on("element:highlight", onHighlight);
  emitter.on("element:unhighlight", onRest);
  return () => {
    root3.removeEventListener("pointerover", pointerover);
    root3.removeEventListener("pointerout", pointerout);
    root3.removeEventListener("pointerleave", pointerleave);
    emitter.off("element:highlight", onHighlight);
    emitter.off("element:unhighlight", onRest);
    for (const e of elements) {
      removeBackground(e);
      removeLink(e);
    }
  };
}
function ElementHighlight(_a2) {
  var { delay: delay2, createGroup, background = false, link: link3 = false } = _a2, rest2 = __rest78(_a2, ["delay", "createGroup", "background", "link"]);
  return (context, _2, emitter) => {
    const { container, view, options } = context;
    const { scale: scale10, coordinate: coordinate2 } = view;
    const plotArea = selectPlotArea(container);
    return elementHighlight(plotArea, Object.assign({
      elements: selectG2Elements,
      datum: createDatumof(view),
      groupKey: createGroup ? createGroup(view) : void 0,
      coordinate: coordinate2,
      scale: scale10,
      state: mergeState(options, [
        ["active", background ? {} : { lineWidth: "1", stroke: "#000" }],
        "inactive"
      ]),
      background,
      link: link3,
      delay: delay2,
      emitter
    }, rest2));
  };
}
ElementHighlight.props = {
  reapplyWhenUpdate: true
};

// node_modules/@antv/g2/esm/interaction/elementHighlightByX.js
function ElementHighlightByX(options) {
  return ElementHighlight(Object.assign(Object.assign({}, options), { createGroup: createXKey }));
}
ElementHighlightByX.props = {
  reapplyWhenUpdate: true
};

// node_modules/@antv/g2/esm/interaction/elementHighlightByColor.js
function ElementHighlightByColor(options) {
  return ElementHighlight(Object.assign(Object.assign({}, options), { createGroup: createColorKey }));
}
ElementHighlightByColor.props = {
  reapplyWhenUpdate: true
};

// node_modules/@antv/g2/esm/interaction/elementSelect.js
var __rest79 = function(s2, e) {
  var t = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
      t[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t[p2[i]] = s2[p2[i]];
    }
  return t;
};
function elementSelect(root3, {
  elements: elementsof,
  // given the root of chart returns elements to be manipulated
  datum,
  // given each element returns the datum of it
  groupKey = (d2) => d2,
  // group elements by specified key
  link: link3 = false,
  // draw link or not
  single = false,
  // single select or not
  coordinate: coordinate2,
  background = false,
  scale: scale10,
  emitter,
  state = {}
}) {
  var _a2;
  const elements = elementsof(root3);
  const elementSet = new Set(elements);
  const keyGroup = group(elements, groupKey);
  const valueof2 = createValueof(elements, datum);
  const [appendLink, removeLink] = renderLink(Object.assign({
    link: link3,
    elements,
    valueof: valueof2,
    coordinate: coordinate2
  }, subObject(state.selected, "link")));
  const [appendBackground, removeBackground] = renderBackground(Object.assign({
    document: root3.ownerDocument,
    background,
    coordinate: coordinate2,
    scale: scale10,
    valueof: valueof2
  }, subObject(state.selected, "background")));
  const elementStyle = deep_mix_default(state, {
    selected: Object.assign({}, ((_a2 = state.selected) === null || _a2 === void 0 ? void 0 : _a2.offset) && {
      //Apply translate to mock slice out.
      transform: (...params) => {
        const value2 = state.selected.offset(...params);
        const [, i] = params;
        return offsetTransform(elements[i], value2, coordinate2);
      }
    })
  });
  const { setState, removeState, hasState } = useState(elementStyle, valueof2);
  const clear = (nativeEvent = true) => {
    for (const e of elements) {
      removeState(e, "selected", "unselected");
      removeLink(e);
      removeBackground(e);
    }
    if (nativeEvent)
      emitter.emit("element:unselect", { nativeEvent: true });
    return;
  };
  const singleSelect = (event, element, nativeEvent = true) => {
    if (hasState(element, "selected"))
      clear();
    else {
      const k2 = groupKey(element);
      const group3 = keyGroup.get(k2);
      const groupSet = new Set(group3);
      for (const e of elements) {
        if (groupSet.has(e))
          setState(e, "selected");
        else {
          setState(e, "unselected");
          removeLink(e);
        }
        if (e !== element)
          removeBackground(e);
      }
      appendLink(group3);
      appendBackground(element);
      if (!nativeEvent)
        return;
      emitter.emit("element:select", Object.assign(Object.assign({}, event), { nativeEvent, data: {
        data: [datum(element), ...group3.map(datum)]
      } }));
    }
  };
  const multipleSelect = (event, element, nativeEvent = true) => {
    const k2 = groupKey(element);
    const group3 = keyGroup.get(k2);
    const groupSet = new Set(group3);
    if (!hasState(element, "selected")) {
      const hasSelectedGroup = group3.some((e) => hasState(e, "selected"));
      for (const e of elements) {
        if (groupSet.has(e))
          setState(e, "selected");
        else if (!hasState(e, "selected"))
          setState(e, "unselected");
      }
      if (!hasSelectedGroup && link3)
        appendLink(group3);
      appendBackground(element);
    } else {
      const hasSelected = elements.some((e) => !groupSet.has(e) && hasState(e, "selected"));
      if (!hasSelected)
        return clear();
      for (const e of group3) {
        setState(e, "unselected");
        removeLink(e);
        removeBackground(e);
      }
    }
    if (!nativeEvent)
      return;
    emitter.emit("element:select", Object.assign(Object.assign({}, event), { nativeEvent, data: {
      data: elements.filter((e) => hasState(e, "selected")).map(datum)
    } }));
  };
  const click = (event) => {
    const { target: element, nativeEvent = true } = event;
    if (!elementSet.has(element))
      return clear();
    if (single)
      return singleSelect(event, element, nativeEvent);
    return multipleSelect(event, element, nativeEvent);
  };
  root3.addEventListener("click", click);
  const onSelect = (e) => {
    const { nativeEvent, data: data2 } = e;
    if (nativeEvent)
      return;
    const selectedData = single ? data2.data.slice(0, 1) : data2.data;
    for (const d2 of selectedData) {
      const element = selectElementByData(elements, d2, datum);
      click({ target: element, nativeEvent: false });
    }
  };
  const onUnSelect = () => {
    clear(false);
  };
  emitter.on("element:select", onSelect);
  emitter.on("element:unselect", onUnSelect);
  return () => {
    for (const e of elements)
      removeLink(e);
    root3.removeEventListener("click", click);
    emitter.off("element:select", onSelect);
    emitter.off("element:unselect", onUnSelect);
  };
}
function ElementSelect(_a2) {
  var { createGroup, background = false, link: link3 = false } = _a2, rest2 = __rest79(_a2, ["createGroup", "background", "link"]);
  return (context, _2, emitter) => {
    const { container, view, options } = context;
    const { coordinate: coordinate2, scale: scale10 } = view;
    const plotArea = selectPlotArea(container);
    return elementSelect(plotArea, Object.assign({
      elements: selectG2Elements,
      datum: createDatumof(view),
      groupKey: createGroup ? createGroup(view) : void 0,
      coordinate: coordinate2,
      scale: scale10,
      state: mergeState(options, [
        ["selected", background ? {} : { lineWidth: "1", stroke: "#000" }],
        "unselected"
      ]),
      background,
      link: link3,
      emitter
    }, rest2));
  };
}
ElementSelect.props = {
  reapplyWhenUpdate: true
};

// node_modules/@antv/g2/esm/interaction/elementSelectByX.js
function ElementSelectByX(options) {
  return ElementSelect(Object.assign(Object.assign({}, options), { createGroup: createXKey }));
}
ElementSelectByX.props = {
  reapplyWhenUpdate: true
};

// node_modules/@antv/g2/esm/interaction/elementSelectByColor.js
function ElementSelectByColor(options) {
  return ElementSelect(Object.assign(Object.assign({}, options), { createGroup: createColorKey }));
}
ElementSelectByColor.props = {
  reapplyWhenUpdate: true
};

// node_modules/@antv/g2/esm/interaction/chartIndex.js
var __awaiter10 = function(thisArg, _arguments, P, generator) {
  function adopt(value2) {
    return value2 instanceof P ? value2 : new P(function(resolve) {
      resolve(value2);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject2) {
    function fulfilled(value2) {
      try {
        step2(generator.next(value2));
      } catch (e) {
        reject2(e);
      }
    }
    function rejected(value2) {
      try {
        step2(generator["throw"](value2));
      } catch (e) {
        reject2(e);
      }
    }
    function step2(result2) {
      result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
    }
    step2((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __rest80 = function(s2, e) {
  var t = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
      t[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t[p2[i]] = s2[p2[i]];
    }
  return t;
};
function maybeTransform(options) {
  const { transform: transform3 = [] } = options;
  const normalizeY = transform3.find((d2) => d2.type === "normalizeY");
  if (normalizeY)
    return normalizeY;
  const newNormalizeY = { type: "normalizeY" };
  transform3.push(newNormalizeY);
  options.transform = transform3;
  return newNormalizeY;
}
function markValue2(markState, markName, channels) {
  const [value2] = Array.from(markState.entries()).filter(([mark2]) => mark2.type === markName).map(([mark2]) => {
    const { encode } = mark2;
    const channel = (name2) => {
      const channel2 = encode[name2];
      return [name2, channel2 ? channel2.value : void 0];
    };
    return Object.fromEntries(channels.map(channel));
  });
  return value2;
}
function ChartIndex(_a2) {
  var { wait = 20, leading, trailing = false, labelFormatter: labelFormatter2 = (date) => `${date}` } = _a2, style = __rest80(_a2, ["wait", "leading", "trailing", "labelFormatter"]);
  return (context) => {
    const { view, container, update: update3, setState } = context;
    const { markState, scale: scale10, coordinate: coordinate2 } = view;
    const value2 = markValue2(markState, "line", ["x", "y", "series"]);
    if (!value2)
      return;
    const { y: Y, x: X, series: S = [] } = value2;
    const I = Y.map((_2, i) => i);
    const sortedX = sort(I.map((i) => X[i]));
    const plotArea = selectPlotArea(container);
    const lines = container.getElementsByClassName(ELEMENT_CLASS_NAME);
    const labels = container.getElementsByClassName(LABEL_CLASS_NAME);
    const keyofLabel = (d2) => d2.__data__.key.split("-")[0];
    const keyLabels = group(labels, keyofLabel);
    const rule = new Line({
      style: Object.assign({ x1: 0, y1: 0, x2: 0, y2: plotArea.getAttribute("height"), stroke: "black", lineWidth: 1 }, subObject(style, "rule"))
    });
    const text = new Text({
      style: Object.assign({ x: 0, y: plotArea.getAttribute("height"), text: "", fontSize: 10 }, subObject(style, "label"))
    });
    rule.append(text);
    plotArea.appendChild(rule);
    const dateByFocus = (coordinate3, scaleX, focus) => {
      const [normalizedX] = coordinate3.invert(focus);
      const date = scaleX.invert(normalizedX);
      return sortedX[bisectCenter(sortedX, date)];
    };
    const updateRule = (focus, date) => {
      rule.setAttribute("x1", focus[0]);
      rule.setAttribute("x2", focus[0]);
      text.setAttribute("text", labelFormatter2(date));
    };
    let newView;
    const updateBasisByRerender = (focus) => __awaiter10(this, void 0, void 0, function* () {
      const { x: scaleX } = scale10;
      const date = dateByFocus(coordinate2, scaleX, focus);
      updateRule(focus, date);
      setState("chartIndex", (options) => {
        const clonedOptions = deep_mix_default({}, options);
        const lineMark = clonedOptions.marks.find((d2) => d2.type === "line");
        const r = (I2) => max4(I2, (i) => +Y[i]) / min4(I2, (i) => +Y[i]);
        const k2 = max4(rollup(I, r, (i) => S[i]).values());
        const domainY = [1 / k2, k2];
        deep_mix_default(lineMark, {
          scale: { y: { domain: domainY } }
        });
        const normalizeY = maybeTransform(lineMark);
        normalizeY.groupBy = "color";
        normalizeY.basis = (I2, Y3) => {
          const i = I2[bisector((i2) => X[+i2]).center(I2, date)];
          return Y3[i];
        };
        for (const mark2 of clonedOptions.marks)
          mark2.animate = false;
        return clonedOptions;
      });
      const newState = yield update3("chartIndex");
      newView = newState.view;
    });
    const updateBasisByTranslate = (focus) => {
      const { scale: scale11, coordinate: coordinate3 } = newView;
      const { x: scaleX, y: scaleY } = scale11;
      const date = dateByFocus(coordinate3, scaleX, focus);
      updateRule(focus, date);
      for (const line4 of lines) {
        const { seriesIndex: SI, key } = line4.__data__;
        const i = SI[bisector((i2) => X[+i2]).center(SI, date)];
        const p0 = [0, scaleY.map(1)];
        const p1 = [0, scaleY.map(Y[i] / Y[SI[0]])];
        const [, y05] = coordinate3.map(p0);
        const [, y12] = coordinate3.map(p1);
        const dy = y05 - y12;
        line4.setAttribute("transform", `translate(0, ${dy})`);
        const labels2 = keyLabels.get(key) || [];
        for (const label of labels2) {
          label.setAttribute("dy", dy);
        }
      }
    };
    const updateBasis = throttle_default((event) => {
      const focus = mousePosition(plotArea, event);
      if (!focus)
        return;
      updateBasisByTranslate(focus);
    }, wait, { leading, trailing });
    updateBasisByRerender([0, 0]);
    plotArea.addEventListener("pointerenter", updateBasis);
    plotArea.addEventListener("pointermove", updateBasis);
    plotArea.addEventListener("pointerleave", updateBasis);
    return () => {
      rule.remove();
      plotArea.removeEventListener("pointerenter", updateBasis);
      plotArea.removeEventListener("pointermove", updateBasis);
      plotArea.removeEventListener("pointerleave", updateBasis);
    };
  };
}
ChartIndex.props = {
  reapplyWhenUpdate: true
};

// node_modules/@antv/g2/esm/interaction/fisheye.js
function maybeCoordinate(options) {
  const { coordinate: coordinate2 = {} } = options;
  const { transform: transform3 = [] } = coordinate2;
  const fisheye2 = transform3.find((d2) => d2.type === "fisheye");
  if (fisheye2)
    return fisheye2;
  const newFisheye = { type: "fisheye" };
  transform3.push(newFisheye);
  coordinate2.transform = transform3;
  options.coordinate = coordinate2;
  return newFisheye;
}
function Fisheye2({ wait = 30, leading, trailing = false }) {
  return (context) => {
    const { options, update: update3, setState, container } = context;
    const plotArea = selectPlotArea(container);
    const updateFocus = throttle_default((event) => {
      const focus = mousePosition(plotArea, event);
      if (!focus) {
        setState("fisheye");
        update3();
        return;
      }
      setState("fisheye", (options2) => {
        const clonedOptions = deep_mix_default({}, options2, {
          interaction: { tooltip: { preserve: true } }
        });
        for (const mark2 of clonedOptions.marks)
          mark2.animate = false;
        const [x3, y3] = focus;
        const fisheye2 = maybeCoordinate(clonedOptions);
        fisheye2.focusX = x3;
        fisheye2.focusY = y3;
        fisheye2.visual = true;
        return clonedOptions;
      });
      update3();
    }, wait, { leading, trailing });
    plotArea.addEventListener("pointerenter", updateFocus);
    plotArea.addEventListener("pointermove", updateFocus);
    plotArea.addEventListener("pointerleave", updateFocus);
    return () => {
      plotArea.removeEventListener("pointerenter", updateFocus);
      plotArea.removeEventListener("pointermove", updateFocus);
      plotArea.removeEventListener("pointerleave", updateFocus);
    };
  };
}

// node_modules/@antv/g2/esm/interaction/tooltip.js
var __rest81 = function(s2, e) {
  var t = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
      t[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t[p2[i]] = s2[p2[i]];
    }
  return t;
};
function getContainer(group3, mount) {
  if (mount) {
    return typeof mount === "string" ? document.querySelector(mount) : mount;
  }
  const canvas = group3.ownerDocument.defaultView.getContextService().getDomElement();
  return canvas.parentElement;
}
function getBounding(root3) {
  const bbox = root3.getBounds();
  const { min: [x12, y12], max: [x22, y22] } = bbox;
  return {
    x: x12,
    y: y12,
    width: x22 - x12,
    height: y22 - y12
  };
}
function getContainerOffset(container1, container2) {
  const r1 = container1.getBoundingClientRect();
  const r2 = container2.getBoundingClientRect();
  return {
    x: r1.x - r2.x,
    y: r1.y - r2.y
  };
}
function createTooltip(container, x05, y05, position, enterable, bounding, containerOffset, css = {}) {
  const defaults5 = {
    ".g2-tooltip": {},
    ".g2-tooltip-title": {
      overflow: "hidden",
      "white-space": "nowrap",
      "text-overflow": "ellipsis"
    }
  };
  const tooltipElement = new Tooltip({
    className: "tooltip",
    style: {
      x: x05,
      y: y05,
      container: containerOffset,
      data: [],
      bounding,
      position,
      enterable,
      title: "",
      offset: [10, 10],
      template: {
        prefixCls: "g2-"
      },
      style: deep_mix_default(defaults5, css)
    }
  });
  container.appendChild(tooltipElement.HTMLTooltipElement);
  return tooltipElement;
}
function showTooltip({ root: root3, data: data2, x: x3, y: y3, render: render3, event, single, position = "right-bottom", enterable = false, css, mount, bounding }) {
  const container = getContainer(root3, mount);
  const canvasContainer = getContainer(root3);
  const parent2 = single ? canvasContainer : root3;
  const b = bounding || getBounding(root3);
  const containerOffset = getContainerOffset(canvasContainer, container);
  const { tooltipElement = createTooltip(container, x3, y3, position, enterable, b, containerOffset, css) } = parent2;
  const { items, title = "" } = data2;
  tooltipElement.update(Object.assign({
    x: x3,
    y: y3,
    data: items,
    title,
    position,
    enterable
  }, render3 !== void 0 && {
    content: render3(event, { items, title })
  }));
  parent2.tooltipElement = tooltipElement;
}
function hideTooltip({ root: root3, single, emitter, nativeEvent = true, event = null }) {
  if (nativeEvent) {
    emitter.emit("tooltip:hide", { nativeEvent });
  }
  const container = getContainer(root3);
  const parent2 = single ? container : root3;
  const { tooltipElement } = parent2;
  if (tooltipElement) {
    tooltipElement.hide(event === null || event === void 0 ? void 0 : event.clientX, event === null || event === void 0 ? void 0 : event.clientY);
  }
}
function destroyTooltip({ root: root3, single }) {
  const container = getContainer(root3);
  const parent2 = single ? container : root3;
  if (!parent2)
    return;
  const { tooltipElement } = parent2;
  if (tooltipElement) {
    tooltipElement.destroy();
    parent2.tooltipElement = void 0;
  }
}
function showUndefined(item) {
  const { value: value2 } = item;
  return Object.assign(Object.assign({}, item), { value: value2 === void 0 ? "undefined" : value2 });
}
function singleItem(element) {
  const { __data__: datum } = element;
  const { title, items = [] } = datum;
  const newItems = items.filter(defined).map((_a2) => {
    var { color: color2 = itemColorOf(element) } = _a2, item = __rest81(_a2, ["color"]);
    return Object.assign(Object.assign({}, item), { color: color2 });
  }).map(showUndefined);
  return Object.assign(Object.assign({}, title && { title }), { items: newItems });
}
function groupNameOf(scale10, datum) {
  const { color: scaleColor, series: scaleSeries, facet = false } = scale10;
  const { color: color2, series } = datum;
  const invertAble = (scale11) => {
    return scale11 && scale11.invert && !(scale11 instanceof Band) && !(scale11 instanceof Constant2);
  };
  if (invertAble(scaleSeries)) {
    const cloned = scaleSeries.clone();
    return cloned.invert(series);
  }
  if (series && scaleSeries instanceof Band && scaleSeries.invert(series) !== color2 && !facet) {
    return scaleSeries.invert(series);
  }
  if (invertAble(scaleColor)) {
    const name2 = scaleColor.invert(color2);
    if (Array.isArray(name2))
      return null;
    return name2;
  }
  return null;
}
function itemColorOf(element) {
  const fill2 = element.getAttribute("fill");
  const stroke2 = element.getAttribute("stroke");
  const { __data__: datum } = element;
  const { color: color2 = fill2 && fill2 !== "transparent" ? fill2 : stroke2 } = datum;
  return color2;
}
function unique2(items, key = (d2) => d2) {
  const valueName = new Map(items.map((d2) => [key(d2), d2]));
  return Array.from(valueName.values());
}
function groupItems(elements, scale10, groupName, data2 = elements.map((d2) => d2["__data__"]), theme = {}) {
  const key = (d2) => d2 instanceof Date ? +d2 : d2;
  const T = unique2(data2.map((d2) => d2.title), key).filter(defined);
  const newItems = data2.flatMap((datum, i) => {
    const element = elements[i];
    const { items = [], title } = datum;
    const definedItems = items.filter(defined);
    const useGroupName = groupName !== void 0 ? groupName : items.length <= 1 ? true : false;
    return definedItems.map((_a2) => {
      var { color: color2 = itemColorOf(element) || theme.color, name: name2 } = _a2, item = __rest81(_a2, ["color", "name"]);
      const groupName2 = groupNameOf(scale10, datum);
      const name1 = useGroupName ? groupName2 || name2 : name2 || groupName2;
      return Object.assign(Object.assign({}, item), { color: color2, name: name1 || title });
    });
  }).map(showUndefined);
  return Object.assign(Object.assign({}, T.length > 0 && { title: T.join(",") }), { items: unique2(newItems, (d2) => `(${key(d2.name)}, ${key(d2.value)}, ${key(d2.color)})`) });
}
function updateRuleY(root3, points, _a2) {
  var { plotWidth, plotHeight, mainWidth, mainHeight, startX, startY, transposed, polar: polar2, insetLeft, insetTop } = _a2, rest2 = __rest81(_a2, ["plotWidth", "plotHeight", "mainWidth", "mainHeight", "startX", "startY", "transposed", "polar", "insetLeft", "insetTop"]);
  const defaults5 = Object.assign({ lineWidth: 1, stroke: "#1b1e23", strokeOpacity: 0.5 }, rest2);
  const Y = points.map((p2) => p2[1]);
  const X = points.map((p2) => p2[0]);
  const y3 = mean(Y);
  const x3 = mean(X);
  const pointsOf = () => {
    if (polar2) {
      const r = Math.min(mainWidth, mainHeight) / 2;
      const cx = startX + insetLeft + mainWidth / 2;
      const cy = startY + insetTop + mainHeight / 2;
      const a4 = angle3(sub6([x3, y3], [cx, cy]));
      const x05 = cx + r * Math.cos(a4);
      const y05 = cy + r * Math.sin(a4);
      return [cx, x05, cy, y05];
    }
    if (transposed)
      return [startX, startX + plotWidth, y3 + startY, y3 + startY];
    return [x3 + startX, x3 + startX, startY, startY + plotHeight];
  };
  const [x12, x22, y12, y22] = pointsOf();
  const createLine = () => {
    const line4 = new Line({
      style: Object.assign({
        x1: x12,
        x2: x22,
        y1: y12,
        y2: y22
      }, defaults5)
    });
    root3.appendChild(line4);
    return line4;
  };
  if (X.length > 0) {
    const ruleY = root3.ruleY || createLine();
    ruleY.style.x1 = x12;
    ruleY.style.x2 = x22;
    ruleY.style.y1 = y12;
    ruleY.style.y2 = y22;
    root3.ruleY = ruleY;
  }
}
function hideRuleY(root3) {
  if (root3.ruleY) {
    root3.ruleY.remove();
    root3.ruleY = void 0;
  }
}
function updateMarker(root3, { data: data2, style, theme }) {
  if (root3.markers)
    root3.markers.forEach((d2) => d2.remove());
  const markers = data2.filter((d2) => {
    const [{ x: x3, y: y3 }] = d2;
    return defined(x3) && defined(y3);
  }).map((d2) => {
    const [{ color: color2, element }, point7] = d2;
    const fill2 = color2 || // encode value
    element.style.fill || element.style.stroke || theme.color;
    const shape23 = new Circle({
      style: Object.assign({ cx: point7[0], cy: point7[1], fill: fill2, r: 4, stroke: "#fff", strokeWidth: 2 }, style)
    });
    return shape23;
  });
  for (const marker of markers)
    root3.appendChild(marker);
  root3.markers = markers;
}
function hideMarker(root3) {
  if (root3.markers) {
    root3.markers.forEach((d2) => d2.remove());
    root3.markers = [];
  }
}
function interactionKeyof(markState, key) {
  return Array.from(markState.values()).some(
    // @ts-ignore
    (d2) => {
      var _a2;
      return (_a2 = d2.interaction) === null || _a2 === void 0 ? void 0 : _a2[key];
    }
  );
}
function maybeValue(specified, defaults5) {
  return specified === void 0 ? defaults5 : specified;
}
function isEmptyTooltipData(data2) {
  const { title, items } = data2;
  if (items.length === 0 && title === void 0)
    return true;
  return false;
}
function hasSeries(markState) {
  return Array.from(markState.values()).some(
    // @ts-ignore
    (d2) => {
      var _a2;
      return ((_a2 = d2.interaction) === null || _a2 === void 0 ? void 0 : _a2.seriesTooltip) && d2.tooltip;
    }
  );
}
function seriesTooltip(root3, _a2) {
  var { elements: elementsof, sort: sortFunction, filter: filterFunction, scale: scale10, coordinate: coordinate2, crosshairs, render: render3, groupName, emitter, wait = 50, leading = true, trailing = false, startX = 0, startY = 0, body = true, single = true, position, enterable, mount, bounding, theme, disableNative = false, marker = true, preserve = false, style: _style = {}, css = {} } = _a2, rest2 = __rest81(_a2, ["elements", "sort", "filter", "scale", "coordinate", "crosshairs", "render", "groupName", "emitter", "wait", "leading", "trailing", "startX", "startY", "body", "single", "position", "enterable", "mount", "bounding", "theme", "disableNative", "marker", "preserve", "style", "css"]);
  const elements = elementsof(root3);
  const transposed = isTranspose(coordinate2);
  const polar2 = isPolar(coordinate2);
  const style = deep_mix_default(_style, rest2);
  const { innerWidth: plotWidth, innerHeight: plotHeight, width: mainWidth, height: mainHeight, insetLeft, insetTop } = coordinate2.getOptions();
  const seriesElements = [];
  const itemElements = [];
  for (const element of elements) {
    const { __data__: data2 } = element;
    const { seriesX, title, items } = data2;
    if (seriesX)
      seriesElements.push(element);
    else if (title || items)
      itemElements.push(element);
  }
  const isBandScale = !!(transposed ? scale10.y : scale10.x).getBandWidth;
  const closest = isBandScale && itemElements.length > 0;
  seriesElements.sort((a4, b) => {
    const index3 = transposed ? 0 : 1;
    const minY = (d2) => d2.getBounds().min[index3];
    return transposed ? minY(b) - minY(a4) : minY(a4) - minY(b);
  });
  const extent2 = (d2) => {
    const index3 = transposed ? 1 : 0;
    const { min: min11, max: max11 } = d2.getLocalBounds();
    return sort([min11[index3], max11[index3]]);
  };
  itemElements.sort((a4, b) => {
    const [minA, maxA] = extent2(a4);
    const [minB, maxB] = extent2(b);
    const midA = (minA + maxA) / 2;
    const midB = (minB + maxB) / 2;
    return transposed ? midB - midA : midA - midB;
  });
  const elementSortedX = new Map(seriesElements.map((element) => {
    const { __data__: data2 } = element;
    const { seriesX } = data2;
    const seriesIndex = seriesX.map((_2, i) => i);
    const sortedIndex3 = sort(seriesIndex, (i) => seriesX[+i]);
    return [element, [sortedIndex3, seriesX]];
  }));
  const { x: scaleX } = scale10;
  const offsetX = (scaleX === null || scaleX === void 0 ? void 0 : scaleX.getBandWidth) ? scaleX.getBandWidth() / 2 : 0;
  const abstractX = (focus) => {
    const [normalizedX] = coordinate2.invert(focus);
    return normalizedX - offsetX;
  };
  const indexByFocus = (focus, I, X) => {
    const finalX = abstractX(focus);
    const DX = X.filter(defined);
    const [minX, maxX] = sort([DX[0], DX[DX.length - 1]]);
    const isOnlyOneElement = minX === maxX;
    if (!closest && (finalX < minX || finalX > maxX) && !isOnlyOneElement)
      return null;
    const search2 = bisector((i2) => X[+i2]).center;
    const i = search2(I, finalX);
    return I[i];
  };
  const elementsByFocus = (focus, elements2) => {
    const index3 = transposed ? 1 : 0;
    const x3 = focus[index3];
    const filtered = elements2.filter((element) => {
      const [min11, max11] = extent2(element);
      return x3 >= min11 && x3 <= max11;
    });
    if (!closest || filtered.length > 0)
      return filtered;
    const search2 = bisector((element) => {
      const [min11, max11] = extent2(element);
      return (min11 + max11) / 2;
    }).center;
    const i = search2(elements2, x3);
    return [elements2[i]].filter(defined);
  };
  const seriesData = (element, index3) => {
    const { __data__: data2 } = element;
    return Object.fromEntries(Object.entries(data2).filter(([key]) => key.startsWith("series") && key !== "series").map(([key, V]) => {
      const d2 = V[index3];
      return [lower_first_default(key.replace("series", "")), d2];
    }));
  };
  const update3 = throttle_default((event) => {
    const mouse = mousePosition(root3, event);
    if (!mouse)
      return;
    const bbox = bboxOf(root3);
    const x3 = bbox.min[0];
    const y3 = bbox.min[1];
    const focus = [mouse[0] - startX, mouse[1] - startY];
    if (!focus)
      return;
    const selectedItems = elementsByFocus(focus, itemElements);
    const selectedSeriesElements = [];
    const selectedSeriesData = [];
    for (const element of seriesElements) {
      const [sortedIndex3, X] = elementSortedX.get(element);
      const index3 = indexByFocus(focus, sortedIndex3, X);
      if (index3 !== null) {
        selectedSeriesElements.push(element);
        const d2 = seriesData(element, index3);
        const { x: x4, y: y4 } = d2;
        const p2 = coordinate2.map([(x4 || 0) + offsetX, y4 || 0]);
        selectedSeriesData.push([Object.assign(Object.assign({}, d2), { element }), p2]);
      }
    }
    const SX = Array.from(new Set(selectedSeriesData.map((d2) => d2[0].x)));
    const closestX = SX[minIndex(SX, (x4) => Math.abs(x4 - abstractX(focus)))];
    const filteredSeriesData = selectedSeriesData.filter((d2) => d2[0].x === closestX);
    const selectedData = [
      ...filteredSeriesData.map((d2) => d2[0]),
      ...selectedItems.map((d2) => d2.__data__)
    ];
    const selectedElements = [...selectedSeriesElements, ...selectedItems];
    const tooltipData = groupItems(selectedElements, scale10, groupName, selectedData, theme);
    if (sortFunction) {
      tooltipData.items.sort((a4, b) => sortFunction(a4) - sortFunction(b));
    }
    if (filterFunction) {
      tooltipData.items = tooltipData.items.filter(filterFunction);
    }
    if (selectedElements.length === 0 || isEmptyTooltipData(tooltipData)) {
      hide3(event);
      return;
    }
    if (body) {
      showTooltip({
        root: root3,
        data: tooltipData,
        x: mouse[0] + x3,
        y: mouse[1] + y3,
        render: render3,
        event,
        single,
        position,
        enterable,
        mount,
        bounding,
        css
      });
    }
    if (crosshairs) {
      const points = filteredSeriesData.map((d2) => d2[1]);
      const ruleStyle = subObject(style, "crosshairs");
      updateRuleY(root3, points, Object.assign(Object.assign({}, ruleStyle), {
        plotWidth,
        plotHeight,
        mainWidth,
        mainHeight,
        insetLeft,
        insetTop,
        startX,
        startY,
        transposed,
        polar: polar2
      }));
    }
    if (marker) {
      const markerStyles = subObject(style, "marker");
      updateMarker(root3, {
        data: filteredSeriesData,
        style: markerStyles,
        theme
      });
    }
    emitter.emit("tooltip:show", Object.assign(Object.assign({}, event), { nativeEvent: true, data: { data: { x: invert4(scale10.x, abstractX(focus), true) } } }));
  }, wait, { leading, trailing });
  const hide3 = (event) => {
    hideTooltip({ root: root3, single, emitter, event });
    if (crosshairs)
      hideRuleY(root3);
    if (marker)
      hideMarker(root3);
  };
  const destroy2 = () => {
    destroyTooltip({ root: root3, single });
    if (crosshairs)
      hideRuleY(root3);
    if (marker)
      hideMarker(root3);
  };
  const onTooltipShow = ({ nativeEvent, data: data2 }) => {
    if (nativeEvent)
      return;
    const { x: x3 } = data2.data;
    const { x: scaleX2 } = scale10;
    const x12 = scaleX2.map(x3);
    const [x22, y22] = coordinate2.map([x12, 0.5]);
    const { min: [minX, minY] } = root3.getRenderBounds();
    update3({ offsetX: x22 + minX, offsetY: y22 + minY });
  };
  const onTooltipHide = () => {
    hideTooltip({ root: root3, single, emitter, nativeEvent: false });
  };
  const onTooltipDisable = () => {
    removeEventListeners();
    destroy2();
  };
  const onTooltipEnable = () => {
    addEventListeners();
  };
  const addEventListeners = () => {
    if (!disableNative) {
      root3.addEventListener("pointerenter", update3);
      root3.addEventListener("pointermove", update3);
      root3.addEventListener("pointerleave", hide3);
    }
  };
  const removeEventListeners = () => {
    if (!disableNative) {
      root3.removeEventListener("pointerenter", update3);
      root3.removeEventListener("pointermove", update3);
      root3.removeEventListener("pointerleave", hide3);
    }
  };
  addEventListeners();
  emitter.on("tooltip:show", onTooltipShow);
  emitter.on("tooltip:hide", onTooltipHide);
  emitter.on("tooltip:disable", onTooltipDisable);
  emitter.on("tooltip:enable", onTooltipEnable);
  return () => {
    removeEventListeners();
    emitter.off("tooltip:show", onTooltipShow);
    emitter.off("tooltip:hide", onTooltipHide);
    emitter.off("tooltip:disable", onTooltipDisable);
    emitter.off("tooltip:enable", onTooltipEnable);
    if (preserve) {
      hideTooltip({ root: root3, single, emitter, nativeEvent: false });
    } else {
      destroy2();
    }
  };
}
function tooltip(root3, {
  elements: elementsof,
  scale: scale10,
  render: render3,
  groupName,
  sort: sortFunction,
  filter: filterFunction,
  emitter,
  wait = 50,
  leading = true,
  trailing = false,
  groupKey = (d2) => d2,
  // group elements by specified key
  single = true,
  position,
  enterable,
  datum,
  view,
  mount,
  bounding,
  theme,
  shared = false,
  body = true,
  disableNative = false,
  preserve = false,
  css = {}
}) {
  const elements = elementsof(root3);
  const elementSet = new Set(elements);
  const keyGroup = group(elements, groupKey);
  const pointermove = throttle_default((event) => {
    const { target: element } = event;
    if (!elementSet.has(element)) {
      hideTooltip({ root: root3, single, emitter, event });
      return;
    }
    const k2 = groupKey(element);
    const group3 = keyGroup.get(k2);
    const data2 = group3.length === 1 && !shared ? singleItem(group3[0]) : groupItems(group3, scale10, groupName, void 0, theme);
    if (sortFunction) {
      data2.items.sort((a4, b) => sortFunction(a4) - sortFunction(b));
    }
    if (filterFunction) {
      data2.items = data2.items.filter(filterFunction);
    }
    if (isEmptyTooltipData(data2)) {
      hideTooltip({ root: root3, single, emitter, event });
      return;
    }
    const { offsetX, offsetY } = event;
    if (body) {
      showTooltip({
        root: root3,
        data: data2,
        x: offsetX,
        y: offsetY,
        render: render3,
        event,
        single,
        position,
        enterable,
        mount,
        bounding,
        css
      });
    }
    emitter.emit("tooltip:show", Object.assign(Object.assign({}, event), { nativeEvent: true, data: {
      data: dataOf(element, view)
    } }));
  }, wait, { leading, trailing });
  const pointerleave = (event) => {
    hideTooltip({ root: root3, single, emitter, event });
  };
  const addEventListeners = () => {
    if (!disableNative) {
      root3.addEventListener("pointermove", pointermove);
      root3.addEventListener("pointerleave", pointerleave);
    }
  };
  const removeEventListeners = () => {
    if (!disableNative) {
      root3.removeEventListener("pointermove", pointermove);
      root3.removeEventListener("pointerleave", pointerleave);
    }
  };
  const onTooltipShow = ({ nativeEvent, data: data2 }) => {
    if (nativeEvent)
      return;
    const element = selectElementByData(elements, data2.data, datum);
    if (!element)
      return;
    const bbox = element.getBBox();
    const { x: x3, y: y3, width, height } = bbox;
    pointermove({
      target: element,
      offsetX: x3 + width / 2,
      offsetY: y3 + height / 2
    });
  };
  const onTooltipHide = ({ nativeEvent } = {}) => {
    if (nativeEvent)
      return;
    hideTooltip({ root: root3, single, emitter, nativeEvent: false });
  };
  const onTooltipDisable = () => {
    removeEventListeners();
    destroyTooltip({ root: root3, single });
  };
  const onTooltipEnable = () => {
    addEventListeners();
  };
  emitter.on("tooltip:show", onTooltipShow);
  emitter.on("tooltip:hide", onTooltipHide);
  emitter.on("tooltip:enable", onTooltipEnable);
  emitter.on("tooltip:disable", onTooltipDisable);
  addEventListeners();
  return () => {
    removeEventListeners();
    emitter.off("tooltip:show", onTooltipShow);
    emitter.off("tooltip:hide", onTooltipHide);
    if (preserve) {
      hideTooltip({ root: root3, single, emitter, nativeEvent: false });
    } else {
      destroyTooltip({ root: root3, single });
    }
  };
}
function Tooltip2(options) {
  const { shared, crosshairs, series, name: name2, item = () => ({}), facet = false } = options, rest2 = __rest81(options, ["shared", "crosshairs", "series", "name", "item", "facet"]);
  return (target, viewInstances, emitter) => {
    const { container, view } = target;
    const { scale: scale10, markState, coordinate: coordinate2, theme } = view;
    const defaultSeries = interactionKeyof(markState, "seriesTooltip");
    const defaultShowCrosshairs = interactionKeyof(markState, "crosshairs");
    const plotArea = selectPlotArea(container);
    const isSeries = maybeValue(series, defaultSeries);
    if (isSeries && hasSeries(markState) && !facet) {
      return seriesTooltip(plotArea, Object.assign(Object.assign({}, rest2), {
        theme,
        elements: selectG2Elements,
        scale: scale10,
        coordinate: coordinate2,
        crosshairs: maybeValue(crosshairs, defaultShowCrosshairs),
        item,
        emitter
      }));
    }
    if (isSeries && facet) {
      const facetInstances = viewInstances.filter((d2) => d2 !== target && d2.options.parentKey === target.options.key);
      const elements = selectFacetG2Elements(target, viewInstances);
      const scale11 = facetInstances[0].view.scale;
      const bbox = plotArea.getBounds();
      const startX = bbox.min[0];
      const startY = bbox.min[1];
      Object.assign(scale11, { facet: true });
      return seriesTooltip(plotArea.parentNode.parentNode, Object.assign(Object.assign({}, rest2), {
        theme,
        elements: () => elements,
        scale: scale11,
        coordinate: coordinate2,
        crosshairs: maybeValue(crosshairs, defaultShowCrosshairs),
        item,
        startX,
        startY,
        emitter
      }));
    }
    return tooltip(plotArea, Object.assign(Object.assign({}, rest2), {
      datum: createDatumof(view),
      elements: selectG2Elements,
      scale: scale10,
      coordinate: coordinate2,
      groupKey: shared ? createXKey(view) : void 0,
      item,
      emitter,
      view,
      theme,
      shared
    }));
  };
}
Tooltip2.props = {
  reapplyWhenUpdate: true
};

// node_modules/@antv/g2/esm/interaction/legendFilter.js
var __awaiter11 = function(thisArg, _arguments, P, generator) {
  function adopt(value2) {
    return value2 instanceof P ? value2 : new P(function(resolve) {
      resolve(value2);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject2) {
    function fulfilled(value2) {
      try {
        step2(generator.next(value2));
      } catch (e) {
        reject2(e);
      }
    }
    function rejected(value2) {
      try {
        step2(generator["throw"](value2));
      } catch (e) {
        reject2(e);
      }
    }
    function step2(result2) {
      result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
    }
    step2((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var CATEGORY_LEGEND_CLASS_NAME = "legend-category";
var CONTINUOUS_LEGEND_CLASS_NAME = "legend-continuous";
var LEGEND_ITEMS_CLASS_NAME = "items-item";
var LEGEND_MAKER_CLASS_NAME = "legend-category-item-marker";
var LEGEND_LABEL_CLASS_NAME = "legend-category-item-label";
function markerOf(item) {
  return item.getElementsByClassName(LEGEND_MAKER_CLASS_NAME)[0];
}
function labelOf(item) {
  return item.getElementsByClassName(LEGEND_LABEL_CLASS_NAME)[0];
}
function itemsOf(root3) {
  return root3.getElementsByClassName(LEGEND_ITEMS_CLASS_NAME);
}
function legendsOf(root3) {
  return root3.getElementsByClassName(CATEGORY_LEGEND_CLASS_NAME);
}
function legendsContinuousOf(root3) {
  return root3.getElementsByClassName(CONTINUOUS_LEGEND_CLASS_NAME);
}
function dataOf2(root3) {
  let parent2 = root3.parentNode;
  while (parent2 && !parent2.__data__) {
    parent2 = parent2.parentNode;
  }
  return parent2.__data__;
}
function legendFilterOrdinal(root3, {
  legends,
  // given the root of chart returns legends to be manipulated
  marker: markerOf2,
  // given the legend returns the marker
  label: labelOf2,
  // given the legend returns the label
  datum,
  // given the legend returns the value
  filter: filter4,
  // invoke when dispatch filter event,
  emitter,
  channel,
  state = {}
  // state options
}) {
  const itemClick = /* @__PURE__ */ new Map();
  const itemPointerenter = /* @__PURE__ */ new Map();
  const itemPointerout = /* @__PURE__ */ new Map();
  const { unselected = {
    markerStroke: "#aaa",
    markerFill: "#aaa",
    labelFill: "#aaa"
  } } = state;
  const markerStyle = { unselected: subObject(unselected, "marker") };
  const labelStyle = { unselected: subObject(unselected, "label") };
  const { setState: setM, removeState: removeM } = useState(markerStyle, void 0);
  const { setState: setL, removeState: removeL } = useState(labelStyle, void 0);
  const items = Array.from(legends(root3));
  let selectedValues = items.map(datum);
  const updateLegendState = () => {
    for (const item of items) {
      const value2 = datum(item);
      const marker = markerOf2(item);
      const label = labelOf2(item);
      if (!selectedValues.includes(value2)) {
        setM(marker, "unselected");
        setL(label, "unselected");
      } else {
        removeM(marker, "unselected");
        removeL(label, "unselected");
      }
    }
  };
  for (const item of items) {
    const pointerenter = () => {
      setCursor(root3, "pointer");
    };
    const pointerout = () => {
      restoreCursor(root3);
    };
    const click = (event) => __awaiter11(this, void 0, void 0, function* () {
      const value2 = datum(item);
      const index3 = selectedValues.indexOf(value2);
      if (index3 === -1)
        selectedValues.push(value2);
      else
        selectedValues.splice(index3, 1);
      if (selectedValues.length === 0)
        selectedValues.push(...items.map(datum));
      yield filter4(selectedValues);
      updateLegendState();
      const { nativeEvent = true } = event;
      if (!nativeEvent)
        return;
      if (selectedValues.length === items.length) {
        emitter.emit("legend:reset", { nativeEvent });
      } else {
        emitter.emit("legend:filter", Object.assign(Object.assign({}, event), { nativeEvent, data: {
          channel,
          values: selectedValues
        } }));
      }
    });
    item.addEventListener("click", click);
    item.addEventListener("pointerenter", pointerenter);
    item.addEventListener("pointerout", pointerout);
    itemClick.set(item, click);
    itemPointerenter.set(item, pointerenter);
    itemPointerout.set(item, pointerout);
  }
  const onFilter = (event) => __awaiter11(this, void 0, void 0, function* () {
    const { nativeEvent } = event;
    if (nativeEvent)
      return;
    const { data: data2 } = event;
    const { channel: specifiedChannel, values: values4 } = data2;
    if (specifiedChannel !== channel)
      return;
    selectedValues = values4;
    yield filter4(selectedValues);
    updateLegendState();
  });
  const onEnd = (event) => __awaiter11(this, void 0, void 0, function* () {
    const { nativeEvent } = event;
    if (nativeEvent)
      return;
    selectedValues = items.map(datum);
    yield filter4(selectedValues);
    updateLegendState();
  });
  emitter.on("legend:filter", onFilter);
  emitter.on("legend:reset", onEnd);
  return () => {
    for (const item of items) {
      item.removeEventListener("click", itemClick.get(item));
      item.removeEventListener("pointerenter", itemPointerenter.get(item));
      item.removeEventListener("pointerout", itemPointerout.get(item));
      emitter.off("legend:filter", onFilter);
      emitter.off("legend:reset", onEnd);
    }
  };
}
function legendFilterContinuous(_2, { legend, filter: filter4, emitter, channel }) {
  const onValueChange = ({ detail: { value: value2 } }) => {
    filter4(value2);
    emitter.emit({
      nativeEvent: true,
      data: {
        channel,
        values: value2
      }
    });
  };
  legend.addEventListener("valuechange", onValueChange);
  return () => {
    legend.removeEventListener("valuechange", onValueChange);
  };
}
function filterView(context, {
  legend,
  // Legend instance.
  channel,
  // Filter Channel.
  value: value2,
  // Filtered Values.
  ordinal,
  // Data type of the legend.
  channels,
  // Channels for this legend.
  allChannels,
  // Channels for all legends.
  facet = false
  // For facet.
}) {
  return __awaiter11(this, void 0, void 0, function* () {
    const { view, update: update3, setState } = context;
    setState(legend, (viewOptions) => {
      const { marks } = viewOptions;
      const newMarks = marks.map((mark2) => {
        if (mark2.type === "legends")
          return mark2;
        const { transform: transform3 = [] } = mark2;
        const index3 = transform3.findIndex(({ type }) => type.startsWith("group") || type.startsWith("bin"));
        const newTransform = [...transform3];
        newTransform.splice(index3 + 1, 0, {
          type: "filter",
          [channel]: { value: value2, ordinal }
        });
        const newScale = Object.fromEntries(channels.map((channel2) => [
          channel2,
          { domain: view.scale[channel2].getOptions().domain }
        ]));
        return deep_mix_default({}, mark2, Object.assign(Object.assign({ transform: newTransform, scale: newScale }, !ordinal && { animate: false }), { legend: facet ? false : Object.fromEntries(allChannels.map((d2) => [d2, { preserve: true }])) }));
      });
      return Object.assign(Object.assign({}, viewOptions), { marks: newMarks });
    });
    yield update3();
  });
}
function filterFacets(facets, options) {
  for (const facet of facets) {
    filterView(facet, Object.assign(Object.assign({}, options), { facet: true }));
  }
}
function LegendFilter() {
  return (context, contexts, emitter) => {
    const { container } = context;
    const facets = contexts.filter((d2) => d2 !== context);
    const isFacet = facets.length > 0;
    const channelsOf = (legend) => {
      return dataOf2(legend).scales.map((d2) => d2.name);
    };
    const legends = [
      ...legendsOf(container),
      ...legendsContinuousOf(container)
    ];
    const allChannels = legends.flatMap(channelsOf);
    const filter4 = isFacet ? throttle_default(filterFacets, 50, { trailing: true }) : throttle_default(filterView, 50, { trailing: true });
    const removes = legends.map((legend) => {
      const { name: channel, domain } = dataOf2(legend).scales[0];
      const channels = channelsOf(legend);
      const common = {
        legend,
        channel,
        channels,
        allChannels
      };
      if (legend.className === CATEGORY_LEGEND_CLASS_NAME) {
        return legendFilterOrdinal(container, {
          legends: itemsOf,
          marker: markerOf,
          label: labelOf,
          datum: (d2) => {
            const { __data__: datum } = d2;
            const { index: index3 } = datum;
            return domain[index3];
          },
          filter: (value2) => {
            const options = Object.assign(Object.assign({}, common), { value: value2, ordinal: true });
            if (isFacet)
              filter4(facets, options);
            else
              filter4(context, options);
          },
          state: legend.attributes.state,
          channel,
          emitter
        });
      } else {
        return legendFilterContinuous(container, {
          legend,
          filter: (value2) => {
            const options = Object.assign(Object.assign({}, common), { value: value2, ordinal: false });
            if (isFacet)
              filter4(facets, options);
            else
              filter4(context, options);
          },
          emitter,
          channel
        });
      }
    });
    return () => {
      removes.forEach((remove2) => remove2());
    };
  };
}

// node_modules/@antv/g2/esm/interaction/legendHighlight.js
function LegendHighlight() {
  return (context, _2, emitter) => {
    const { container, view, options } = context;
    const legends = legendsOf(container);
    const elements = selectG2Elements(container);
    const channelOf = (legend) => {
      return dataOf2(legend).scales[0].name;
    };
    const scaleOf2 = (channel) => {
      const { scale: { [channel]: scale10 } } = view;
      return scale10;
    };
    const markState = mergeState(options, ["active", "inactive"]);
    const valueof2 = createValueof(elements, createDatumof(view));
    const destroys = [];
    for (const legend of legends) {
      const datumOf = (item) => {
        const { data: data2 } = legend.attributes;
        const { __data__: datum } = item;
        const { index: index3 } = datum;
        return data2[index3].label;
      };
      const channel = channelOf(legend);
      const items = itemsOf(legend);
      const scale10 = scaleOf2(channel);
      const elementGroup = group(elements, (d2) => scale10.invert(d2.__data__[channel]));
      const { state: legendState = {} } = legend.attributes;
      const { inactive = {} } = legendState;
      const { setState, removeState } = useState(markState, valueof2);
      const markerStyle = { inactive: subObject(inactive, "marker") };
      const labelStyle = { inactive: subObject(inactive, "label") };
      const { setState: setM, removeState: removeM } = useState(markerStyle);
      const { setState: setL, removeState: removeL } = useState(labelStyle);
      const updateLegendState = (highlight) => {
        for (const item of items) {
          const marker = markerOf(item);
          const label = labelOf(item);
          if (item === highlight || highlight === null) {
            removeM(marker, "inactive");
            removeL(label, "inactive");
          } else {
            setM(marker, "inactive");
            setL(label, "inactive");
          }
        }
      };
      const highlightItem = (event, item) => {
        const value2 = datumOf(item);
        const elementSet = new Set(elementGroup.get(value2));
        for (const e of elements) {
          if (elementSet.has(e))
            setState(e, "active");
          else
            setState(e, "inactive");
        }
        updateLegendState(item);
        const { nativeEvent = true } = event;
        if (!nativeEvent)
          return;
        emitter.emit("legend:highlight", Object.assign(Object.assign({}, event), { nativeEvent, data: { channel, value: value2 } }));
      };
      const itemPointerover = /* @__PURE__ */ new Map();
      for (const item of items) {
        const pointerover = (event) => {
          highlightItem(event, item);
        };
        item.addEventListener("pointerover", pointerover);
        itemPointerover.set(item, pointerover);
      }
      const pointerleave = (event) => {
        for (const e of elements)
          removeState(e, "inactive", "active");
        updateLegendState(null);
        const { nativeEvent = true } = event;
        if (!nativeEvent)
          return;
        emitter.emit("legend:unhighlight", { nativeEvent });
      };
      const onHighlight = (event) => {
        const { nativeEvent, data: data2 } = event;
        if (nativeEvent)
          return;
        const { channel: specifiedChannel, value: value2 } = data2;
        if (specifiedChannel !== channel)
          return;
        const item = items.find((d2) => datumOf(d2) === value2);
        if (!item)
          return;
        highlightItem({ nativeEvent: false }, item);
      };
      const onUnHighlight = (event) => {
        const { nativeEvent } = event;
        if (nativeEvent)
          return;
        pointerleave({ nativeEvent: false });
      };
      legend.addEventListener("pointerleave", pointerleave);
      emitter.on("legend:highlight", onHighlight);
      emitter.on("legend:unhighlight", onUnHighlight);
      const destroy2 = () => {
        legend.removeEventListener(pointerleave);
        emitter.off("legend:highlight", onHighlight);
        emitter.off("legend:unhighlight", onUnHighlight);
        for (const [item, pointerover] of itemPointerover) {
          item.removeEventListener(pointerover);
        }
      };
      destroys.push(destroy2);
    }
    return () => destroys.forEach((d2) => d2());
  };
}

// node_modules/@antv/g2/esm/interaction/brushHighlight.js
var __rest82 = function(s2, e) {
  var t = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
      t[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t[p2[i]] = s2[p2[i]];
    }
  return t;
};
function intersect3(bbox1, bbox2) {
  const [minX1, minY1, maxX1, maxY1] = bbox1;
  const [minX2, minY2, maxX2, maxY2] = bbox2;
  return !(minX2 > maxX1 || maxX2 < minX1 || minY2 > maxY1 || maxY2 < minY1);
}
function normalizeBounds(x3, y3, x12, y12, extent2) {
  const [minX, minY, maxX, maxY2] = extent2;
  return [
    Math.max(minX, Math.min(x3, x12)),
    Math.max(minY, Math.min(y3, y12)),
    Math.min(maxX, Math.max(x3, x12)),
    Math.min(maxY2, Math.max(y3, y12))
  ];
}
function bboxOf2(root3) {
  const { width, height } = root3.getBBox();
  return [0, 0, width, height];
}
function applyStyle3(selection, style) {
  for (const [key, value2] of Object.entries(style)) {
    selection.style(key, value2);
  }
}
var ResizableMask = createElement((g) => {
  const _a2 = g.attributes, { x: x3, y: y3, width, height, class: className2, renders = {}, handleSize: size5 = 10, document: document2 } = _a2, style = __rest82(_a2, ["x", "y", "width", "height", "class", "renders", "handleSize", "document"]);
  if (!document2 || width === void 0 || height === void 0 || x3 === void 0 || y3 === void 0)
    return;
  const half = size5 / 2;
  const renderRect = (g2, options, document3) => {
    if (!g2.handle) {
      g2.handle = document3.createElement("rect");
      g2.append(g2.handle);
    }
    const { handle } = g2;
    handle.attr(options);
    return handle;
  };
  const _b = subObject(omitPrefixObject(style, "handleNW", "handleNE"), "handleN"), { render: handleNRender = renderRect } = _b, handleNStyle = __rest82(_b, ["render"]);
  const _c = subObject(style, "handleE"), { render: handleERender = renderRect } = _c, handleEStyle = __rest82(_c, ["render"]);
  const _d = subObject(omitPrefixObject(style, "handleSE", "handleSW"), "handleS"), { render: handleSRender = renderRect } = _d, handleSStyle = __rest82(_d, ["render"]);
  const _e = subObject(style, "handleW"), { render: handleWRender = renderRect } = _e, handleWStyle = __rest82(_e, ["render"]);
  const _f = subObject(style, "handleNW"), { render: handleNWRender = renderRect } = _f, handleNWStyle = __rest82(_f, ["render"]);
  const _g = subObject(style, "handleNE"), { render: handleNERender = renderRect } = _g, handleNEStyle = __rest82(_g, ["render"]);
  const _h = subObject(style, "handleSE"), { render: handleSERender = renderRect } = _h, handleSEStyle = __rest82(_h, ["render"]);
  const _j = subObject(style, "handleSW"), { render: handleSWRender = renderRect } = _j, handleSWStyle = __rest82(_j, ["render"]);
  const renderHandle = (g2, renderNode) => {
    const { id: id3 } = g2;
    const _a3 = g2.attributes, { x: x4, y: y4 } = _a3, style2 = __rest82(_a3, ["x", "y"]);
    const handle = renderNode(g2, Object.assign({ x: 0, y: 0 }, style2), document2);
    handle.id = id3;
    handle.style.draggable = true;
  };
  const appendHandle = (handleRender) => {
    return () => {
      const Node5 = createElement((g2) => renderHandle(g2, handleRender));
      return new Node5({});
    };
  };
  const container = select(g).attr("className", className2).style("x", x3).style("y", y3).style("draggable", true);
  container.maybeAppend("selection", "rect").style("draggable", true).style("fill", "transparent").call(applyStyle3, Object.assign({ width, height }, omitPrefixObject(style, "handle")));
  container.maybeAppend("handle-n", appendHandle(handleNRender)).style("x", half).style("y", -half).style("width", width - size5).style("height", size5).style("fill", "transparent").call(applyStyle3, handleNStyle);
  container.maybeAppend("handle-e", appendHandle(handleERender)).style("x", width - half).style("y", half).style("width", size5).style("height", height - size5).style("fill", "transparent").call(applyStyle3, handleEStyle);
  container.maybeAppend("handle-s", appendHandle(handleSRender)).style("x", half).style("y", height - half).style("width", width - size5).style("height", size5).style("fill", "transparent").call(applyStyle3, handleSStyle);
  container.maybeAppend("handle-w", appendHandle(handleWRender)).style("x", -half).style("y", half).style("width", size5).style("height", height - size5).style("fill", "transparent").call(applyStyle3, handleWStyle);
  container.maybeAppend("handle-nw", appendHandle(handleNWRender)).style("x", -half).style("y", -half).style("width", size5).style("height", size5).style("fill", "transparent").call(applyStyle3, handleNWStyle);
  container.maybeAppend("handle-ne", appendHandle(handleNERender)).style("x", width - half).style("y", -half).style("width", size5).style("height", size5).style("fill", "transparent").call(applyStyle3, handleNEStyle);
  container.maybeAppend("handle-se", appendHandle(handleSERender)).style("x", width - half).style("y", height - half).style("width", size5).style("height", size5).style("fill", "transparent").call(applyStyle3, handleSEStyle);
  container.maybeAppend("handle-sw", appendHandle(handleSWRender)).style("x", -half).style("y", height - half).style("width", size5).style("height", size5).style("fill", "transparent").call(applyStyle3, handleSWStyle);
});
function brush(root3, _a2) {
  var { brushed = () => {
  }, brushended = () => {
  }, brushcreated = () => {
  }, brushstarted = () => {
  }, brushupdated = () => {
  }, extent: extent2 = bboxOf2(root3), brushRegion = (x3, y3, x12, y12, extent3) => [x3, y3, x12, y12], reverse: reverse3 = false, fill: fill2 = "#777", fillOpacity = "0.3", stroke: stroke2 = "#fff", selectedHandles = [
    "handle-n",
    "handle-e",
    "handle-s",
    "handle-w",
    "handle-nw",
    "handle-ne",
    "handle-se",
    "handle-sw"
  ] } = _a2, style = __rest82(_a2, ["brushed", "brushended", "brushcreated", "brushstarted", "brushupdated", "extent", "brushRegion", "reverse", "fill", "fillOpacity", "stroke", "selectedHandles"]);
  let start = null;
  let end = null;
  let moveStart = null;
  let mask = null;
  let background = null;
  let creating = false;
  const [originX, originY, width, height] = extent2;
  setCursor(root3, "crosshair");
  root3.style.draggable = true;
  const initMask = (x3, y3, event) => {
    brushstarted(event);
    if (mask)
      mask.remove();
    if (background)
      background.remove();
    start = [x3, y3];
    if (reverse3)
      return initReverseMask();
    initNormalMask();
  };
  const initReverseMask = () => {
    background = new Path2({
      style: Object.assign(Object.assign({}, style), {
        fill: fill2,
        fillOpacity,
        stroke: stroke2,
        pointerEvents: "none"
      })
    });
    mask = new ResizableMask({
      // @ts-ignore
      style: {
        x: 0,
        y: 0,
        width: 0,
        height: 0,
        draggable: true,
        document: root3.ownerDocument
      },
      className: "mask"
    });
    root3.appendChild(background);
    root3.appendChild(mask);
  };
  const initNormalMask = () => {
    mask = new ResizableMask({
      // @ts-ignore
      style: Object.assign(Object.assign({ document: root3.ownerDocument, x: 0, y: 0 }, style), {
        fill: fill2,
        fillOpacity,
        stroke: stroke2,
        draggable: true
      }),
      className: "mask"
    });
    root3.appendChild(mask);
  };
  const removeMask = (emit = true) => {
    if (mask)
      mask.remove();
    if (background)
      background.remove();
    start = null;
    end = null;
    moveStart = null;
    creating = false;
    mask = null;
    background = null;
    brushended(emit);
  };
  const updateMask = (start2, end2, emit = true) => {
    const [x3, y3, x12, y12] = normalizeBounds(start2[0], start2[1], end2[0], end2[1], extent2);
    const [fx, fy, fx1, fy1] = brushRegion(x3, y3, x12, y12, extent2);
    if (reverse3)
      updateReverseMask(fx, fy, fx1, fy1);
    else
      updateNormalMask(fx, fy, fx1, fy1);
    brushed(fx, fy, fx1, fy1, emit);
    return [fx, fy, fx1, fy1];
  };
  const updateNormalMask = (x3, y3, x12, y12) => {
    mask.style.x = x3;
    mask.style.y = y3;
    mask.style.width = x12 - x3;
    mask.style.height = y12 - y3;
  };
  const updateReverseMask = (x3, y3, x12, y12) => {
    background.style.d = `
      M${originX},${originY}L${width},${originY}L${width},${height}L${originX},${height}Z
      M${x3},${y3}L${x3},${y12}L${x12},${y12}L${x12},${y3}Z
    `;
    mask.style.x = x3;
    mask.style.y = y3;
    mask.style.width = x12 - x3;
    mask.style.height = y12 - y3;
  };
  const moveMask = (current) => {
    const clip = (dt, start2, end2, min11, max11) => {
      if (dt + start2 < min11)
        return min11 - start2;
      if (dt + end2 > max11)
        return max11 - end2;
      return dt;
    };
    const dx = current[0] - moveStart[0];
    const dy = current[1] - moveStart[1];
    const dx1 = clip(dx, start[0], end[0], originX, width);
    const dy1 = clip(dy, start[1], end[1], originY, height);
    const currentStart = [start[0] + dx1, start[1] + dy1];
    const currentEnd = [end[0] + dx1, end[1] + dy1];
    updateMask(currentStart, currentEnd);
  };
  const handles = {
    "handle-n": { vector: [0, 1, 0, 0], cursor: "ns-resize" },
    "handle-e": { vector: [0, 0, 1, 0], cursor: "ew-resize" },
    "handle-s": { vector: [0, 0, 0, 1], cursor: "ns-resize" },
    "handle-w": { vector: [1, 0, 0, 0], cursor: "ew-resize" },
    "handle-nw": { vector: [1, 1, 0, 0], cursor: "nwse-resize" },
    "handle-ne": { vector: [0, 1, 1, 0], cursor: "nesw-resize" },
    "handle-se": { vector: [0, 0, 1, 1], cursor: "nwse-resize" },
    "handle-sw": { vector: [1, 0, 0, 1], cursor: "nesw-resize" }
  };
  const isMask = (target) => {
    return isSelection(target) || isHandle(target);
  };
  const isHandle = (target) => {
    const { id: id3 } = target;
    if (selectedHandles.indexOf(id3) === -1)
      return false;
    return new Set(Object.keys(handles)).has(id3);
  };
  const isSelection = (target) => {
    return target === mask.getElementById("selection");
  };
  const dragstart = (event) => {
    const { target } = event;
    const [offsetX, offsetY] = brushMousePosition(root3, event);
    if (!mask || !isMask(target)) {
      initMask(offsetX, offsetY, event);
      creating = true;
      return;
    }
    if (isMask(target)) {
      moveStart = [offsetX, offsetY];
    }
  };
  const drag = (event) => {
    const { target } = event;
    const mouse = brushMousePosition(root3, event);
    if (!start)
      return;
    if (!moveStart)
      return updateMask(start, mouse);
    if (isSelection(target))
      return moveMask(mouse);
    const [dx, dy] = [mouse[0] - moveStart[0], mouse[1] - moveStart[1]];
    const { id: id3 } = target;
    if (handles[id3]) {
      const [sx, sy, ex, ey] = handles[id3].vector;
      return updateMask([start[0] + dx * sx, start[1] + dy * sy], [end[0] + dx * ex, end[1] + dy * ey]);
    }
  };
  const dragend = (event) => {
    if (moveStart) {
      moveStart = null;
      const { x: x3, y: y3, width: width2, height: height2 } = mask.style;
      start = [x3, y3];
      end = [x3 + width2, y3 + height2];
      brushupdated(x3, y3, x3 + width2, y3 + height2, event);
      return;
    }
    end = brushMousePosition(root3, event);
    const [fx, fy, fx1, fy1] = updateMask(start, end);
    creating = false;
    brushcreated(fx, fy, fx1, fy1, event);
  };
  const click = (event) => {
    const { target } = event;
    if (mask && !isMask(target))
      removeMask();
  };
  const pointermove = (event) => {
    const { target } = event;
    if (!mask || !isMask(target) || creating)
      setCursor(root3, "crosshair");
    else if (isSelection(target))
      setCursor(root3, "move");
    else if (isHandle(target))
      setCursor(root3, handles[target.id].cursor);
  };
  const pointerleave = () => {
    setCursor(root3, "default");
  };
  root3.addEventListener("dragstart", dragstart);
  root3.addEventListener("drag", drag);
  root3.addEventListener("dragend", dragend);
  root3.addEventListener("click", click);
  root3.addEventListener("pointermove", pointermove);
  root3.addEventListener("pointerleave", pointerleave);
  return {
    mask,
    move(x3, y3, x12, y12, emit = true) {
      if (!mask)
        initMask(x3, y3, {});
      start = [x3, y3];
      end = [x12, y12];
      updateMask([x3, y3], [x12, y12], emit);
    },
    remove(emit = true) {
      if (mask)
        removeMask(emit);
    },
    destroy() {
      if (mask)
        removeMask(false);
      setCursor(root3, "default");
      root3.removeEventListener("dragstart", dragstart);
      root3.removeEventListener("drag", drag);
      root3.removeEventListener("dragend", dragend);
      root3.removeEventListener("click", click);
      root3.removeEventListener("pointermove", pointermove);
      root3.removeEventListener("pointerleave", pointerleave);
    }
  };
}
function selectSiblingViews(target, viewInstances, brushKey) {
  return viewInstances.filter((d2) => {
    if (d2 === target)
      return false;
    const { interaction = {} } = d2.options;
    return Object.values(interaction).find((d3) => d3.brushKey === brushKey);
  });
}
function selectSiblingContainers(target, viewInstances, brushKey) {
  return selectSiblingViews(target, viewInstances, brushKey).map((d2) => selectPlotArea(d2.container));
}
function selectSiblingOptions(target, viewInstances, brushKey) {
  return selectSiblingViews(target, viewInstances, brushKey).map((d2) => d2.options);
}
function brushHighlight(root3, _a2) {
  var { elements: elementof, selectedHandles, siblings: siblingsof = (root4) => [], datum, brushRegion, extent: optionalExtent, reverse: reverse3, scale: scale10, coordinate: coordinate2, series = false, key = (d2) => d2, bboxOf: bboxOf3 = (root4) => {
    const { x: x3, y: y3, width, height } = root4.style;
    return { x: x3, y: y3, width, height };
  }, state = {}, emitter } = _a2, rest2 = __rest82(_a2, ["elements", "selectedHandles", "siblings", "datum", "brushRegion", "extent", "reverse", "scale", "coordinate", "series", "key", "bboxOf", "state", "emitter"]);
  const elements = elementof(root3);
  const siblings = siblingsof(root3);
  const siblingElements = siblings.flatMap(elementof);
  const valueof2 = createValueof(elements, datum);
  const brushStyle = subObject(rest2, "mask");
  const { setState, removeState } = useState(state, valueof2);
  const clonedElement = /* @__PURE__ */ new Map();
  const { width: rootWidth, height: rootHeight, x: ordinalX = 0, y: ordinalY = 0 } = bboxOf3(root3);
  const extent2 = optionalExtent ? optionalExtent : [0, 0, rootWidth, rootHeight];
  const brushended = () => {
    for (const element of [...elements, ...siblingElements]) {
      removeState(element, "active", "inactive");
    }
  };
  const brushed = (x3, y3, x12, y12) => {
    var _a3;
    for (const sibling of siblings)
      (_a3 = sibling.brush) === null || _a3 === void 0 ? void 0 : _a3.remove();
    const keys3 = /* @__PURE__ */ new Set();
    for (const element of elements) {
      const { min: min11, max: max11 } = element.getLocalBounds();
      const [ex, ey] = min11;
      const [ex1, ey1] = max11;
      if (!intersect3([ex, ey, ex1, ey1], [x3, y3, x12, y12])) {
        setState(element, "inactive");
      } else {
        setState(element, "active");
        keys3.add(key(element));
      }
    }
    for (const element of siblingElements) {
      if (keys3.has(key(element)))
        setState(element, "active");
      else
        setState(element, "inactive");
    }
  };
  const seriesBrushend = () => {
    for (const element of elements)
      removeState(element, "inactive");
    for (const cloned of clonedElement.values())
      cloned.remove();
    clonedElement.clear();
  };
  const seriesBrushed = (x3, y3, x12, y12) => {
    const clone9 = (element) => {
      const cloned = element.cloneNode();
      cloned.__data__ = element.__data__;
      element.parentNode.appendChild(cloned);
      clonedElement.set(element, cloned);
      return cloned;
    };
    for (const element of elements) {
      const cloned = clonedElement.get(element) || clone9(element);
      cloned.style.clipPath = new Rect({
        style: {
          x: x3 + ordinalX,
          y: y3 + ordinalY,
          width: x12 - x3,
          height: y12 - y3
        }
      });
      setState(element, "inactive");
      setState(cloned, "active");
    }
  };
  const brushHandler = brush(root3, Object.assign(Object.assign({}, brushStyle), {
    extent: extent2,
    brushRegion,
    reverse: reverse3,
    selectedHandles,
    brushended: (emit) => {
      const handler = series ? seriesBrushend : brushended;
      if (emit) {
        emitter.emit("brush:remove", { nativeEvent: true });
      }
      handler();
    },
    brushed: (x3, y3, x12, y12, emit) => {
      const selection = selectionOf(x3, y3, x12, y12, scale10, coordinate2);
      if (emit) {
        emitter.emit("brush:highlight", {
          nativeEvent: true,
          data: { selection }
        });
      }
      const handler = series ? seriesBrushed : brushed;
      handler(x3, y3, x12, y12);
    },
    brushcreated: (x3, y3, x12, y12, event) => {
      const selection = selectionOf(x3, y3, x12, y12, scale10, coordinate2);
      emitter.emit("brush:end", Object.assign(Object.assign({}, event), { nativeEvent: true, data: { selection } }));
    },
    brushupdated: (x3, y3, x12, y12, event) => {
      const selection = selectionOf(x3, y3, x12, y12, scale10, coordinate2);
      emitter.emit("brush:end", Object.assign(Object.assign({}, event), { nativeEvent: true, data: { selection } }));
    },
    brushstarted: (e) => {
      emitter.emit("brush:start", e);
    }
  }));
  const onHighlight = ({ nativeEvent, data: data2 }) => {
    if (nativeEvent)
      return;
    const { selection } = data2;
    const [x3, y3, x12, y12] = pixelsOf(selection, scale10, coordinate2);
    brushHandler.move(x3, y3, x12, y12, false);
  };
  emitter.on("brush:highlight", onHighlight);
  const onRemove = ({ nativeEvent } = {}) => {
    if (nativeEvent)
      return;
    brushHandler.remove(false);
  };
  emitter.on("brush:remove", onRemove);
  const preBrushDestroy = brushHandler.destroy.bind(brushHandler);
  brushHandler.destroy = () => {
    emitter.off("brush:highlight", onHighlight);
    emitter.off("brush:remove", onRemove);
    preBrushDestroy();
  };
  return brushHandler;
}
function BrushHighlight(_a2) {
  var { facet, brushKey } = _a2, rest2 = __rest82(_a2, ["facet", "brushKey"]);
  return (target, viewInstances, emitter) => {
    const { container, view, options } = target;
    const plotArea = selectPlotArea(container);
    const defaultOptions = {
      maskFill: "#777",
      maskFillOpacity: "0.3",
      maskStroke: "#fff",
      reverse: false
    };
    const defaultStates = ["active", ["inactive", { opacity: 0.5 }]];
    const { scale: scale10, coordinate: coordinate2 } = view;
    if (facet) {
      const bbox = plotArea.getBounds();
      const x3 = bbox.min[0];
      const y3 = bbox.min[1];
      const x12 = bbox.max[0];
      const y12 = bbox.max[1];
      return brushHighlight(plotArea.parentNode.parentNode, Object.assign(Object.assign({
        elements: () => selectFacetG2Elements(target, viewInstances),
        datum: createDatumof(selectFacetViews(target, viewInstances).map((d2) => d2.view)),
        brushRegion: (x4, y4, x13, y13) => [x4, y4, x13, y13],
        extent: [x3, y3, x12, y12],
        state: mergeState(selectFacetViews(target, viewInstances).map((d2) => d2.options), defaultStates),
        emitter,
        scale: scale10,
        coordinate: coordinate2,
        selectedHandles: void 0
      }, defaultOptions), rest2));
    }
    const brush2 = brushHighlight(plotArea, Object.assign(Object.assign({
      elements: selectG2Elements,
      key: (element) => element.__data__.key,
      siblings: () => selectSiblingContainers(target, viewInstances, brushKey),
      datum: createDatumof([
        view,
        ...selectSiblingViews(target, viewInstances, brushKey).map((d2) => d2.view)
      ]),
      brushRegion: (x3, y3, x12, y12) => [x3, y3, x12, y12],
      extent: void 0,
      state: mergeState([options, ...selectSiblingOptions(target, viewInstances, brushKey)], defaultStates),
      emitter,
      scale: scale10,
      coordinate: coordinate2,
      selectedHandles: void 0
    }, defaultOptions), rest2));
    plotArea.brush = brush2;
    return () => brush2.destroy();
  };
}

// node_modules/@antv/g2/esm/interaction/brushXHighlight.js
function brushXRegion(x3, y3, x12, y12, extent2) {
  const [, minY, , maxY2] = extent2;
  return [x3, minY, x12, maxY2];
}
function BrushXHighlight(options) {
  return BrushHighlight(Object.assign(Object.assign({}, options), { brushRegion: brushXRegion, selectedHandles: ["handle-e", "handle-w"] }));
}

// node_modules/@antv/g2/esm/interaction/brushYHighlight.js
function brushYRegion(x3, y3, x12, y12, extent2) {
  const [minX, , maxX] = extent2;
  return [minX, y3, maxX, y12];
}
function BrushYHighlight(options) {
  return BrushHighlight(Object.assign(Object.assign({}, options), { brushRegion: brushYRegion, selectedHandles: ["handle-n", "handle-s"] }));
}

// node_modules/@antv/g2/esm/interaction/brushAxisHighlight.js
var __rest83 = function(s2, e) {
  var t = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
      t[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t[p2[i]] = s2[p2[i]];
    }
  return t;
};
var AXIS_CLASS_NAME = "axis";
var AXIS_LINE_CLASS_NAME = "axis-line";
var AXIS_MAIN_CLASS_NAME = "axis-main-group";
var AXIS_HOT_AREA_CLASS_NAME = "axis-hot-area";
function axesOf(container) {
  return container.getElementsByClassName(AXIS_CLASS_NAME);
}
function lineOf(axis) {
  return axis.getElementsByClassName(AXIS_LINE_CLASS_NAME)[0];
}
function mainGroupOf(axis) {
  return axis.getElementsByClassName(AXIS_MAIN_CLASS_NAME)[0];
}
function boundsOfAxis(axis) {
  return mainGroupOf(axis).getLocalBounds();
}
function verticalBrush(axis, _a2) {
  var { cross: cross7, offsetX, offsetY } = _a2, style = __rest83(_a2, ["cross", "offsetX", "offsetY"]);
  const bounds = boundsOfAxis(axis);
  const axisLine = lineOf(axis);
  const [lineX] = axisLine.getLocalBounds().min;
  const [minX, minY] = bounds.min;
  const [maxX, maxY2] = bounds.max;
  const size5 = (maxX - minX) * 2;
  return {
    brushRegion: brushYRegion,
    hotZone: new Rect({
      className: AXIS_HOT_AREA_CLASS_NAME,
      style: Object.assign({
        // If it is not cross, draw brush in both side of axisLine,
        // otherwise the draw brush within bounds area.
        x: cross7 ? minX : lineX - size5 / 2,
        width: cross7 ? size5 / 2 : size5,
        y: minY,
        height: maxY2 - minY
      }, style)
    }),
    extent: cross7 ? (
      // If it is cross, the x range is ignored.
      (x3, y3, x12, y12) => [-Infinity, y3, Infinity, y12]
    ) : (x3, y3, x12, y12) => [
      Math.floor(minX - offsetX),
      y3,
      Math.ceil(maxX - offsetX),
      y12
    ]
  };
}
function horizontalBrush(axis, _a2) {
  var { offsetY, offsetX, cross: cross7 = false } = _a2, style = __rest83(_a2, ["offsetY", "offsetX", "cross"]);
  const bounds = boundsOfAxis(axis);
  const axisLine = lineOf(axis);
  const [, lineY] = axisLine.getLocalBounds().min;
  const [minX, minY] = bounds.min;
  const [maxX, maxY2] = bounds.max;
  const size5 = maxY2 - minY;
  return {
    brushRegion: brushXRegion,
    hotZone: new Rect({
      className: AXIS_HOT_AREA_CLASS_NAME,
      style: Object.assign({
        x: minX,
        width: maxX - minX,
        // If it is not cross, draw brush in both side of axisLine,
        // otherwise the draw brush within bounds area.
        y: cross7 ? minY : lineY - size5,
        height: cross7 ? size5 : size5 * 2
      }, style)
    }),
    extent: cross7 ? (
      // If it is cross, the y range is ignored.
      (x3, y3, x12, y12) => [x3, -Infinity, x12, Infinity]
    ) : (x3, y3, x12, y12) => [
      x3,
      Math.floor(minY - offsetY),
      x12,
      Math.ceil(maxY2 - offsetY)
    ]
  };
}
function brushAxisHighlight(root3, _a2) {
  var {
    axes: axesOf2,
    // given root, return axes
    elements: elementsOf,
    // given root, return elements
    points: pointsOf,
    // given shape, return control points
    horizontal: isHorizontal3,
    // given axis, return direction
    datum,
    // given shape, return datum
    offsetY,
    // offsetY for shape area
    offsetX,
    // offsetX for shape area
    reverse: reverse3 = false,
    state = {},
    emitter,
    coordinate: coordinate2
  } = _a2, rest2 = __rest83(_a2, ["axes", "elements", "points", "horizontal", "datum", "offsetY", "offsetX", "reverse", "state", "emitter", "coordinate"]);
  const elements = elementsOf(root3);
  const axes = axesOf2(root3);
  const valueof2 = createValueof(elements, datum);
  const { setState, removeState } = useState(state, valueof2);
  const axisExtent = /* @__PURE__ */ new Map();
  const brushStyle = subObject(rest2, "mask");
  const brushed = (points) => Array.from(axisExtent.values()).every(([x3, y3, x12, y12]) => points.some(([x05, y05]) => {
    return x05 >= x3 && x05 <= x12 && y05 >= y3 && y05 <= y12;
  }));
  const scales = axes.map((d2) => d2.attributes.scale);
  const extentOf2 = (D2) => D2.length > 2 ? [D2[0], D2[D2.length - 1]] : D2;
  const indexDomain = /* @__PURE__ */ new Map();
  const initIndexDomain = () => {
    indexDomain.clear();
    for (let i = 0; i < axes.length; i++) {
      const scale10 = scales[i];
      const { domain } = scale10.getOptions();
      indexDomain.set(i, extentOf2(domain));
    }
  };
  initIndexDomain();
  const updateElement = (i, emit) => {
    const selectedElements = [];
    for (const element of elements) {
      const points = pointsOf(element);
      if (brushed(points)) {
        setState(element, "active");
        selectedElements.push(element);
      } else
        setState(element, "inactive");
    }
    indexDomain.set(i, selectionOf2(selectedElements, i));
    if (!emit)
      return;
    const selection = () => {
      if (!cross7)
        return Array.from(indexDomain.values());
      const S = [];
      for (const [index3, domain] of indexDomain) {
        const scale10 = scales[index3];
        const { name: name2 } = scale10.getOptions();
        if (name2 === "x")
          S[0] = domain;
        else
          S[1] = domain;
      }
      return S;
    };
    emitter.emit("brushAxis:highlight", {
      nativeEvent: true,
      data: {
        selection: selection()
      }
    });
  };
  const clearElement = (emit) => {
    for (const element of elements)
      removeState(element, "active", "inactive");
    initIndexDomain();
    if (!emit)
      return;
    emitter.emit("brushAxis:remove", { nativeEvent: true });
  };
  const selectionOf2 = (selected, i) => {
    const scale10 = scales[i];
    const { name: name2 } = scale10.getOptions();
    const domain = selected.map((d2) => {
      const data2 = d2.__data__;
      return scale10.invert(data2[name2]);
    });
    return extentOf2(domainOf3(scale10, domain));
  };
  const cross7 = axes.some(isHorizontal3) && axes.some((d2) => !isHorizontal3(d2));
  const handlers = [];
  for (let i = 0; i < axes.length; i++) {
    const axis = axes[i];
    const createBrush = isHorizontal3(axis) ? horizontalBrush : verticalBrush;
    const { hotZone, brushRegion, extent: extent2 } = createBrush(axis, {
      offsetY,
      offsetX,
      cross: cross7,
      zIndex: 999,
      fill: "transparent"
      // Make it interactive.
    });
    axis.parentNode.appendChild(hotZone);
    const brushHandler = brush(hotZone, Object.assign(Object.assign({}, brushStyle), {
      reverse: reverse3,
      brushRegion,
      brushended(emit) {
        axisExtent.delete(axis);
        if (Array.from(axisExtent.entries()).length === 0)
          clearElement(emit);
        else
          updateElement(i, emit);
      },
      brushed(x3, y3, x12, y12, emit) {
        axisExtent.set(axis, extent2(x3, y3, x12, y12));
        updateElement(i, emit);
      }
    }));
    handlers.push(brushHandler);
  }
  const onRemove = (event = {}) => {
    const { nativeEvent } = event;
    if (nativeEvent)
      return;
    handlers.forEach((d2) => d2.remove(false));
  };
  const rangeOf5 = (domain, scale10, axis) => {
    const [d0, d1] = domain;
    const maybeStep = (scale11) => scale11.getStep ? scale11.getStep() : 0;
    const x3 = abstractOf2(d0, scale10, axis);
    const x12 = abstractOf2(d1, scale10, axis) + maybeStep(scale10);
    if (isHorizontal3(axis))
      return [x3, -Infinity, x12, Infinity];
    return [-Infinity, x3, Infinity, x12];
  };
  const abstractOf2 = (x3, scale10, axis) => {
    const { height, width } = coordinate2.getOptions();
    const scale1 = scale10.clone();
    if (isHorizontal3(axis))
      scale1.update({ range: [0, width] });
    else
      scale1.update({ range: [height, 0] });
    return scale1.map(x3);
  };
  const onHighlight = (event) => {
    const { nativeEvent } = event;
    if (nativeEvent)
      return;
    const { selection } = event.data;
    for (let i = 0; i < handlers.length; i++) {
      const domain = selection[i];
      const handler = handlers[i];
      const axis = axes[i];
      if (domain) {
        const scale10 = scales[i];
        handler.move(...rangeOf5(domain, scale10, axis), false);
      } else {
        handler.remove(false);
      }
    }
  };
  emitter.on("brushAxis:remove", onRemove);
  emitter.on("brushAxis:highlight", onHighlight);
  return () => {
    handlers.forEach((d2) => d2.destroy());
    emitter.off("brushAxis:remove", onRemove);
    emitter.off("brushAxis:highlight", onHighlight);
  };
}
function BrushAxisHighlight(options) {
  return (target, _2, emitter) => {
    const { container, view, options: viewOptions } = target;
    const plotArea = selectPlotArea(container);
    const { x: x05, y: y05 } = plotArea.getBBox();
    const { coordinate: coordinate2 } = view;
    return brushAxisHighlight(container, Object.assign({
      elements: selectG2Elements,
      axes: axesOf,
      offsetY: y05,
      offsetX: x05,
      points: (element) => element.__data__.points,
      horizontal: (axis) => {
        const { startPos: [sx, sy], endPos: [ex, ey] } = axis.attributes;
        return sx !== ex && sy === ey;
      },
      datum: createDatumof(view),
      state: mergeState(viewOptions, [
        "active",
        ["inactive", { opacity: 0.5 }]
      ]),
      coordinate: coordinate2,
      emitter
    }, options));
  };
}

// node_modules/@antv/g2/esm/interaction/brushFilter.js
var __awaiter12 = function(thisArg, _arguments, P, generator) {
  function adopt(value2) {
    return value2 instanceof P ? value2 : new P(function(resolve) {
      resolve(value2);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject2) {
    function fulfilled(value2) {
      try {
        step2(generator.next(value2));
      } catch (e) {
        reject2(e);
      }
    }
    function rejected(value2) {
      try {
        step2(generator["throw"](value2));
      } catch (e) {
        reject2(e);
      }
    }
    function step2(result2) {
      result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
    }
    step2((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __rest84 = function(s2, e) {
  var t = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
      t[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t[p2[i]] = s2[p2[i]];
    }
  return t;
};
function dblclick(interval2 = 300) {
  let preTimeStamp = null;
  return (e) => {
    const { timeStamp } = e;
    if (preTimeStamp !== null && timeStamp - preTimeStamp < interval2) {
      preTimeStamp = timeStamp;
      return true;
    }
    preTimeStamp = timeStamp;
    return false;
  };
}
function brushFilter(root3, _a2) {
  var { filter: filter4, reset, brushRegion, extent: optionalExtent, reverse: reverse3, emitter, scale: scale10, coordinate: coordinate2, selection, series = false } = _a2, rest2 = __rest84(_a2, ["filter", "reset", "brushRegion", "extent", "reverse", "emitter", "scale", "coordinate", "selection", "series"]);
  const brushStyle = subObject(rest2, "mask");
  const { width: rootWidth, height: rootHeight } = root3.getBBox();
  const extent2 = optionalExtent ? optionalExtent : [0, 0, rootWidth, rootHeight];
  const isDblclick = dblclick();
  const brush2 = brush(root3, Object.assign(Object.assign({}, brushStyle), {
    extent: extent2,
    brushRegion,
    reverse: reverse3,
    brushcreated
  }));
  root3.addEventListener("click", click);
  function brushcreated(x3, y3, x12, y12, event) {
    event.nativeEvent = true;
    filter4(selection(x3, y3, x12, y12), event);
    brush2.remove();
  }
  function click(e) {
    if (isDblclick(e)) {
      e.nativeEvent = true;
      reset(e);
    }
  }
  const onFilter = ({ nativeEvent, data: data2 }) => {
    if (nativeEvent)
      return;
    const { selection: selection2 } = data2;
    filter4(selection2, { nativeEvent: false });
  };
  emitter.on("brush:filter", onFilter);
  return () => {
    brush2.destroy();
    emitter.off("brush:filter", onFilter);
    root3.removeEventListener("click", click);
  };
}
function BrushFilter(_a2) {
  var { hideX = true, hideY = true } = _a2, rest2 = __rest84(_a2, ["hideX", "hideY"]);
  return (target, viewInstances, emitter) => {
    const { container, view, options: viewOptions, update: update3, setState } = target;
    const plotArea = selectPlotArea(container);
    const defaultOptions = {
      maskFill: "#777",
      maskFillOpacity: "0.3",
      maskStroke: "#fff",
      unhighlightedOpacity: 0.5,
      reverse: false
    };
    let filtered = false;
    let filtering = false;
    let newView = view;
    const { scale: scale10, coordinate: coordinate2 } = view;
    return brushFilter(plotArea, Object.assign(Object.assign({
      brushRegion: (x3, y3, x12, y12) => [x3, y3, x12, y12],
      selection: (x3, y3, x12, y12) => {
        const { scale: scale11, coordinate: coordinate3 } = newView;
        return selectionOf(x3, y3, x12, y12, scale11, coordinate3);
      },
      filter: (selection, event) => __awaiter12(this, void 0, void 0, function* () {
        if (filtering)
          return;
        filtering = true;
        const [domainX, domainY] = selection;
        setState("brushFilter", (options) => {
          const { marks } = options;
          const newMarks = marks.map((mark2) => deep_mix_default({
            // Hide label to keep smooth transition.
            axis: Object.assign(Object.assign({}, hideX && { x: { transform: [{ type: "hide" }] } }), hideY && { y: { transform: [{ type: "hide" }] } })
          }, mark2, {
            // Set nice to false to avoid modify domain.
            scale: {
              x: { domain: domainX, nice: false },
              y: { domain: domainY, nice: false }
            }
          }));
          return Object.assign(Object.assign({}, viewOptions), { marks: newMarks, clip: true });
        });
        emitter.emit("brush:filter", Object.assign(Object.assign({}, event), { data: { selection: [domainX, domainY] } }));
        const newState = yield update3();
        newView = newState.view;
        filtering = false;
        filtered = true;
      }),
      reset: (event) => {
        if (filtering || !filtered)
          return;
        const { scale: scale11 } = view;
        const { x: scaleX, y: scaleY } = scale11;
        const domainX = scaleX.getOptions().domain;
        const domainY = scaleY.getOptions().domain;
        emitter.emit("brush:filter", Object.assign(Object.assign({}, event), { data: { selection: [domainX, domainY] } }));
        filtered = false;
        newView = view;
        setState("brushFilter");
        update3();
      },
      extent: void 0,
      emitter,
      scale: scale10,
      coordinate: coordinate2
    }, defaultOptions), rest2));
  };
}

// node_modules/@antv/g2/esm/interaction/brushXFilter.js
function BrushXFilter(options) {
  return BrushFilter(Object.assign(Object.assign({ hideX: true }, options), { brushRegion: brushXRegion }));
}

// node_modules/@antv/g2/esm/interaction/brushYFilter.js
function BrushYFilter(options) {
  return BrushFilter(Object.assign(Object.assign({ hideY: true }, options), { brushRegion: brushYRegion }));
}

// node_modules/@antv/g2/esm/interaction/sliderFilter.js
var __awaiter13 = function(thisArg, _arguments, P, generator) {
  function adopt(value2) {
    return value2 instanceof P ? value2 : new P(function(resolve) {
      resolve(value2);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject2) {
    function fulfilled(value2) {
      try {
        step2(generator.next(value2));
      } catch (e) {
        reject2(e);
      }
    }
    function rejected(value2) {
      try {
        step2(generator["throw"](value2));
      } catch (e) {
        reject2(e);
      }
    }
    function step2(result2) {
      result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
    }
    step2((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var SLIDER_CLASS_NAME = "slider";
function filterDataByDomain(options, scaleOptions, prefix, hasState = false, channel0 = "x", channel1 = "y") {
  const { marks } = options;
  const newMarks = marks.map((mark2) => {
    var _a2, _b;
    return deep_mix_default({
      // Hide label to keep smooth transition.
      axis: {
        x: { transform: [{ type: "hide" }] },
        y: { transform: [{ type: "hide" }] }
      }
    }, mark2, {
      scale: scaleOptions,
      // Don't rerender sliders.
      [prefix]: Object.assign(Object.assign({}, ((_a2 = mark2[prefix]) === null || _a2 === void 0 ? void 0 : _a2[channel0]) && {
        [channel0]: Object.assign({ preserve: true }, hasState && { ratio: null })
      }), ((_b = mark2[prefix]) === null || _b === void 0 ? void 0 : _b[channel1]) && {
        [channel1]: { preserve: true }
      }),
      animate: false
    });
  });
  return Object.assign(Object.assign({}, options), { marks: newMarks, clip: true, animate: false });
}
function abstractValue(values4, scale10, reverse3) {
  const [x3, x12] = values4;
  const v = reverse3 ? (d2) => 1 - d2 : (d2) => d2;
  const d0 = invert4(scale10, v(x3), true);
  const d1 = invert4(scale10, v(x12), false);
  return domainOf3(scale10, [d0, d1]);
}
function extentOf(domain) {
  return [domain[0], domain[domain.length - 1]];
}
function SliderFilter({ initDomain = {}, className: className2 = SLIDER_CLASS_NAME, prefix = "slider", setValue = (component, values4) => component.setValues(values4), hasState = false, wait = 50, leading = true, trailing = false }) {
  return (context, _2, emitter) => {
    const { container, view, update: update3, setState } = context;
    const sliders = container.getElementsByClassName(className2);
    if (!sliders.length)
      return () => {
      };
    let filtering = false;
    const { scale: scale10, coordinate: coordinate2, layout } = view;
    const { paddingLeft, paddingTop, paddingBottom, paddingRight } = layout;
    const { x: scaleX, y: scaleY } = scale10;
    const transposed = isTranspose(coordinate2);
    const channelOf = (orientation) => {
      const channel0 = orientation === "vertical" ? "y" : "x";
      const channel1 = orientation === "vertical" ? "x" : "y";
      if (transposed)
        return [channel1, channel0];
      return [channel0, channel1];
    };
    const sliderHandler = /* @__PURE__ */ new Map();
    const emitHandlers = /* @__PURE__ */ new Set();
    const channelDomain = {
      x: initDomain.x || scaleX.getOptions().domain,
      y: initDomain.y || scaleY.getOptions().domain
    };
    for (const slider of sliders) {
      const { orientation } = slider.attributes;
      const [channel0, channel1] = channelOf(orientation);
      const eventName = `${prefix}${upper_first_default(channel0)}:filter`;
      const isX = channel0 === "x";
      const { ratio: ratioX } = scaleX.getOptions();
      const { ratio: ratioY } = scaleY.getOptions();
      const domainsOf = (event) => {
        if (event.data) {
          const { selection } = event.data;
          const [X = extentOf(channelDomain.x), Y = extentOf(channelDomain.y)] = selection;
          return isX ? [domainOf3(scaleX, X, ratioX), domainOf3(scaleY, Y, ratioY)] : [domainOf3(scaleY, Y, ratioY), domainOf3(scaleX, X, ratioX)];
        }
        const { value: values4 } = event.detail;
        const scale0 = scale10[channel0];
        const domain0 = abstractValue(values4, scale0, transposed && orientation === "horizontal");
        const domain1 = channelDomain[channel1];
        return [domain0, domain1];
      };
      const onValueChange = throttle_default((event) => __awaiter13(this, void 0, void 0, function* () {
        if (filtering)
          return;
        filtering = true;
        const { nativeEvent = true } = event;
        const [domain0, domain1] = domainsOf(event);
        channelDomain[channel0] = domain0;
        channelDomain[channel1] = domain1;
        if (nativeEvent) {
          const X = isX ? domain0 : domain1;
          const Y = isX ? domain1 : domain0;
          emitter.emit(eventName, Object.assign(Object.assign({}, event), { nativeEvent, data: { selection: [extentOf(X), extentOf(Y)] } }));
        }
        setState(slider, (options) => Object.assign(Object.assign({}, filterDataByDomain(
          options,
          // Set nice to false to avoid modify domain.
          // Only update domain of current slider / scrollbar.
          { [channel0]: { domain: domain0, nice: false } },
          prefix,
          hasState,
          channel0,
          channel1
        )), {
          paddingLeft,
          paddingTop,
          paddingBottom,
          paddingRight
        }));
        yield update3();
        filtering = false;
      }), wait, { leading, trailing });
      const emitHandler = (event) => {
        const { nativeEvent } = event;
        if (nativeEvent)
          return;
        const { data: data2 } = event;
        const { selection } = data2;
        const [X, Y] = selection;
        slider.dispatchEvent(new CustomEvent("valuechange", {
          data: data2,
          nativeEvent: false
        }));
        const V = isX ? abstractOf(X, scaleX) : abstractOf(Y, scaleY);
        setValue(slider, V);
      };
      emitter.on(eventName, emitHandler);
      slider.addEventListener("valuechange", onValueChange);
      sliderHandler.set(slider, onValueChange);
      emitHandlers.add([eventName, emitHandler]);
    }
    update3();
    return () => {
      for (const [slider, handler] of sliderHandler) {
        slider.removeEventListener("valuechange", handler);
      }
      for (const [name2, handler] of emitHandlers) {
        emitter.off(name2, handler);
      }
    };
  };
}

// node_modules/@antv/g2/esm/interaction/scrollbarFilter.js
var SCROLLBAR_CLASS_NAME = "g2-scrollbar";
function ScrollbarFilter(options = {}) {
  return (context, _2, emitter) => {
    const { view, container } = context;
    const scrollbars = container.getElementsByClassName(SCROLLBAR_CLASS_NAME);
    if (!scrollbars.length)
      return () => {
      };
    const { scale: scale10 } = view;
    const { x: scaleX, y: scaleY } = scale10;
    const initDomain = {
      x: [...scaleX.getOptions().domain],
      y: [...scaleY.getOptions().domain]
    };
    scaleX.update({ domain: scaleX.getOptions().expectedDomain });
    scaleY.update({ domain: scaleY.getOptions().expectedDomain });
    const interaction = SliderFilter(Object.assign(Object.assign({}, options), { initDomain, className: SCROLLBAR_CLASS_NAME, prefix: "scrollbar", hasState: true, setValue: (component, values4) => component.setValue(values4[0]) }));
    return interaction(context, _2, emitter);
  };
}

// node_modules/@antv/g2/esm/interaction/poptip.js
var __rest85 = function(s2, e) {
  var t = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
      t[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t[p2[i]] = s2[p2[i]];
    }
  return t;
};
function dom(tag, children, style) {
  return `<${tag} style="${Object.entries(style).map(([key, value2]) => `${kebabCase(key)}:${value2}`).join(";")}">${children}</${tag}>`;
}
var defaultTipStyle = {
  backgroundColor: "rgba(0,0,0,0.75)",
  color: "#fff",
  width: "max-content",
  padding: "1px 4px",
  fontSize: "12px",
  borderRadius: "2.5px",
  boxShadow: "0 3px 6px -4px rgba(0,0,0,0.12), 0 6px 16px 0 rgba(0,0,0,0.08), 0 9px 28px 8px rgba(0,0,0,0.05)"
};
function isTipText(element) {
  if (element.nodeName !== "text")
    return false;
  if (element.isOverflowing())
    return true;
  return false;
}
function Poptip2(_a2) {
  var { offsetX = 8, offsetY = 8 } = _a2, style = __rest85(_a2, ["offsetX", "offsetY"]);
  return (context) => {
    const { container } = context;
    const [x05, y05] = container.getBounds().min;
    const tipStyle = subObject(style, "tip");
    const tips = /* @__PURE__ */ new Set();
    const pointerover = (e) => {
      const { target } = e;
      if (!isTipText(target)) {
        e.stopPropagation();
        return;
      }
      const { offsetX: mouseX, offsetY: mouseY } = e;
      const x3 = mouseX + offsetX - x05;
      const y3 = mouseY + offsetY - y05;
      if (target.tip) {
        target.tip.style.x = x3;
        target.tip.style.y = y3;
        return;
      }
      const { text } = target.style;
      const tipELement = new HTML({
        className: "poptip",
        style: {
          innerHTML: dom("div", text, Object.assign(Object.assign({}, defaultTipStyle), tipStyle)),
          x: x3,
          y: y3
        }
      });
      container.appendChild(tipELement);
      target.tip = tipELement;
      tips.add(tipELement);
    };
    const pointerout = (e) => {
      const { target } = e;
      if (!isTipText(target)) {
        e.stopPropagation();
        return;
      }
      if (!target.tip)
        return;
      target.tip.remove();
      target.tip = null;
      tips.delete(target.tip);
    };
    container.addEventListener("pointerover", pointerover);
    container.addEventListener("pointerout", pointerout);
    return () => {
      container.removeEventListener("pointerover", pointerover);
      container.removeEventListener("pointerout", pointerout);
      tips.forEach((tip) => tip.remove());
    };
  };
}
Poptip2.props = {
  reapplyWhenUpdate: true
};

// node_modules/@antv/g2/esm/utils/bounds.js
function parseAABB(min22) {
  const { min: min11, max: max11 } = min22;
  return [
    [min11[0], min11[1]],
    [max11[0], max11[1]]
  ];
}
function isInBounds(point7, bounds) {
  const [x3, y3] = point7;
  const [min11, max11] = bounds;
  return x3 >= min11[0] && x3 <= max11[0] && y3 >= min11[1] && y3 <= max11[1];
}
function isOverflow(b1, b2) {
  const [min11, max11] = b1;
  return !(isInBounds(min11, b2) && isInBounds(max11, b2));
}
function isOverlap(b1, b2) {
  const [min1, max1] = b1;
  const [min22, max22] = b2;
  return min1[0] < max22[0] && max1[0] > min22[0] && min1[1] < max22[1] && max1[1] > min22[1];
}

// node_modules/@antv/g2/esm/label-transform/overlapHide.js
var OverlapHide = (options) => {
  const { priority } = options;
  return (labels) => {
    const displayLabels = [];
    if (priority)
      labels.sort(priority);
    labels.forEach((l) => {
      show2(l);
      const b1 = l.getLocalBounds();
      const overlaping = displayLabels.some((dl) => isOverlap(parseAABB(b1), parseAABB(dl.getLocalBounds())));
      if (overlaping)
        hide2(l);
      else
        displayLabels.push(l);
    });
    return labels;
  };
};

// node_modules/@antv/g2/esm/label-transform/overlapDodgeY.js
function isSegmentIntersect([a4, b], [c5, d2]) {
  return d2 > a4 && b > c5;
}
function useMap() {
  const map5 = /* @__PURE__ */ new Map();
  const get3 = (key) => map5.get(key);
  const set9 = (key, value2) => map5.set(key, value2);
  return [get3, set9];
}
function getBoundsWithoutConnector(shape23) {
  const node = shape23.cloneNode(true);
  const connectorShape = node.getElementById("connector");
  connectorShape && node.removeChild(connectorShape);
  const { min: min11, max: max11 } = node.getRenderBounds();
  node.destroy();
  return { min: min11, max: max11 };
}
var OverlapDodgeY = (options) => {
  const { maxIterations = 10, maxError = 0.1, padding = 1 } = options;
  return (labels) => {
    const n = labels.length;
    if (n <= 1)
      return labels;
    const [y05, setY0] = useMap();
    const [y3, setY] = useMap();
    const [h, setH] = useMap();
    const [xx, setXX] = useMap();
    for (const label of labels) {
      const { min: min11, max: max11 } = getBoundsWithoutConnector(label);
      const [x05, y06] = min11;
      const [x12, y12] = max11;
      setY0(label, y06);
      setY(label, y06);
      setH(label, y12 - y06);
      setXX(label, [x05, x12]);
    }
    for (let iter = 0; iter < maxIterations; iter++) {
      labels.sort((a4, b) => ascending(y3(a4), y3(b)));
      let error3 = 0;
      for (let i = 0; i < n - 1; i++) {
        const l0 = labels[i];
        let j = i + 1;
        let l1;
        while ((l1 = labels[j]) && !isSegmentIntersect(xx(l0), xx(l1)))
          j += 1;
        if (l1) {
          const y06 = y3(l0);
          const h0 = h(l0);
          const y12 = y3(l1);
          const delta = y12 - (y06 + h0);
          if (delta < padding) {
            const newDelta = (padding - delta) / 2;
            error3 = Math.max(error3, newDelta);
            setY(l0, y06 - newDelta);
            setY(l1, y12 + newDelta);
          }
        }
      }
      if (error3 < maxError)
        break;
    }
    for (const label of labels) {
      label.style.y += y3(label) - y05(label);
    }
    return labels;
  };
};

// node_modules/@antv/g2/esm/utils/color.js
function parseToRGB(c5) {
  if (typeof c5 === "object")
    return c5;
  return parseColor(c5);
}

// node_modules/@antv/g2/esm/label-transform/contrastReverse.js
function getsRGB(s2) {
  let c5 = s2 / 255;
  c5 = c5 <= 0.03928 ? c5 / 12.92 : Math.pow((c5 + 0.055) / 1.055, 2.4);
  return c5;
}
function getL(r, g, b) {
  return 0.2126 * getsRGB(r) + 0.7152 * getsRGB(g) + 0.0722 * getsRGB(b);
}
function contrast(foreground, background) {
  const { r, g, b } = foreground;
  const { r: rb, g: gb, b: bb } = background;
  const L1 = getL(r, g, b);
  const L2 = getL(rb, gb, bb);
  return (Math.max(L1, L2) + 0.05) / (Math.min(L1, L2) + 0.05);
}
function mostContrast(color2, palette) {
  const i = maxIndex(palette, (c5) => contrast(color2, parseToRGB(c5)));
  return palette[i];
}
var ContrastReverse = (options) => {
  const { threshold = 4.5, palette = ["#000", "#fff"] } = options;
  return (labels) => {
    labels.forEach((l) => {
      const background = l.attr("dependentElement").parsedStyle.fill;
      const foreground = l.parsedStyle.fill;
      const c5 = contrast(foreground, background);
      if (c5 < threshold)
        l.attr("fill", mostContrast(background, palette));
    });
    return labels;
  };
};

// node_modules/@antv/g2/esm/label-transform/overflowHide.js
var OverflowHide = () => {
  return (labels) => {
    labels.forEach((l) => {
      show2(l);
      const bounds = l.attr("bounds");
      const b = l.getLocalBounds();
      const overflow = isOverflow(parseAABB(b), bounds);
      if (overflow)
        hide2(l);
    });
    return labels;
  };
};

// node_modules/@antv/g2/esm/lib/core.js
function corelib() {
  return {
    "data.fetch": Fetch,
    "data.inline": Inline,
    "data.sortBy": SortBy,
    "data.sort": Sort2,
    "data.filter": Filter2,
    "data.pick": Pick,
    "data.rename": Rename,
    "data.fold": Fold,
    "data.slice": Slice,
    "data.custom": Custom,
    "data.map": Map2,
    "data.join": Join,
    "data.kde": KDE,
    "data.log": Log2,
    "transform.stackY": StackY,
    "transform.binX": BinX,
    "transform.bin": Bin,
    "transform.dodgeX": DodgeX,
    "transform.jitter": Jitter,
    "transform.jitterX": JitterX,
    "transform.jitterY": JitterY,
    "transform.symmetryY": SymmetryY,
    "transform.diffY": DiffY,
    "transform.stackEnter": StackEnter,
    "transform.normalizeY": NormalizeY,
    "transform.select": Select,
    "transform.selectX": SelectX,
    "transform.selectY": SelectY,
    "transform.groupX": GroupX,
    "transform.groupY": GroupY,
    "transform.groupColor": GroupColor,
    "transform.group": Group,
    "transform.sortX": SortX,
    "transform.sortY": SortY,
    "transform.sortColor": SortColor,
    "transform.flexX": FlexX,
    "transform.pack": Pack,
    "transform.sample": Sample,
    "transform.filter": Filter,
    "coordinate.cartesian": Cartesian,
    "coordinate.polar": Polar,
    "coordinate.transpose": Transpose,
    "coordinate.theta": Theta,
    "coordinate.parallel": Parallel,
    "coordinate.fisheye": Fisheye,
    "coordinate.radial": Radial,
    "coordinate.radar": Radar,
    "encode.constant": Constant,
    "encode.field": Field,
    "encode.transform": Transform,
    "encode.column": Column,
    "mark.interval": Interval,
    "mark.rect": Rect3,
    "mark.line": Line5,
    "mark.point": Point4,
    "mark.text": Text4,
    "mark.cell": Cell,
    "mark.area": Area2,
    "mark.link": Link2,
    "mark.image": Image4,
    "mark.polygon": Polygon3,
    "mark.box": Box2,
    "mark.vector": Vector2,
    "mark.lineX": LineX,
    "mark.lineY": LineY,
    "mark.connector": Connector2,
    "mark.range": Range2,
    "mark.rangeX": RangeX,
    "mark.rangeY": RangeY,
    "mark.path": Path4,
    "mark.shape": Shape3,
    "mark.density": Density2,
    "mark.heatmap": Heatmap2,
    "palette.category10": Category10,
    "palette.category20": Category20,
    "scale.linear": Linear3,
    "scale.ordinal": Ordinal2,
    "scale.band": Band2,
    "scale.identity": Identity2,
    "scale.point": Point5,
    "scale.time": Time2,
    "scale.log": Log3,
    "scale.pow": Pow2,
    "scale.sqrt": Sqrt2,
    "scale.threshold": Threshold2,
    "scale.quantile": Quantile2,
    "scale.quantize": Quantize2,
    "scale.sequential": Sequential3,
    "scale.constant": Constant3,
    "theme.classic": Classic,
    "theme.classicDark": ClassicDark,
    "theme.academy": Academy,
    "theme.light": Light,
    "theme.dark": Dark,
    "component.axisX": AxisX,
    "component.axisY": AxisY,
    "component.legendCategory": LegendCategory,
    "component.legendContinuous": LegendContinuous,
    "component.legends": Legends,
    "component.title": TitleComponent,
    "component.sliderX": SliderX,
    "component.sliderY": SliderY,
    "component.scrollbarX": ScrollbarX,
    "component.scrollbarY": ScrollbarY,
    "animation.scaleInX": ScaleInX,
    "animation.scaleOutX": ScaleOutX,
    "animation.scaleInY": ScaleInY,
    "animation.scaleOutY": ScaleOutY,
    "animation.waveIn": WaveIn,
    "animation.fadeIn": FadeIn,
    "animation.fadeOut": FadeOut,
    "animation.zoomIn": ZoomIn,
    "animation.zoomOut": ZoomOut,
    "animation.pathIn": PathIn,
    "animation.morphing": Morphing,
    "animation.growInX": GrowInX,
    "animation.growInY": GrowInY,
    "interaction.elementHighlight": ElementHighlight,
    "interaction.elementHighlightByX": ElementHighlightByX,
    "interaction.elementHighlightByColor": ElementHighlightByColor,
    "interaction.elementSelect": ElementSelect,
    "interaction.elementSelectByX": ElementSelectByX,
    "interaction.elementSelectByColor": ElementSelectByColor,
    "interaction.fisheye": Fisheye2,
    "interaction.chartIndex": ChartIndex,
    "interaction.tooltip": Tooltip2,
    "interaction.legendFilter": LegendFilter,
    "interaction.legendHighlight": LegendHighlight,
    "interaction.brushHighlight": BrushHighlight,
    "interaction.brushXHighlight": BrushXHighlight,
    "interaction.brushYHighlight": BrushYHighlight,
    "interaction.brushAxisHighlight": BrushAxisHighlight,
    "interaction.brushFilter": BrushFilter,
    "interaction.brushXFilter": BrushXFilter,
    "interaction.brushYFilter": BrushYFilter,
    "interaction.sliderFilter": SliderFilter,
    "interaction.scrollbarFilter": ScrollbarFilter,
    "interaction.poptip": Poptip2,
    "composition.spaceLayer": SpaceLayer,
    "composition.spaceFlex": SpaceFlex,
    "composition.facetRect": FacetRect,
    "composition.repeatMatrix": RepeatMatrix,
    "composition.facetCircle": FacetCircle,
    "composition.timingKeyframe": TimingKeyframe,
    "labelTransform.overlapHide": OverlapHide,
    "labelTransform.overlapDodgeY": OverlapDodgeY,
    "labelTransform.overflowHide": OverflowHide,
    "labelTransform.contrastReverse": ContrastReverse
  };
}

// node_modules/@antv/g2/esm/lib/geo.js
function geolib() {
  return {
    "composition.geoView": GeoView,
    "composition.geoPath": GeoPath
  };
}

// node_modules/@antv/g2/esm/lib/graph.js
function graphlib() {
  return {
    "data.arc": Arc3,
    "data.cluster": Cluster,
    "mark.forceGraph": ForceGraph,
    "mark.tree": Tree2,
    "mark.pack": Pack2,
    "mark.sankey": Sankey3,
    "mark.chord": Chord,
    "mark.treemap": Treemap
  };
}

// node_modules/@antv/g2/esm/lib/plot.js
function plotlib() {
  return {
    "data.venn": Venn,
    "mark.boxplot": Boxplot,
    "mark.gauge": Gauge,
    "mark.wordCloud": WordCloud2,
    "mark.liquid": Liquid2
  };
}

// node_modules/@antv/g2/esm/lib/std.js
function stdlib() {
  return Object.assign(Object.assign(Object.assign(Object.assign({}, geolib()), graphlib()), plotlib()), corelib());
}

// node_modules/@antv/g2/esm/api/extend.js
function extend4(Runtime2, library3) {
  class Chart4 extends Runtime2 {
    constructor(options) {
      super(Object.assign(Object.assign({}, options), { lib: library3 }));
    }
  }
  return Chart4;
}

// node_modules/@antv/g2/esm/api/library.js
var library = {};
function register(key, component) {
  Object.assign(library, { [key]: component });
}

// node_modules/@antv/g2/esm/utils/size.js
var parseInt10 = (d2) => d2 ? parseInt(d2) : 0;
function getContainerSize(container) {
  const style = getComputedStyle(container);
  const wrapperWidth = container.clientWidth || parseInt10(style.width);
  const wrapperHeight = container.clientHeight || parseInt10(style.height);
  const widthPadding = parseInt10(style.paddingLeft) + parseInt10(style.paddingRight);
  const heightPadding = parseInt10(style.paddingTop) + parseInt10(style.paddingBottom);
  return {
    width: wrapperWidth - widthPadding,
    height: wrapperHeight - heightPadding
  };
}

// node_modules/@antv/g2/esm/api/node.js
function bfs(node, callback) {
  const discovered = [node];
  while (discovered.length) {
    const currentNode = discovered.shift();
    callback && callback(currentNode);
    const children = currentNode.children || [];
    for (const child of children) {
      discovered.push(child);
    }
  }
}
var Node4 = class {
  constructor(value2 = {}, type) {
    this.parentNode = null;
    this.children = [];
    this.index = 0;
    this.type = type;
    this.value = value2;
  }
  /**
   * Apply specified transform to current value. Mount the node
   * to replace the original one in the tree and then return it.
   */
  map(transform3 = (x3) => x3) {
    const newValue = transform3(this.value);
    this.value = newValue;
    return this;
  }
  /**
   * Set or get the specified attribute. It the value is specified, update
   * the attribute of current value and return the node. Otherwise
   * return the the attribute of current value.
   */
  attr(key, value2) {
    if (arguments.length === 1)
      return this.value[key];
    return this.map((v) => (v[key] = value2, v));
  }
  /**
   * Create a new node and append to children nodes.
   */
  append(Ctor) {
    const node = new Ctor({});
    node.children = [];
    this.push(node);
    return node;
  }
  push(node) {
    node.parentNode = this;
    node.index = this.children.length;
    this.children.push(node);
    return this;
  }
  /**
   * Remove current node from parentNode.
   */
  remove() {
    const parent2 = this.parentNode;
    if (parent2) {
      const { children } = parent2;
      const index3 = children.findIndex((item) => item === this);
      children.splice(index3, 1);
    }
    return this;
  }
  getNodeByKey(key) {
    let targetNode = null;
    const callback = (node) => {
      if (key === node.attr("key")) {
        targetNode = node;
      }
    };
    bfs(this, callback);
    return targetNode;
  }
  getNodesByType(type) {
    const nodes = [];
    const callback = (node) => {
      if (type === node.type) {
        nodes.push(node);
      }
    };
    bfs(this, callback);
    return nodes;
  }
  getNodeByType(type) {
    let node = null;
    bfs(this, (current) => {
      if (node)
        return;
      if (type === current.type)
        node = current;
    });
    return node;
  }
  /**
   * Apply specified callback to the node value.
   */
  call(callback, ...params) {
    callback(this.map(), ...params);
    return this;
  }
  getRoot() {
    let root3 = this;
    while (root3 && root3.parentNode) {
      root3 = root3.parentNode;
    }
    return root3;
  }
};

// node_modules/@antv/g2/esm/api/utils.js
var __rest86 = function(s2, e) {
  var t = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
      t[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t[p2[i]] = s2[p2[i]];
    }
  return t;
};
var VIEW_KEYS = [
  "width",
  "height",
  "depth",
  "padding",
  "paddingLeft",
  "paddingRight",
  "paddingBottom",
  "paddingTop",
  "inset",
  "insetLeft",
  "insetRight",
  "insetTop",
  "insetBottom",
  "margin",
  "marginLeft",
  "marginRight",
  "marginTop",
  "marginBottom",
  "autoFit",
  "theme",
  "title"
];
var REMOVE_FLAG = "__remove__";
var CALLBACK_NODE = "__callback__";
var MIN_CHART_WIDTH = 1;
var MIN_CHART_HEIGHT = 1;
function normalizeContainer2(container) {
  if (container === void 0) {
    const container2 = document.createElement("div");
    container2[REMOVE_FLAG] = true;
    return container2;
  }
  if (typeof container === "string") {
    const node = document.getElementById(container);
    return node;
  }
  return container;
}
function removeContainer(container) {
  const parent2 = container.parentNode;
  if (parent2) {
    parent2.removeChild(container);
  }
}
function normalizeRoot(node) {
  if (node.type !== null)
    return node;
  const root3 = node.children[node.children.length - 1];
  for (const key of VIEW_KEYS)
    root3.attr(key, node.attr(key));
  return root3;
}
function valueOf3(node) {
  return Object.assign(Object.assign({}, node.value), { type: node.type });
}
function sizeOf2(options, container) {
  const { width = 640, height = 480, autoFit, depth = 0 } = options;
  let effectiveWidth = width;
  let effectiveHeight = height;
  if (autoFit) {
    const { width: containerWidth, height: containerHeight } = getContainerSize(container);
    effectiveWidth = containerWidth || effectiveWidth;
    effectiveHeight = containerHeight || effectiveHeight;
  }
  return {
    width: Math.max(is_number_default(effectiveWidth) ? effectiveWidth : MIN_CHART_WIDTH, MIN_CHART_WIDTH),
    height: Math.max(is_number_default(effectiveHeight) ? effectiveHeight : MIN_CHART_HEIGHT, MIN_CHART_HEIGHT),
    depth
  };
}
function optionsOf(node) {
  const root3 = normalizeRoot(node);
  const discovered = [root3];
  const nodeValue = /* @__PURE__ */ new Map();
  nodeValue.set(root3, valueOf3(root3));
  while (discovered.length) {
    const node2 = discovered.pop();
    const value2 = nodeValue.get(node2);
    const { children = [] } = node2;
    for (const child of children) {
      if (child.type === CALLBACK_NODE) {
        value2.children = child.value;
      } else {
        const childValue = valueOf3(child);
        const { children: children2 = [] } = value2;
        children2.push(childValue);
        discovered.push(child);
        nodeValue.set(child, childValue);
        value2.children = children2;
      }
    }
  }
  return nodeValue.get(root3);
}
function isMark(type, mark2) {
  if (typeof type === "function")
    return true;
  return new Set(Object.keys(mark2)).has(type);
}
function normalizeRootOptions(node, options, previousType, marks) {
  const { type: oldType } = node;
  const { type = previousType || oldType } = options;
  if (type === "view")
    return options;
  if (!isMark(type, marks))
    return options;
  const view = { type: "view" };
  const mark2 = Object.assign({}, options);
  for (const key of VIEW_KEYS) {
    if (mark2[key] !== void 0) {
      view[key] = mark2[key];
      delete mark2[key];
    }
  }
  return Object.assign(Object.assign({}, view), { children: [mark2] });
}
function typeCtor(type, mark2, composition) {
  if (typeof type === "function")
    return mark2.mark;
  const node = Object.assign(Object.assign({}, mark2), composition);
  const ctor = node[type];
  if (!ctor)
    throw new Error(`Unknown mark: ${type}.`);
  return ctor;
}
function createNode(options, mark2, composition) {
  if (typeof options === "function") {
    const node2 = new Node4();
    node2.value = options;
    node2.type = CALLBACK_NODE;
    return node2;
  }
  const { type, children } = options, value2 = __rest86(options, ["type", "children"]);
  const Ctor = typeCtor(type, mark2, composition);
  const node = new Ctor();
  node.value = value2;
  node.type = type;
  return node;
}
function updateNode(node, newOptions) {
  const { type, children } = newOptions, value2 = __rest86(newOptions, ["type", "children"]);
  if (node.type === type || type === void 0) {
    deepAssign(node.value, value2);
  } else if (typeof type === "string") {
    node.type = type;
    node.value = value2;
  }
}
function appendNode(parent2, newOptions, mark2, composition) {
  if (!parent2)
    return;
  const discovered = [[parent2, newOptions]];
  while (discovered.length) {
    const [parent3, nodeOptions] = discovered.shift();
    const node = createNode(nodeOptions, mark2, composition);
    if (Array.isArray(parent3.children))
      parent3.push(node);
    const { children } = nodeOptions;
    if (Array.isArray(children)) {
      for (const child of children) {
        discovered.push([node, child]);
      }
    } else if (typeof children === "function") {
      discovered.push([node, children]);
    }
  }
}
function updateRoot(node, options, definedType, mark2, composition) {
  const rootOptions = normalizeRootOptions(node, options, definedType, mark2);
  const discovered = [[null, node, rootOptions]];
  while (discovered.length) {
    const [parent2, oldNode, newNode] = discovered.shift();
    if (!oldNode) {
      appendNode(parent2, newNode, mark2, composition);
    } else if (!newNode) {
      oldNode.remove();
    } else {
      updateNode(oldNode, newNode);
      const { children: newChildren } = newNode;
      const { children: oldChildren } = oldNode;
      if (Array.isArray(newChildren) && Array.isArray(oldChildren)) {
        const n = Math.max(newChildren.length, oldChildren.length);
        for (let i = 0; i < n; i++) {
          const newChild = newChildren[i];
          const oldChild = oldChildren[i];
          discovered.push([oldNode, oldChild, newChild]);
        }
      } else if (typeof newChildren === "function") {
        discovered.push([oldNode, null, newChildren]);
      }
    }
  }
}
function createEmptyPromise() {
  let reject2;
  let resolve;
  const cloned = new Promise((res, rej) => {
    resolve = res;
    reject2 = rej;
  });
  return [cloned, resolve, reject2];
}

// node_modules/@antv/g2/esm/api/define.js
function defineValueProp(Node5, name2, { key = name2 }) {
  Node5.prototype[name2] = function(value2) {
    if (arguments.length === 0)
      return this.attr(key);
    return this.attr(key, value2);
  };
}
function defineArrayProp(Node5, name2, { key = name2 }) {
  Node5.prototype[name2] = function(value2) {
    if (arguments.length === 0)
      return this.attr(key);
    if (Array.isArray(value2))
      return this.attr(key, value2);
    const array2 = [...this.attr(key) || [], value2];
    return this.attr(key, array2);
  };
}
function defineObjectProp(Node5, name2, { key: k2 = name2 }) {
  Node5.prototype[name2] = function(key, value2) {
    if (arguments.length === 0)
      return this.attr(k2);
    if (arguments.length === 1 && typeof key !== "string") {
      return this.attr(k2, key);
    }
    const obj = this.attr(k2) || {};
    obj[key] = arguments.length === 1 ? true : value2;
    return this.attr(k2, obj);
  };
}
function defineMixProp(Node5, name2, descriptor) {
  Node5.prototype[name2] = function(key) {
    if (arguments.length === 0)
      return this.attr(name2);
    if (Array.isArray(key))
      return this.attr(name2, { items: key });
    if (isStrictObject(key) && (key.title !== void 0 || key.items !== void 0)) {
      return this.attr(name2, key);
    }
    if (key === null || key === false)
      return this.attr(name2, key);
    const obj = this.attr(name2) || {};
    const { items = [] } = obj;
    items.push(key);
    obj.items = items;
    return this.attr(name2, obj);
  };
}
function defineNodeProp(Node5, name2, { ctor }) {
  Node5.prototype[name2] = function(hocMark) {
    const node = this.append(ctor);
    if (name2 === "mark") {
      node.type = hocMark;
    }
    return node;
  };
}
function defineContainerProp(Node5, name2, { ctor }) {
  Node5.prototype[name2] = function() {
    this.type = null;
    return this.append(ctor);
  };
}
function defineProps(descriptors) {
  return (Node5) => {
    for (const [name2, descriptor] of Object.entries(descriptors)) {
      const { type } = descriptor;
      if (type === "value")
        defineValueProp(Node5, name2, descriptor);
      else if (type === "array")
        defineArrayProp(Node5, name2, descriptor);
      else if (type === "object")
        defineObjectProp(Node5, name2, descriptor);
      else if (type === "node")
        defineNodeProp(Node5, name2, descriptor);
      else if (type === "container")
        defineContainerProp(Node5, name2, descriptor);
      else if (type === "mix")
        defineMixProp(Node5, name2, descriptor);
    }
    return Node5;
  };
}
function nodeProps(node) {
  return Object.fromEntries(Object.entries(node).map(([name2, ctor]) => [name2, { type: "node", ctor }]));
}

// node_modules/@antv/g2/esm/api/props.js
var commonProps = {
  encode: { type: "object" },
  scale: { type: "object" },
  data: { type: "value" },
  transform: { type: "array" },
  style: { type: "object" },
  animate: { type: "object" },
  coordinate: { type: "object" },
  interaction: { type: "object" },
  label: { type: "array", key: "labels" },
  axis: { type: "object" },
  legend: { type: "object" },
  slider: { type: "object" },
  scrollbar: { type: "object" },
  state: { type: "object" },
  layout: { type: "object" },
  theme: { type: "object" },
  title: { type: "value" }
};
var markProps = Object.assign(Object.assign({}, commonProps), { tooltip: { type: "mix" }, viewStyle: { type: "object" } });
var compositionProps = Object.assign(Object.assign({}, commonProps), { labelTransform: { type: "array" } });

// node_modules/@antv/g2/esm/api/composition.js
var __decorate3 = function(decorators, target, key, desc) {
  var c5 = arguments.length, r = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d2 = decorators[i])
        r = (c5 < 3 ? d2(r) : c5 > 3 ? d2(target, key, r) : d2(target, key)) || r;
  return c5 > 3 && r && Object.defineProperty(target, key, r), r;
};
var CompositionNode = class CompositionNode2 extends Node4 {
  /**
   * Change current node data and its children data.
   */
  changeData(data2) {
    var _a2;
    const chart = this.getRoot();
    if (!chart)
      return;
    this.attr("data", data2);
    if ((_a2 = this.children) === null || _a2 === void 0 ? void 0 : _a2.length) {
      this.children.forEach((child) => {
        child.attr("data", data2);
      });
    }
    return chart === null || chart === void 0 ? void 0 : chart.render();
  }
  /**
   * Get view instance by key.
   */
  getView() {
    const chart = this.getRoot();
    const { views } = chart.getContext();
    if (!(views === null || views === void 0 ? void 0 : views.length))
      return void 0;
    return views.find((view) => view.key === this._key);
  }
  getScale() {
    var _a2;
    return (_a2 = this.getView()) === null || _a2 === void 0 ? void 0 : _a2.scale;
  }
  getScaleByChannel(channel) {
    const scale10 = this.getScale();
    if (scale10)
      return scale10[channel];
    return;
  }
  getCoordinate() {
    var _a2;
    return (_a2 = this.getView()) === null || _a2 === void 0 ? void 0 : _a2.coordinate;
  }
  getTheme() {
    var _a2;
    return (_a2 = this.getView()) === null || _a2 === void 0 ? void 0 : _a2.theme;
  }
  getGroup() {
    const key = this._key;
    if (!key)
      return void 0;
    const chart = this.getRoot();
    const chartGroup = chart.getContext().canvas.getRoot();
    return chartGroup.getElementById(key);
  }
  /**
   * Show the view.
   */
  show() {
    const group3 = this.getGroup();
    if (!group3)
      return;
    !group3.isVisible() && show2(group3);
  }
  /**
   * Hide the view.
   */
  hide() {
    const group3 = this.getGroup();
    if (!group3)
      return;
    group3.isVisible() && hide2(group3);
  }
};
CompositionNode = __decorate3([
  defineProps(compositionProps)
], CompositionNode);

// node_modules/@antv/g2/esm/api/mark.js
var __decorate4 = function(decorators, target, key, desc) {
  var c5 = arguments.length, r = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d2 = decorators[i])
        r = (c5 < 3 ? d2(r) : c5 > 3 ? d2(target, key, r) : d2(target, key)) || r;
  return c5 > 3 && r && Object.defineProperty(target, key, r), r;
};
var MarkNode = class MarkNode2 extends Node4 {
  changeData(data2) {
    const chart = this.getRoot();
    if (!chart)
      return;
    this.attr("data", data2);
    return chart === null || chart === void 0 ? void 0 : chart.render();
  }
  /**
   * Get mark from chart views.
   */
  getMark() {
    var _a2;
    const chartView = (_a2 = this.getRoot()) === null || _a2 === void 0 ? void 0 : _a2.getView();
    if (!chartView)
      return void 0;
    const { markState } = chartView;
    const markKey = Array.from(markState.keys()).find((item) => item.key === this.attr("key"));
    return markState.get(markKey);
  }
  /**
   * Get all scales instance.
   */
  getScale() {
    var _a2;
    const chartView = (_a2 = this.getRoot()) === null || _a2 === void 0 ? void 0 : _a2.getView();
    if (!chartView)
      return void 0;
    return chartView === null || chartView === void 0 ? void 0 : chartView.scale;
  }
  /**
   * Get the scale instance by channel.
   */
  getScaleByChannel(channel) {
    var _a2, _b;
    const chartView = (_a2 = this.getRoot()) === null || _a2 === void 0 ? void 0 : _a2.getView();
    if (!chartView)
      return void 0;
    return (_b = chartView === null || chartView === void 0 ? void 0 : chartView.scale) === null || _b === void 0 ? void 0 : _b[channel];
  }
  /**
   * Get canvas group.
   */
  getGroup() {
    const key = this.attr("key");
    if (!key)
      return void 0;
    const chart = this.getRoot();
    const chartGroup = chart.getContext().canvas.getRoot();
    return chartGroup.getElementById(key);
  }
};
MarkNode = __decorate4([
  defineProps(markProps)
], MarkNode);

// node_modules/@antv/g2/esm/api/runtime.js
var __decorate5 = function(decorators, target, key, desc) {
  var c5 = arguments.length, r = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d2 = decorators[i])
        r = (c5 < 3 ? d2(r) : c5 > 3 ? d2(target, key, r) : d2(target, key)) || r;
  return c5 > 3 && r && Object.defineProperty(target, key, r), r;
};
var __rest87 = function(s2, e) {
  var t = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
      t[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t[p2[i]] = s2[p2[i]];
    }
  return t;
};
var G2_CHART_KEY = "G2_CHART_KEY";
var Runtime = class extends CompositionNode {
  constructor(options) {
    const { container, canvas, renderer, plugins, lib } = options, rest2 = __rest87(options, ["container", "canvas", "renderer", "plugins", "lib"]);
    super(rest2, "view");
    this._hasBindAutoFit = false;
    this._rendering = false;
    this._trailing = false;
    this._trailingResolve = null;
    this._trailingReject = null;
    this._previousDefinedType = null;
    this._onResize = debounce_default(() => {
      this.forceFit();
    }, 300);
    this._renderer = renderer || new Renderer();
    this._plugins = plugins || [];
    this._container = normalizeContainer2(container);
    this._emitter = new esm_default();
    this._context = {
      library: Object.assign(Object.assign({}, lib), library),
      emitter: this._emitter,
      canvas
    };
    this._create();
  }
  render() {
    if (this._rendering)
      return this._addToTrailing();
    if (!this._context.canvas)
      this._createCanvas();
    this._context.canvas.getConfig().supportsCSSTransform = true;
    this._bindAutoFit();
    this._rendering = true;
    const finished = new Promise((resolve2, reject3) => render(this._computedOptions(), this._context, this._createResolve(resolve2), this._createReject(reject3)));
    const [finished1, resolve, reject2] = createEmptyPromise();
    finished.then(resolve).catch(reject2).then(() => this._renderTrailing());
    return finished1;
  }
  /**
   * @overload
   * @param {G2ViewTree} [options]
   * @returns {Runtime|Spec}
   */
  options(options) {
    if (arguments.length === 0)
      return optionsOf(this);
    const { type } = options;
    if (type)
      this._previousDefinedType = type;
    updateRoot(this, options, this._previousDefinedType, this._marks, this._compositions);
    return this;
  }
  getContainer() {
    return this._container;
  }
  getContext() {
    return this._context;
  }
  on(event, callback, once2) {
    this._emitter.on(event, callback, once2);
    return this;
  }
  once(event, callback) {
    this._emitter.once(event, callback);
    return this;
  }
  emit(event, ...args) {
    this._emitter.emit(event, ...args);
    return this;
  }
  off(event, callback) {
    this._emitter.off(event, callback);
    return this;
  }
  clear() {
    const options = this.options();
    this.emit(ChartEvent.BEFORE_CLEAR);
    this._reset();
    destroy(options, this._context, false);
    this.emit(ChartEvent.AFTER_CLEAR);
  }
  destroy() {
    const options = this.options();
    this.emit(ChartEvent.BEFORE_DESTROY);
    this._unbindAutoFit();
    this._reset();
    destroy(options, this._context, true);
    if (this._container[REMOVE_FLAG])
      removeContainer(this._container);
    this.emit(ChartEvent.AFTER_DESTROY);
  }
  forceFit() {
    this.options["autoFit"] = true;
    const { width, height } = sizeOf2(this.options(), this._container);
    if (width === this._width && height === this._height) {
      return Promise.resolve(this);
    }
    this.emit(ChartEvent.BEFORE_CHANGE_SIZE);
    const finished = this.render();
    finished.then(() => {
      this.emit(ChartEvent.AFTER_CHANGE_SIZE);
    });
    return finished;
  }
  changeSize(width, height) {
    if (width === this._width && height === this._height) {
      return Promise.resolve(this);
    }
    this.emit(ChartEvent.BEFORE_CHANGE_SIZE);
    this.attr("width", width);
    this.attr("height", height);
    const finished = this.render();
    finished.then(() => {
      this.emit(ChartEvent.AFTER_CHANGE_SIZE);
    });
    return finished;
  }
  _create() {
    const { library: library3 } = this._context;
    const isMark2 = (key) => key.startsWith("mark.") || key === "component.axisX" || key === "component.axisY" || key === "component.legends";
    const marks = [
      "mark.mark",
      ...Object.keys(library3).filter(isMark2)
    ];
    this._marks = {};
    for (const key of marks) {
      const name2 = key.split(".").pop();
      class Mark2 extends MarkNode {
        constructor() {
          super({}, name2);
        }
      }
      this._marks[name2] = Mark2;
      this[name2] = function(composite) {
        const node = this.append(Mark2);
        if (name2 === "mark")
          node.type = composite;
        return node;
      };
    }
    const compositions = [
      "composition.view",
      ...Object.keys(library3).filter((key) => key.startsWith("composition.") && key !== "composition.mark")
    ];
    this._compositions = Object.fromEntries(compositions.map((key) => {
      const name2 = key.split(".").pop();
      let Composition = class Composition extends CompositionNode {
        constructor() {
          super({}, name2);
        }
      };
      Composition = __decorate5([
        defineProps(nodeProps(this._marks))
      ], Composition);
      return [name2, Composition];
    }));
    for (const Ctor of Object.values(this._compositions)) {
      defineProps(nodeProps(this._compositions))(Ctor);
    }
    for (const key of compositions) {
      const name2 = key.split(".").pop();
      this[name2] = function() {
        const Composition = this._compositions[name2];
        this.type = null;
        return this.append(Composition);
      };
    }
  }
  _reset() {
    const KEYS = ["theme", "type", "width", "height", "autoFit"];
    this.type = "view";
    this.value = Object.fromEntries(Object.entries(this.value).filter(([key]) => key.startsWith("margin") || key.startsWith("padding") || key.startsWith("inset") || KEYS.includes(key)));
    this.children = [];
  }
  _renderTrailing() {
    if (!this._trailing)
      return;
    this._trailing = false;
    this.render().then(() => {
      const trailingResolve = this._trailingResolve.bind(this);
      this._trailingResolve = null;
      trailingResolve(this);
    }).catch((error3) => {
      const trailingReject = this._trailingReject.bind(this);
      this._trailingReject = null;
      trailingReject(error3);
    });
  }
  _createResolve(resolve) {
    return () => {
      this._rendering = false;
      resolve(this);
    };
  }
  _createReject(reject2) {
    return (error3) => {
      this._rendering = false;
      reject2(error3);
    };
  }
  // Update actual size and key.
  _computedOptions() {
    const options = this.options();
    const { key = G2_CHART_KEY } = options;
    const { width, height, depth } = sizeOf2(options, this._container);
    this._width = width;
    this._height = height;
    this._key = key;
    return Object.assign(Object.assign({ key: this._key }, options), { width, height, depth });
  }
  // Create canvas if it does not exist.
  // DragAndDropPlugin is for interaction.
  // It is OK to register more than one time, G will handle this.
  _createCanvas() {
    const { width, height } = sizeOf2(this.options(), this._container);
    this._plugins.push(new Plugin7());
    this._plugins.forEach((d2) => this._renderer.registerPlugin(d2));
    this._context.canvas = new Canvas({
      container: this._container,
      width,
      height,
      renderer: this._renderer
    });
  }
  _addToTrailing() {
    var _a2;
    (_a2 = this._trailingResolve) === null || _a2 === void 0 ? void 0 : _a2.call(this, this);
    this._trailing = true;
    const promise = new Promise((resolve, reject2) => {
      this._trailingResolve = resolve;
      this._trailingReject = reject2;
    });
    return promise;
  }
  _bindAutoFit() {
    const options = this.options();
    const { autoFit } = options;
    if (this._hasBindAutoFit) {
      if (!autoFit)
        this._unbindAutoFit();
      return;
    }
    if (autoFit) {
      this._hasBindAutoFit = true;
      window.addEventListener("resize", this._onResize);
    }
  }
  _unbindAutoFit() {
    if (this._hasBindAutoFit) {
      this._hasBindAutoFit = false;
      window.removeEventListener("resize", this._onResize);
    }
  }
};

// node_modules/@antv/g2/esm/api/chart.js
var Chart = extend4(Runtime, library);

// node_modules/@antv/g2/esm/exports.js
runtime.enableCSSParsing = false;

// node_modules/@antv/g2/esm/index.js
var library2 = Object.assign({}, stdlib());
var Chart2 = extend4(Runtime, library2);

// node_modules/@ant-design/plots/es/components/base/index.js
var import_react4 = __toESM(require_react());

// node_modules/@ant-design/charts-util/es/react/render.js
var ReactDOM = __toESM(require_react_dom());
var __assign2 = function() {
  __assign2 = Object.assign || function(t) {
    for (var s2, i = 1, n = arguments.length; i < n; i++) {
      s2 = arguments[i];
      for (var p2 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p2))
          t[p2] = s2[p2];
    }
    return t;
  };
  return __assign2.apply(this, arguments);
};
var fullClone = __assign2({}, ReactDOM);
var version = fullClone.version;
var reactRender = fullClone.render;
var unmountComponentAtNode = fullClone.unmountComponentAtNode;
var createRoot;
try {
  mainVersion = Number((version || "").split(".")[0]);
  if (mainVersion >= 18) {
    createRoot = fullClone.createRoot;
  }
} catch (e) {
}
var mainVersion;
function toggleWarning(skip) {
  var __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = fullClone.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
  if (__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED && typeof __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED === "object") {
    __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.usingClientEntryPoint = skip;
  }
}
var MARK = "__rc_react_root__";
function modernRender(node, container) {
  toggleWarning(true);
  var root3 = container[MARK] || createRoot(container);
  toggleWarning(false);
  root3.render(node);
  container[MARK] = root3;
}
function legacyRender(node, container) {
  reactRender(node, container);
}
function render2(node, container) {
  if (createRoot) {
    modernRender(node, container);
    return;
  }
  legacyRender(node, container);
}

// node_modules/@ant-design/charts-util/es/rc/create-node.js
var mountMapping = /* @__PURE__ */ new Map();
mountMapping.set("tooltip", document.createElement("div"));
var createNode2 = function(children, isTooltip) {
  if (isTooltip === void 0) {
    isTooltip = false;
  }
  var mount = null;
  if (isTooltip) {
    mount = mountMapping.get("tooltip");
  } else {
    mount = document.createElement("div");
    if (children === null || children === void 0 ? void 0 : children.key) {
      var exist = mountMapping.get(children.key);
      if (exist) {
        mount = exist;
      } else {
        mountMapping.set(children.key, mount);
      }
    }
  }
  render2(children, mount);
  return mount;
};

// node_modules/@ant-design/charts-util/es/rc/chart-loading.js
var import_react = __toESM(require_react());
var shadowLoading = function(ele) {
  var shadowRoot = ele.attachShadow({ mode: "open" });
  var shadowDiv = document.createElement("div");
  var shadowStyle = document.createElement("style");
  shadowStyle.innerHTML = ".loading {\n    display: inline-block;\n    position: relative;\n    width: 80px;\n    height: 80px;\n  }\n  .loading div {\n    position: absolute;\n    top: 33px;\n    width: 13px;\n    height: 13px;\n    border-radius: 50%;\n    background: #ccc;\n    animation-timing-function: cubic-bezier(0, 1, 1, 0);\n  }\n  .loading div:nth-child(1) {\n    left: 8px;\n    animation: loading1 0.6s infinite;\n  }\n  .loading div:nth-child(2) {\n    left: 8px;\n    animation: loading2 0.6s infinite;\n  }\n  .loading div:nth-child(3) {\n    left: 32px;\n    animation: loading2 0.6s infinite;\n  }\n  .loading div:nth-child(4) {\n    left: 56px;\n    animation: loading3 0.6s infinite;\n  }\n  @keyframes loading1 {\n    0% {\n      transform: scale(0);\n    }\n    100% {\n      transform: scale(1);\n    }\n  }\n  @keyframes loading3 {\n    0% {\n      transform: scale(1);\n    }\n    100% {\n      transform: scale(0);\n    }\n  }\n  @keyframes loading2 {\n    0% {\n      transform: translate(0, 0);\n    }\n    100% {\n      transform: translate(24px, 0);\n    }\n  }\n  ";
  shadowDiv.classList.add("loading");
  shadowDiv.innerHTML = "<div></div><div></div><div></div><div></div>";
  shadowRoot.appendChild(shadowStyle);
  shadowRoot.appendChild(shadowDiv);
};
var ChartLoading = function(_a2) {
  var loadingTemplate = _a2.loadingTemplate, _b = _a2.theme, theme = _b === void 0 ? "light" : _b;
  var shadow = import_react.default.useRef(null);
  import_react.default.useEffect(function() {
    if (!loadingTemplate && shadow.current) {
      shadowLoading(shadow.current);
    }
  }, []);
  var renderLoading = function() {
    if (loadingTemplate)
      return loadingTemplate;
    return import_react.default.createElement("div", { ref: shadow });
  };
  return import_react.default.createElement("div", { className: "charts-loading-container", style: {
    position: "absolute",
    width: "100%",
    height: "100%",
    display: "flex",
    alignItems: "center",
    justifyContent: "center",
    left: 0,
    top: 0,
    zIndex: 99,
    backgroundColor: theme === "dark" ? "rgb(20, 20, 20)" : "rgb(255, 255, 255)"
  } }, renderLoading());
};

// node_modules/@ant-design/charts-util/es/rc/error-boundary.js
var import_react2 = __toESM(require_react());
var __extends2 = function() {
  var extendStatics2 = function(d2, b) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b2) {
      d3.__proto__ = b2;
    } || function(d3, b2) {
      for (var p2 in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p2))
          d3[p2] = b2[p2];
    };
    return extendStatics2(d2, b);
  };
  return function(d2, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics2(d2, b);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var ErrorBoundary = (
  /** @class */
  function(_super) {
    __extends2(ErrorBoundary2, _super);
    function ErrorBoundary2() {
      var _this2 = _super !== null && _super.apply(this, arguments) || this;
      _this2.state = {
        hasError: false
      };
      _this2.renderError = function(e) {
        var errorTemplate = _this2.props.errorTemplate;
        switch (e) {
          default:
            if (typeof errorTemplate === "function")
              return errorTemplate(e);
            return errorTemplate ? errorTemplate : import_react2.default.createElement(
              "h5",
              null,
              " ",
              e.message
            );
        }
      };
      return _this2;
    }
    ErrorBoundary2.getDerivedStateFromError = function(error3) {
      return { hasError: true, error: error3 };
    };
    ErrorBoundary2.getDerivedStateFromProps = function(nextProps, state) {
      if (state.children !== nextProps.children) {
        return {
          children: nextProps.children,
          hasError: false,
          error: void 0
        };
      }
      return null;
    };
    ErrorBoundary2.prototype.render = function() {
      if (this.state.hasError) {
        return this.renderError(this.state.error);
      }
      return import_react2.default.createElement(import_react2.Fragment, null, this.props.children);
    };
    return ErrorBoundary2;
  }(import_react2.default.Component)
);

// node_modules/@ant-design/plots/es/hooks/useChart.js
var import_react3 = __toESM(require_react());

// node_modules/lodash-es/_freeGlobal.js
var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
var freeGlobal_default = freeGlobal;

// node_modules/lodash-es/_root.js
var freeSelf = typeof self == "object" && self && self.Object === Object && self;
var root2 = freeGlobal_default || freeSelf || Function("return this")();
var root_default2 = root2;

// node_modules/lodash-es/_Symbol.js
var Symbol3 = root_default2.Symbol;
var Symbol_default = Symbol3;

// node_modules/lodash-es/_getRawTag.js
var objectProto4 = Object.prototype;
var hasOwnProperty2 = objectProto4.hasOwnProperty;
var nativeObjectToString = objectProto4.toString;
var symToStringTag = Symbol_default ? Symbol_default.toStringTag : void 0;
function getRawTag(value2) {
  var isOwn = hasOwnProperty2.call(value2, symToStringTag), tag = value2[symToStringTag];
  try {
    value2[symToStringTag] = void 0;
    var unmasked = true;
  } catch (e) {
  }
  var result2 = nativeObjectToString.call(value2);
  if (unmasked) {
    if (isOwn) {
      value2[symToStringTag] = tag;
    } else {
      delete value2[symToStringTag];
    }
  }
  return result2;
}
var getRawTag_default = getRawTag;

// node_modules/lodash-es/_objectToString.js
var objectProto5 = Object.prototype;
var nativeObjectToString2 = objectProto5.toString;
function objectToString(value2) {
  return nativeObjectToString2.call(value2);
}
var objectToString_default = objectToString;

// node_modules/lodash-es/_baseGetTag.js
var nullTag = "[object Null]";
var undefinedTag = "[object Undefined]";
var symToStringTag2 = Symbol_default ? Symbol_default.toStringTag : void 0;
function baseGetTag(value2) {
  if (value2 == null) {
    return value2 === void 0 ? undefinedTag : nullTag;
  }
  return symToStringTag2 && symToStringTag2 in Object(value2) ? getRawTag_default(value2) : objectToString_default(value2);
}
var baseGetTag_default = baseGetTag;

// node_modules/lodash-es/isObjectLike.js
function isObjectLike4(value2) {
  return value2 != null && typeof value2 == "object";
}
var isObjectLike_default = isObjectLike4;

// node_modules/lodash-es/isSymbol.js
var symbolTag = "[object Symbol]";
function isSymbol2(value2) {
  return typeof value2 == "symbol" || isObjectLike_default(value2) && baseGetTag_default(value2) == symbolTag;
}
var isSymbol_default = isSymbol2;

// node_modules/lodash-es/_baseToNumber.js
var NAN = 0 / 0;
function baseToNumber(value2) {
  if (typeof value2 == "number") {
    return value2;
  }
  if (isSymbol_default(value2)) {
    return NAN;
  }
  return +value2;
}
var baseToNumber_default = baseToNumber;

// node_modules/lodash-es/_arrayMap.js
function arrayMap(array2, iteratee2) {
  var index3 = -1, length5 = array2 == null ? 0 : array2.length, result2 = Array(length5);
  while (++index3 < length5) {
    result2[index3] = iteratee2(array2[index3], index3, array2);
  }
  return result2;
}
var arrayMap_default = arrayMap;

// node_modules/lodash-es/isArray.js
var isArray = Array.isArray;
var isArray_default = isArray;

// node_modules/lodash-es/_baseToString.js
var INFINITY = 1 / 0;
var symbolProto = Symbol_default ? Symbol_default.prototype : void 0;
var symbolToString = symbolProto ? symbolProto.toString : void 0;
function baseToString(value2) {
  if (typeof value2 == "string") {
    return value2;
  }
  if (isArray_default(value2)) {
    return arrayMap_default(value2, baseToString) + "";
  }
  if (isSymbol_default(value2)) {
    return symbolToString ? symbolToString.call(value2) : "";
  }
  var result2 = value2 + "";
  return result2 == "0" && 1 / value2 == -INFINITY ? "-0" : result2;
}
var baseToString_default = baseToString;

// node_modules/lodash-es/_createMathOperation.js
function createMathOperation(operator, defaultValue) {
  return function(value2, other) {
    var result2;
    if (value2 === void 0 && other === void 0) {
      return defaultValue;
    }
    if (value2 !== void 0) {
      result2 = value2;
    }
    if (other !== void 0) {
      if (result2 === void 0) {
        return other;
      }
      if (typeof value2 == "string" || typeof other == "string") {
        value2 = baseToString_default(value2);
        other = baseToString_default(other);
      } else {
        value2 = baseToNumber_default(value2);
        other = baseToNumber_default(other);
      }
      result2 = operator(value2, other);
    }
    return result2;
  };
}
var createMathOperation_default = createMathOperation;

// node_modules/lodash-es/add.js
var add10 = createMathOperation_default(function(augend, addend) {
  return augend + addend;
}, 0);
var add_default2 = add10;

// node_modules/lodash-es/_trimmedEndIndex.js
var reWhitespace = /\s/;
function trimmedEndIndex(string) {
  var index3 = string.length;
  while (index3-- && reWhitespace.test(string.charAt(index3))) {
  }
  return index3;
}
var trimmedEndIndex_default = trimmedEndIndex;

// node_modules/lodash-es/_baseTrim.js
var reTrimStart = /^\s+/;
function baseTrim(string) {
  return string ? string.slice(0, trimmedEndIndex_default(string) + 1).replace(reTrimStart, "") : string;
}
var baseTrim_default = baseTrim;

// node_modules/lodash-es/isObject.js
function isObject3(value2) {
  var type = typeof value2;
  return value2 != null && (type == "object" || type == "function");
}
var isObject_default = isObject3;

// node_modules/lodash-es/toNumber.js
var NAN2 = 0 / 0;
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
var reIsBinary = /^0b[01]+$/i;
var reIsOctal = /^0o[0-7]+$/i;
var freeParseInt = parseInt;
function toNumber(value2) {
  if (typeof value2 == "number") {
    return value2;
  }
  if (isSymbol_default(value2)) {
    return NAN2;
  }
  if (isObject_default(value2)) {
    var other = typeof value2.valueOf == "function" ? value2.valueOf() : value2;
    value2 = isObject_default(other) ? other + "" : other;
  }
  if (typeof value2 != "string") {
    return value2 === 0 ? value2 : +value2;
  }
  value2 = baseTrim_default(value2);
  var isBinary = reIsBinary.test(value2);
  return isBinary || reIsOctal.test(value2) ? freeParseInt(value2.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value2) ? NAN2 : +value2;
}
var toNumber_default = toNumber;

// node_modules/lodash-es/toFinite.js
var INFINITY2 = 1 / 0;
var MAX_INTEGER = 17976931348623157e292;
function toFinite(value2) {
  if (!value2) {
    return value2 === 0 ? value2 : 0;
  }
  value2 = toNumber_default(value2);
  if (value2 === INFINITY2 || value2 === -INFINITY2) {
    var sign3 = value2 < 0 ? -1 : 1;
    return sign3 * MAX_INTEGER;
  }
  return value2 === value2 ? value2 : 0;
}
var toFinite_default = toFinite;

// node_modules/lodash-es/toInteger.js
function toInteger(value2) {
  var result2 = toFinite_default(value2), remainder = result2 % 1;
  return result2 === result2 ? remainder ? result2 - remainder : result2 : 0;
}
var toInteger_default = toInteger;

// node_modules/lodash-es/after.js
var FUNC_ERROR_TEXT = "Expected a function";
function after(n, func) {
  if (typeof func != "function") {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  n = toInteger_default(n);
  return function() {
    if (--n < 1) {
      return func.apply(this, arguments);
    }
  };
}
var after_default = after;

// node_modules/lodash-es/identity.js
function identity7(value2) {
  return value2;
}
var identity_default8 = identity7;

// node_modules/lodash-es/isFunction.js
var asyncTag = "[object AsyncFunction]";
var funcTag = "[object Function]";
var genTag = "[object GeneratorFunction]";
var proxyTag = "[object Proxy]";
function isFunction2(value2) {
  if (!isObject_default(value2)) {
    return false;
  }
  var tag = baseGetTag_default(value2);
  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
}
var isFunction_default = isFunction2;

// node_modules/lodash-es/_coreJsData.js
var coreJsData = root_default2["__core-js_shared__"];
var coreJsData_default = coreJsData;

// node_modules/lodash-es/_isMasked.js
var maskSrcKey = function() {
  var uid = /[^.]+$/.exec(coreJsData_default && coreJsData_default.keys && coreJsData_default.keys.IE_PROTO || "");
  return uid ? "Symbol(src)_1." + uid : "";
}();
function isMasked(func) {
  return !!maskSrcKey && maskSrcKey in func;
}
var isMasked_default = isMasked;

// node_modules/lodash-es/_toSource.js
var funcProto = Function.prototype;
var funcToString = funcProto.toString;
function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {
    }
    try {
      return func + "";
    } catch (e) {
    }
  }
  return "";
}
var toSource_default = toSource;

// node_modules/lodash-es/_baseIsNative.js
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
var reIsHostCtor = /^\[object .+?Constructor\]$/;
var funcProto2 = Function.prototype;
var objectProto6 = Object.prototype;
var funcToString2 = funcProto2.toString;
var hasOwnProperty3 = objectProto6.hasOwnProperty;
var reIsNative = RegExp(
  "^" + funcToString2.call(hasOwnProperty3).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
);
function baseIsNative(value2) {
  if (!isObject_default(value2) || isMasked_default(value2)) {
    return false;
  }
  var pattern = isFunction_default(value2) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource_default(value2));
}
var baseIsNative_default = baseIsNative;

// node_modules/lodash-es/_getValue.js
function getValue(object, key) {
  return object == null ? void 0 : object[key];
}
var getValue_default = getValue;

// node_modules/lodash-es/_getNative.js
function getNative(object, key) {
  var value2 = getValue_default(object, key);
  return baseIsNative_default(value2) ? value2 : void 0;
}
var getNative_default = getNative;

// node_modules/lodash-es/_WeakMap.js
var WeakMap2 = getNative_default(root_default2, "WeakMap");
var WeakMap_default = WeakMap2;

// node_modules/lodash-es/_metaMap.js
var metaMap = WeakMap_default && new WeakMap_default();
var metaMap_default = metaMap;

// node_modules/lodash-es/_baseSetData.js
var baseSetData = !metaMap_default ? identity_default8 : function(func, data2) {
  metaMap_default.set(func, data2);
  return func;
};
var baseSetData_default = baseSetData;

// node_modules/lodash-es/_baseCreate.js
var objectCreate = Object.create;
var baseCreate = function() {
  function object() {
  }
  return function(proto) {
    if (!isObject_default(proto)) {
      return {};
    }
    if (objectCreate) {
      return objectCreate(proto);
    }
    object.prototype = proto;
    var result2 = new object();
    object.prototype = void 0;
    return result2;
  };
}();
var baseCreate_default = baseCreate;

// node_modules/lodash-es/_createCtor.js
function createCtor(Ctor) {
  return function() {
    var args = arguments;
    switch (args.length) {
      case 0:
        return new Ctor();
      case 1:
        return new Ctor(args[0]);
      case 2:
        return new Ctor(args[0], args[1]);
      case 3:
        return new Ctor(args[0], args[1], args[2]);
      case 4:
        return new Ctor(args[0], args[1], args[2], args[3]);
      case 5:
        return new Ctor(args[0], args[1], args[2], args[3], args[4]);
      case 6:
        return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
      case 7:
        return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
    }
    var thisBinding = baseCreate_default(Ctor.prototype), result2 = Ctor.apply(thisBinding, args);
    return isObject_default(result2) ? result2 : thisBinding;
  };
}
var createCtor_default = createCtor;

// node_modules/lodash-es/_createBind.js
var WRAP_BIND_FLAG = 1;
function createBind(func, bitmask, thisArg) {
  var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor_default(func);
  function wrapper() {
    var fn = this && this !== root_default2 && this instanceof wrapper ? Ctor : func;
    return fn.apply(isBind ? thisArg : this, arguments);
  }
  return wrapper;
}
var createBind_default = createBind;

// node_modules/lodash-es/_apply.js
function apply(func, thisArg, args) {
  switch (args.length) {
    case 0:
      return func.call(thisArg);
    case 1:
      return func.call(thisArg, args[0]);
    case 2:
      return func.call(thisArg, args[0], args[1]);
    case 3:
      return func.call(thisArg, args[0], args[1], args[2]);
  }
  return func.apply(thisArg, args);
}
var apply_default = apply;

// node_modules/lodash-es/_composeArgs.js
var nativeMax = Math.max;
function composeArgs(args, partials, holders, isCurried) {
  var argsIndex = -1, argsLength = args.length, holdersLength = holders.length, leftIndex = -1, leftLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array(leftLength + rangeLength), isUncurried = !isCurried;
  while (++leftIndex < leftLength) {
    result2[leftIndex] = partials[leftIndex];
  }
  while (++argsIndex < holdersLength) {
    if (isUncurried || argsIndex < argsLength) {
      result2[holders[argsIndex]] = args[argsIndex];
    }
  }
  while (rangeLength--) {
    result2[leftIndex++] = args[argsIndex++];
  }
  return result2;
}
var composeArgs_default = composeArgs;

// node_modules/lodash-es/_composeArgsRight.js
var nativeMax2 = Math.max;
function composeArgsRight(args, partials, holders, isCurried) {
  var argsIndex = -1, argsLength = args.length, holdersIndex = -1, holdersLength = holders.length, rightIndex = -1, rightLength = partials.length, rangeLength = nativeMax2(argsLength - holdersLength, 0), result2 = Array(rangeLength + rightLength), isUncurried = !isCurried;
  while (++argsIndex < rangeLength) {
    result2[argsIndex] = args[argsIndex];
  }
  var offset2 = argsIndex;
  while (++rightIndex < rightLength) {
    result2[offset2 + rightIndex] = partials[rightIndex];
  }
  while (++holdersIndex < holdersLength) {
    if (isUncurried || argsIndex < argsLength) {
      result2[offset2 + holders[holdersIndex]] = args[argsIndex++];
    }
  }
  return result2;
}
var composeArgsRight_default = composeArgsRight;

// node_modules/lodash-es/_countHolders.js
function countHolders(array2, placeholder) {
  var length5 = array2.length, result2 = 0;
  while (length5--) {
    if (array2[length5] === placeholder) {
      ++result2;
    }
  }
  return result2;
}
var countHolders_default = countHolders;

// node_modules/lodash-es/_baseLodash.js
function baseLodash() {
}
var baseLodash_default = baseLodash;

// node_modules/lodash-es/_LazyWrapper.js
var MAX_ARRAY_LENGTH = 4294967295;
function LazyWrapper(value2) {
  this.__wrapped__ = value2;
  this.__actions__ = [];
  this.__dir__ = 1;
  this.__filtered__ = false;
  this.__iteratees__ = [];
  this.__takeCount__ = MAX_ARRAY_LENGTH;
  this.__views__ = [];
}
LazyWrapper.prototype = baseCreate_default(baseLodash_default.prototype);
LazyWrapper.prototype.constructor = LazyWrapper;
var LazyWrapper_default = LazyWrapper;

// node_modules/lodash-es/noop.js
function noop3() {
}
var noop_default5 = noop3;

// node_modules/lodash-es/_getData.js
var getData3 = !metaMap_default ? noop_default5 : function(func) {
  return metaMap_default.get(func);
};
var getData_default = getData3;

// node_modules/lodash-es/_realNames.js
var realNames = {};
var realNames_default = realNames;

// node_modules/lodash-es/_getFuncName.js
var objectProto7 = Object.prototype;
var hasOwnProperty4 = objectProto7.hasOwnProperty;
function getFuncName(func) {
  var result2 = func.name + "", array2 = realNames_default[result2], length5 = hasOwnProperty4.call(realNames_default, result2) ? array2.length : 0;
  while (length5--) {
    var data2 = array2[length5], otherFunc = data2.func;
    if (otherFunc == null || otherFunc == func) {
      return data2.name;
    }
  }
  return result2;
}
var getFuncName_default = getFuncName;

// node_modules/lodash-es/_LodashWrapper.js
function LodashWrapper(value2, chainAll) {
  this.__wrapped__ = value2;
  this.__actions__ = [];
  this.__chain__ = !!chainAll;
  this.__index__ = 0;
  this.__values__ = void 0;
}
LodashWrapper.prototype = baseCreate_default(baseLodash_default.prototype);
LodashWrapper.prototype.constructor = LodashWrapper;
var LodashWrapper_default = LodashWrapper;

// node_modules/lodash-es/_copyArray.js
function copyArray(source, array2) {
  var index3 = -1, length5 = source.length;
  array2 || (array2 = Array(length5));
  while (++index3 < length5) {
    array2[index3] = source[index3];
  }
  return array2;
}
var copyArray_default = copyArray;

// node_modules/lodash-es/_wrapperClone.js
function wrapperClone(wrapper) {
  if (wrapper instanceof LazyWrapper_default) {
    return wrapper.clone();
  }
  var result2 = new LodashWrapper_default(wrapper.__wrapped__, wrapper.__chain__);
  result2.__actions__ = copyArray_default(wrapper.__actions__);
  result2.__index__ = wrapper.__index__;
  result2.__values__ = wrapper.__values__;
  return result2;
}
var wrapperClone_default = wrapperClone;

// node_modules/lodash-es/wrapperLodash.js
var objectProto8 = Object.prototype;
var hasOwnProperty5 = objectProto8.hasOwnProperty;
function lodash(value2) {
  if (isObjectLike_default(value2) && !isArray_default(value2) && !(value2 instanceof LazyWrapper_default)) {
    if (value2 instanceof LodashWrapper_default) {
      return value2;
    }
    if (hasOwnProperty5.call(value2, "__wrapped__")) {
      return wrapperClone_default(value2);
    }
  }
  return new LodashWrapper_default(value2);
}
lodash.prototype = baseLodash_default.prototype;
lodash.prototype.constructor = lodash;
var wrapperLodash_default = lodash;

// node_modules/lodash-es/_isLaziable.js
function isLaziable(func) {
  var funcName = getFuncName_default(func), other = wrapperLodash_default[funcName];
  if (typeof other != "function" || !(funcName in LazyWrapper_default.prototype)) {
    return false;
  }
  if (func === other) {
    return true;
  }
  var data2 = getData_default(other);
  return !!data2 && func === data2[0];
}
var isLaziable_default = isLaziable;

// node_modules/lodash-es/_shortOut.js
var HOT_COUNT = 800;
var HOT_SPAN = 16;
var nativeNow = Date.now;
function shortOut(func) {
  var count4 = 0, lastCalled = 0;
  return function() {
    var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
    lastCalled = stamp;
    if (remaining > 0) {
      if (++count4 >= HOT_COUNT) {
        return arguments[0];
      }
    } else {
      count4 = 0;
    }
    return func.apply(void 0, arguments);
  };
}
var shortOut_default = shortOut;

// node_modules/lodash-es/_setData.js
var setData3 = shortOut_default(baseSetData_default);
var setData_default = setData3;

// node_modules/lodash-es/_getWrapDetails.js
var reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/;
var reSplitDetails = /,? & /;
function getWrapDetails(source) {
  var match = source.match(reWrapDetails);
  return match ? match[1].split(reSplitDetails) : [];
}
var getWrapDetails_default = getWrapDetails;

// node_modules/lodash-es/_insertWrapDetails.js
var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/;
function insertWrapDetails(source, details) {
  var length5 = details.length;
  if (!length5) {
    return source;
  }
  var lastIndex = length5 - 1;
  details[lastIndex] = (length5 > 1 ? "& " : "") + details[lastIndex];
  details = details.join(length5 > 2 ? ", " : " ");
  return source.replace(reWrapComment, "{\n/* [wrapped with " + details + "] */\n");
}
var insertWrapDetails_default = insertWrapDetails;

// node_modules/lodash-es/constant.js
function constant4(value2) {
  return function() {
    return value2;
  };
}
var constant_default6 = constant4;

// node_modules/lodash-es/_defineProperty.js
var defineProperty = function() {
  try {
    var func = getNative_default(Object, "defineProperty");
    func({}, "", {});
    return func;
  } catch (e) {
  }
}();
var defineProperty_default = defineProperty;

// node_modules/lodash-es/_baseSetToString.js
var baseSetToString = !defineProperty_default ? identity_default8 : function(func, string) {
  return defineProperty_default(func, "toString", {
    "configurable": true,
    "enumerable": false,
    "value": constant_default6(string),
    "writable": true
  });
};
var baseSetToString_default = baseSetToString;

// node_modules/lodash-es/_setToString.js
var setToString = shortOut_default(baseSetToString_default);
var setToString_default = setToString;

// node_modules/lodash-es/_arrayEach.js
function arrayEach(array2, iteratee2) {
  var index3 = -1, length5 = array2 == null ? 0 : array2.length;
  while (++index3 < length5) {
    if (iteratee2(array2[index3], index3, array2) === false) {
      break;
    }
  }
  return array2;
}
var arrayEach_default = arrayEach;

// node_modules/lodash-es/_baseFindIndex.js
function baseFindIndex(array2, predicate, fromIndex, fromRight) {
  var length5 = array2.length, index3 = fromIndex + (fromRight ? 1 : -1);
  while (fromRight ? index3-- : ++index3 < length5) {
    if (predicate(array2[index3], index3, array2)) {
      return index3;
    }
  }
  return -1;
}
var baseFindIndex_default = baseFindIndex;

// node_modules/lodash-es/_baseIsNaN.js
function baseIsNaN(value2) {
  return value2 !== value2;
}
var baseIsNaN_default = baseIsNaN;

// node_modules/lodash-es/_strictIndexOf.js
function strictIndexOf(array2, value2, fromIndex) {
  var index3 = fromIndex - 1, length5 = array2.length;
  while (++index3 < length5) {
    if (array2[index3] === value2) {
      return index3;
    }
  }
  return -1;
}
var strictIndexOf_default = strictIndexOf;

// node_modules/lodash-es/_baseIndexOf.js
function baseIndexOf(array2, value2, fromIndex) {
  return value2 === value2 ? strictIndexOf_default(array2, value2, fromIndex) : baseFindIndex_default(array2, baseIsNaN_default, fromIndex);
}
var baseIndexOf_default = baseIndexOf;

// node_modules/lodash-es/_arrayIncludes.js
function arrayIncludes(array2, value2) {
  var length5 = array2 == null ? 0 : array2.length;
  return !!length5 && baseIndexOf_default(array2, value2, 0) > -1;
}
var arrayIncludes_default = arrayIncludes;

// node_modules/lodash-es/_updateWrapDetails.js
var WRAP_BIND_FLAG2 = 1;
var WRAP_BIND_KEY_FLAG = 2;
var WRAP_CURRY_FLAG = 8;
var WRAP_CURRY_RIGHT_FLAG = 16;
var WRAP_PARTIAL_FLAG = 32;
var WRAP_PARTIAL_RIGHT_FLAG = 64;
var WRAP_ARY_FLAG = 128;
var WRAP_REARG_FLAG = 256;
var WRAP_FLIP_FLAG = 512;
var wrapFlags = [
  ["ary", WRAP_ARY_FLAG],
  ["bind", WRAP_BIND_FLAG2],
  ["bindKey", WRAP_BIND_KEY_FLAG],
  ["curry", WRAP_CURRY_FLAG],
  ["curryRight", WRAP_CURRY_RIGHT_FLAG],
  ["flip", WRAP_FLIP_FLAG],
  ["partial", WRAP_PARTIAL_FLAG],
  ["partialRight", WRAP_PARTIAL_RIGHT_FLAG],
  ["rearg", WRAP_REARG_FLAG]
];
function updateWrapDetails(details, bitmask) {
  arrayEach_default(wrapFlags, function(pair) {
    var value2 = "_." + pair[0];
    if (bitmask & pair[1] && !arrayIncludes_default(details, value2)) {
      details.push(value2);
    }
  });
  return details.sort();
}
var updateWrapDetails_default = updateWrapDetails;

// node_modules/lodash-es/_setWrapToString.js
function setWrapToString(wrapper, reference, bitmask) {
  var source = reference + "";
  return setToString_default(wrapper, insertWrapDetails_default(source, updateWrapDetails_default(getWrapDetails_default(source), bitmask)));
}
var setWrapToString_default = setWrapToString;

// node_modules/lodash-es/_createRecurry.js
var WRAP_BIND_FLAG3 = 1;
var WRAP_BIND_KEY_FLAG2 = 2;
var WRAP_CURRY_BOUND_FLAG = 4;
var WRAP_CURRY_FLAG2 = 8;
var WRAP_PARTIAL_FLAG2 = 32;
var WRAP_PARTIAL_RIGHT_FLAG2 = 64;
function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary2, arity) {
  var isCurry = bitmask & WRAP_CURRY_FLAG2, newHolders = isCurry ? holders : void 0, newHoldersRight = isCurry ? void 0 : holders, newPartials = isCurry ? partials : void 0, newPartialsRight = isCurry ? void 0 : partials;
  bitmask |= isCurry ? WRAP_PARTIAL_FLAG2 : WRAP_PARTIAL_RIGHT_FLAG2;
  bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG2 : WRAP_PARTIAL_FLAG2);
  if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {
    bitmask &= ~(WRAP_BIND_FLAG3 | WRAP_BIND_KEY_FLAG2);
  }
  var newData = [
    func,
    bitmask,
    thisArg,
    newPartials,
    newHolders,
    newPartialsRight,
    newHoldersRight,
    argPos,
    ary2,
    arity
  ];
  var result2 = wrapFunc.apply(void 0, newData);
  if (isLaziable_default(func)) {
    setData_default(result2, newData);
  }
  result2.placeholder = placeholder;
  return setWrapToString_default(result2, func, bitmask);
}
var createRecurry_default = createRecurry;

// node_modules/lodash-es/_getHolder.js
function getHolder(func) {
  var object = func;
  return object.placeholder;
}
var getHolder_default = getHolder;

// node_modules/lodash-es/_isIndex.js
var MAX_SAFE_INTEGER = 9007199254740991;
var reIsUint = /^(?:0|[1-9]\d*)$/;
function isIndex(value2, length5) {
  var type = typeof value2;
  length5 = length5 == null ? MAX_SAFE_INTEGER : length5;
  return !!length5 && (type == "number" || type != "symbol" && reIsUint.test(value2)) && (value2 > -1 && value2 % 1 == 0 && value2 < length5);
}
var isIndex_default = isIndex;

// node_modules/lodash-es/_reorder.js
var nativeMin = Math.min;
function reorder2(array2, indexes2) {
  var arrLength = array2.length, length5 = nativeMin(indexes2.length, arrLength), oldArray = copyArray_default(array2);
  while (length5--) {
    var index3 = indexes2[length5];
    array2[length5] = isIndex_default(index3, arrLength) ? oldArray[index3] : void 0;
  }
  return array2;
}
var reorder_default = reorder2;

// node_modules/lodash-es/_replaceHolders.js
var PLACEHOLDER = "__lodash_placeholder__";
function replaceHolders(array2, placeholder) {
  var index3 = -1, length5 = array2.length, resIndex = 0, result2 = [];
  while (++index3 < length5) {
    var value2 = array2[index3];
    if (value2 === placeholder || value2 === PLACEHOLDER) {
      array2[index3] = PLACEHOLDER;
      result2[resIndex++] = index3;
    }
  }
  return result2;
}
var replaceHolders_default = replaceHolders;

// node_modules/lodash-es/_createHybrid.js
var WRAP_BIND_FLAG4 = 1;
var WRAP_BIND_KEY_FLAG3 = 2;
var WRAP_CURRY_FLAG3 = 8;
var WRAP_CURRY_RIGHT_FLAG2 = 16;
var WRAP_ARY_FLAG2 = 128;
var WRAP_FLIP_FLAG2 = 512;
function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary2, arity) {
  var isAry = bitmask & WRAP_ARY_FLAG2, isBind = bitmask & WRAP_BIND_FLAG4, isBindKey = bitmask & WRAP_BIND_KEY_FLAG3, isCurried = bitmask & (WRAP_CURRY_FLAG3 | WRAP_CURRY_RIGHT_FLAG2), isFlip = bitmask & WRAP_FLIP_FLAG2, Ctor = isBindKey ? void 0 : createCtor_default(func);
  function wrapper() {
    var length5 = arguments.length, args = Array(length5), index3 = length5;
    while (index3--) {
      args[index3] = arguments[index3];
    }
    if (isCurried) {
      var placeholder = getHolder_default(wrapper), holdersCount = countHolders_default(args, placeholder);
    }
    if (partials) {
      args = composeArgs_default(args, partials, holders, isCurried);
    }
    if (partialsRight) {
      args = composeArgsRight_default(args, partialsRight, holdersRight, isCurried);
    }
    length5 -= holdersCount;
    if (isCurried && length5 < arity) {
      var newHolders = replaceHolders_default(args, placeholder);
      return createRecurry_default(
        func,
        bitmask,
        createHybrid,
        wrapper.placeholder,
        thisArg,
        args,
        newHolders,
        argPos,
        ary2,
        arity - length5
      );
    }
    var thisBinding = isBind ? thisArg : this, fn = isBindKey ? thisBinding[func] : func;
    length5 = args.length;
    if (argPos) {
      args = reorder_default(args, argPos);
    } else if (isFlip && length5 > 1) {
      args.reverse();
    }
    if (isAry && ary2 < length5) {
      args.length = ary2;
    }
    if (this && this !== root_default2 && this instanceof wrapper) {
      fn = Ctor || createCtor_default(fn);
    }
    return fn.apply(thisBinding, args);
  }
  return wrapper;
}
var createHybrid_default = createHybrid;

// node_modules/lodash-es/_createCurry.js
function createCurry(func, bitmask, arity) {
  var Ctor = createCtor_default(func);
  function wrapper() {
    var length5 = arguments.length, args = Array(length5), index3 = length5, placeholder = getHolder_default(wrapper);
    while (index3--) {
      args[index3] = arguments[index3];
    }
    var holders = length5 < 3 && args[0] !== placeholder && args[length5 - 1] !== placeholder ? [] : replaceHolders_default(args, placeholder);
    length5 -= holders.length;
    if (length5 < arity) {
      return createRecurry_default(
        func,
        bitmask,
        createHybrid_default,
        wrapper.placeholder,
        void 0,
        args,
        holders,
        void 0,
        void 0,
        arity - length5
      );
    }
    var fn = this && this !== root_default2 && this instanceof wrapper ? Ctor : func;
    return apply_default(fn, this, args);
  }
  return wrapper;
}
var createCurry_default = createCurry;

// node_modules/lodash-es/_createPartial.js
var WRAP_BIND_FLAG5 = 1;
function createPartial(func, bitmask, thisArg, partials) {
  var isBind = bitmask & WRAP_BIND_FLAG5, Ctor = createCtor_default(func);
  function wrapper() {
    var argsIndex = -1, argsLength = arguments.length, leftIndex = -1, leftLength = partials.length, args = Array(leftLength + argsLength), fn = this && this !== root_default2 && this instanceof wrapper ? Ctor : func;
    while (++leftIndex < leftLength) {
      args[leftIndex] = partials[leftIndex];
    }
    while (argsLength--) {
      args[leftIndex++] = arguments[++argsIndex];
    }
    return apply_default(fn, isBind ? thisArg : this, args);
  }
  return wrapper;
}
var createPartial_default = createPartial;

// node_modules/lodash-es/_mergeData.js
var PLACEHOLDER2 = "__lodash_placeholder__";
var WRAP_BIND_FLAG6 = 1;
var WRAP_BIND_KEY_FLAG4 = 2;
var WRAP_CURRY_BOUND_FLAG2 = 4;
var WRAP_CURRY_FLAG4 = 8;
var WRAP_ARY_FLAG3 = 128;
var WRAP_REARG_FLAG2 = 256;
var nativeMin2 = Math.min;
function mergeData2(data2, source) {
  var bitmask = data2[1], srcBitmask = source[1], newBitmask = bitmask | srcBitmask, isCommon = newBitmask < (WRAP_BIND_FLAG6 | WRAP_BIND_KEY_FLAG4 | WRAP_ARY_FLAG3);
  var isCombo = srcBitmask == WRAP_ARY_FLAG3 && bitmask == WRAP_CURRY_FLAG4 || srcBitmask == WRAP_ARY_FLAG3 && bitmask == WRAP_REARG_FLAG2 && data2[7].length <= source[8] || srcBitmask == (WRAP_ARY_FLAG3 | WRAP_REARG_FLAG2) && source[7].length <= source[8] && bitmask == WRAP_CURRY_FLAG4;
  if (!(isCommon || isCombo)) {
    return data2;
  }
  if (srcBitmask & WRAP_BIND_FLAG6) {
    data2[2] = source[2];
    newBitmask |= bitmask & WRAP_BIND_FLAG6 ? 0 : WRAP_CURRY_BOUND_FLAG2;
  }
  var value2 = source[3];
  if (value2) {
    var partials = data2[3];
    data2[3] = partials ? composeArgs_default(partials, value2, source[4]) : value2;
    data2[4] = partials ? replaceHolders_default(data2[3], PLACEHOLDER2) : source[4];
  }
  value2 = source[5];
  if (value2) {
    partials = data2[5];
    data2[5] = partials ? composeArgsRight_default(partials, value2, source[6]) : value2;
    data2[6] = partials ? replaceHolders_default(data2[5], PLACEHOLDER2) : source[6];
  }
  value2 = source[7];
  if (value2) {
    data2[7] = value2;
  }
  if (srcBitmask & WRAP_ARY_FLAG3) {
    data2[8] = data2[8] == null ? source[8] : nativeMin2(data2[8], source[8]);
  }
  if (data2[9] == null) {
    data2[9] = source[9];
  }
  data2[0] = source[0];
  data2[1] = newBitmask;
  return data2;
}
var mergeData_default = mergeData2;

// node_modules/lodash-es/_createWrap.js
var FUNC_ERROR_TEXT2 = "Expected a function";
var WRAP_BIND_FLAG7 = 1;
var WRAP_BIND_KEY_FLAG5 = 2;
var WRAP_CURRY_FLAG5 = 8;
var WRAP_CURRY_RIGHT_FLAG3 = 16;
var WRAP_PARTIAL_FLAG3 = 32;
var WRAP_PARTIAL_RIGHT_FLAG3 = 64;
var nativeMax3 = Math.max;
function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary2, arity) {
  var isBindKey = bitmask & WRAP_BIND_KEY_FLAG5;
  if (!isBindKey && typeof func != "function") {
    throw new TypeError(FUNC_ERROR_TEXT2);
  }
  var length5 = partials ? partials.length : 0;
  if (!length5) {
    bitmask &= ~(WRAP_PARTIAL_FLAG3 | WRAP_PARTIAL_RIGHT_FLAG3);
    partials = holders = void 0;
  }
  ary2 = ary2 === void 0 ? ary2 : nativeMax3(toInteger_default(ary2), 0);
  arity = arity === void 0 ? arity : toInteger_default(arity);
  length5 -= holders ? holders.length : 0;
  if (bitmask & WRAP_PARTIAL_RIGHT_FLAG3) {
    var partialsRight = partials, holdersRight = holders;
    partials = holders = void 0;
  }
  var data2 = isBindKey ? void 0 : getData_default(func);
  var newData = [
    func,
    bitmask,
    thisArg,
    partials,
    holders,
    partialsRight,
    holdersRight,
    argPos,
    ary2,
    arity
  ];
  if (data2) {
    mergeData_default(newData, data2);
  }
  func = newData[0];
  bitmask = newData[1];
  thisArg = newData[2];
  partials = newData[3];
  holders = newData[4];
  arity = newData[9] = newData[9] === void 0 ? isBindKey ? 0 : func.length : nativeMax3(newData[9] - length5, 0);
  if (!arity && bitmask & (WRAP_CURRY_FLAG5 | WRAP_CURRY_RIGHT_FLAG3)) {
    bitmask &= ~(WRAP_CURRY_FLAG5 | WRAP_CURRY_RIGHT_FLAG3);
  }
  if (!bitmask || bitmask == WRAP_BIND_FLAG7) {
    var result2 = createBind_default(func, bitmask, thisArg);
  } else if (bitmask == WRAP_CURRY_FLAG5 || bitmask == WRAP_CURRY_RIGHT_FLAG3) {
    result2 = createCurry_default(func, bitmask, arity);
  } else if ((bitmask == WRAP_PARTIAL_FLAG3 || bitmask == (WRAP_BIND_FLAG7 | WRAP_PARTIAL_FLAG3)) && !holders.length) {
    result2 = createPartial_default(func, bitmask, thisArg, partials);
  } else {
    result2 = createHybrid_default.apply(void 0, newData);
  }
  var setter = data2 ? baseSetData_default : setData_default;
  return setWrapToString_default(setter(result2, newData), func, bitmask);
}
var createWrap_default = createWrap;

// node_modules/lodash-es/ary.js
var WRAP_ARY_FLAG4 = 128;
function ary(func, n, guard) {
  n = guard ? void 0 : n;
  n = func && n == null ? func.length : n;
  return createWrap_default(func, WRAP_ARY_FLAG4, void 0, void 0, void 0, void 0, n);
}
var ary_default = ary;

// node_modules/lodash-es/_baseAssignValue.js
function baseAssignValue(object, key, value2) {
  if (key == "__proto__" && defineProperty_default) {
    defineProperty_default(object, key, {
      "configurable": true,
      "enumerable": true,
      "value": value2,
      "writable": true
    });
  } else {
    object[key] = value2;
  }
}
var baseAssignValue_default = baseAssignValue;

// node_modules/lodash-es/eq.js
function eq(value2, other) {
  return value2 === other || value2 !== value2 && other !== other;
}
var eq_default = eq;

// node_modules/lodash-es/_assignValue.js
var objectProto9 = Object.prototype;
var hasOwnProperty6 = objectProto9.hasOwnProperty;
function assignValue(object, key, value2) {
  var objValue = object[key];
  if (!(hasOwnProperty6.call(object, key) && eq_default(objValue, value2)) || value2 === void 0 && !(key in object)) {
    baseAssignValue_default(object, key, value2);
  }
}
var assignValue_default = assignValue;

// node_modules/lodash-es/_copyObject.js
function copyObject(source, props, object, customizer) {
  var isNew = !object;
  object || (object = {});
  var index3 = -1, length5 = props.length;
  while (++index3 < length5) {
    var key = props[index3];
    var newValue = customizer ? customizer(object[key], source[key], key, object, source) : void 0;
    if (newValue === void 0) {
      newValue = source[key];
    }
    if (isNew) {
      baseAssignValue_default(object, key, newValue);
    } else {
      assignValue_default(object, key, newValue);
    }
  }
  return object;
}
var copyObject_default = copyObject;

// node_modules/lodash-es/_overRest.js
var nativeMax4 = Math.max;
function overRest(func, start, transform3) {
  start = nativeMax4(start === void 0 ? func.length - 1 : start, 0);
  return function() {
    var args = arguments, index3 = -1, length5 = nativeMax4(args.length - start, 0), array2 = Array(length5);
    while (++index3 < length5) {
      array2[index3] = args[start + index3];
    }
    index3 = -1;
    var otherArgs = Array(start + 1);
    while (++index3 < start) {
      otherArgs[index3] = args[index3];
    }
    otherArgs[start] = transform3(array2);
    return apply_default(func, this, otherArgs);
  };
}
var overRest_default = overRest;

// node_modules/lodash-es/_baseRest.js
function baseRest(func, start) {
  return setToString_default(overRest_default(func, start, identity_default8), func + "");
}
var baseRest_default = baseRest;

// node_modules/lodash-es/isLength.js
var MAX_SAFE_INTEGER2 = 9007199254740991;
function isLength(value2) {
  return typeof value2 == "number" && value2 > -1 && value2 % 1 == 0 && value2 <= MAX_SAFE_INTEGER2;
}
var isLength_default = isLength;

// node_modules/lodash-es/isArrayLike.js
function isArrayLike3(value2) {
  return value2 != null && isLength_default(value2.length) && !isFunction_default(value2);
}
var isArrayLike_default = isArrayLike3;

// node_modules/lodash-es/_isIterateeCall.js
function isIterateeCall(value2, index3, object) {
  if (!isObject_default(object)) {
    return false;
  }
  var type = typeof index3;
  if (type == "number" ? isArrayLike_default(object) && isIndex_default(index3, object.length) : type == "string" && index3 in object) {
    return eq_default(object[index3], value2);
  }
  return false;
}
var isIterateeCall_default = isIterateeCall;

// node_modules/lodash-es/_createAssigner.js
function createAssigner(assigner) {
  return baseRest_default(function(object, sources) {
    var index3 = -1, length5 = sources.length, customizer = length5 > 1 ? sources[length5 - 1] : void 0, guard = length5 > 2 ? sources[2] : void 0;
    customizer = assigner.length > 3 && typeof customizer == "function" ? (length5--, customizer) : void 0;
    if (guard && isIterateeCall_default(sources[0], sources[1], guard)) {
      customizer = length5 < 3 ? void 0 : customizer;
      length5 = 1;
    }
    object = Object(object);
    while (++index3 < length5) {
      var source = sources[index3];
      if (source) {
        assigner(object, source, index3, customizer);
      }
    }
    return object;
  });
}
var createAssigner_default = createAssigner;

// node_modules/lodash-es/_isPrototype.js
var objectProto10 = Object.prototype;
function isPrototype(value2) {
  var Ctor = value2 && value2.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto10;
  return value2 === proto;
}
var isPrototype_default = isPrototype;

// node_modules/lodash-es/_baseTimes.js
function baseTimes(n, iteratee2) {
  var index3 = -1, result2 = Array(n);
  while (++index3 < n) {
    result2[index3] = iteratee2(index3);
  }
  return result2;
}
var baseTimes_default = baseTimes;

// node_modules/lodash-es/_baseIsArguments.js
var argsTag = "[object Arguments]";
function baseIsArguments(value2) {
  return isObjectLike_default(value2) && baseGetTag_default(value2) == argsTag;
}
var baseIsArguments_default = baseIsArguments;

// node_modules/lodash-es/isArguments.js
var objectProto11 = Object.prototype;
var hasOwnProperty7 = objectProto11.hasOwnProperty;
var propertyIsEnumerable = objectProto11.propertyIsEnumerable;
var isArguments = baseIsArguments_default(function() {
  return arguments;
}()) ? baseIsArguments_default : function(value2) {
  return isObjectLike_default(value2) && hasOwnProperty7.call(value2, "callee") && !propertyIsEnumerable.call(value2, "callee");
};
var isArguments_default = isArguments;

// node_modules/lodash-es/stubFalse.js
function stubFalse() {
  return false;
}
var stubFalse_default = stubFalse;

// node_modules/lodash-es/isBuffer.js
var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
var moduleExports = freeModule && freeModule.exports === freeExports;
var Buffer = moduleExports ? root_default2.Buffer : void 0;
var nativeIsBuffer = Buffer ? Buffer.isBuffer : void 0;
var isBuffer = nativeIsBuffer || stubFalse_default;
var isBuffer_default = isBuffer;

// node_modules/lodash-es/_baseIsTypedArray.js
var argsTag2 = "[object Arguments]";
var arrayTag = "[object Array]";
var boolTag = "[object Boolean]";
var dateTag = "[object Date]";
var errorTag = "[object Error]";
var funcTag2 = "[object Function]";
var mapTag = "[object Map]";
var numberTag = "[object Number]";
var objectTag = "[object Object]";
var regexpTag = "[object RegExp]";
var setTag = "[object Set]";
var stringTag = "[object String]";
var weakMapTag = "[object WeakMap]";
var arrayBufferTag = "[object ArrayBuffer]";
var dataViewTag = "[object DataView]";
var float32Tag = "[object Float32Array]";
var float64Tag = "[object Float64Array]";
var int8Tag = "[object Int8Array]";
var int16Tag = "[object Int16Array]";
var int32Tag = "[object Int32Array]";
var uint8Tag = "[object Uint8Array]";
var uint8ClampedTag = "[object Uint8ClampedArray]";
var uint16Tag = "[object Uint16Array]";
var uint32Tag = "[object Uint32Array]";
var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag2] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag2] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
function baseIsTypedArray(value2) {
  return isObjectLike_default(value2) && isLength_default(value2.length) && !!typedArrayTags[baseGetTag_default(value2)];
}
var baseIsTypedArray_default = baseIsTypedArray;

// node_modules/lodash-es/_baseUnary.js
function baseUnary(func) {
  return function(value2) {
    return func(value2);
  };
}
var baseUnary_default = baseUnary;

// node_modules/lodash-es/_nodeUtil.js
var freeExports2 = typeof exports == "object" && exports && !exports.nodeType && exports;
var freeModule2 = freeExports2 && typeof module == "object" && module && !module.nodeType && module;
var moduleExports2 = freeModule2 && freeModule2.exports === freeExports2;
var freeProcess = moduleExports2 && freeGlobal_default.process;
var nodeUtil = function() {
  try {
    var types = freeModule2 && freeModule2.require && freeModule2.require("util").types;
    if (types) {
      return types;
    }
    return freeProcess && freeProcess.binding && freeProcess.binding("util");
  } catch (e) {
  }
}();
var nodeUtil_default = nodeUtil;

// node_modules/lodash-es/isTypedArray.js
var nodeIsTypedArray = nodeUtil_default && nodeUtil_default.isTypedArray;
var isTypedArray = nodeIsTypedArray ? baseUnary_default(nodeIsTypedArray) : baseIsTypedArray_default;
var isTypedArray_default = isTypedArray;

// node_modules/lodash-es/_arrayLikeKeys.js
var objectProto12 = Object.prototype;
var hasOwnProperty8 = objectProto12.hasOwnProperty;
function arrayLikeKeys(value2, inherited) {
  var isArr = isArray_default(value2), isArg = !isArr && isArguments_default(value2), isBuff = !isArr && !isArg && isBuffer_default(value2), isType4 = !isArr && !isArg && !isBuff && isTypedArray_default(value2), skipIndexes = isArr || isArg || isBuff || isType4, result2 = skipIndexes ? baseTimes_default(value2.length, String) : [], length5 = result2.length;
  for (var key in value2) {
    if ((inherited || hasOwnProperty8.call(value2, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
    (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
    isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
    isType4 && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
    isIndex_default(key, length5)))) {
      result2.push(key);
    }
  }
  return result2;
}
var arrayLikeKeys_default = arrayLikeKeys;

// node_modules/lodash-es/_overArg.js
function overArg(func, transform3) {
  return function(arg) {
    return func(transform3(arg));
  };
}
var overArg_default = overArg;

// node_modules/lodash-es/_nativeKeys.js
var nativeKeys = overArg_default(Object.keys, Object);
var nativeKeys_default = nativeKeys;

// node_modules/lodash-es/_baseKeys.js
var objectProto13 = Object.prototype;
var hasOwnProperty9 = objectProto13.hasOwnProperty;
function baseKeys(object) {
  if (!isPrototype_default(object)) {
    return nativeKeys_default(object);
  }
  var result2 = [];
  for (var key in Object(object)) {
    if (hasOwnProperty9.call(object, key) && key != "constructor") {
      result2.push(key);
    }
  }
  return result2;
}
var baseKeys_default = baseKeys;

// node_modules/lodash-es/keys.js
function keys2(object) {
  return isArrayLike_default(object) ? arrayLikeKeys_default(object) : baseKeys_default(object);
}
var keys_default4 = keys2;

// node_modules/lodash-es/assign.js
var objectProto14 = Object.prototype;
var hasOwnProperty10 = objectProto14.hasOwnProperty;
var assign2 = createAssigner_default(function(object, source) {
  if (isPrototype_default(source) || isArrayLike_default(source)) {
    copyObject_default(source, keys_default4(source), object);
    return;
  }
  for (var key in source) {
    if (hasOwnProperty10.call(source, key)) {
      assignValue_default(object, key, source[key]);
    }
  }
});
var assign_default = assign2;

// node_modules/lodash-es/_nativeKeysIn.js
function nativeKeysIn(object) {
  var result2 = [];
  if (object != null) {
    for (var key in Object(object)) {
      result2.push(key);
    }
  }
  return result2;
}
var nativeKeysIn_default = nativeKeysIn;

// node_modules/lodash-es/_baseKeysIn.js
var objectProto15 = Object.prototype;
var hasOwnProperty11 = objectProto15.hasOwnProperty;
function baseKeysIn(object) {
  if (!isObject_default(object)) {
    return nativeKeysIn_default(object);
  }
  var isProto = isPrototype_default(object), result2 = [];
  for (var key in object) {
    if (!(key == "constructor" && (isProto || !hasOwnProperty11.call(object, key)))) {
      result2.push(key);
    }
  }
  return result2;
}
var baseKeysIn_default = baseKeysIn;

// node_modules/lodash-es/keysIn.js
function keysIn(object) {
  return isArrayLike_default(object) ? arrayLikeKeys_default(object, true) : baseKeysIn_default(object);
}
var keysIn_default = keysIn;

// node_modules/lodash-es/assignIn.js
var assignIn = createAssigner_default(function(object, source) {
  copyObject_default(source, keysIn_default(source), object);
});
var assignIn_default = assignIn;

// node_modules/lodash-es/assignInWith.js
var assignInWith = createAssigner_default(function(object, source, srcIndex, customizer) {
  copyObject_default(source, keysIn_default(source), object, customizer);
});
var assignInWith_default = assignInWith;

// node_modules/lodash-es/assignWith.js
var assignWith = createAssigner_default(function(object, source, srcIndex, customizer) {
  copyObject_default(source, keys_default4(source), object, customizer);
});
var assignWith_default = assignWith;

// node_modules/lodash-es/_isKey.js
var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/;
var reIsPlainProp = /^\w*$/;
function isKey(value2, object) {
  if (isArray_default(value2)) {
    return false;
  }
  var type = typeof value2;
  if (type == "number" || type == "symbol" || type == "boolean" || value2 == null || isSymbol_default(value2)) {
    return true;
  }
  return reIsPlainProp.test(value2) || !reIsDeepProp.test(value2) || object != null && value2 in Object(object);
}
var isKey_default = isKey;

// node_modules/lodash-es/_nativeCreate.js
var nativeCreate = getNative_default(Object, "create");
var nativeCreate_default = nativeCreate;

// node_modules/lodash-es/_hashClear.js
function hashClear() {
  this.__data__ = nativeCreate_default ? nativeCreate_default(null) : {};
  this.size = 0;
}
var hashClear_default = hashClear;

// node_modules/lodash-es/_hashDelete.js
function hashDelete(key) {
  var result2 = this.has(key) && delete this.__data__[key];
  this.size -= result2 ? 1 : 0;
  return result2;
}
var hashDelete_default = hashDelete;

// node_modules/lodash-es/_hashGet.js
var HASH_UNDEFINED = "__lodash_hash_undefined__";
var objectProto16 = Object.prototype;
var hasOwnProperty12 = objectProto16.hasOwnProperty;
function hashGet(key) {
  var data2 = this.__data__;
  if (nativeCreate_default) {
    var result2 = data2[key];
    return result2 === HASH_UNDEFINED ? void 0 : result2;
  }
  return hasOwnProperty12.call(data2, key) ? data2[key] : void 0;
}
var hashGet_default = hashGet;

// node_modules/lodash-es/_hashHas.js
var objectProto17 = Object.prototype;
var hasOwnProperty13 = objectProto17.hasOwnProperty;
function hashHas(key) {
  var data2 = this.__data__;
  return nativeCreate_default ? data2[key] !== void 0 : hasOwnProperty13.call(data2, key);
}
var hashHas_default = hashHas;

// node_modules/lodash-es/_hashSet.js
var HASH_UNDEFINED2 = "__lodash_hash_undefined__";
function hashSet(key, value2) {
  var data2 = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data2[key] = nativeCreate_default && value2 === void 0 ? HASH_UNDEFINED2 : value2;
  return this;
}
var hashSet_default = hashSet;

// node_modules/lodash-es/_Hash.js
function Hash(entries) {
  var index3 = -1, length5 = entries == null ? 0 : entries.length;
  this.clear();
  while (++index3 < length5) {
    var entry = entries[index3];
    this.set(entry[0], entry[1]);
  }
}
Hash.prototype.clear = hashClear_default;
Hash.prototype["delete"] = hashDelete_default;
Hash.prototype.get = hashGet_default;
Hash.prototype.has = hashHas_default;
Hash.prototype.set = hashSet_default;
var Hash_default = Hash;

// node_modules/lodash-es/_listCacheClear.js
function listCacheClear() {
  this.__data__ = [];
  this.size = 0;
}
var listCacheClear_default = listCacheClear;

// node_modules/lodash-es/_assocIndexOf.js
function assocIndexOf(array2, key) {
  var length5 = array2.length;
  while (length5--) {
    if (eq_default(array2[length5][0], key)) {
      return length5;
    }
  }
  return -1;
}
var assocIndexOf_default = assocIndexOf;

// node_modules/lodash-es/_listCacheDelete.js
var arrayProto = Array.prototype;
var splice8 = arrayProto.splice;
function listCacheDelete(key) {
  var data2 = this.__data__, index3 = assocIndexOf_default(data2, key);
  if (index3 < 0) {
    return false;
  }
  var lastIndex = data2.length - 1;
  if (index3 == lastIndex) {
    data2.pop();
  } else {
    splice8.call(data2, index3, 1);
  }
  --this.size;
  return true;
}
var listCacheDelete_default = listCacheDelete;

// node_modules/lodash-es/_listCacheGet.js
function listCacheGet(key) {
  var data2 = this.__data__, index3 = assocIndexOf_default(data2, key);
  return index3 < 0 ? void 0 : data2[index3][1];
}
var listCacheGet_default = listCacheGet;

// node_modules/lodash-es/_listCacheHas.js
function listCacheHas(key) {
  return assocIndexOf_default(this.__data__, key) > -1;
}
var listCacheHas_default = listCacheHas;

// node_modules/lodash-es/_listCacheSet.js
function listCacheSet(key, value2) {
  var data2 = this.__data__, index3 = assocIndexOf_default(data2, key);
  if (index3 < 0) {
    ++this.size;
    data2.push([key, value2]);
  } else {
    data2[index3][1] = value2;
  }
  return this;
}
var listCacheSet_default = listCacheSet;

// node_modules/lodash-es/_ListCache.js
function ListCache(entries) {
  var index3 = -1, length5 = entries == null ? 0 : entries.length;
  this.clear();
  while (++index3 < length5) {
    var entry = entries[index3];
    this.set(entry[0], entry[1]);
  }
}
ListCache.prototype.clear = listCacheClear_default;
ListCache.prototype["delete"] = listCacheDelete_default;
ListCache.prototype.get = listCacheGet_default;
ListCache.prototype.has = listCacheHas_default;
ListCache.prototype.set = listCacheSet_default;
var ListCache_default = ListCache;

// node_modules/lodash-es/_Map.js
var Map3 = getNative_default(root_default2, "Map");
var Map_default = Map3;

// node_modules/lodash-es/_mapCacheClear.js
function mapCacheClear() {
  this.size = 0;
  this.__data__ = {
    "hash": new Hash_default(),
    "map": new (Map_default || ListCache_default)(),
    "string": new Hash_default()
  };
}
var mapCacheClear_default = mapCacheClear;

// node_modules/lodash-es/_isKeyable.js
function isKeyable(value2) {
  var type = typeof value2;
  return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value2 !== "__proto__" : value2 === null;
}
var isKeyable_default = isKeyable;

// node_modules/lodash-es/_getMapData.js
function getMapData(map5, key) {
  var data2 = map5.__data__;
  return isKeyable_default(key) ? data2[typeof key == "string" ? "string" : "hash"] : data2.map;
}
var getMapData_default = getMapData;

// node_modules/lodash-es/_mapCacheDelete.js
function mapCacheDelete(key) {
  var result2 = getMapData_default(this, key)["delete"](key);
  this.size -= result2 ? 1 : 0;
  return result2;
}
var mapCacheDelete_default = mapCacheDelete;

// node_modules/lodash-es/_mapCacheGet.js
function mapCacheGet(key) {
  return getMapData_default(this, key).get(key);
}
var mapCacheGet_default = mapCacheGet;

// node_modules/lodash-es/_mapCacheHas.js
function mapCacheHas(key) {
  return getMapData_default(this, key).has(key);
}
var mapCacheHas_default = mapCacheHas;

// node_modules/lodash-es/_mapCacheSet.js
function mapCacheSet(key, value2) {
  var data2 = getMapData_default(this, key), size5 = data2.size;
  data2.set(key, value2);
  this.size += data2.size == size5 ? 0 : 1;
  return this;
}
var mapCacheSet_default = mapCacheSet;

// node_modules/lodash-es/_MapCache.js
function MapCache(entries) {
  var index3 = -1, length5 = entries == null ? 0 : entries.length;
  this.clear();
  while (++index3 < length5) {
    var entry = entries[index3];
    this.set(entry[0], entry[1]);
  }
}
MapCache.prototype.clear = mapCacheClear_default;
MapCache.prototype["delete"] = mapCacheDelete_default;
MapCache.prototype.get = mapCacheGet_default;
MapCache.prototype.has = mapCacheHas_default;
MapCache.prototype.set = mapCacheSet_default;
var MapCache_default = MapCache;

// node_modules/lodash-es/memoize.js
var FUNC_ERROR_TEXT3 = "Expected a function";
function memoize2(func, resolver) {
  if (typeof func != "function" || resolver != null && typeof resolver != "function") {
    throw new TypeError(FUNC_ERROR_TEXT3);
  }
  var memoized = function() {
    var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache2 = memoized.cache;
    if (cache2.has(key)) {
      return cache2.get(key);
    }
    var result2 = func.apply(this, args);
    memoized.cache = cache2.set(key, result2) || cache2;
    return result2;
  };
  memoized.cache = new (memoize2.Cache || MapCache_default)();
  return memoized;
}
memoize2.Cache = MapCache_default;
var memoize_default4 = memoize2;

// node_modules/lodash-es/_memoizeCapped.js
var MAX_MEMOIZE_SIZE = 500;
function memoizeCapped(func) {
  var result2 = memoize_default4(func, function(key) {
    if (cache2.size === MAX_MEMOIZE_SIZE) {
      cache2.clear();
    }
    return key;
  });
  var cache2 = result2.cache;
  return result2;
}
var memoizeCapped_default = memoizeCapped;

// node_modules/lodash-es/_stringToPath.js
var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
var reEscapeChar = /\\(\\)?/g;
var stringToPath = memoizeCapped_default(function(string) {
  var result2 = [];
  if (string.charCodeAt(0) === 46) {
    result2.push("");
  }
  string.replace(rePropName, function(match, number2, quote, subString) {
    result2.push(quote ? subString.replace(reEscapeChar, "$1") : number2 || match);
  });
  return result2;
});
var stringToPath_default = stringToPath;

// node_modules/lodash-es/toString.js
function toString7(value2) {
  return value2 == null ? "" : baseToString_default(value2);
}
var toString_default = toString7;

// node_modules/lodash-es/_castPath.js
function castPath(value2, object) {
  if (isArray_default(value2)) {
    return value2;
  }
  return isKey_default(value2, object) ? [value2] : stringToPath_default(toString_default(value2));
}
var castPath_default = castPath;

// node_modules/lodash-es/_toKey.js
var INFINITY3 = 1 / 0;
function toKey(value2) {
  if (typeof value2 == "string" || isSymbol_default(value2)) {
    return value2;
  }
  var result2 = value2 + "";
  return result2 == "0" && 1 / value2 == -INFINITY3 ? "-0" : result2;
}
var toKey_default = toKey;

// node_modules/lodash-es/_baseGet.js
function baseGet(object, path2) {
  path2 = castPath_default(path2, object);
  var index3 = 0, length5 = path2.length;
  while (object != null && index3 < length5) {
    object = object[toKey_default(path2[index3++])];
  }
  return index3 && index3 == length5 ? object : void 0;
}
var baseGet_default = baseGet;

// node_modules/lodash-es/get.js
function get2(object, path2, defaultValue) {
  var result2 = object == null ? void 0 : baseGet_default(object, path2);
  return result2 === void 0 ? defaultValue : result2;
}
var get_default4 = get2;

// node_modules/lodash-es/_baseAt.js
function baseAt(object, paths) {
  var index3 = -1, length5 = paths.length, result2 = Array(length5), skip = object == null;
  while (++index3 < length5) {
    result2[index3] = skip ? void 0 : get_default4(object, paths[index3]);
  }
  return result2;
}
var baseAt_default = baseAt;

// node_modules/lodash-es/_arrayPush.js
function arrayPush(array2, values4) {
  var index3 = -1, length5 = values4.length, offset2 = array2.length;
  while (++index3 < length5) {
    array2[offset2 + index3] = values4[index3];
  }
  return array2;
}
var arrayPush_default = arrayPush;

// node_modules/lodash-es/_isFlattenable.js
var spreadableSymbol = Symbol_default ? Symbol_default.isConcatSpreadable : void 0;
function isFlattenable(value2) {
  return isArray_default(value2) || isArguments_default(value2) || !!(spreadableSymbol && value2 && value2[spreadableSymbol]);
}
var isFlattenable_default = isFlattenable;

// node_modules/lodash-es/_baseFlatten.js
function baseFlatten(array2, depth, predicate, isStrict, result2) {
  var index3 = -1, length5 = array2.length;
  predicate || (predicate = isFlattenable_default);
  result2 || (result2 = []);
  while (++index3 < length5) {
    var value2 = array2[index3];
    if (depth > 0 && predicate(value2)) {
      if (depth > 1) {
        baseFlatten(value2, depth - 1, predicate, isStrict, result2);
      } else {
        arrayPush_default(result2, value2);
      }
    } else if (!isStrict) {
      result2[result2.length] = value2;
    }
  }
  return result2;
}
var baseFlatten_default = baseFlatten;

// node_modules/lodash-es/flatten.js
function flatten2(array2) {
  var length5 = array2 == null ? 0 : array2.length;
  return length5 ? baseFlatten_default(array2, 1) : [];
}
var flatten_default4 = flatten2;

// node_modules/lodash-es/_flatRest.js
function flatRest(func) {
  return setToString_default(overRest_default(func, void 0, flatten_default4), func + "");
}
var flatRest_default = flatRest;

// node_modules/lodash-es/at.js
var at = flatRest_default(baseAt_default);
var at_default = at;

// node_modules/lodash-es/_getPrototype.js
var getPrototype = overArg_default(Object.getPrototypeOf, Object);
var getPrototype_default = getPrototype;

// node_modules/lodash-es/isPlainObject.js
var objectTag2 = "[object Object]";
var funcProto3 = Function.prototype;
var objectProto18 = Object.prototype;
var funcToString3 = funcProto3.toString;
var hasOwnProperty14 = objectProto18.hasOwnProperty;
var objectCtorString = funcToString3.call(Object);
function isPlainObject4(value2) {
  if (!isObjectLike_default(value2) || baseGetTag_default(value2) != objectTag2) {
    return false;
  }
  var proto = getPrototype_default(value2);
  if (proto === null) {
    return true;
  }
  var Ctor = hasOwnProperty14.call(proto, "constructor") && proto.constructor;
  return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString3.call(Ctor) == objectCtorString;
}
var isPlainObject_default = isPlainObject4;

// node_modules/lodash-es/isError.js
var domExcTag = "[object DOMException]";
var errorTag2 = "[object Error]";
function isError(value2) {
  if (!isObjectLike_default(value2)) {
    return false;
  }
  var tag = baseGetTag_default(value2);
  return tag == errorTag2 || tag == domExcTag || typeof value2.message == "string" && typeof value2.name == "string" && !isPlainObject_default(value2);
}
var isError_default = isError;

// node_modules/lodash-es/attempt.js
var attempt = baseRest_default(function(func, args) {
  try {
    return apply_default(func, void 0, args);
  } catch (e) {
    return isError_default(e) ? e : new Error(e);
  }
});
var attempt_default = attempt;

// node_modules/lodash-es/before.js
var FUNC_ERROR_TEXT4 = "Expected a function";
function before(n, func) {
  var result2;
  if (typeof func != "function") {
    throw new TypeError(FUNC_ERROR_TEXT4);
  }
  n = toInteger_default(n);
  return function() {
    if (--n > 0) {
      result2 = func.apply(this, arguments);
    }
    if (n <= 1) {
      func = void 0;
    }
    return result2;
  };
}
var before_default = before;

// node_modules/lodash-es/bind.js
var WRAP_BIND_FLAG8 = 1;
var WRAP_PARTIAL_FLAG4 = 32;
var bind = baseRest_default(function(func, thisArg, partials) {
  var bitmask = WRAP_BIND_FLAG8;
  if (partials.length) {
    var holders = replaceHolders_default(partials, getHolder_default(bind));
    bitmask |= WRAP_PARTIAL_FLAG4;
  }
  return createWrap_default(func, bitmask, thisArg, partials, holders);
});
bind.placeholder = {};
var bind_default = bind;

// node_modules/lodash-es/bindAll.js
var bindAll = flatRest_default(function(object, methodNames) {
  arrayEach_default(methodNames, function(key) {
    key = toKey_default(key);
    baseAssignValue_default(object, key, bind_default(object[key], object));
  });
  return object;
});
var bindAll_default = bindAll;

// node_modules/lodash-es/bindKey.js
var WRAP_BIND_FLAG9 = 1;
var WRAP_BIND_KEY_FLAG6 = 2;
var WRAP_PARTIAL_FLAG5 = 32;
var bindKey = baseRest_default(function(object, key, partials) {
  var bitmask = WRAP_BIND_FLAG9 | WRAP_BIND_KEY_FLAG6;
  if (partials.length) {
    var holders = replaceHolders_default(partials, getHolder_default(bindKey));
    bitmask |= WRAP_PARTIAL_FLAG5;
  }
  return createWrap_default(key, bitmask, object, partials, holders);
});
bindKey.placeholder = {};
var bindKey_default = bindKey;

// node_modules/lodash-es/_baseSlice.js
function baseSlice(array2, start, end) {
  var index3 = -1, length5 = array2.length;
  if (start < 0) {
    start = -start > length5 ? 0 : length5 + start;
  }
  end = end > length5 ? length5 : end;
  if (end < 0) {
    end += length5;
  }
  length5 = start > end ? 0 : end - start >>> 0;
  start >>>= 0;
  var result2 = Array(length5);
  while (++index3 < length5) {
    result2[index3] = array2[index3 + start];
  }
  return result2;
}
var baseSlice_default = baseSlice;

// node_modules/lodash-es/_castSlice.js
function castSlice(array2, start, end) {
  var length5 = array2.length;
  end = end === void 0 ? length5 : end;
  return !start && end >= length5 ? array2 : baseSlice_default(array2, start, end);
}
var castSlice_default = castSlice;

// node_modules/lodash-es/_hasUnicode.js
var rsAstralRange = "\\ud800-\\udfff";
var rsComboMarksRange = "\\u0300-\\u036f";
var reComboHalfMarksRange = "\\ufe20-\\ufe2f";
var rsComboSymbolsRange = "\\u20d0-\\u20ff";
var rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange;
var rsVarRange = "\\ufe0e\\ufe0f";
var rsZWJ = "\\u200d";
var reHasUnicode = RegExp("[" + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + "]");
function hasUnicode(string) {
  return reHasUnicode.test(string);
}
var hasUnicode_default = hasUnicode;

// node_modules/lodash-es/_asciiToArray.js
function asciiToArray(string) {
  return string.split("");
}
var asciiToArray_default = asciiToArray;

// node_modules/lodash-es/_unicodeToArray.js
var rsAstralRange2 = "\\ud800-\\udfff";
var rsComboMarksRange2 = "\\u0300-\\u036f";
var reComboHalfMarksRange2 = "\\ufe20-\\ufe2f";
var rsComboSymbolsRange2 = "\\u20d0-\\u20ff";
var rsComboRange2 = rsComboMarksRange2 + reComboHalfMarksRange2 + rsComboSymbolsRange2;
var rsVarRange2 = "\\ufe0e\\ufe0f";
var rsAstral = "[" + rsAstralRange2 + "]";
var rsCombo = "[" + rsComboRange2 + "]";
var rsFitz = "\\ud83c[\\udffb-\\udfff]";
var rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")";
var rsNonAstral = "[^" + rsAstralRange2 + "]";
var rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}";
var rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]";
var rsZWJ2 = "\\u200d";
var reOptMod = rsModifier + "?";
var rsOptVar = "[" + rsVarRange2 + "]?";
var rsOptJoin = "(?:" + rsZWJ2 + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*";
var rsSeq = rsOptVar + reOptMod + rsOptJoin;
var rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
function unicodeToArray(string) {
  return string.match(reUnicode) || [];
}
var unicodeToArray_default = unicodeToArray;

// node_modules/lodash-es/_stringToArray.js
function stringToArray(string) {
  return hasUnicode_default(string) ? unicodeToArray_default(string) : asciiToArray_default(string);
}
var stringToArray_default = stringToArray;

// node_modules/lodash-es/_createCaseFirst.js
function createCaseFirst(methodName) {
  return function(string) {
    string = toString_default(string);
    var strSymbols = hasUnicode_default(string) ? stringToArray_default(string) : void 0;
    var chr = strSymbols ? strSymbols[0] : string.charAt(0);
    var trailing = strSymbols ? castSlice_default(strSymbols, 1).join("") : string.slice(1);
    return chr[methodName]() + trailing;
  };
}
var createCaseFirst_default = createCaseFirst;

// node_modules/lodash-es/upperFirst.js
var upperFirst2 = createCaseFirst_default("toUpperCase");
var upperFirst_default = upperFirst2;

// node_modules/lodash-es/capitalize.js
function capitalize(string) {
  return upperFirst_default(toString_default(string).toLowerCase());
}
var capitalize_default = capitalize;

// node_modules/lodash-es/_arrayReduce.js
function arrayReduce(array2, iteratee2, accumulator, initAccum) {
  var index3 = -1, length5 = array2 == null ? 0 : array2.length;
  if (initAccum && length5) {
    accumulator = array2[++index3];
  }
  while (++index3 < length5) {
    accumulator = iteratee2(accumulator, array2[index3], index3, array2);
  }
  return accumulator;
}
var arrayReduce_default = arrayReduce;

// node_modules/lodash-es/_basePropertyOf.js
function basePropertyOf(object) {
  return function(key) {
    return object == null ? void 0 : object[key];
  };
}
var basePropertyOf_default = basePropertyOf;

// node_modules/lodash-es/_deburrLetter.js
var deburredLetters = {
  // Latin-1 Supplement block.
  "": "A",
  "": "A",
  "": "A",
  "": "A",
  "": "A",
  "": "A",
  "": "a",
  "": "a",
  "": "a",
  "": "a",
  "": "a",
  "": "a",
  "": "C",
  "": "c",
  "": "D",
  "": "d",
  "": "E",
  "": "E",
  "": "E",
  "": "E",
  "": "e",
  "": "e",
  "": "e",
  "": "e",
  "": "I",
  "": "I",
  "": "I",
  "": "I",
  "": "i",
  "": "i",
  "": "i",
  "": "i",
  "": "N",
  "": "n",
  "": "O",
  "": "O",
  "": "O",
  "": "O",
  "": "O",
  "": "O",
  "": "o",
  "": "o",
  "": "o",
  "": "o",
  "": "o",
  "": "o",
  "": "U",
  "": "U",
  "": "U",
  "": "U",
  "": "u",
  "": "u",
  "": "u",
  "": "u",
  "": "Y",
  "": "y",
  "": "y",
  "": "Ae",
  "": "ae",
  "": "Th",
  "": "th",
  "": "ss",
  // Latin Extended-A block.
  "": "A",
  "": "A",
  "": "A",
  "": "a",
  "": "a",
  "": "a",
  "": "C",
  "": "C",
  "": "C",
  "": "C",
  "": "c",
  "": "c",
  "": "c",
  "": "c",
  "": "D",
  "": "D",
  "": "d",
  "": "d",
  "": "E",
  "": "E",
  "": "E",
  "": "E",
  "": "E",
  "": "e",
  "": "e",
  "": "e",
  "": "e",
  "": "e",
  "": "G",
  "": "G",
  "": "G",
  "": "G",
  "": "g",
  "": "g",
  "": "g",
  "": "g",
  "": "H",
  "": "H",
  "": "h",
  "": "h",
  "": "I",
  "": "I",
  "": "I",
  "": "I",
  "": "I",
  "": "i",
  "": "i",
  "": "i",
  "": "i",
  "": "i",
  "": "J",
  "": "j",
  "": "K",
  "": "k",
  "": "k",
  "": "L",
  "": "L",
  "": "L",
  "": "L",
  "": "L",
  "": "l",
  "": "l",
  "": "l",
  "": "l",
  "": "l",
  "": "N",
  "": "N",
  "": "N",
  "": "N",
  "": "n",
  "": "n",
  "": "n",
  "": "n",
  "": "O",
  "": "O",
  "": "O",
  "": "o",
  "": "o",
  "": "o",
  "": "R",
  "": "R",
  "": "R",
  "": "r",
  "": "r",
  "": "r",
  "": "S",
  "": "S",
  "": "S",
  "": "S",
  "": "s",
  "": "s",
  "": "s",
  "": "s",
  "": "T",
  "": "T",
  "": "T",
  "": "t",
  "": "t",
  "": "t",
  "": "U",
  "": "U",
  "": "U",
  "": "U",
  "": "U",
  "": "U",
  "": "u",
  "": "u",
  "": "u",
  "": "u",
  "": "u",
  "": "u",
  "": "W",
  "": "w",
  "": "Y",
  "": "y",
  "": "Y",
  "": "Z",
  "": "Z",
  "": "Z",
  "": "z",
  "": "z",
  "": "z",
  "": "IJ",
  "": "ij",
  "": "Oe",
  "": "oe",
  "": "'n",
  "": "s"
};
var deburrLetter = basePropertyOf_default(deburredLetters);
var deburrLetter_default = deburrLetter;

// node_modules/lodash-es/deburr.js
var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
var rsComboMarksRange3 = "\\u0300-\\u036f";
var reComboHalfMarksRange3 = "\\ufe20-\\ufe2f";
var rsComboSymbolsRange3 = "\\u20d0-\\u20ff";
var rsComboRange3 = rsComboMarksRange3 + reComboHalfMarksRange3 + rsComboSymbolsRange3;
var rsCombo2 = "[" + rsComboRange3 + "]";
var reComboMark = RegExp(rsCombo2, "g");
function deburr(string) {
  string = toString_default(string);
  return string && string.replace(reLatin, deburrLetter_default).replace(reComboMark, "");
}
var deburr_default = deburr;

// node_modules/lodash-es/_asciiWords.js
var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
function asciiWords(string) {
  return string.match(reAsciiWord) || [];
}
var asciiWords_default = asciiWords;

// node_modules/lodash-es/_hasUnicodeWord.js
var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
function hasUnicodeWord(string) {
  return reHasUnicodeWord.test(string);
}
var hasUnicodeWord_default = hasUnicodeWord;

// node_modules/lodash-es/_unicodeWords.js
var rsAstralRange3 = "\\ud800-\\udfff";
var rsComboMarksRange4 = "\\u0300-\\u036f";
var reComboHalfMarksRange4 = "\\ufe20-\\ufe2f";
var rsComboSymbolsRange4 = "\\u20d0-\\u20ff";
var rsComboRange4 = rsComboMarksRange4 + reComboHalfMarksRange4 + rsComboSymbolsRange4;
var rsDingbatRange = "\\u2700-\\u27bf";
var rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff";
var rsMathOpRange = "\\xac\\xb1\\xd7\\xf7";
var rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf";
var rsPunctuationRange = "\\u2000-\\u206f";
var rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000";
var rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde";
var rsVarRange3 = "\\ufe0e\\ufe0f";
var rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
var rsApos = "[']";
var rsBreak = "[" + rsBreakRange + "]";
var rsCombo3 = "[" + rsComboRange4 + "]";
var rsDigits = "\\d+";
var rsDingbat = "[" + rsDingbatRange + "]";
var rsLower = "[" + rsLowerRange + "]";
var rsMisc = "[^" + rsAstralRange3 + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]";
var rsFitz2 = "\\ud83c[\\udffb-\\udfff]";
var rsModifier2 = "(?:" + rsCombo3 + "|" + rsFitz2 + ")";
var rsNonAstral2 = "[^" + rsAstralRange3 + "]";
var rsRegional2 = "(?:\\ud83c[\\udde6-\\uddff]){2}";
var rsSurrPair2 = "[\\ud800-\\udbff][\\udc00-\\udfff]";
var rsUpper = "[" + rsUpperRange + "]";
var rsZWJ3 = "\\u200d";
var rsMiscLower = "(?:" + rsLower + "|" + rsMisc + ")";
var rsMiscUpper = "(?:" + rsUpper + "|" + rsMisc + ")";
var rsOptContrLower = "(?:" + rsApos + "(?:d|ll|m|re|s|t|ve))?";
var rsOptContrUpper = "(?:" + rsApos + "(?:D|LL|M|RE|S|T|VE))?";
var reOptMod2 = rsModifier2 + "?";
var rsOptVar2 = "[" + rsVarRange3 + "]?";
var rsOptJoin2 = "(?:" + rsZWJ3 + "(?:" + [rsNonAstral2, rsRegional2, rsSurrPair2].join("|") + ")" + rsOptVar2 + reOptMod2 + ")*";
var rsOrdLower = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])";
var rsOrdUpper = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])";
var rsSeq2 = rsOptVar2 + reOptMod2 + rsOptJoin2;
var rsEmoji = "(?:" + [rsDingbat, rsRegional2, rsSurrPair2].join("|") + ")" + rsSeq2;
var reUnicodeWord = RegExp([
  rsUpper + "?" + rsLower + "+" + rsOptContrLower + "(?=" + [rsBreak, rsUpper, "$"].join("|") + ")",
  rsMiscUpper + "+" + rsOptContrUpper + "(?=" + [rsBreak, rsUpper + rsMiscLower, "$"].join("|") + ")",
  rsUpper + "?" + rsMiscLower + "+" + rsOptContrLower,
  rsUpper + "+" + rsOptContrUpper,
  rsOrdUpper,
  rsOrdLower,
  rsDigits,
  rsEmoji
].join("|"), "g");
function unicodeWords(string) {
  return string.match(reUnicodeWord) || [];
}
var unicodeWords_default = unicodeWords;

// node_modules/lodash-es/words.js
function words(string, pattern, guard) {
  string = toString_default(string);
  pattern = guard ? void 0 : pattern;
  if (pattern === void 0) {
    return hasUnicodeWord_default(string) ? unicodeWords_default(string) : asciiWords_default(string);
  }
  return string.match(pattern) || [];
}
var words_default = words;

// node_modules/lodash-es/_createCompounder.js
var rsApos2 = "[']";
var reApos = RegExp(rsApos2, "g");
function createCompounder(callback) {
  return function(string) {
    return arrayReduce_default(words_default(deburr_default(string).replace(reApos, "")), callback, "");
  };
}
var createCompounder_default = createCompounder;

// node_modules/lodash-es/camelCase.js
var camelCase3 = createCompounder_default(function(result2, word2, index3) {
  word2 = word2.toLowerCase();
  return result2 + (index3 ? capitalize_default(word2) : word2);
});
var camelCase_default = camelCase3;

// node_modules/lodash-es/castArray.js
function castArray() {
  if (!arguments.length) {
    return [];
  }
  var value2 = arguments[0];
  return isArray_default(value2) ? value2 : [value2];
}
var castArray_default = castArray;

// node_modules/lodash-es/_createRound.js
var nativeIsFinite = root_default2.isFinite;
var nativeMin3 = Math.min;
function createRound(methodName) {
  var func = Math[methodName];
  return function(number2, precision) {
    number2 = toNumber_default(number2);
    precision = precision == null ? 0 : nativeMin3(toInteger_default(precision), 292);
    if (precision && nativeIsFinite(number2)) {
      var pair = (toString_default(number2) + "e").split("e"), value2 = func(pair[0] + "e" + (+pair[1] + precision));
      pair = (toString_default(value2) + "e").split("e");
      return +(pair[0] + "e" + (+pair[1] - precision));
    }
    return func(number2);
  };
}
var createRound_default = createRound;

// node_modules/lodash-es/ceil.js
var ceil5 = createRound_default("ceil");
var ceil_default = ceil5;

// node_modules/lodash-es/chain.js
function chain(value2) {
  var result2 = wrapperLodash_default(value2);
  result2.__chain__ = true;
  return result2;
}
var chain_default = chain;

// node_modules/lodash-es/chunk.js
var nativeCeil = Math.ceil;
var nativeMax5 = Math.max;
function chunk(array2, size5, guard) {
  if (guard ? isIterateeCall_default(array2, size5, guard) : size5 === void 0) {
    size5 = 1;
  } else {
    size5 = nativeMax5(toInteger_default(size5), 0);
  }
  var length5 = array2 == null ? 0 : array2.length;
  if (!length5 || size5 < 1) {
    return [];
  }
  var index3 = 0, resIndex = 0, result2 = Array(nativeCeil(length5 / size5));
  while (index3 < length5) {
    result2[resIndex++] = baseSlice_default(array2, index3, index3 += size5);
  }
  return result2;
}
var chunk_default = chunk;

// node_modules/lodash-es/_baseClamp.js
function baseClamp(number2, lower2, upper2) {
  if (number2 === number2) {
    if (upper2 !== void 0) {
      number2 = number2 <= upper2 ? number2 : upper2;
    }
    if (lower2 !== void 0) {
      number2 = number2 >= lower2 ? number2 : lower2;
    }
  }
  return number2;
}
var baseClamp_default = baseClamp;

// node_modules/lodash-es/clamp.js
function clamp3(number2, lower2, upper2) {
  if (upper2 === void 0) {
    upper2 = lower2;
    lower2 = void 0;
  }
  if (upper2 !== void 0) {
    upper2 = toNumber_default(upper2);
    upper2 = upper2 === upper2 ? upper2 : 0;
  }
  if (lower2 !== void 0) {
    lower2 = toNumber_default(lower2);
    lower2 = lower2 === lower2 ? lower2 : 0;
  }
  return baseClamp_default(toNumber_default(number2), lower2, upper2);
}
var clamp_default4 = clamp3;

// node_modules/lodash-es/_stackClear.js
function stackClear() {
  this.__data__ = new ListCache_default();
  this.size = 0;
}
var stackClear_default = stackClear;

// node_modules/lodash-es/_stackDelete.js
function stackDelete(key) {
  var data2 = this.__data__, result2 = data2["delete"](key);
  this.size = data2.size;
  return result2;
}
var stackDelete_default = stackDelete;

// node_modules/lodash-es/_stackGet.js
function stackGet(key) {
  return this.__data__.get(key);
}
var stackGet_default = stackGet;

// node_modules/lodash-es/_stackHas.js
function stackHas(key) {
  return this.__data__.has(key);
}
var stackHas_default = stackHas;

// node_modules/lodash-es/_stackSet.js
var LARGE_ARRAY_SIZE = 200;
function stackSet(key, value2) {
  var data2 = this.__data__;
  if (data2 instanceof ListCache_default) {
    var pairs2 = data2.__data__;
    if (!Map_default || pairs2.length < LARGE_ARRAY_SIZE - 1) {
      pairs2.push([key, value2]);
      this.size = ++data2.size;
      return this;
    }
    data2 = this.__data__ = new MapCache_default(pairs2);
  }
  data2.set(key, value2);
  this.size = data2.size;
  return this;
}
var stackSet_default = stackSet;

// node_modules/lodash-es/_Stack.js
function Stack(entries) {
  var data2 = this.__data__ = new ListCache_default(entries);
  this.size = data2.size;
}
Stack.prototype.clear = stackClear_default;
Stack.prototype["delete"] = stackDelete_default;
Stack.prototype.get = stackGet_default;
Stack.prototype.has = stackHas_default;
Stack.prototype.set = stackSet_default;
var Stack_default = Stack;

// node_modules/lodash-es/_baseAssign.js
function baseAssign(object, source) {
  return object && copyObject_default(source, keys_default4(source), object);
}
var baseAssign_default = baseAssign;

// node_modules/lodash-es/_baseAssignIn.js
function baseAssignIn(object, source) {
  return object && copyObject_default(source, keysIn_default(source), object);
}
var baseAssignIn_default = baseAssignIn;

// node_modules/lodash-es/_cloneBuffer.js
var freeExports3 = typeof exports == "object" && exports && !exports.nodeType && exports;
var freeModule3 = freeExports3 && typeof module == "object" && module && !module.nodeType && module;
var moduleExports3 = freeModule3 && freeModule3.exports === freeExports3;
var Buffer2 = moduleExports3 ? root_default2.Buffer : void 0;
var allocUnsafe = Buffer2 ? Buffer2.allocUnsafe : void 0;
function cloneBuffer(buffer, isDeep) {
  if (isDeep) {
    return buffer.slice();
  }
  var length5 = buffer.length, result2 = allocUnsafe ? allocUnsafe(length5) : new buffer.constructor(length5);
  buffer.copy(result2);
  return result2;
}
var cloneBuffer_default = cloneBuffer;

// node_modules/lodash-es/_arrayFilter.js
function arrayFilter(array2, predicate) {
  var index3 = -1, length5 = array2 == null ? 0 : array2.length, resIndex = 0, result2 = [];
  while (++index3 < length5) {
    var value2 = array2[index3];
    if (predicate(value2, index3, array2)) {
      result2[resIndex++] = value2;
    }
  }
  return result2;
}
var arrayFilter_default = arrayFilter;

// node_modules/lodash-es/stubArray.js
function stubArray() {
  return [];
}
var stubArray_default = stubArray;

// node_modules/lodash-es/_getSymbols.js
var objectProto19 = Object.prototype;
var propertyIsEnumerable2 = objectProto19.propertyIsEnumerable;
var nativeGetSymbols = Object.getOwnPropertySymbols;
var getSymbols = !nativeGetSymbols ? stubArray_default : function(object) {
  if (object == null) {
    return [];
  }
  object = Object(object);
  return arrayFilter_default(nativeGetSymbols(object), function(symbol) {
    return propertyIsEnumerable2.call(object, symbol);
  });
};
var getSymbols_default = getSymbols;

// node_modules/lodash-es/_copySymbols.js
function copySymbols(source, object) {
  return copyObject_default(source, getSymbols_default(source), object);
}
var copySymbols_default = copySymbols;

// node_modules/lodash-es/_getSymbolsIn.js
var nativeGetSymbols2 = Object.getOwnPropertySymbols;
var getSymbolsIn = !nativeGetSymbols2 ? stubArray_default : function(object) {
  var result2 = [];
  while (object) {
    arrayPush_default(result2, getSymbols_default(object));
    object = getPrototype_default(object);
  }
  return result2;
};
var getSymbolsIn_default = getSymbolsIn;

// node_modules/lodash-es/_copySymbolsIn.js
function copySymbolsIn(source, object) {
  return copyObject_default(source, getSymbolsIn_default(source), object);
}
var copySymbolsIn_default = copySymbolsIn;

// node_modules/lodash-es/_baseGetAllKeys.js
function baseGetAllKeys(object, keysFunc, symbolsFunc) {
  var result2 = keysFunc(object);
  return isArray_default(object) ? result2 : arrayPush_default(result2, symbolsFunc(object));
}
var baseGetAllKeys_default = baseGetAllKeys;

// node_modules/lodash-es/_getAllKeys.js
function getAllKeys(object) {
  return baseGetAllKeys_default(object, keys_default4, getSymbols_default);
}
var getAllKeys_default = getAllKeys;

// node_modules/lodash-es/_getAllKeysIn.js
function getAllKeysIn(object) {
  return baseGetAllKeys_default(object, keysIn_default, getSymbolsIn_default);
}
var getAllKeysIn_default = getAllKeysIn;

// node_modules/lodash-es/_DataView.js
var DataView2 = getNative_default(root_default2, "DataView");
var DataView_default = DataView2;

// node_modules/lodash-es/_Promise.js
var Promise2 = getNative_default(root_default2, "Promise");
var Promise_default = Promise2;

// node_modules/lodash-es/_Set.js
var Set2 = getNative_default(root_default2, "Set");
var Set_default = Set2;

// node_modules/lodash-es/_getTag.js
var mapTag2 = "[object Map]";
var objectTag3 = "[object Object]";
var promiseTag = "[object Promise]";
var setTag2 = "[object Set]";
var weakMapTag2 = "[object WeakMap]";
var dataViewTag2 = "[object DataView]";
var dataViewCtorString = toSource_default(DataView_default);
var mapCtorString = toSource_default(Map_default);
var promiseCtorString = toSource_default(Promise_default);
var setCtorString = toSource_default(Set_default);
var weakMapCtorString = toSource_default(WeakMap_default);
var getTag = baseGetTag_default;
if (DataView_default && getTag(new DataView_default(new ArrayBuffer(1))) != dataViewTag2 || Map_default && getTag(new Map_default()) != mapTag2 || Promise_default && getTag(Promise_default.resolve()) != promiseTag || Set_default && getTag(new Set_default()) != setTag2 || WeakMap_default && getTag(new WeakMap_default()) != weakMapTag2) {
  getTag = function(value2) {
    var result2 = baseGetTag_default(value2), Ctor = result2 == objectTag3 ? value2.constructor : void 0, ctorString = Ctor ? toSource_default(Ctor) : "";
    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString:
          return dataViewTag2;
        case mapCtorString:
          return mapTag2;
        case promiseCtorString:
          return promiseTag;
        case setCtorString:
          return setTag2;
        case weakMapCtorString:
          return weakMapTag2;
      }
    }
    return result2;
  };
}
var getTag_default = getTag;

// node_modules/lodash-es/_initCloneArray.js
var objectProto20 = Object.prototype;
var hasOwnProperty15 = objectProto20.hasOwnProperty;
function initCloneArray(array2) {
  var length5 = array2.length, result2 = new array2.constructor(length5);
  if (length5 && typeof array2[0] == "string" && hasOwnProperty15.call(array2, "index")) {
    result2.index = array2.index;
    result2.input = array2.input;
  }
  return result2;
}
var initCloneArray_default = initCloneArray;

// node_modules/lodash-es/_Uint8Array.js
var Uint8Array = root_default2.Uint8Array;
var Uint8Array_default = Uint8Array;

// node_modules/lodash-es/_cloneArrayBuffer.js
function cloneArrayBuffer(arrayBuffer) {
  var result2 = new arrayBuffer.constructor(arrayBuffer.byteLength);
  new Uint8Array_default(result2).set(new Uint8Array_default(arrayBuffer));
  return result2;
}
var cloneArrayBuffer_default = cloneArrayBuffer;

// node_modules/lodash-es/_cloneDataView.js
function cloneDataView(dataView, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer_default(dataView.buffer) : dataView.buffer;
  return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
}
var cloneDataView_default = cloneDataView;

// node_modules/lodash-es/_cloneRegExp.js
var reFlags = /\w*$/;
function cloneRegExp(regexp) {
  var result2 = new regexp.constructor(regexp.source, reFlags.exec(regexp));
  result2.lastIndex = regexp.lastIndex;
  return result2;
}
var cloneRegExp_default = cloneRegExp;

// node_modules/lodash-es/_cloneSymbol.js
var symbolProto2 = Symbol_default ? Symbol_default.prototype : void 0;
var symbolValueOf = symbolProto2 ? symbolProto2.valueOf : void 0;
function cloneSymbol(symbol) {
  return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
}
var cloneSymbol_default = cloneSymbol;

// node_modules/lodash-es/_cloneTypedArray.js
function cloneTypedArray(typedArray, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer_default(typedArray.buffer) : typedArray.buffer;
  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
}
var cloneTypedArray_default = cloneTypedArray;

// node_modules/lodash-es/_initCloneByTag.js
var boolTag2 = "[object Boolean]";
var dateTag2 = "[object Date]";
var mapTag3 = "[object Map]";
var numberTag2 = "[object Number]";
var regexpTag2 = "[object RegExp]";
var setTag3 = "[object Set]";
var stringTag2 = "[object String]";
var symbolTag2 = "[object Symbol]";
var arrayBufferTag2 = "[object ArrayBuffer]";
var dataViewTag3 = "[object DataView]";
var float32Tag2 = "[object Float32Array]";
var float64Tag2 = "[object Float64Array]";
var int8Tag2 = "[object Int8Array]";
var int16Tag2 = "[object Int16Array]";
var int32Tag2 = "[object Int32Array]";
var uint8Tag2 = "[object Uint8Array]";
var uint8ClampedTag2 = "[object Uint8ClampedArray]";
var uint16Tag2 = "[object Uint16Array]";
var uint32Tag2 = "[object Uint32Array]";
function initCloneByTag(object, tag, isDeep) {
  var Ctor = object.constructor;
  switch (tag) {
    case arrayBufferTag2:
      return cloneArrayBuffer_default(object);
    case boolTag2:
    case dateTag2:
      return new Ctor(+object);
    case dataViewTag3:
      return cloneDataView_default(object, isDeep);
    case float32Tag2:
    case float64Tag2:
    case int8Tag2:
    case int16Tag2:
    case int32Tag2:
    case uint8Tag2:
    case uint8ClampedTag2:
    case uint16Tag2:
    case uint32Tag2:
      return cloneTypedArray_default(object, isDeep);
    case mapTag3:
      return new Ctor();
    case numberTag2:
    case stringTag2:
      return new Ctor(object);
    case regexpTag2:
      return cloneRegExp_default(object);
    case setTag3:
      return new Ctor();
    case symbolTag2:
      return cloneSymbol_default(object);
  }
}
var initCloneByTag_default = initCloneByTag;

// node_modules/lodash-es/_initCloneObject.js
function initCloneObject(object) {
  return typeof object.constructor == "function" && !isPrototype_default(object) ? baseCreate_default(getPrototype_default(object)) : {};
}
var initCloneObject_default = initCloneObject;

// node_modules/lodash-es/_baseIsMap.js
var mapTag4 = "[object Map]";
function baseIsMap(value2) {
  return isObjectLike_default(value2) && getTag_default(value2) == mapTag4;
}
var baseIsMap_default = baseIsMap;

// node_modules/lodash-es/isMap.js
var nodeIsMap = nodeUtil_default && nodeUtil_default.isMap;
var isMap = nodeIsMap ? baseUnary_default(nodeIsMap) : baseIsMap_default;
var isMap_default = isMap;

// node_modules/lodash-es/_baseIsSet.js
var setTag4 = "[object Set]";
function baseIsSet(value2) {
  return isObjectLike_default(value2) && getTag_default(value2) == setTag4;
}
var baseIsSet_default = baseIsSet;

// node_modules/lodash-es/isSet.js
var nodeIsSet = nodeUtil_default && nodeUtil_default.isSet;
var isSet = nodeIsSet ? baseUnary_default(nodeIsSet) : baseIsSet_default;
var isSet_default = isSet;

// node_modules/lodash-es/_baseClone.js
var CLONE_DEEP_FLAG = 1;
var CLONE_FLAT_FLAG = 2;
var CLONE_SYMBOLS_FLAG = 4;
var argsTag3 = "[object Arguments]";
var arrayTag2 = "[object Array]";
var boolTag3 = "[object Boolean]";
var dateTag3 = "[object Date]";
var errorTag3 = "[object Error]";
var funcTag3 = "[object Function]";
var genTag2 = "[object GeneratorFunction]";
var mapTag5 = "[object Map]";
var numberTag3 = "[object Number]";
var objectTag4 = "[object Object]";
var regexpTag3 = "[object RegExp]";
var setTag5 = "[object Set]";
var stringTag3 = "[object String]";
var symbolTag3 = "[object Symbol]";
var weakMapTag3 = "[object WeakMap]";
var arrayBufferTag3 = "[object ArrayBuffer]";
var dataViewTag4 = "[object DataView]";
var float32Tag3 = "[object Float32Array]";
var float64Tag3 = "[object Float64Array]";
var int8Tag3 = "[object Int8Array]";
var int16Tag3 = "[object Int16Array]";
var int32Tag3 = "[object Int32Array]";
var uint8Tag3 = "[object Uint8Array]";
var uint8ClampedTag3 = "[object Uint8ClampedArray]";
var uint16Tag3 = "[object Uint16Array]";
var uint32Tag3 = "[object Uint32Array]";
var cloneableTags = {};
cloneableTags[argsTag3] = cloneableTags[arrayTag2] = cloneableTags[arrayBufferTag3] = cloneableTags[dataViewTag4] = cloneableTags[boolTag3] = cloneableTags[dateTag3] = cloneableTags[float32Tag3] = cloneableTags[float64Tag3] = cloneableTags[int8Tag3] = cloneableTags[int16Tag3] = cloneableTags[int32Tag3] = cloneableTags[mapTag5] = cloneableTags[numberTag3] = cloneableTags[objectTag4] = cloneableTags[regexpTag3] = cloneableTags[setTag5] = cloneableTags[stringTag3] = cloneableTags[symbolTag3] = cloneableTags[uint8Tag3] = cloneableTags[uint8ClampedTag3] = cloneableTags[uint16Tag3] = cloneableTags[uint32Tag3] = true;
cloneableTags[errorTag3] = cloneableTags[funcTag3] = cloneableTags[weakMapTag3] = false;
function baseClone(value2, bitmask, customizer, key, object, stack) {
  var result2, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG;
  if (customizer) {
    result2 = object ? customizer(value2, key, object, stack) : customizer(value2);
  }
  if (result2 !== void 0) {
    return result2;
  }
  if (!isObject_default(value2)) {
    return value2;
  }
  var isArr = isArray_default(value2);
  if (isArr) {
    result2 = initCloneArray_default(value2);
    if (!isDeep) {
      return copyArray_default(value2, result2);
    }
  } else {
    var tag = getTag_default(value2), isFunc = tag == funcTag3 || tag == genTag2;
    if (isBuffer_default(value2)) {
      return cloneBuffer_default(value2, isDeep);
    }
    if (tag == objectTag4 || tag == argsTag3 || isFunc && !object) {
      result2 = isFlat || isFunc ? {} : initCloneObject_default(value2);
      if (!isDeep) {
        return isFlat ? copySymbolsIn_default(value2, baseAssignIn_default(result2, value2)) : copySymbols_default(value2, baseAssign_default(result2, value2));
      }
    } else {
      if (!cloneableTags[tag]) {
        return object ? value2 : {};
      }
      result2 = initCloneByTag_default(value2, tag, isDeep);
    }
  }
  stack || (stack = new Stack_default());
  var stacked = stack.get(value2);
  if (stacked) {
    return stacked;
  }
  stack.set(value2, result2);
  if (isSet_default(value2)) {
    value2.forEach(function(subValue) {
      result2.add(baseClone(subValue, bitmask, customizer, subValue, value2, stack));
    });
  } else if (isMap_default(value2)) {
    value2.forEach(function(subValue, key2) {
      result2.set(key2, baseClone(subValue, bitmask, customizer, key2, value2, stack));
    });
  }
  var keysFunc = isFull ? isFlat ? getAllKeysIn_default : getAllKeys_default : isFlat ? keysIn_default : keys_default4;
  var props = isArr ? void 0 : keysFunc(value2);
  arrayEach_default(props || value2, function(subValue, key2) {
    if (props) {
      key2 = subValue;
      subValue = value2[key2];
    }
    assignValue_default(result2, key2, baseClone(subValue, bitmask, customizer, key2, value2, stack));
  });
  return result2;
}
var baseClone_default = baseClone;

// node_modules/lodash-es/clone.js
var CLONE_SYMBOLS_FLAG2 = 4;
function clone8(value2) {
  return baseClone_default(value2, CLONE_SYMBOLS_FLAG2);
}
var clone_default4 = clone8;

// node_modules/lodash-es/cloneDeep.js
var CLONE_DEEP_FLAG2 = 1;
var CLONE_SYMBOLS_FLAG3 = 4;
function cloneDeep(value2) {
  return baseClone_default(value2, CLONE_DEEP_FLAG2 | CLONE_SYMBOLS_FLAG3);
}
var cloneDeep_default = cloneDeep;

// node_modules/lodash-es/cloneDeepWith.js
var CLONE_DEEP_FLAG3 = 1;
var CLONE_SYMBOLS_FLAG4 = 4;
function cloneDeepWith(value2, customizer) {
  customizer = typeof customizer == "function" ? customizer : void 0;
  return baseClone_default(value2, CLONE_DEEP_FLAG3 | CLONE_SYMBOLS_FLAG4, customizer);
}
var cloneDeepWith_default = cloneDeepWith;

// node_modules/lodash-es/cloneWith.js
var CLONE_SYMBOLS_FLAG5 = 4;
function cloneWith(value2, customizer) {
  customizer = typeof customizer == "function" ? customizer : void 0;
  return baseClone_default(value2, CLONE_SYMBOLS_FLAG5, customizer);
}
var cloneWith_default = cloneWith;

// node_modules/lodash-es/commit.js
function wrapperCommit() {
  return new LodashWrapper_default(this.value(), this.__chain__);
}
var commit_default = wrapperCommit;

// node_modules/lodash-es/compact.js
function compact(array2) {
  var index3 = -1, length5 = array2 == null ? 0 : array2.length, resIndex = 0, result2 = [];
  while (++index3 < length5) {
    var value2 = array2[index3];
    if (value2) {
      result2[resIndex++] = value2;
    }
  }
  return result2;
}
var compact_default = compact;

// node_modules/lodash-es/concat.js
function concat() {
  var length5 = arguments.length;
  if (!length5) {
    return [];
  }
  var args = Array(length5 - 1), array2 = arguments[0], index3 = length5;
  while (index3--) {
    args[index3 - 1] = arguments[index3];
  }
  return arrayPush_default(isArray_default(array2) ? copyArray_default(array2) : [array2], baseFlatten_default(args, 1));
}
var concat_default = concat;

// node_modules/lodash-es/_setCacheAdd.js
var HASH_UNDEFINED3 = "__lodash_hash_undefined__";
function setCacheAdd(value2) {
  this.__data__.set(value2, HASH_UNDEFINED3);
  return this;
}
var setCacheAdd_default = setCacheAdd;

// node_modules/lodash-es/_setCacheHas.js
function setCacheHas(value2) {
  return this.__data__.has(value2);
}
var setCacheHas_default = setCacheHas;

// node_modules/lodash-es/_SetCache.js
function SetCache(values4) {
  var index3 = -1, length5 = values4 == null ? 0 : values4.length;
  this.__data__ = new MapCache_default();
  while (++index3 < length5) {
    this.add(values4[index3]);
  }
}
SetCache.prototype.add = SetCache.prototype.push = setCacheAdd_default;
SetCache.prototype.has = setCacheHas_default;
var SetCache_default = SetCache;

// node_modules/lodash-es/_arraySome.js
function arraySome(array2, predicate) {
  var index3 = -1, length5 = array2 == null ? 0 : array2.length;
  while (++index3 < length5) {
    if (predicate(array2[index3], index3, array2)) {
      return true;
    }
  }
  return false;
}
var arraySome_default = arraySome;

// node_modules/lodash-es/_cacheHas.js
function cacheHas(cache2, key) {
  return cache2.has(key);
}
var cacheHas_default = cacheHas;

// node_modules/lodash-es/_equalArrays.js
var COMPARE_PARTIAL_FLAG = 1;
var COMPARE_UNORDERED_FLAG = 2;
function equalArrays(array2, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array2.length, othLength = other.length;
  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
    return false;
  }
  var arrStacked = stack.get(array2);
  var othStacked = stack.get(other);
  if (arrStacked && othStacked) {
    return arrStacked == other && othStacked == array2;
  }
  var index3 = -1, result2 = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache_default() : void 0;
  stack.set(array2, other);
  stack.set(other, array2);
  while (++index3 < arrLength) {
    var arrValue = array2[index3], othValue = other[index3];
    if (customizer) {
      var compared = isPartial ? customizer(othValue, arrValue, index3, other, array2, stack) : customizer(arrValue, othValue, index3, array2, other, stack);
    }
    if (compared !== void 0) {
      if (compared) {
        continue;
      }
      result2 = false;
      break;
    }
    if (seen) {
      if (!arraySome_default(other, function(othValue2, othIndex) {
        if (!cacheHas_default(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
          return seen.push(othIndex);
        }
      })) {
        result2 = false;
        break;
      }
    } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
      result2 = false;
      break;
    }
  }
  stack["delete"](array2);
  stack["delete"](other);
  return result2;
}
var equalArrays_default = equalArrays;

// node_modules/lodash-es/_mapToArray.js
function mapToArray(map5) {
  var index3 = -1, result2 = Array(map5.size);
  map5.forEach(function(value2, key) {
    result2[++index3] = [key, value2];
  });
  return result2;
}
var mapToArray_default = mapToArray;

// node_modules/lodash-es/_setToArray.js
function setToArray(set9) {
  var index3 = -1, result2 = Array(set9.size);
  set9.forEach(function(value2) {
    result2[++index3] = value2;
  });
  return result2;
}
var setToArray_default = setToArray;

// node_modules/lodash-es/_equalByTag.js
var COMPARE_PARTIAL_FLAG2 = 1;
var COMPARE_UNORDERED_FLAG2 = 2;
var boolTag4 = "[object Boolean]";
var dateTag4 = "[object Date]";
var errorTag4 = "[object Error]";
var mapTag6 = "[object Map]";
var numberTag4 = "[object Number]";
var regexpTag4 = "[object RegExp]";
var setTag6 = "[object Set]";
var stringTag4 = "[object String]";
var symbolTag4 = "[object Symbol]";
var arrayBufferTag4 = "[object ArrayBuffer]";
var dataViewTag5 = "[object DataView]";
var symbolProto3 = Symbol_default ? Symbol_default.prototype : void 0;
var symbolValueOf2 = symbolProto3 ? symbolProto3.valueOf : void 0;
function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
  switch (tag) {
    case dataViewTag5:
      if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
        return false;
      }
      object = object.buffer;
      other = other.buffer;
    case arrayBufferTag4:
      if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array_default(object), new Uint8Array_default(other))) {
        return false;
      }
      return true;
    case boolTag4:
    case dateTag4:
    case numberTag4:
      return eq_default(+object, +other);
    case errorTag4:
      return object.name == other.name && object.message == other.message;
    case regexpTag4:
    case stringTag4:
      return object == other + "";
    case mapTag6:
      var convert = mapToArray_default;
    case setTag6:
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG2;
      convert || (convert = setToArray_default);
      if (object.size != other.size && !isPartial) {
        return false;
      }
      var stacked = stack.get(object);
      if (stacked) {
        return stacked == other;
      }
      bitmask |= COMPARE_UNORDERED_FLAG2;
      stack.set(object, other);
      var result2 = equalArrays_default(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
      stack["delete"](object);
      return result2;
    case symbolTag4:
      if (symbolValueOf2) {
        return symbolValueOf2.call(object) == symbolValueOf2.call(other);
      }
  }
  return false;
}
var equalByTag_default = equalByTag;

// node_modules/lodash-es/_equalObjects.js
var COMPARE_PARTIAL_FLAG3 = 1;
var objectProto21 = Object.prototype;
var hasOwnProperty16 = objectProto21.hasOwnProperty;
function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG3, objProps = getAllKeys_default(object), objLength = objProps.length, othProps = getAllKeys_default(other), othLength = othProps.length;
  if (objLength != othLength && !isPartial) {
    return false;
  }
  var index3 = objLength;
  while (index3--) {
    var key = objProps[index3];
    if (!(isPartial ? key in other : hasOwnProperty16.call(other, key))) {
      return false;
    }
  }
  var objStacked = stack.get(object);
  var othStacked = stack.get(other);
  if (objStacked && othStacked) {
    return objStacked == other && othStacked == object;
  }
  var result2 = true;
  stack.set(object, other);
  stack.set(other, object);
  var skipCtor = isPartial;
  while (++index3 < objLength) {
    key = objProps[index3];
    var objValue = object[key], othValue = other[key];
    if (customizer) {
      var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
    }
    if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
      result2 = false;
      break;
    }
    skipCtor || (skipCtor = key == "constructor");
  }
  if (result2 && !skipCtor) {
    var objCtor = object.constructor, othCtor = other.constructor;
    if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
      result2 = false;
    }
  }
  stack["delete"](object);
  stack["delete"](other);
  return result2;
}
var equalObjects_default = equalObjects;

// node_modules/lodash-es/_baseIsEqualDeep.js
var COMPARE_PARTIAL_FLAG4 = 1;
var argsTag4 = "[object Arguments]";
var arrayTag3 = "[object Array]";
var objectTag5 = "[object Object]";
var objectProto22 = Object.prototype;
var hasOwnProperty17 = objectProto22.hasOwnProperty;
function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
  var objIsArr = isArray_default(object), othIsArr = isArray_default(other), objTag = objIsArr ? arrayTag3 : getTag_default(object), othTag = othIsArr ? arrayTag3 : getTag_default(other);
  objTag = objTag == argsTag4 ? objectTag5 : objTag;
  othTag = othTag == argsTag4 ? objectTag5 : othTag;
  var objIsObj = objTag == objectTag5, othIsObj = othTag == objectTag5, isSameTag = objTag == othTag;
  if (isSameTag && isBuffer_default(object)) {
    if (!isBuffer_default(other)) {
      return false;
    }
    objIsArr = true;
    objIsObj = false;
  }
  if (isSameTag && !objIsObj) {
    stack || (stack = new Stack_default());
    return objIsArr || isTypedArray_default(object) ? equalArrays_default(object, other, bitmask, customizer, equalFunc, stack) : equalByTag_default(object, other, objTag, bitmask, customizer, equalFunc, stack);
  }
  if (!(bitmask & COMPARE_PARTIAL_FLAG4)) {
    var objIsWrapped = objIsObj && hasOwnProperty17.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty17.call(other, "__wrapped__");
    if (objIsWrapped || othIsWrapped) {
      var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
      stack || (stack = new Stack_default());
      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
    }
  }
  if (!isSameTag) {
    return false;
  }
  stack || (stack = new Stack_default());
  return equalObjects_default(object, other, bitmask, customizer, equalFunc, stack);
}
var baseIsEqualDeep_default = baseIsEqualDeep;

// node_modules/lodash-es/_baseIsEqual.js
function baseIsEqual(value2, other, bitmask, customizer, stack) {
  if (value2 === other) {
    return true;
  }
  if (value2 == null || other == null || !isObjectLike_default(value2) && !isObjectLike_default(other)) {
    return value2 !== value2 && other !== other;
  }
  return baseIsEqualDeep_default(value2, other, bitmask, customizer, baseIsEqual, stack);
}
var baseIsEqual_default = baseIsEqual;

// node_modules/lodash-es/_baseIsMatch.js
var COMPARE_PARTIAL_FLAG5 = 1;
var COMPARE_UNORDERED_FLAG3 = 2;
function baseIsMatch(object, source, matchData, customizer) {
  var index3 = matchData.length, length5 = index3, noCustomizer = !customizer;
  if (object == null) {
    return !length5;
  }
  object = Object(object);
  while (index3--) {
    var data2 = matchData[index3];
    if (noCustomizer && data2[2] ? data2[1] !== object[data2[0]] : !(data2[0] in object)) {
      return false;
    }
  }
  while (++index3 < length5) {
    data2 = matchData[index3];
    var key = data2[0], objValue = object[key], srcValue = data2[1];
    if (noCustomizer && data2[2]) {
      if (objValue === void 0 && !(key in object)) {
        return false;
      }
    } else {
      var stack = new Stack_default();
      if (customizer) {
        var result2 = customizer(objValue, srcValue, key, object, source, stack);
      }
      if (!(result2 === void 0 ? baseIsEqual_default(srcValue, objValue, COMPARE_PARTIAL_FLAG5 | COMPARE_UNORDERED_FLAG3, customizer, stack) : result2)) {
        return false;
      }
    }
  }
  return true;
}
var baseIsMatch_default = baseIsMatch;

// node_modules/lodash-es/_isStrictComparable.js
function isStrictComparable(value2) {
  return value2 === value2 && !isObject_default(value2);
}
var isStrictComparable_default = isStrictComparable;

// node_modules/lodash-es/_getMatchData.js
function getMatchData(object) {
  var result2 = keys_default4(object), length5 = result2.length;
  while (length5--) {
    var key = result2[length5], value2 = object[key];
    result2[length5] = [key, value2, isStrictComparable_default(value2)];
  }
  return result2;
}
var getMatchData_default = getMatchData;

// node_modules/lodash-es/_matchesStrictComparable.js
function matchesStrictComparable(key, srcValue) {
  return function(object) {
    if (object == null) {
      return false;
    }
    return object[key] === srcValue && (srcValue !== void 0 || key in Object(object));
  };
}
var matchesStrictComparable_default = matchesStrictComparable;

// node_modules/lodash-es/_baseMatches.js
function baseMatches(source) {
  var matchData = getMatchData_default(source);
  if (matchData.length == 1 && matchData[0][2]) {
    return matchesStrictComparable_default(matchData[0][0], matchData[0][1]);
  }
  return function(object) {
    return object === source || baseIsMatch_default(object, source, matchData);
  };
}
var baseMatches_default = baseMatches;

// node_modules/lodash-es/_baseHasIn.js
function baseHasIn(object, key) {
  return object != null && key in Object(object);
}
var baseHasIn_default = baseHasIn;

// node_modules/lodash-es/_hasPath.js
function hasPath(object, path2, hasFunc) {
  path2 = castPath_default(path2, object);
  var index3 = -1, length5 = path2.length, result2 = false;
  while (++index3 < length5) {
    var key = toKey_default(path2[index3]);
    if (!(result2 = object != null && hasFunc(object, key))) {
      break;
    }
    object = object[key];
  }
  if (result2 || ++index3 != length5) {
    return result2;
  }
  length5 = object == null ? 0 : object.length;
  return !!length5 && isLength_default(length5) && isIndex_default(key, length5) && (isArray_default(object) || isArguments_default(object));
}
var hasPath_default = hasPath;

// node_modules/lodash-es/hasIn.js
function hasIn(object, path2) {
  return object != null && hasPath_default(object, path2, baseHasIn_default);
}
var hasIn_default = hasIn;

// node_modules/lodash-es/_baseMatchesProperty.js
var COMPARE_PARTIAL_FLAG6 = 1;
var COMPARE_UNORDERED_FLAG4 = 2;
function baseMatchesProperty(path2, srcValue) {
  if (isKey_default(path2) && isStrictComparable_default(srcValue)) {
    return matchesStrictComparable_default(toKey_default(path2), srcValue);
  }
  return function(object) {
    var objValue = get_default4(object, path2);
    return objValue === void 0 && objValue === srcValue ? hasIn_default(object, path2) : baseIsEqual_default(srcValue, objValue, COMPARE_PARTIAL_FLAG6 | COMPARE_UNORDERED_FLAG4);
  };
}
var baseMatchesProperty_default = baseMatchesProperty;

// node_modules/lodash-es/_baseProperty.js
function baseProperty(key) {
  return function(object) {
    return object == null ? void 0 : object[key];
  };
}
var baseProperty_default = baseProperty;

// node_modules/lodash-es/_basePropertyDeep.js
function basePropertyDeep(path2) {
  return function(object) {
    return baseGet_default(object, path2);
  };
}
var basePropertyDeep_default = basePropertyDeep;

// node_modules/lodash-es/property.js
function property(path2) {
  return isKey_default(path2) ? baseProperty_default(toKey_default(path2)) : basePropertyDeep_default(path2);
}
var property_default = property;

// node_modules/lodash-es/_baseIteratee.js
function baseIteratee(value2) {
  if (typeof value2 == "function") {
    return value2;
  }
  if (value2 == null) {
    return identity_default8;
  }
  if (typeof value2 == "object") {
    return isArray_default(value2) ? baseMatchesProperty_default(value2[0], value2[1]) : baseMatches_default(value2);
  }
  return property_default(value2);
}
var baseIteratee_default = baseIteratee;

// node_modules/lodash-es/cond.js
var FUNC_ERROR_TEXT5 = "Expected a function";
function cond(pairs2) {
  var length5 = pairs2 == null ? 0 : pairs2.length, toIteratee = baseIteratee_default;
  pairs2 = !length5 ? [] : arrayMap_default(pairs2, function(pair) {
    if (typeof pair[1] != "function") {
      throw new TypeError(FUNC_ERROR_TEXT5);
    }
    return [toIteratee(pair[0]), pair[1]];
  });
  return baseRest_default(function(args) {
    var index3 = -1;
    while (++index3 < length5) {
      var pair = pairs2[index3];
      if (apply_default(pair[0], this, args)) {
        return apply_default(pair[1], this, args);
      }
    }
  });
}
var cond_default = cond;

// node_modules/lodash-es/_baseConformsTo.js
function baseConformsTo(object, source, props) {
  var length5 = props.length;
  if (object == null) {
    return !length5;
  }
  object = Object(object);
  while (length5--) {
    var key = props[length5], predicate = source[key], value2 = object[key];
    if (value2 === void 0 && !(key in object) || !predicate(value2)) {
      return false;
    }
  }
  return true;
}
var baseConformsTo_default = baseConformsTo;

// node_modules/lodash-es/_baseConforms.js
function baseConforms(source) {
  var props = keys_default4(source);
  return function(object) {
    return baseConformsTo_default(object, source, props);
  };
}
var baseConforms_default = baseConforms;

// node_modules/lodash-es/conforms.js
var CLONE_DEEP_FLAG4 = 1;
function conforms(source) {
  return baseConforms_default(baseClone_default(source, CLONE_DEEP_FLAG4));
}
var conforms_default = conforms;

// node_modules/lodash-es/conformsTo.js
function conformsTo(object, source) {
  return source == null || baseConformsTo_default(object, source, keys_default4(source));
}
var conformsTo_default = conformsTo;

// node_modules/lodash-es/_arrayAggregator.js
function arrayAggregator(array2, setter, iteratee2, accumulator) {
  var index3 = -1, length5 = array2 == null ? 0 : array2.length;
  while (++index3 < length5) {
    var value2 = array2[index3];
    setter(accumulator, value2, iteratee2(value2), array2);
  }
  return accumulator;
}
var arrayAggregator_default = arrayAggregator;

// node_modules/lodash-es/_createBaseFor.js
function createBaseFor(fromRight) {
  return function(object, iteratee2, keysFunc) {
    var index3 = -1, iterable = Object(object), props = keysFunc(object), length5 = props.length;
    while (length5--) {
      var key = props[fromRight ? length5 : ++index3];
      if (iteratee2(iterable[key], key, iterable) === false) {
        break;
      }
    }
    return object;
  };
}
var createBaseFor_default = createBaseFor;

// node_modules/lodash-es/_baseFor.js
var baseFor = createBaseFor_default();
var baseFor_default = baseFor;

// node_modules/lodash-es/_baseForOwn.js
function baseForOwn(object, iteratee2) {
  return object && baseFor_default(object, iteratee2, keys_default4);
}
var baseForOwn_default = baseForOwn;

// node_modules/lodash-es/_createBaseEach.js
function createBaseEach(eachFunc, fromRight) {
  return function(collection, iteratee2) {
    if (collection == null) {
      return collection;
    }
    if (!isArrayLike_default(collection)) {
      return eachFunc(collection, iteratee2);
    }
    var length5 = collection.length, index3 = fromRight ? length5 : -1, iterable = Object(collection);
    while (fromRight ? index3-- : ++index3 < length5) {
      if (iteratee2(iterable[index3], index3, iterable) === false) {
        break;
      }
    }
    return collection;
  };
}
var createBaseEach_default = createBaseEach;

// node_modules/lodash-es/_baseEach.js
var baseEach = createBaseEach_default(baseForOwn_default);
var baseEach_default = baseEach;

// node_modules/lodash-es/_baseAggregator.js
function baseAggregator(collection, setter, iteratee2, accumulator) {
  baseEach_default(collection, function(value2, key, collection2) {
    setter(accumulator, value2, iteratee2(value2), collection2);
  });
  return accumulator;
}
var baseAggregator_default = baseAggregator;

// node_modules/lodash-es/_createAggregator.js
function createAggregator(setter, initializer) {
  return function(collection, iteratee2) {
    var func = isArray_default(collection) ? arrayAggregator_default : baseAggregator_default, accumulator = initializer ? initializer() : {};
    return func(collection, setter, baseIteratee_default(iteratee2, 2), accumulator);
  };
}
var createAggregator_default = createAggregator;

// node_modules/lodash-es/countBy.js
var objectProto23 = Object.prototype;
var hasOwnProperty18 = objectProto23.hasOwnProperty;
var countBy = createAggregator_default(function(result2, value2, key) {
  if (hasOwnProperty18.call(result2, key)) {
    ++result2[key];
  } else {
    baseAssignValue_default(result2, key, 1);
  }
});
var countBy_default = countBy;

// node_modules/lodash-es/create.js
function create8(prototype, properties) {
  var result2 = baseCreate_default(prototype);
  return properties == null ? result2 : baseAssign_default(result2, properties);
}
var create_default = create8;

// node_modules/lodash-es/curry.js
var WRAP_CURRY_FLAG6 = 8;
function curry(func, arity, guard) {
  arity = guard ? void 0 : arity;
  var result2 = createWrap_default(func, WRAP_CURRY_FLAG6, void 0, void 0, void 0, void 0, void 0, arity);
  result2.placeholder = curry.placeholder;
  return result2;
}
curry.placeholder = {};
var curry_default = curry;

// node_modules/lodash-es/curryRight.js
var WRAP_CURRY_RIGHT_FLAG4 = 16;
function curryRight(func, arity, guard) {
  arity = guard ? void 0 : arity;
  var result2 = createWrap_default(func, WRAP_CURRY_RIGHT_FLAG4, void 0, void 0, void 0, void 0, void 0, arity);
  result2.placeholder = curryRight.placeholder;
  return result2;
}
curryRight.placeholder = {};
var curryRight_default = curryRight;

// node_modules/lodash-es/now.js
var now2 = function() {
  return root_default2.Date.now();
};
var now_default = now2;

// node_modules/lodash-es/debounce.js
var FUNC_ERROR_TEXT6 = "Expected a function";
var nativeMax6 = Math.max;
var nativeMin4 = Math.min;
function debounce2(func, wait, options) {
  var lastArgs, lastThis, maxWait, result2, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
  if (typeof func != "function") {
    throw new TypeError(FUNC_ERROR_TEXT6);
  }
  wait = toNumber_default(wait) || 0;
  if (isObject_default(options)) {
    leading = !!options.leading;
    maxing = "maxWait" in options;
    maxWait = maxing ? nativeMax6(toNumber_default(options.maxWait) || 0, wait) : maxWait;
    trailing = "trailing" in options ? !!options.trailing : trailing;
  }
  function invokeFunc(time) {
    var args = lastArgs, thisArg = lastThis;
    lastArgs = lastThis = void 0;
    lastInvokeTime = time;
    result2 = func.apply(thisArg, args);
    return result2;
  }
  function leadingEdge(time) {
    lastInvokeTime = time;
    timerId = setTimeout(timerExpired, wait);
    return leading ? invokeFunc(time) : result2;
  }
  function remainingWait(time) {
    var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
    return maxing ? nativeMin4(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
  }
  function shouldInvoke(time) {
    var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
    return lastCallTime === void 0 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
  }
  function timerExpired() {
    var time = now_default();
    if (shouldInvoke(time)) {
      return trailingEdge(time);
    }
    timerId = setTimeout(timerExpired, remainingWait(time));
  }
  function trailingEdge(time) {
    timerId = void 0;
    if (trailing && lastArgs) {
      return invokeFunc(time);
    }
    lastArgs = lastThis = void 0;
    return result2;
  }
  function cancel2() {
    if (timerId !== void 0) {
      clearTimeout(timerId);
    }
    lastInvokeTime = 0;
    lastArgs = lastCallTime = lastThis = timerId = void 0;
  }
  function flush() {
    return timerId === void 0 ? result2 : trailingEdge(now_default());
  }
  function debounced() {
    var time = now_default(), isInvoking = shouldInvoke(time);
    lastArgs = arguments;
    lastThis = this;
    lastCallTime = time;
    if (isInvoking) {
      if (timerId === void 0) {
        return leadingEdge(lastCallTime);
      }
      if (maxing) {
        clearTimeout(timerId);
        timerId = setTimeout(timerExpired, wait);
        return invokeFunc(lastCallTime);
      }
    }
    if (timerId === void 0) {
      timerId = setTimeout(timerExpired, wait);
    }
    return result2;
  }
  debounced.cancel = cancel2;
  debounced.flush = flush;
  return debounced;
}
var debounce_default4 = debounce2;

// node_modules/lodash-es/defaultTo.js
function defaultTo(value2, defaultValue) {
  return value2 == null || value2 !== value2 ? defaultValue : value2;
}
var defaultTo_default = defaultTo;

// node_modules/lodash-es/defaults.js
var objectProto24 = Object.prototype;
var hasOwnProperty19 = objectProto24.hasOwnProperty;
var defaults4 = baseRest_default(function(object, sources) {
  object = Object(object);
  var index3 = -1;
  var length5 = sources.length;
  var guard = length5 > 2 ? sources[2] : void 0;
  if (guard && isIterateeCall_default(sources[0], sources[1], guard)) {
    length5 = 1;
  }
  while (++index3 < length5) {
    var source = sources[index3];
    var props = keysIn_default(source);
    var propsIndex = -1;
    var propsLength = props.length;
    while (++propsIndex < propsLength) {
      var key = props[propsIndex];
      var value2 = object[key];
      if (value2 === void 0 || eq_default(value2, objectProto24[key]) && !hasOwnProperty19.call(object, key)) {
        object[key] = source[key];
      }
    }
  }
  return object;
});
var defaults_default = defaults4;

// node_modules/lodash-es/_assignMergeValue.js
function assignMergeValue(object, key, value2) {
  if (value2 !== void 0 && !eq_default(object[key], value2) || value2 === void 0 && !(key in object)) {
    baseAssignValue_default(object, key, value2);
  }
}
var assignMergeValue_default = assignMergeValue;

// node_modules/lodash-es/isArrayLikeObject.js
function isArrayLikeObject(value2) {
  return isObjectLike_default(value2) && isArrayLike_default(value2);
}
var isArrayLikeObject_default = isArrayLikeObject;

// node_modules/lodash-es/_safeGet.js
function safeGet(object, key) {
  if (key === "constructor" && typeof object[key] === "function") {
    return;
  }
  if (key == "__proto__") {
    return;
  }
  return object[key];
}
var safeGet_default = safeGet;

// node_modules/lodash-es/toPlainObject.js
function toPlainObject(value2) {
  return copyObject_default(value2, keysIn_default(value2));
}
var toPlainObject_default = toPlainObject;

// node_modules/lodash-es/_baseMergeDeep.js
function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
  var objValue = safeGet_default(object, key), srcValue = safeGet_default(source, key), stacked = stack.get(srcValue);
  if (stacked) {
    assignMergeValue_default(object, key, stacked);
    return;
  }
  var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack) : void 0;
  var isCommon = newValue === void 0;
  if (isCommon) {
    var isArr = isArray_default(srcValue), isBuff = !isArr && isBuffer_default(srcValue), isTyped = !isArr && !isBuff && isTypedArray_default(srcValue);
    newValue = srcValue;
    if (isArr || isBuff || isTyped) {
      if (isArray_default(objValue)) {
        newValue = objValue;
      } else if (isArrayLikeObject_default(objValue)) {
        newValue = copyArray_default(objValue);
      } else if (isBuff) {
        isCommon = false;
        newValue = cloneBuffer_default(srcValue, true);
      } else if (isTyped) {
        isCommon = false;
        newValue = cloneTypedArray_default(srcValue, true);
      } else {
        newValue = [];
      }
    } else if (isPlainObject_default(srcValue) || isArguments_default(srcValue)) {
      newValue = objValue;
      if (isArguments_default(objValue)) {
        newValue = toPlainObject_default(objValue);
      } else if (!isObject_default(objValue) || isFunction_default(objValue)) {
        newValue = initCloneObject_default(srcValue);
      }
    } else {
      isCommon = false;
    }
  }
  if (isCommon) {
    stack.set(srcValue, newValue);
    mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
    stack["delete"](srcValue);
  }
  assignMergeValue_default(object, key, newValue);
}
var baseMergeDeep_default = baseMergeDeep;

// node_modules/lodash-es/_baseMerge.js
function baseMerge(object, source, srcIndex, customizer, stack) {
  if (object === source) {
    return;
  }
  baseFor_default(source, function(srcValue, key) {
    stack || (stack = new Stack_default());
    if (isObject_default(srcValue)) {
      baseMergeDeep_default(object, source, key, srcIndex, baseMerge, customizer, stack);
    } else {
      var newValue = customizer ? customizer(safeGet_default(object, key), srcValue, key + "", object, source, stack) : void 0;
      if (newValue === void 0) {
        newValue = srcValue;
      }
      assignMergeValue_default(object, key, newValue);
    }
  }, keysIn_default);
}
var baseMerge_default = baseMerge;

// node_modules/lodash-es/_customDefaultsMerge.js
function customDefaultsMerge(objValue, srcValue, key, object, source, stack) {
  if (isObject_default(objValue) && isObject_default(srcValue)) {
    stack.set(srcValue, objValue);
    baseMerge_default(objValue, srcValue, void 0, customDefaultsMerge, stack);
    stack["delete"](srcValue);
  }
  return objValue;
}
var customDefaultsMerge_default = customDefaultsMerge;

// node_modules/lodash-es/mergeWith.js
var mergeWith = createAssigner_default(function(object, source, srcIndex, customizer) {
  baseMerge_default(object, source, srcIndex, customizer);
});
var mergeWith_default = mergeWith;

// node_modules/lodash-es/defaultsDeep.js
var defaultsDeep = baseRest_default(function(args) {
  args.push(void 0, customDefaultsMerge_default);
  return apply_default(mergeWith_default, void 0, args);
});
var defaultsDeep_default = defaultsDeep;

// node_modules/lodash-es/_baseDelay.js
var FUNC_ERROR_TEXT7 = "Expected a function";
function baseDelay(func, wait, args) {
  if (typeof func != "function") {
    throw new TypeError(FUNC_ERROR_TEXT7);
  }
  return setTimeout(function() {
    func.apply(void 0, args);
  }, wait);
}
var baseDelay_default = baseDelay;

// node_modules/lodash-es/defer.js
var defer = baseRest_default(function(func, args) {
  return baseDelay_default(func, 1, args);
});
var defer_default = defer;

// node_modules/lodash-es/delay.js
var delay = baseRest_default(function(func, wait, args) {
  return baseDelay_default(func, toNumber_default(wait) || 0, args);
});
var delay_default = delay;

// node_modules/lodash-es/_arrayIncludesWith.js
function arrayIncludesWith(array2, value2, comparator) {
  var index3 = -1, length5 = array2 == null ? 0 : array2.length;
  while (++index3 < length5) {
    if (comparator(value2, array2[index3])) {
      return true;
    }
  }
  return false;
}
var arrayIncludesWith_default = arrayIncludesWith;

// node_modules/lodash-es/_baseDifference.js
var LARGE_ARRAY_SIZE2 = 200;
function baseDifference(array2, values4, iteratee2, comparator) {
  var index3 = -1, includes2 = arrayIncludes_default, isCommon = true, length5 = array2.length, result2 = [], valuesLength = values4.length;
  if (!length5) {
    return result2;
  }
  if (iteratee2) {
    values4 = arrayMap_default(values4, baseUnary_default(iteratee2));
  }
  if (comparator) {
    includes2 = arrayIncludesWith_default;
    isCommon = false;
  } else if (values4.length >= LARGE_ARRAY_SIZE2) {
    includes2 = cacheHas_default;
    isCommon = false;
    values4 = new SetCache_default(values4);
  }
  outer:
    while (++index3 < length5) {
      var value2 = array2[index3], computed = iteratee2 == null ? value2 : iteratee2(value2);
      value2 = comparator || value2 !== 0 ? value2 : 0;
      if (isCommon && computed === computed) {
        var valuesIndex = valuesLength;
        while (valuesIndex--) {
          if (values4[valuesIndex] === computed) {
            continue outer;
          }
        }
        result2.push(value2);
      } else if (!includes2(values4, computed, comparator)) {
        result2.push(value2);
      }
    }
  return result2;
}
var baseDifference_default = baseDifference;

// node_modules/lodash-es/difference.js
var difference2 = baseRest_default(function(array2, values4) {
  return isArrayLikeObject_default(array2) ? baseDifference_default(array2, baseFlatten_default(values4, 1, isArrayLikeObject_default, true)) : [];
});
var difference_default4 = difference2;

// node_modules/lodash-es/last.js
function last6(array2) {
  var length5 = array2 == null ? 0 : array2.length;
  return length5 ? array2[length5 - 1] : void 0;
}
var last_default = last6;

// node_modules/lodash-es/differenceBy.js
var differenceBy = baseRest_default(function(array2, values4) {
  var iteratee2 = last_default(values4);
  if (isArrayLikeObject_default(iteratee2)) {
    iteratee2 = void 0;
  }
  return isArrayLikeObject_default(array2) ? baseDifference_default(array2, baseFlatten_default(values4, 1, isArrayLikeObject_default, true), baseIteratee_default(iteratee2, 2)) : [];
});
var differenceBy_default = differenceBy;

// node_modules/lodash-es/differenceWith.js
var differenceWith = baseRest_default(function(array2, values4) {
  var comparator = last_default(values4);
  if (isArrayLikeObject_default(comparator)) {
    comparator = void 0;
  }
  return isArrayLikeObject_default(array2) ? baseDifference_default(array2, baseFlatten_default(values4, 1, isArrayLikeObject_default, true), void 0, comparator) : [];
});
var differenceWith_default = differenceWith;

// node_modules/lodash-es/divide.js
var divide5 = createMathOperation_default(function(dividend, divisor) {
  return dividend / divisor;
}, 1);
var divide_default = divide5;

// node_modules/lodash-es/drop.js
function drop(array2, n, guard) {
  var length5 = array2 == null ? 0 : array2.length;
  if (!length5) {
    return [];
  }
  n = guard || n === void 0 ? 1 : toInteger_default(n);
  return baseSlice_default(array2, n < 0 ? 0 : n, length5);
}
var drop_default = drop;

// node_modules/lodash-es/dropRight.js
function dropRight(array2, n, guard) {
  var length5 = array2 == null ? 0 : array2.length;
  if (!length5) {
    return [];
  }
  n = guard || n === void 0 ? 1 : toInteger_default(n);
  n = length5 - n;
  return baseSlice_default(array2, 0, n < 0 ? 0 : n);
}
var dropRight_default = dropRight;

// node_modules/lodash-es/_baseWhile.js
function baseWhile(array2, predicate, isDrop, fromRight) {
  var length5 = array2.length, index3 = fromRight ? length5 : -1;
  while ((fromRight ? index3-- : ++index3 < length5) && predicate(array2[index3], index3, array2)) {
  }
  return isDrop ? baseSlice_default(array2, fromRight ? 0 : index3, fromRight ? index3 + 1 : length5) : baseSlice_default(array2, fromRight ? index3 + 1 : 0, fromRight ? length5 : index3);
}
var baseWhile_default = baseWhile;

// node_modules/lodash-es/dropRightWhile.js
function dropRightWhile(array2, predicate) {
  return array2 && array2.length ? baseWhile_default(array2, baseIteratee_default(predicate, 3), true, true) : [];
}
var dropRightWhile_default = dropRightWhile;

// node_modules/lodash-es/dropWhile.js
function dropWhile(array2, predicate) {
  return array2 && array2.length ? baseWhile_default(array2, baseIteratee_default(predicate, 3), true) : [];
}
var dropWhile_default = dropWhile;

// node_modules/lodash-es/_castFunction.js
function castFunction(value2) {
  return typeof value2 == "function" ? value2 : identity_default8;
}
var castFunction_default = castFunction;

// node_modules/lodash-es/forEach.js
function forEach4(collection, iteratee2) {
  var func = isArray_default(collection) ? arrayEach_default : baseEach_default;
  return func(collection, castFunction_default(iteratee2));
}
var forEach_default = forEach4;

// node_modules/lodash-es/_arrayEachRight.js
function arrayEachRight(array2, iteratee2) {
  var length5 = array2 == null ? 0 : array2.length;
  while (length5--) {
    if (iteratee2(array2[length5], length5, array2) === false) {
      break;
    }
  }
  return array2;
}
var arrayEachRight_default = arrayEachRight;

// node_modules/lodash-es/_baseForRight.js
var baseForRight = createBaseFor_default(true);
var baseForRight_default = baseForRight;

// node_modules/lodash-es/_baseForOwnRight.js
function baseForOwnRight(object, iteratee2) {
  return object && baseForRight_default(object, iteratee2, keys_default4);
}
var baseForOwnRight_default = baseForOwnRight;

// node_modules/lodash-es/_baseEachRight.js
var baseEachRight = createBaseEach_default(baseForOwnRight_default, true);
var baseEachRight_default = baseEachRight;

// node_modules/lodash-es/forEachRight.js
function forEachRight(collection, iteratee2) {
  var func = isArray_default(collection) ? arrayEachRight_default : baseEachRight_default;
  return func(collection, castFunction_default(iteratee2));
}
var forEachRight_default = forEachRight;

// node_modules/lodash-es/endsWith.js
function endsWith(string, target, position) {
  string = toString_default(string);
  target = baseToString_default(target);
  var length5 = string.length;
  position = position === void 0 ? length5 : baseClamp_default(toInteger_default(position), 0, length5);
  var end = position;
  position -= target.length;
  return position >= 0 && string.slice(position, end) == target;
}
var endsWith_default = endsWith;

// node_modules/lodash-es/_baseToPairs.js
function baseToPairs(object, props) {
  return arrayMap_default(props, function(key) {
    return [key, object[key]];
  });
}
var baseToPairs_default = baseToPairs;

// node_modules/lodash-es/_setToPairs.js
function setToPairs(set9) {
  var index3 = -1, result2 = Array(set9.size);
  set9.forEach(function(value2) {
    result2[++index3] = [value2, value2];
  });
  return result2;
}
var setToPairs_default = setToPairs;

// node_modules/lodash-es/_createToPairs.js
var mapTag7 = "[object Map]";
var setTag7 = "[object Set]";
function createToPairs(keysFunc) {
  return function(object) {
    var tag = getTag_default(object);
    if (tag == mapTag7) {
      return mapToArray_default(object);
    }
    if (tag == setTag7) {
      return setToPairs_default(object);
    }
    return baseToPairs_default(object, keysFunc(object));
  };
}
var createToPairs_default = createToPairs;

// node_modules/lodash-es/toPairs.js
var toPairs = createToPairs_default(keys_default4);
var toPairs_default = toPairs;

// node_modules/lodash-es/toPairsIn.js
var toPairsIn = createToPairs_default(keysIn_default);
var toPairsIn_default = toPairsIn;

// node_modules/lodash-es/_escapeHtmlChar.js
var htmlEscapes = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#39;"
};
var escapeHtmlChar = basePropertyOf_default(htmlEscapes);
var escapeHtmlChar_default = escapeHtmlChar;

// node_modules/lodash-es/escape.js
var reUnescapedHtml = /[&<>"']/g;
var reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
function escape(string) {
  string = toString_default(string);
  return string && reHasUnescapedHtml.test(string) ? string.replace(reUnescapedHtml, escapeHtmlChar_default) : string;
}
var escape_default = escape;

// node_modules/lodash-es/escapeRegExp.js
var reRegExpChar2 = /[\\^$.*+?()[\]{}|]/g;
var reHasRegExpChar = RegExp(reRegExpChar2.source);
function escapeRegExp(string) {
  string = toString_default(string);
  return string && reHasRegExpChar.test(string) ? string.replace(reRegExpChar2, "\\$&") : string;
}
var escapeRegExp_default = escapeRegExp;

// node_modules/lodash-es/_arrayEvery.js
function arrayEvery(array2, predicate) {
  var index3 = -1, length5 = array2 == null ? 0 : array2.length;
  while (++index3 < length5) {
    if (!predicate(array2[index3], index3, array2)) {
      return false;
    }
  }
  return true;
}
var arrayEvery_default = arrayEvery;

// node_modules/lodash-es/_baseEvery.js
function baseEvery(collection, predicate) {
  var result2 = true;
  baseEach_default(collection, function(value2, index3, collection2) {
    result2 = !!predicate(value2, index3, collection2);
    return result2;
  });
  return result2;
}
var baseEvery_default = baseEvery;

// node_modules/lodash-es/every.js
function every2(collection, predicate, guard) {
  var func = isArray_default(collection) ? arrayEvery_default : baseEvery_default;
  if (guard && isIterateeCall_default(collection, predicate, guard)) {
    predicate = void 0;
  }
  return func(collection, baseIteratee_default(predicate, 3));
}
var every_default4 = every2;

// node_modules/lodash-es/toLength.js
var MAX_ARRAY_LENGTH2 = 4294967295;
function toLength(value2) {
  return value2 ? baseClamp_default(toInteger_default(value2), 0, MAX_ARRAY_LENGTH2) : 0;
}
var toLength_default = toLength;

// node_modules/lodash-es/_baseFill.js
function baseFill(array2, value2, start, end) {
  var length5 = array2.length;
  start = toInteger_default(start);
  if (start < 0) {
    start = -start > length5 ? 0 : length5 + start;
  }
  end = end === void 0 || end > length5 ? length5 : toInteger_default(end);
  if (end < 0) {
    end += length5;
  }
  end = start > end ? 0 : toLength_default(end);
  while (start < end) {
    array2[start++] = value2;
  }
  return array2;
}
var baseFill_default = baseFill;

// node_modules/lodash-es/fill.js
function fill(array2, value2, start, end) {
  var length5 = array2 == null ? 0 : array2.length;
  if (!length5) {
    return [];
  }
  if (start && typeof start != "number" && isIterateeCall_default(array2, value2, start)) {
    start = 0;
    end = length5;
  }
  return baseFill_default(array2, value2, start, end);
}
var fill_default = fill;

// node_modules/lodash-es/_baseFilter.js
function baseFilter(collection, predicate) {
  var result2 = [];
  baseEach_default(collection, function(value2, index3, collection2) {
    if (predicate(value2, index3, collection2)) {
      result2.push(value2);
    }
  });
  return result2;
}
var baseFilter_default = baseFilter;

// node_modules/lodash-es/filter.js
function filter3(collection, predicate) {
  var func = isArray_default(collection) ? arrayFilter_default : baseFilter_default;
  return func(collection, baseIteratee_default(predicate, 3));
}
var filter_default4 = filter3;

// node_modules/lodash-es/_createFind.js
function createFind(findIndexFunc) {
  return function(collection, predicate, fromIndex) {
    var iterable = Object(collection);
    if (!isArrayLike_default(collection)) {
      var iteratee2 = baseIteratee_default(predicate, 3);
      collection = keys_default4(collection);
      predicate = function(key) {
        return iteratee2(iterable[key], key, iterable);
      };
    }
    var index3 = findIndexFunc(collection, predicate, fromIndex);
    return index3 > -1 ? iterable[iteratee2 ? collection[index3] : index3] : void 0;
  };
}
var createFind_default = createFind;

// node_modules/lodash-es/findIndex.js
var nativeMax7 = Math.max;
function findIndex(array2, predicate, fromIndex) {
  var length5 = array2 == null ? 0 : array2.length;
  if (!length5) {
    return -1;
  }
  var index3 = fromIndex == null ? 0 : toInteger_default(fromIndex);
  if (index3 < 0) {
    index3 = nativeMax7(length5 + index3, 0);
  }
  return baseFindIndex_default(array2, baseIteratee_default(predicate, 3), index3);
}
var findIndex_default = findIndex;

// node_modules/lodash-es/find.js
var find4 = createFind_default(findIndex_default);
var find_default6 = find4;

// node_modules/lodash-es/_baseFindKey.js
function baseFindKey(collection, predicate, eachFunc) {
  var result2;
  eachFunc(collection, function(value2, key, collection2) {
    if (predicate(value2, key, collection2)) {
      result2 = key;
      return false;
    }
  });
  return result2;
}
var baseFindKey_default = baseFindKey;

// node_modules/lodash-es/findKey.js
function findKey(object, predicate) {
  return baseFindKey_default(object, baseIteratee_default(predicate, 3), baseForOwn_default);
}
var findKey_default = findKey;

// node_modules/lodash-es/findLastIndex.js
var nativeMax8 = Math.max;
var nativeMin5 = Math.min;
function findLastIndex(array2, predicate, fromIndex) {
  var length5 = array2 == null ? 0 : array2.length;
  if (!length5) {
    return -1;
  }
  var index3 = length5 - 1;
  if (fromIndex !== void 0) {
    index3 = toInteger_default(fromIndex);
    index3 = fromIndex < 0 ? nativeMax8(length5 + index3, 0) : nativeMin5(index3, length5 - 1);
  }
  return baseFindIndex_default(array2, baseIteratee_default(predicate, 3), index3, true);
}
var findLastIndex_default = findLastIndex;

// node_modules/lodash-es/findLast.js
var findLast = createFind_default(findLastIndex_default);
var findLast_default = findLast;

// node_modules/lodash-es/findLastKey.js
function findLastKey(object, predicate) {
  return baseFindKey_default(object, baseIteratee_default(predicate, 3), baseForOwnRight_default);
}
var findLastKey_default = findLastKey;

// node_modules/lodash-es/head.js
function head4(array2) {
  return array2 && array2.length ? array2[0] : void 0;
}
var head_default = head4;

// node_modules/lodash-es/_baseMap.js
function baseMap(collection, iteratee2) {
  var index3 = -1, result2 = isArrayLike_default(collection) ? Array(collection.length) : [];
  baseEach_default(collection, function(value2, key, collection2) {
    result2[++index3] = iteratee2(value2, key, collection2);
  });
  return result2;
}
var baseMap_default = baseMap;

// node_modules/lodash-es/map.js
function map4(collection, iteratee2) {
  var func = isArray_default(collection) ? arrayMap_default : baseMap_default;
  return func(collection, baseIteratee_default(iteratee2, 3));
}
var map_default4 = map4;

// node_modules/lodash-es/flatMap.js
function flatMap(collection, iteratee2) {
  return baseFlatten_default(map_default4(collection, iteratee2), 1);
}
var flatMap_default = flatMap;

// node_modules/lodash-es/flatMapDeep.js
var INFINITY4 = 1 / 0;
function flatMapDeep(collection, iteratee2) {
  return baseFlatten_default(map_default4(collection, iteratee2), INFINITY4);
}
var flatMapDeep_default = flatMapDeep;

// node_modules/lodash-es/flatMapDepth.js
function flatMapDepth(collection, iteratee2, depth) {
  depth = depth === void 0 ? 1 : toInteger_default(depth);
  return baseFlatten_default(map_default4(collection, iteratee2), depth);
}
var flatMapDepth_default = flatMapDepth;

// node_modules/lodash-es/flattenDeep.js
var INFINITY5 = 1 / 0;
function flattenDeep(array2) {
  var length5 = array2 == null ? 0 : array2.length;
  return length5 ? baseFlatten_default(array2, INFINITY5) : [];
}
var flattenDeep_default = flattenDeep;

// node_modules/lodash-es/flattenDepth.js
function flattenDepth(array2, depth) {
  var length5 = array2 == null ? 0 : array2.length;
  if (!length5) {
    return [];
  }
  depth = depth === void 0 ? 1 : toInteger_default(depth);
  return baseFlatten_default(array2, depth);
}
var flattenDepth_default = flattenDepth;

// node_modules/lodash-es/flip.js
var WRAP_FLIP_FLAG3 = 512;
function flip(func) {
  return createWrap_default(func, WRAP_FLIP_FLAG3);
}
var flip_default = flip;

// node_modules/lodash-es/floor.js
var floor4 = createRound_default("floor");
var floor_default = floor4;

// node_modules/lodash-es/_createFlow.js
var FUNC_ERROR_TEXT8 = "Expected a function";
var WRAP_CURRY_FLAG7 = 8;
var WRAP_PARTIAL_FLAG6 = 32;
var WRAP_ARY_FLAG5 = 128;
var WRAP_REARG_FLAG3 = 256;
function createFlow(fromRight) {
  return flatRest_default(function(funcs) {
    var length5 = funcs.length, index3 = length5, prereq = LodashWrapper_default.prototype.thru;
    if (fromRight) {
      funcs.reverse();
    }
    while (index3--) {
      var func = funcs[index3];
      if (typeof func != "function") {
        throw new TypeError(FUNC_ERROR_TEXT8);
      }
      if (prereq && !wrapper && getFuncName_default(func) == "wrapper") {
        var wrapper = new LodashWrapper_default([], true);
      }
    }
    index3 = wrapper ? index3 : length5;
    while (++index3 < length5) {
      func = funcs[index3];
      var funcName = getFuncName_default(func), data2 = funcName == "wrapper" ? getData_default(func) : void 0;
      if (data2 && isLaziable_default(data2[0]) && data2[1] == (WRAP_ARY_FLAG5 | WRAP_CURRY_FLAG7 | WRAP_PARTIAL_FLAG6 | WRAP_REARG_FLAG3) && !data2[4].length && data2[9] == 1) {
        wrapper = wrapper[getFuncName_default(data2[0])].apply(wrapper, data2[3]);
      } else {
        wrapper = func.length == 1 && isLaziable_default(func) ? wrapper[funcName]() : wrapper.thru(func);
      }
    }
    return function() {
      var args = arguments, value2 = args[0];
      if (wrapper && args.length == 1 && isArray_default(value2)) {
        return wrapper.plant(value2).value();
      }
      var index4 = 0, result2 = length5 ? funcs[index4].apply(this, args) : value2;
      while (++index4 < length5) {
        result2 = funcs[index4].call(this, result2);
      }
      return result2;
    };
  });
}
var createFlow_default = createFlow;

// node_modules/lodash-es/flow.js
var flow2 = createFlow_default();
var flow_default = flow2;

// node_modules/lodash-es/flowRight.js
var flowRight = createFlow_default(true);
var flowRight_default = flowRight;

// node_modules/lodash-es/forIn.js
function forIn(object, iteratee2) {
  return object == null ? object : baseFor_default(object, castFunction_default(iteratee2), keysIn_default);
}
var forIn_default = forIn;

// node_modules/lodash-es/forInRight.js
function forInRight(object, iteratee2) {
  return object == null ? object : baseForRight_default(object, castFunction_default(iteratee2), keysIn_default);
}
var forInRight_default = forInRight;

// node_modules/lodash-es/forOwn.js
function forOwn(object, iteratee2) {
  return object && baseForOwn_default(object, castFunction_default(iteratee2));
}
var forOwn_default = forOwn;

// node_modules/lodash-es/forOwnRight.js
function forOwnRight(object, iteratee2) {
  return object && baseForOwnRight_default(object, castFunction_default(iteratee2));
}
var forOwnRight_default = forOwnRight;

// node_modules/lodash-es/fromPairs.js
function fromPairs(pairs2) {
  var index3 = -1, length5 = pairs2 == null ? 0 : pairs2.length, result2 = {};
  while (++index3 < length5) {
    var pair = pairs2[index3];
    result2[pair[0]] = pair[1];
  }
  return result2;
}
var fromPairs_default = fromPairs;

// node_modules/lodash-es/_baseFunctions.js
function baseFunctions(object, props) {
  return arrayFilter_default(props, function(key) {
    return isFunction_default(object[key]);
  });
}
var baseFunctions_default = baseFunctions;

// node_modules/lodash-es/functions.js
function functions(object) {
  return object == null ? [] : baseFunctions_default(object, keys_default4(object));
}
var functions_default = functions;

// node_modules/lodash-es/functionsIn.js
function functionsIn(object) {
  return object == null ? [] : baseFunctions_default(object, keysIn_default(object));
}
var functionsIn_default = functionsIn;

// node_modules/lodash-es/groupBy.js
var objectProto25 = Object.prototype;
var hasOwnProperty20 = objectProto25.hasOwnProperty;
var groupBy2 = createAggregator_default(function(result2, value2, key) {
  if (hasOwnProperty20.call(result2, key)) {
    result2[key].push(value2);
  } else {
    baseAssignValue_default(result2, key, [value2]);
  }
});
var groupBy_default = groupBy2;

// node_modules/lodash-es/_baseGt.js
function baseGt(value2, other) {
  return value2 > other;
}
var baseGt_default = baseGt;

// node_modules/lodash-es/_createRelationalOperation.js
function createRelationalOperation(operator) {
  return function(value2, other) {
    if (!(typeof value2 == "string" && typeof other == "string")) {
      value2 = toNumber_default(value2);
      other = toNumber_default(other);
    }
    return operator(value2, other);
  };
}
var createRelationalOperation_default = createRelationalOperation;

// node_modules/lodash-es/gt.js
var gt = createRelationalOperation_default(baseGt_default);
var gt_default = gt;

// node_modules/lodash-es/gte.js
var gte = createRelationalOperation_default(function(value2, other) {
  return value2 >= other;
});
var gte_default = gte;

// node_modules/lodash-es/_baseHas.js
var objectProto26 = Object.prototype;
var hasOwnProperty21 = objectProto26.hasOwnProperty;
function baseHas(object, key) {
  return object != null && hasOwnProperty21.call(object, key);
}
var baseHas_default = baseHas;

// node_modules/lodash-es/has.js
function has(object, path2) {
  return object != null && hasPath_default(object, path2, baseHas_default);
}
var has_default4 = has;

// node_modules/lodash-es/_baseInRange.js
var nativeMax9 = Math.max;
var nativeMin6 = Math.min;
function baseInRange(number2, start, end) {
  return number2 >= nativeMin6(start, end) && number2 < nativeMax9(start, end);
}
var baseInRange_default = baseInRange;

// node_modules/lodash-es/inRange.js
function inRange2(number2, start, end) {
  start = toFinite_default(start);
  if (end === void 0) {
    end = start;
    start = 0;
  } else {
    end = toFinite_default(end);
  }
  number2 = toNumber_default(number2);
  return baseInRange_default(number2, start, end);
}
var inRange_default = inRange2;

// node_modules/lodash-es/isString.js
var stringTag5 = "[object String]";
function isString(value2) {
  return typeof value2 == "string" || !isArray_default(value2) && isObjectLike_default(value2) && baseGetTag_default(value2) == stringTag5;
}
var isString_default = isString;

// node_modules/lodash-es/_baseValues.js
function baseValues(object, props) {
  return arrayMap_default(props, function(key) {
    return object[key];
  });
}
var baseValues_default = baseValues;

// node_modules/lodash-es/values.js
function values3(object) {
  return object == null ? [] : baseValues_default(object, keys_default4(object));
}
var values_default4 = values3;

// node_modules/lodash-es/includes.js
var nativeMax10 = Math.max;
function includes(collection, value2, fromIndex, guard) {
  collection = isArrayLike_default(collection) ? collection : values_default4(collection);
  fromIndex = fromIndex && !guard ? toInteger_default(fromIndex) : 0;
  var length5 = collection.length;
  if (fromIndex < 0) {
    fromIndex = nativeMax10(length5 + fromIndex, 0);
  }
  return isString_default(collection) ? fromIndex <= length5 && collection.indexOf(value2, fromIndex) > -1 : !!length5 && baseIndexOf_default(collection, value2, fromIndex) > -1;
}
var includes_default = includes;

// node_modules/lodash-es/indexOf.js
var nativeMax11 = Math.max;
function indexOf6(array2, value2, fromIndex) {
  var length5 = array2 == null ? 0 : array2.length;
  if (!length5) {
    return -1;
  }
  var index3 = fromIndex == null ? 0 : toInteger_default(fromIndex);
  if (index3 < 0) {
    index3 = nativeMax11(length5 + index3, 0);
  }
  return baseIndexOf_default(array2, value2, index3);
}
var indexOf_default = indexOf6;

// node_modules/lodash-es/initial.js
function initial(array2) {
  var length5 = array2 == null ? 0 : array2.length;
  return length5 ? baseSlice_default(array2, 0, -1) : [];
}
var initial_default = initial;

// node_modules/lodash-es/_baseIntersection.js
var nativeMin7 = Math.min;
function baseIntersection(arrays, iteratee2, comparator) {
  var includes2 = comparator ? arrayIncludesWith_default : arrayIncludes_default, length5 = arrays[0].length, othLength = arrays.length, othIndex = othLength, caches = Array(othLength), maxLength = Infinity, result2 = [];
  while (othIndex--) {
    var array2 = arrays[othIndex];
    if (othIndex && iteratee2) {
      array2 = arrayMap_default(array2, baseUnary_default(iteratee2));
    }
    maxLength = nativeMin7(array2.length, maxLength);
    caches[othIndex] = !comparator && (iteratee2 || length5 >= 120 && array2.length >= 120) ? new SetCache_default(othIndex && array2) : void 0;
  }
  array2 = arrays[0];
  var index3 = -1, seen = caches[0];
  outer:
    while (++index3 < length5 && result2.length < maxLength) {
      var value2 = array2[index3], computed = iteratee2 ? iteratee2(value2) : value2;
      value2 = comparator || value2 !== 0 ? value2 : 0;
      if (!(seen ? cacheHas_default(seen, computed) : includes2(result2, computed, comparator))) {
        othIndex = othLength;
        while (--othIndex) {
          var cache2 = caches[othIndex];
          if (!(cache2 ? cacheHas_default(cache2, computed) : includes2(arrays[othIndex], computed, comparator))) {
            continue outer;
          }
        }
        if (seen) {
          seen.push(computed);
        }
        result2.push(value2);
      }
    }
  return result2;
}
var baseIntersection_default = baseIntersection;

// node_modules/lodash-es/_castArrayLikeObject.js
function castArrayLikeObject(value2) {
  return isArrayLikeObject_default(value2) ? value2 : [];
}
var castArrayLikeObject_default = castArrayLikeObject;

// node_modules/lodash-es/intersection.js
var intersection3 = baseRest_default(function(arrays) {
  var mapped = arrayMap_default(arrays, castArrayLikeObject_default);
  return mapped.length && mapped[0] === arrays[0] ? baseIntersection_default(mapped) : [];
});
var intersection_default = intersection3;

// node_modules/lodash-es/intersectionBy.js
var intersectionBy = baseRest_default(function(arrays) {
  var iteratee2 = last_default(arrays), mapped = arrayMap_default(arrays, castArrayLikeObject_default);
  if (iteratee2 === last_default(mapped)) {
    iteratee2 = void 0;
  } else {
    mapped.pop();
  }
  return mapped.length && mapped[0] === arrays[0] ? baseIntersection_default(mapped, baseIteratee_default(iteratee2, 2)) : [];
});
var intersectionBy_default = intersectionBy;

// node_modules/lodash-es/intersectionWith.js
var intersectionWith = baseRest_default(function(arrays) {
  var comparator = last_default(arrays), mapped = arrayMap_default(arrays, castArrayLikeObject_default);
  comparator = typeof comparator == "function" ? comparator : void 0;
  if (comparator) {
    mapped.pop();
  }
  return mapped.length && mapped[0] === arrays[0] ? baseIntersection_default(mapped, void 0, comparator) : [];
});
var intersectionWith_default = intersectionWith;

// node_modules/lodash-es/_baseInverter.js
function baseInverter(object, setter, iteratee2, accumulator) {
  baseForOwn_default(object, function(value2, key, object2) {
    setter(accumulator, iteratee2(value2), key, object2);
  });
  return accumulator;
}
var baseInverter_default = baseInverter;

// node_modules/lodash-es/_createInverter.js
function createInverter(setter, toIteratee) {
  return function(object, iteratee2) {
    return baseInverter_default(object, setter, toIteratee(iteratee2), {});
  };
}
var createInverter_default = createInverter;

// node_modules/lodash-es/invert.js
var objectProto27 = Object.prototype;
var nativeObjectToString3 = objectProto27.toString;
var invert5 = createInverter_default(function(result2, value2, key) {
  if (value2 != null && typeof value2.toString != "function") {
    value2 = nativeObjectToString3.call(value2);
  }
  result2[value2] = key;
}, constant_default6(identity_default8));
var invert_default = invert5;

// node_modules/lodash-es/invertBy.js
var objectProto28 = Object.prototype;
var hasOwnProperty22 = objectProto28.hasOwnProperty;
var nativeObjectToString4 = objectProto28.toString;
var invertBy = createInverter_default(function(result2, value2, key) {
  if (value2 != null && typeof value2.toString != "function") {
    value2 = nativeObjectToString4.call(value2);
  }
  if (hasOwnProperty22.call(result2, value2)) {
    result2[value2].push(key);
  } else {
    result2[value2] = [key];
  }
}, baseIteratee_default);
var invertBy_default = invertBy;

// node_modules/lodash-es/_parent.js
function parent(object, path2) {
  return path2.length < 2 ? object : baseGet_default(object, baseSlice_default(path2, 0, -1));
}
var parent_default = parent;

// node_modules/lodash-es/_baseInvoke.js
function baseInvoke(object, path2, args) {
  path2 = castPath_default(path2, object);
  object = parent_default(object, path2);
  var func = object == null ? object : object[toKey_default(last_default(path2))];
  return func == null ? void 0 : apply_default(func, object, args);
}
var baseInvoke_default = baseInvoke;

// node_modules/lodash-es/invoke.js
var invoke = baseRest_default(baseInvoke_default);
var invoke_default = invoke;

// node_modules/lodash-es/invokeMap.js
var invokeMap = baseRest_default(function(collection, path2, args) {
  var index3 = -1, isFunc = typeof path2 == "function", result2 = isArrayLike_default(collection) ? Array(collection.length) : [];
  baseEach_default(collection, function(value2) {
    result2[++index3] = isFunc ? apply_default(path2, value2, args) : baseInvoke_default(value2, path2, args);
  });
  return result2;
});
var invokeMap_default = invokeMap;

// node_modules/lodash-es/_baseIsArrayBuffer.js
var arrayBufferTag5 = "[object ArrayBuffer]";
function baseIsArrayBuffer(value2) {
  return isObjectLike_default(value2) && baseGetTag_default(value2) == arrayBufferTag5;
}
var baseIsArrayBuffer_default = baseIsArrayBuffer;

// node_modules/lodash-es/isArrayBuffer.js
var nodeIsArrayBuffer = nodeUtil_default && nodeUtil_default.isArrayBuffer;
var isArrayBuffer = nodeIsArrayBuffer ? baseUnary_default(nodeIsArrayBuffer) : baseIsArrayBuffer_default;
var isArrayBuffer_default = isArrayBuffer;

// node_modules/lodash-es/isBoolean.js
var boolTag5 = "[object Boolean]";
function isBoolean2(value2) {
  return value2 === true || value2 === false || isObjectLike_default(value2) && baseGetTag_default(value2) == boolTag5;
}
var isBoolean_default = isBoolean2;

// node_modules/lodash-es/_baseIsDate.js
var dateTag5 = "[object Date]";
function baseIsDate(value2) {
  return isObjectLike_default(value2) && baseGetTag_default(value2) == dateTag5;
}
var baseIsDate_default = baseIsDate;

// node_modules/lodash-es/isDate.js
var nodeIsDate = nodeUtil_default && nodeUtil_default.isDate;
var isDate = nodeIsDate ? baseUnary_default(nodeIsDate) : baseIsDate_default;
var isDate_default = isDate;

// node_modules/lodash-es/isElement.js
function isElement3(value2) {
  return isObjectLike_default(value2) && value2.nodeType === 1 && !isPlainObject_default(value2);
}
var isElement_default = isElement3;

// node_modules/lodash-es/isEmpty.js
var mapTag8 = "[object Map]";
var setTag8 = "[object Set]";
var objectProto29 = Object.prototype;
var hasOwnProperty23 = objectProto29.hasOwnProperty;
function isEmpty3(value2) {
  if (value2 == null) {
    return true;
  }
  if (isArrayLike_default(value2) && (isArray_default(value2) || typeof value2 == "string" || typeof value2.splice == "function" || isBuffer_default(value2) || isTypedArray_default(value2) || isArguments_default(value2))) {
    return !value2.length;
  }
  var tag = getTag_default(value2);
  if (tag == mapTag8 || tag == setTag8) {
    return !value2.size;
  }
  if (isPrototype_default(value2)) {
    return !baseKeys_default(value2).length;
  }
  for (var key in value2) {
    if (hasOwnProperty23.call(value2, key)) {
      return false;
    }
  }
  return true;
}
var isEmpty_default = isEmpty3;

// node_modules/lodash-es/isEqual.js
function isEqual2(value2, other) {
  return baseIsEqual_default(value2, other);
}
var isEqual_default = isEqual2;

// node_modules/lodash-es/isEqualWith.js
function isEqualWith(value2, other, customizer) {
  customizer = typeof customizer == "function" ? customizer : void 0;
  var result2 = customizer ? customizer(value2, other) : void 0;
  return result2 === void 0 ? baseIsEqual_default(value2, other, void 0, customizer) : !!result2;
}
var isEqualWith_default = isEqualWith;

// node_modules/lodash-es/isFinite.js
var nativeIsFinite2 = root_default2.isFinite;
function isFinite2(value2) {
  return typeof value2 == "number" && nativeIsFinite2(value2);
}
var isFinite_default = isFinite2;

// node_modules/lodash-es/isInteger.js
function isInteger4(value2) {
  return typeof value2 == "number" && value2 == toInteger_default(value2);
}
var isInteger_default = isInteger4;

// node_modules/lodash-es/isMatch.js
function isMatch(object, source) {
  return object === source || baseIsMatch_default(object, source, getMatchData_default(source));
}
var isMatch_default = isMatch;

// node_modules/lodash-es/isMatchWith.js
function isMatchWith(object, source, customizer) {
  customizer = typeof customizer == "function" ? customizer : void 0;
  return baseIsMatch_default(object, source, getMatchData_default(source), customizer);
}
var isMatchWith_default = isMatchWith;

// node_modules/lodash-es/isNumber.js
var numberTag5 = "[object Number]";
function isNumber4(value2) {
  return typeof value2 == "number" || isObjectLike_default(value2) && baseGetTag_default(value2) == numberTag5;
}
var isNumber_default = isNumber4;

// node_modules/lodash-es/isNaN.js
function isNaN2(value2) {
  return isNumber_default(value2) && value2 != +value2;
}
var isNaN_default = isNaN2;

// node_modules/lodash-es/_isMaskable.js
var isMaskable = coreJsData_default ? isFunction_default : stubFalse_default;
var isMaskable_default = isMaskable;

// node_modules/lodash-es/isNative.js
var CORE_ERROR_TEXT = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.";
function isNative(value2) {
  if (isMaskable_default(value2)) {
    throw new Error(CORE_ERROR_TEXT);
  }
  return baseIsNative_default(value2);
}
var isNative_default = isNative;

// node_modules/lodash-es/isNil.js
function isNil3(value2) {
  return value2 == null;
}
var isNil_default = isNil3;

// node_modules/lodash-es/isNull.js
function isNull2(value2) {
  return value2 === null;
}
var isNull_default = isNull2;

// node_modules/lodash-es/_baseIsRegExp.js
var regexpTag5 = "[object RegExp]";
function baseIsRegExp(value2) {
  return isObjectLike_default(value2) && baseGetTag_default(value2) == regexpTag5;
}
var baseIsRegExp_default = baseIsRegExp;

// node_modules/lodash-es/isRegExp.js
var nodeIsRegExp = nodeUtil_default && nodeUtil_default.isRegExp;
var isRegExp = nodeIsRegExp ? baseUnary_default(nodeIsRegExp) : baseIsRegExp_default;
var isRegExp_default = isRegExp;

// node_modules/lodash-es/isSafeInteger.js
var MAX_SAFE_INTEGER3 = 9007199254740991;
function isSafeInteger(value2) {
  return isInteger_default(value2) && value2 >= -MAX_SAFE_INTEGER3 && value2 <= MAX_SAFE_INTEGER3;
}
var isSafeInteger_default = isSafeInteger;

// node_modules/lodash-es/isUndefined.js
function isUndefined3(value2) {
  return value2 === void 0;
}
var isUndefined_default = isUndefined3;

// node_modules/lodash-es/isWeakMap.js
var weakMapTag4 = "[object WeakMap]";
function isWeakMap(value2) {
  return isObjectLike_default(value2) && getTag_default(value2) == weakMapTag4;
}
var isWeakMap_default = isWeakMap;

// node_modules/lodash-es/isWeakSet.js
var weakSetTag = "[object WeakSet]";
function isWeakSet(value2) {
  return isObjectLike_default(value2) && baseGetTag_default(value2) == weakSetTag;
}
var isWeakSet_default = isWeakSet;

// node_modules/lodash-es/iteratee.js
var CLONE_DEEP_FLAG5 = 1;
function iteratee(func) {
  return baseIteratee_default(typeof func == "function" ? func : baseClone_default(func, CLONE_DEEP_FLAG5));
}
var iteratee_default = iteratee;

// node_modules/lodash-es/join.js
var arrayProto2 = Array.prototype;
var nativeJoin = arrayProto2.join;
function join(array2, separator) {
  return array2 == null ? "" : nativeJoin.call(array2, separator);
}
var join_default = join;

// node_modules/lodash-es/kebabCase.js
var kebabCase2 = createCompounder_default(function(result2, word2, index3) {
  return result2 + (index3 ? "-" : "") + word2.toLowerCase();
});
var kebabCase_default = kebabCase2;

// node_modules/lodash-es/keyBy.js
var keyBy = createAggregator_default(function(result2, value2, key) {
  baseAssignValue_default(result2, key, value2);
});
var keyBy_default = keyBy;

// node_modules/lodash-es/_strictLastIndexOf.js
function strictLastIndexOf(array2, value2, fromIndex) {
  var index3 = fromIndex + 1;
  while (index3--) {
    if (array2[index3] === value2) {
      return index3;
    }
  }
  return index3;
}
var strictLastIndexOf_default = strictLastIndexOf;

// node_modules/lodash-es/lastIndexOf.js
var nativeMax12 = Math.max;
var nativeMin8 = Math.min;
function lastIndexOf(array2, value2, fromIndex) {
  var length5 = array2 == null ? 0 : array2.length;
  if (!length5) {
    return -1;
  }
  var index3 = length5;
  if (fromIndex !== void 0) {
    index3 = toInteger_default(fromIndex);
    index3 = index3 < 0 ? nativeMax12(length5 + index3, 0) : nativeMin8(index3, length5 - 1);
  }
  return value2 === value2 ? strictLastIndexOf_default(array2, value2, index3) : baseFindIndex_default(array2, baseIsNaN_default, index3, true);
}
var lastIndexOf_default = lastIndexOf;

// node_modules/lodash-es/lowerCase.js
var lowerCase = createCompounder_default(function(result2, word2, index3) {
  return result2 + (index3 ? " " : "") + word2.toLowerCase();
});
var lowerCase_default = lowerCase;

// node_modules/lodash-es/lowerFirst.js
var lowerFirst2 = createCaseFirst_default("toLowerCase");
var lowerFirst_default = lowerFirst2;

// node_modules/lodash-es/_baseLt.js
function baseLt(value2, other) {
  return value2 < other;
}
var baseLt_default = baseLt;

// node_modules/lodash-es/lt.js
var lt = createRelationalOperation_default(baseLt_default);
var lt_default = lt;

// node_modules/lodash-es/lte.js
var lte = createRelationalOperation_default(function(value2, other) {
  return value2 <= other;
});
var lte_default = lte;

// node_modules/lodash-es/mapKeys.js
function mapKeys(object, iteratee2) {
  var result2 = {};
  iteratee2 = baseIteratee_default(iteratee2, 3);
  baseForOwn_default(object, function(value2, key, object2) {
    baseAssignValue_default(result2, iteratee2(value2, key, object2), value2);
  });
  return result2;
}
var mapKeys_default = mapKeys;

// node_modules/lodash-es/mapValues.js
function mapValues(object, iteratee2) {
  var result2 = {};
  iteratee2 = baseIteratee_default(iteratee2, 3);
  baseForOwn_default(object, function(value2, key, object2) {
    baseAssignValue_default(result2, key, iteratee2(value2, key, object2));
  });
  return result2;
}
var mapValues_default = mapValues;

// node_modules/lodash-es/matches.js
var CLONE_DEEP_FLAG6 = 1;
function matches(source) {
  return baseMatches_default(baseClone_default(source, CLONE_DEEP_FLAG6));
}
var matches_default = matches;

// node_modules/lodash-es/matchesProperty.js
var CLONE_DEEP_FLAG7 = 1;
function matchesProperty(path2, srcValue) {
  return baseMatchesProperty_default(path2, baseClone_default(srcValue, CLONE_DEEP_FLAG7));
}
var matchesProperty_default = matchesProperty;

// node_modules/lodash-es/_baseExtremum.js
function baseExtremum(array2, iteratee2, comparator) {
  var index3 = -1, length5 = array2.length;
  while (++index3 < length5) {
    var value2 = array2[index3], current = iteratee2(value2);
    if (current != null && (computed === void 0 ? current === current && !isSymbol_default(current) : comparator(current, computed))) {
      var computed = current, result2 = value2;
    }
  }
  return result2;
}
var baseExtremum_default = baseExtremum;

// node_modules/lodash-es/max.js
function max10(array2) {
  return array2 && array2.length ? baseExtremum_default(array2, identity_default8, baseGt_default) : void 0;
}
var max_default4 = max10;

// node_modules/lodash-es/maxBy.js
function maxBy(array2, iteratee2) {
  return array2 && array2.length ? baseExtremum_default(array2, baseIteratee_default(iteratee2, 2), baseGt_default) : void 0;
}
var maxBy_default = maxBy;

// node_modules/lodash-es/_baseSum.js
function baseSum(array2, iteratee2) {
  var result2, index3 = -1, length5 = array2.length;
  while (++index3 < length5) {
    var current = iteratee2(array2[index3]);
    if (current !== void 0) {
      result2 = result2 === void 0 ? current : result2 + current;
    }
  }
  return result2;
}
var baseSum_default = baseSum;

// node_modules/lodash-es/_baseMean.js
var NAN3 = 0 / 0;
function baseMean(array2, iteratee2) {
  var length5 = array2 == null ? 0 : array2.length;
  return length5 ? baseSum_default(array2, iteratee2) / length5 : NAN3;
}
var baseMean_default = baseMean;

// node_modules/lodash-es/mean.js
function mean3(array2) {
  return baseMean_default(array2, identity_default8);
}
var mean_default = mean3;

// node_modules/lodash-es/meanBy.js
function meanBy(array2, iteratee2) {
  return baseMean_default(array2, baseIteratee_default(iteratee2, 2));
}
var meanBy_default = meanBy;

// node_modules/lodash-es/merge.js
var merge2 = createAssigner_default(function(object, source, srcIndex) {
  baseMerge_default(object, source, srcIndex);
});
var merge_default = merge2;

// node_modules/lodash-es/method.js
var method = baseRest_default(function(path2, args) {
  return function(object) {
    return baseInvoke_default(object, path2, args);
  };
});
var method_default = method;

// node_modules/lodash-es/methodOf.js
var methodOf = baseRest_default(function(object, args) {
  return function(path2) {
    return baseInvoke_default(object, path2, args);
  };
});
var methodOf_default = methodOf;

// node_modules/lodash-es/min.js
function min10(array2) {
  return array2 && array2.length ? baseExtremum_default(array2, identity_default8, baseLt_default) : void 0;
}
var min_default4 = min10;

// node_modules/lodash-es/minBy.js
function minBy(array2, iteratee2) {
  return array2 && array2.length ? baseExtremum_default(array2, baseIteratee_default(iteratee2, 2), baseLt_default) : void 0;
}
var minBy_default = minBy;

// node_modules/lodash-es/mixin.js
function mixin(object, source, options) {
  var props = keys_default4(source), methodNames = baseFunctions_default(source, props);
  var chain2 = !(isObject_default(options) && "chain" in options) || !!options.chain, isFunc = isFunction_default(object);
  arrayEach_default(methodNames, function(methodName) {
    var func = source[methodName];
    object[methodName] = func;
    if (isFunc) {
      object.prototype[methodName] = function() {
        var chainAll = this.__chain__;
        if (chain2 || chainAll) {
          var result2 = object(this.__wrapped__), actions = result2.__actions__ = copyArray_default(this.__actions__);
          actions.push({ "func": func, "args": arguments, "thisArg": object });
          result2.__chain__ = chainAll;
          return result2;
        }
        return func.apply(object, arrayPush_default([this.value()], arguments));
      };
    }
  });
  return object;
}
var mixin_default = mixin;

// node_modules/lodash-es/multiply.js
var multiply7 = createMathOperation_default(function(multiplier, multiplicand) {
  return multiplier * multiplicand;
}, 1);
var multiply_default = multiply7;

// node_modules/lodash-es/negate.js
var FUNC_ERROR_TEXT9 = "Expected a function";
function negate4(predicate) {
  if (typeof predicate != "function") {
    throw new TypeError(FUNC_ERROR_TEXT9);
  }
  return function() {
    var args = arguments;
    switch (args.length) {
      case 0:
        return !predicate.call(this);
      case 1:
        return !predicate.call(this, args[0]);
      case 2:
        return !predicate.call(this, args[0], args[1]);
      case 3:
        return !predicate.call(this, args[0], args[1], args[2]);
    }
    return !predicate.apply(this, args);
  };
}
var negate_default = negate4;

// node_modules/lodash-es/_iteratorToArray.js
function iteratorToArray(iterator) {
  var data2, result2 = [];
  while (!(data2 = iterator.next()).done) {
    result2.push(data2.value);
  }
  return result2;
}
var iteratorToArray_default = iteratorToArray;

// node_modules/lodash-es/toArray.js
var mapTag9 = "[object Map]";
var setTag9 = "[object Set]";
var symIterator = Symbol_default ? Symbol_default.iterator : void 0;
function toArray(value2) {
  if (!value2) {
    return [];
  }
  if (isArrayLike_default(value2)) {
    return isString_default(value2) ? stringToArray_default(value2) : copyArray_default(value2);
  }
  if (symIterator && value2[symIterator]) {
    return iteratorToArray_default(value2[symIterator]());
  }
  var tag = getTag_default(value2), func = tag == mapTag9 ? mapToArray_default : tag == setTag9 ? setToArray_default : values_default4;
  return func(value2);
}
var toArray_default = toArray;

// node_modules/lodash-es/next.js
function wrapperNext() {
  if (this.__values__ === void 0) {
    this.__values__ = toArray_default(this.value());
  }
  var done = this.__index__ >= this.__values__.length, value2 = done ? void 0 : this.__values__[this.__index__++];
  return { "done": done, "value": value2 };
}
var next_default = wrapperNext;

// node_modules/lodash-es/_baseNth.js
function baseNth(array2, n) {
  var length5 = array2.length;
  if (!length5) {
    return;
  }
  n += n < 0 ? length5 : 0;
  return isIndex_default(n, length5) ? array2[n] : void 0;
}
var baseNth_default = baseNth;

// node_modules/lodash-es/nth.js
function nth(array2, n) {
  return array2 && array2.length ? baseNth_default(array2, toInteger_default(n)) : void 0;
}
var nth_default = nth;

// node_modules/lodash-es/nthArg.js
function nthArg(n) {
  n = toInteger_default(n);
  return baseRest_default(function(args) {
    return baseNth_default(args, n);
  });
}
var nthArg_default = nthArg;

// node_modules/lodash-es/_baseUnset.js
function baseUnset(object, path2) {
  path2 = castPath_default(path2, object);
  object = parent_default(object, path2);
  return object == null || delete object[toKey_default(last_default(path2))];
}
var baseUnset_default = baseUnset;

// node_modules/lodash-es/_customOmitClone.js
function customOmitClone(value2) {
  return isPlainObject_default(value2) ? void 0 : value2;
}
var customOmitClone_default = customOmitClone;

// node_modules/lodash-es/omit.js
var CLONE_DEEP_FLAG8 = 1;
var CLONE_FLAT_FLAG2 = 2;
var CLONE_SYMBOLS_FLAG6 = 4;
var omit2 = flatRest_default(function(object, paths) {
  var result2 = {};
  if (object == null) {
    return result2;
  }
  var isDeep = false;
  paths = arrayMap_default(paths, function(path2) {
    path2 = castPath_default(path2, object);
    isDeep || (isDeep = path2.length > 1);
    return path2;
  });
  copyObject_default(object, getAllKeysIn_default(object), result2);
  if (isDeep) {
    result2 = baseClone_default(result2, CLONE_DEEP_FLAG8 | CLONE_FLAT_FLAG2 | CLONE_SYMBOLS_FLAG6, customOmitClone_default);
  }
  var length5 = paths.length;
  while (length5--) {
    baseUnset_default(result2, paths[length5]);
  }
  return result2;
});
var omit_default4 = omit2;

// node_modules/lodash-es/_baseSet.js
function baseSet(object, path2, value2, customizer) {
  if (!isObject_default(object)) {
    return object;
  }
  path2 = castPath_default(path2, object);
  var index3 = -1, length5 = path2.length, lastIndex = length5 - 1, nested = object;
  while (nested != null && ++index3 < length5) {
    var key = toKey_default(path2[index3]), newValue = value2;
    if (key === "__proto__" || key === "constructor" || key === "prototype") {
      return object;
    }
    if (index3 != lastIndex) {
      var objValue = nested[key];
      newValue = customizer ? customizer(objValue, key, nested) : void 0;
      if (newValue === void 0) {
        newValue = isObject_default(objValue) ? objValue : isIndex_default(path2[index3 + 1]) ? [] : {};
      }
    }
    assignValue_default(nested, key, newValue);
    nested = nested[key];
  }
  return object;
}
var baseSet_default = baseSet;

// node_modules/lodash-es/_basePickBy.js
function basePickBy(object, paths, predicate) {
  var index3 = -1, length5 = paths.length, result2 = {};
  while (++index3 < length5) {
    var path2 = paths[index3], value2 = baseGet_default(object, path2);
    if (predicate(value2, path2)) {
      baseSet_default(result2, castPath_default(path2, object), value2);
    }
  }
  return result2;
}
var basePickBy_default = basePickBy;

// node_modules/lodash-es/pickBy.js
function pickBy(object, predicate) {
  if (object == null) {
    return {};
  }
  var props = arrayMap_default(getAllKeysIn_default(object), function(prop) {
    return [prop];
  });
  predicate = baseIteratee_default(predicate);
  return basePickBy_default(object, props, function(value2, path2) {
    return predicate(value2, path2[0]);
  });
}
var pickBy_default = pickBy;

// node_modules/lodash-es/omitBy.js
function omitBy(object, predicate) {
  return pickBy_default(object, negate_default(baseIteratee_default(predicate)));
}
var omitBy_default = omitBy;

// node_modules/lodash-es/once.js
function once(func) {
  return before_default(2, func);
}
var once_default = once;

// node_modules/lodash-es/_baseSortBy.js
function baseSortBy(array2, comparer) {
  var length5 = array2.length;
  array2.sort(comparer);
  while (length5--) {
    array2[length5] = array2[length5].value;
  }
  return array2;
}
var baseSortBy_default = baseSortBy;

// node_modules/lodash-es/_compareAscending.js
function compareAscending(value2, other) {
  if (value2 !== other) {
    var valIsDefined = value2 !== void 0, valIsNull = value2 === null, valIsReflexive = value2 === value2, valIsSymbol = isSymbol_default(value2);
    var othIsDefined = other !== void 0, othIsNull = other === null, othIsReflexive = other === other, othIsSymbol = isSymbol_default(other);
    if (!othIsNull && !othIsSymbol && !valIsSymbol && value2 > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
      return 1;
    }
    if (!valIsNull && !valIsSymbol && !othIsSymbol && value2 < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
      return -1;
    }
  }
  return 0;
}
var compareAscending_default = compareAscending;

// node_modules/lodash-es/_compareMultiple.js
function compareMultiple(object, other, orders) {
  var index3 = -1, objCriteria = object.criteria, othCriteria = other.criteria, length5 = objCriteria.length, ordersLength = orders.length;
  while (++index3 < length5) {
    var result2 = compareAscending_default(objCriteria[index3], othCriteria[index3]);
    if (result2) {
      if (index3 >= ordersLength) {
        return result2;
      }
      var order = orders[index3];
      return result2 * (order == "desc" ? -1 : 1);
    }
  }
  return object.index - other.index;
}
var compareMultiple_default = compareMultiple;

// node_modules/lodash-es/_baseOrderBy.js
function baseOrderBy(collection, iteratees, orders) {
  if (iteratees.length) {
    iteratees = arrayMap_default(iteratees, function(iteratee2) {
      if (isArray_default(iteratee2)) {
        return function(value2) {
          return baseGet_default(value2, iteratee2.length === 1 ? iteratee2[0] : iteratee2);
        };
      }
      return iteratee2;
    });
  } else {
    iteratees = [identity_default8];
  }
  var index3 = -1;
  iteratees = arrayMap_default(iteratees, baseUnary_default(baseIteratee_default));
  var result2 = baseMap_default(collection, function(value2, key, collection2) {
    var criteria = arrayMap_default(iteratees, function(iteratee2) {
      return iteratee2(value2);
    });
    return { "criteria": criteria, "index": ++index3, "value": value2 };
  });
  return baseSortBy_default(result2, function(object, other) {
    return compareMultiple_default(object, other, orders);
  });
}
var baseOrderBy_default = baseOrderBy;

// node_modules/lodash-es/orderBy.js
function orderBy(collection, iteratees, orders, guard) {
  if (collection == null) {
    return [];
  }
  if (!isArray_default(iteratees)) {
    iteratees = iteratees == null ? [] : [iteratees];
  }
  orders = guard ? void 0 : orders;
  if (!isArray_default(orders)) {
    orders = orders == null ? [] : [orders];
  }
  return baseOrderBy_default(collection, iteratees, orders);
}
var orderBy_default = orderBy;

// node_modules/lodash-es/_createOver.js
function createOver(arrayFunc) {
  return flatRest_default(function(iteratees) {
    iteratees = arrayMap_default(iteratees, baseUnary_default(baseIteratee_default));
    return baseRest_default(function(args) {
      var thisArg = this;
      return arrayFunc(iteratees, function(iteratee2) {
        return apply_default(iteratee2, thisArg, args);
      });
    });
  });
}
var createOver_default = createOver;

// node_modules/lodash-es/over.js
var over = createOver_default(arrayMap_default);
var over_default = over;

// node_modules/lodash-es/_castRest.js
var castRest = baseRest_default;
var castRest_default = castRest;

// node_modules/lodash-es/overArgs.js
var nativeMin9 = Math.min;
var overArgs = castRest_default(function(func, transforms) {
  transforms = transforms.length == 1 && isArray_default(transforms[0]) ? arrayMap_default(transforms[0], baseUnary_default(baseIteratee_default)) : arrayMap_default(baseFlatten_default(transforms, 1), baseUnary_default(baseIteratee_default));
  var funcsLength = transforms.length;
  return baseRest_default(function(args) {
    var index3 = -1, length5 = nativeMin9(args.length, funcsLength);
    while (++index3 < length5) {
      args[index3] = transforms[index3].call(this, args[index3]);
    }
    return apply_default(func, this, args);
  });
});
var overArgs_default = overArgs;

// node_modules/lodash-es/overEvery.js
var overEvery = createOver_default(arrayEvery_default);
var overEvery_default = overEvery;

// node_modules/lodash-es/overSome.js
var overSome = createOver_default(arraySome_default);
var overSome_default = overSome;

// node_modules/lodash-es/_baseRepeat.js
var MAX_SAFE_INTEGER4 = 9007199254740991;
var nativeFloor = Math.floor;
function baseRepeat(string, n) {
  var result2 = "";
  if (!string || n < 1 || n > MAX_SAFE_INTEGER4) {
    return result2;
  }
  do {
    if (n % 2) {
      result2 += string;
    }
    n = nativeFloor(n / 2);
    if (n) {
      string += string;
    }
  } while (n);
  return result2;
}
var baseRepeat_default = baseRepeat;

// node_modules/lodash-es/_asciiSize.js
var asciiSize = baseProperty_default("length");
var asciiSize_default = asciiSize;

// node_modules/lodash-es/_unicodeSize.js
var rsAstralRange4 = "\\ud800-\\udfff";
var rsComboMarksRange5 = "\\u0300-\\u036f";
var reComboHalfMarksRange5 = "\\ufe20-\\ufe2f";
var rsComboSymbolsRange5 = "\\u20d0-\\u20ff";
var rsComboRange5 = rsComboMarksRange5 + reComboHalfMarksRange5 + rsComboSymbolsRange5;
var rsVarRange4 = "\\ufe0e\\ufe0f";
var rsAstral2 = "[" + rsAstralRange4 + "]";
var rsCombo4 = "[" + rsComboRange5 + "]";
var rsFitz3 = "\\ud83c[\\udffb-\\udfff]";
var rsModifier3 = "(?:" + rsCombo4 + "|" + rsFitz3 + ")";
var rsNonAstral3 = "[^" + rsAstralRange4 + "]";
var rsRegional3 = "(?:\\ud83c[\\udde6-\\uddff]){2}";
var rsSurrPair3 = "[\\ud800-\\udbff][\\udc00-\\udfff]";
var rsZWJ4 = "\\u200d";
var reOptMod3 = rsModifier3 + "?";
var rsOptVar3 = "[" + rsVarRange4 + "]?";
var rsOptJoin3 = "(?:" + rsZWJ4 + "(?:" + [rsNonAstral3, rsRegional3, rsSurrPair3].join("|") + ")" + rsOptVar3 + reOptMod3 + ")*";
var rsSeq3 = rsOptVar3 + reOptMod3 + rsOptJoin3;
var rsSymbol2 = "(?:" + [rsNonAstral3 + rsCombo4 + "?", rsCombo4, rsRegional3, rsSurrPair3, rsAstral2].join("|") + ")";
var reUnicode2 = RegExp(rsFitz3 + "(?=" + rsFitz3 + ")|" + rsSymbol2 + rsSeq3, "g");
function unicodeSize(string) {
  var result2 = reUnicode2.lastIndex = 0;
  while (reUnicode2.test(string)) {
    ++result2;
  }
  return result2;
}
var unicodeSize_default = unicodeSize;

// node_modules/lodash-es/_stringSize.js
function stringSize(string) {
  return hasUnicode_default(string) ? unicodeSize_default(string) : asciiSize_default(string);
}
var stringSize_default = stringSize;

// node_modules/lodash-es/_createPadding.js
var nativeCeil2 = Math.ceil;
function createPadding(length5, chars) {
  chars = chars === void 0 ? " " : baseToString_default(chars);
  var charsLength = chars.length;
  if (charsLength < 2) {
    return charsLength ? baseRepeat_default(chars, length5) : chars;
  }
  var result2 = baseRepeat_default(chars, nativeCeil2(length5 / stringSize_default(chars)));
  return hasUnicode_default(chars) ? castSlice_default(stringToArray_default(result2), 0, length5).join("") : result2.slice(0, length5);
}
var createPadding_default = createPadding;

// node_modules/lodash-es/pad.js
var nativeCeil3 = Math.ceil;
var nativeFloor2 = Math.floor;
function pad3(string, length5, chars) {
  string = toString_default(string);
  length5 = toInteger_default(length5);
  var strLength = length5 ? stringSize_default(string) : 0;
  if (!length5 || strLength >= length5) {
    return string;
  }
  var mid2 = (length5 - strLength) / 2;
  return createPadding_default(nativeFloor2(mid2), chars) + string + createPadding_default(nativeCeil3(mid2), chars);
}
var pad_default = pad3;

// node_modules/lodash-es/padEnd.js
function padEnd(string, length5, chars) {
  string = toString_default(string);
  length5 = toInteger_default(length5);
  var strLength = length5 ? stringSize_default(string) : 0;
  return length5 && strLength < length5 ? string + createPadding_default(length5 - strLength, chars) : string;
}
var padEnd_default = padEnd;

// node_modules/lodash-es/padStart.js
function padStart(string, length5, chars) {
  string = toString_default(string);
  length5 = toInteger_default(length5);
  var strLength = length5 ? stringSize_default(string) : 0;
  return length5 && strLength < length5 ? createPadding_default(length5 - strLength, chars) + string : string;
}
var padStart_default = padStart;

// node_modules/lodash-es/parseInt.js
var reTrimStart2 = /^\s+/;
var nativeParseInt = root_default2.parseInt;
function parseInt2(string, radix, guard) {
  if (guard || radix == null) {
    radix = 0;
  } else if (radix) {
    radix = +radix;
  }
  return nativeParseInt(toString_default(string).replace(reTrimStart2, ""), radix || 0);
}
var parseInt_default = parseInt2;

// node_modules/lodash-es/partial.js
var WRAP_PARTIAL_FLAG7 = 32;
var partial = baseRest_default(function(func, partials) {
  var holders = replaceHolders_default(partials, getHolder_default(partial));
  return createWrap_default(func, WRAP_PARTIAL_FLAG7, void 0, partials, holders);
});
partial.placeholder = {};
var partial_default = partial;

// node_modules/lodash-es/partialRight.js
var WRAP_PARTIAL_RIGHT_FLAG4 = 64;
var partialRight = baseRest_default(function(func, partials) {
  var holders = replaceHolders_default(partials, getHolder_default(partialRight));
  return createWrap_default(func, WRAP_PARTIAL_RIGHT_FLAG4, void 0, partials, holders);
});
partialRight.placeholder = {};
var partialRight_default = partialRight;

// node_modules/lodash-es/partition.js
var partition = createAggregator_default(function(result2, value2, key) {
  result2[key ? 0 : 1].push(value2);
}, function() {
  return [[], []];
});
var partition_default2 = partition;

// node_modules/lodash-es/_basePick.js
function basePick(object, paths) {
  return basePickBy_default(object, paths, function(value2, path2) {
    return hasIn_default(object, path2);
  });
}
var basePick_default = basePick;

// node_modules/lodash-es/pick.js
var pick2 = flatRest_default(function(object, paths) {
  return object == null ? {} : basePick_default(object, paths);
});
var pick_default4 = pick2;

// node_modules/lodash-es/plant.js
function wrapperPlant(value2) {
  var result2, parent2 = this;
  while (parent2 instanceof baseLodash_default) {
    var clone9 = wrapperClone_default(parent2);
    clone9.__index__ = 0;
    clone9.__values__ = void 0;
    if (result2) {
      previous.__wrapped__ = clone9;
    } else {
      result2 = clone9;
    }
    var previous = clone9;
    parent2 = parent2.__wrapped__;
  }
  previous.__wrapped__ = value2;
  return result2;
}
var plant_default = wrapperPlant;

// node_modules/lodash-es/propertyOf.js
function propertyOf(object) {
  return function(path2) {
    return object == null ? void 0 : baseGet_default(object, path2);
  };
}
var propertyOf_default = propertyOf;

// node_modules/lodash-es/_baseIndexOfWith.js
function baseIndexOfWith(array2, value2, fromIndex, comparator) {
  var index3 = fromIndex - 1, length5 = array2.length;
  while (++index3 < length5) {
    if (comparator(array2[index3], value2)) {
      return index3;
    }
  }
  return -1;
}
var baseIndexOfWith_default = baseIndexOfWith;

// node_modules/lodash-es/_basePullAll.js
var arrayProto3 = Array.prototype;
var splice9 = arrayProto3.splice;
function basePullAll(array2, values4, iteratee2, comparator) {
  var indexOf7 = comparator ? baseIndexOfWith_default : baseIndexOf_default, index3 = -1, length5 = values4.length, seen = array2;
  if (array2 === values4) {
    values4 = copyArray_default(values4);
  }
  if (iteratee2) {
    seen = arrayMap_default(array2, baseUnary_default(iteratee2));
  }
  while (++index3 < length5) {
    var fromIndex = 0, value2 = values4[index3], computed = iteratee2 ? iteratee2(value2) : value2;
    while ((fromIndex = indexOf7(seen, computed, fromIndex, comparator)) > -1) {
      if (seen !== array2) {
        splice9.call(seen, fromIndex, 1);
      }
      splice9.call(array2, fromIndex, 1);
    }
  }
  return array2;
}
var basePullAll_default = basePullAll;

// node_modules/lodash-es/pullAll.js
function pullAll(array2, values4) {
  return array2 && array2.length && values4 && values4.length ? basePullAll_default(array2, values4) : array2;
}
var pullAll_default = pullAll;

// node_modules/lodash-es/pull.js
var pull = baseRest_default(pullAll_default);
var pull_default4 = pull;

// node_modules/lodash-es/pullAllBy.js
function pullAllBy(array2, values4, iteratee2) {
  return array2 && array2.length && values4 && values4.length ? basePullAll_default(array2, values4, baseIteratee_default(iteratee2, 2)) : array2;
}
var pullAllBy_default = pullAllBy;

// node_modules/lodash-es/pullAllWith.js
function pullAllWith(array2, values4, comparator) {
  return array2 && array2.length && values4 && values4.length ? basePullAll_default(array2, values4, void 0, comparator) : array2;
}
var pullAllWith_default = pullAllWith;

// node_modules/lodash-es/_basePullAt.js
var arrayProto4 = Array.prototype;
var splice10 = arrayProto4.splice;
function basePullAt(array2, indexes2) {
  var length5 = array2 ? indexes2.length : 0, lastIndex = length5 - 1;
  while (length5--) {
    var index3 = indexes2[length5];
    if (length5 == lastIndex || index3 !== previous) {
      var previous = index3;
      if (isIndex_default(index3)) {
        splice10.call(array2, index3, 1);
      } else {
        baseUnset_default(array2, index3);
      }
    }
  }
  return array2;
}
var basePullAt_default = basePullAt;

// node_modules/lodash-es/pullAt.js
var pullAt = flatRest_default(function(array2, indexes2) {
  var length5 = array2 == null ? 0 : array2.length, result2 = baseAt_default(array2, indexes2);
  basePullAt_default(array2, arrayMap_default(indexes2, function(index3) {
    return isIndex_default(index3, length5) ? +index3 : index3;
  }).sort(compareAscending_default));
  return result2;
});
var pullAt_default = pullAt;

// node_modules/lodash-es/_baseRandom.js
var nativeFloor3 = Math.floor;
var nativeRandom = Math.random;
function baseRandom(lower2, upper2) {
  return lower2 + nativeFloor3(nativeRandom() * (upper2 - lower2 + 1));
}
var baseRandom_default = baseRandom;

// node_modules/lodash-es/random.js
var freeParseFloat = parseFloat;
var nativeMin10 = Math.min;
var nativeRandom2 = Math.random;
function random5(lower2, upper2, floating) {
  if (floating && typeof floating != "boolean" && isIterateeCall_default(lower2, upper2, floating)) {
    upper2 = floating = void 0;
  }
  if (floating === void 0) {
    if (typeof upper2 == "boolean") {
      floating = upper2;
      upper2 = void 0;
    } else if (typeof lower2 == "boolean") {
      floating = lower2;
      lower2 = void 0;
    }
  }
  if (lower2 === void 0 && upper2 === void 0) {
    lower2 = 0;
    upper2 = 1;
  } else {
    lower2 = toFinite_default(lower2);
    if (upper2 === void 0) {
      upper2 = lower2;
      lower2 = 0;
    } else {
      upper2 = toFinite_default(upper2);
    }
  }
  if (lower2 > upper2) {
    var temp = lower2;
    lower2 = upper2;
    upper2 = temp;
  }
  if (floating || lower2 % 1 || upper2 % 1) {
    var rand = nativeRandom2();
    return nativeMin10(lower2 + rand * (upper2 - lower2 + freeParseFloat("1e-" + ((rand + "").length - 1))), upper2);
  }
  return baseRandom_default(lower2, upper2);
}
var random_default = random5;

// node_modules/lodash-es/_baseRange.js
var nativeCeil4 = Math.ceil;
var nativeMax13 = Math.max;
function baseRange(start, end, step2, fromRight) {
  var index3 = -1, length5 = nativeMax13(nativeCeil4((end - start) / (step2 || 1)), 0), result2 = Array(length5);
  while (length5--) {
    result2[fromRight ? length5 : ++index3] = start;
    start += step2;
  }
  return result2;
}
var baseRange_default = baseRange;

// node_modules/lodash-es/_createRange.js
function createRange(fromRight) {
  return function(start, end, step2) {
    if (step2 && typeof step2 != "number" && isIterateeCall_default(start, end, step2)) {
      end = step2 = void 0;
    }
    start = toFinite_default(start);
    if (end === void 0) {
      end = start;
      start = 0;
    } else {
      end = toFinite_default(end);
    }
    step2 = step2 === void 0 ? start < end ? 1 : -1 : toFinite_default(step2);
    return baseRange_default(start, end, step2, fromRight);
  };
}
var createRange_default = createRange;

// node_modules/lodash-es/range.js
var range3 = createRange_default();
var range_default = range3;

// node_modules/lodash-es/rangeRight.js
var rangeRight = createRange_default(true);
var rangeRight_default = rangeRight;

// node_modules/lodash-es/rearg.js
var WRAP_REARG_FLAG4 = 256;
var rearg = flatRest_default(function(func, indexes2) {
  return createWrap_default(func, WRAP_REARG_FLAG4, void 0, void 0, void 0, indexes2);
});
var rearg_default = rearg;

// node_modules/lodash-es/_baseReduce.js
function baseReduce(collection, iteratee2, accumulator, initAccum, eachFunc) {
  eachFunc(collection, function(value2, index3, collection2) {
    accumulator = initAccum ? (initAccum = false, value2) : iteratee2(accumulator, value2, index3, collection2);
  });
  return accumulator;
}
var baseReduce_default = baseReduce;

// node_modules/lodash-es/reduce.js
function reduce3(collection, iteratee2, accumulator) {
  var func = isArray_default(collection) ? arrayReduce_default : baseReduce_default, initAccum = arguments.length < 3;
  return func(collection, baseIteratee_default(iteratee2, 4), accumulator, initAccum, baseEach_default);
}
var reduce_default4 = reduce3;

// node_modules/lodash-es/_arrayReduceRight.js
function arrayReduceRight(array2, iteratee2, accumulator, initAccum) {
  var length5 = array2 == null ? 0 : array2.length;
  if (initAccum && length5) {
    accumulator = array2[--length5];
  }
  while (length5--) {
    accumulator = iteratee2(accumulator, array2[length5], length5, array2);
  }
  return accumulator;
}
var arrayReduceRight_default = arrayReduceRight;

// node_modules/lodash-es/reduceRight.js
function reduceRight(collection, iteratee2, accumulator) {
  var func = isArray_default(collection) ? arrayReduceRight_default : baseReduce_default, initAccum = arguments.length < 3;
  return func(collection, baseIteratee_default(iteratee2, 4), accumulator, initAccum, baseEachRight_default);
}
var reduceRight_default = reduceRight;

// node_modules/lodash-es/reject.js
function reject(collection, predicate) {
  var func = isArray_default(collection) ? arrayFilter_default : baseFilter_default;
  return func(collection, negate_default(baseIteratee_default(predicate, 3)));
}
var reject_default = reject;

// node_modules/lodash-es/remove.js
function remove(array2, predicate) {
  var result2 = [];
  if (!(array2 && array2.length)) {
    return result2;
  }
  var index3 = -1, indexes2 = [], length5 = array2.length;
  predicate = baseIteratee_default(predicate, 3);
  while (++index3 < length5) {
    var value2 = array2[index3];
    if (predicate(value2, index3, array2)) {
      result2.push(value2);
      indexes2.push(index3);
    }
  }
  basePullAt_default(array2, indexes2);
  return result2;
}
var remove_default5 = remove;

// node_modules/lodash-es/repeat.js
function repeat(string, n, guard) {
  if (guard ? isIterateeCall_default(string, n, guard) : n === void 0) {
    n = 1;
  } else {
    n = toInteger_default(n);
  }
  return baseRepeat_default(toString_default(string), n);
}
var repeat_default = repeat;

// node_modules/lodash-es/replace.js
function replace() {
  var args = arguments, string = toString_default(args[0]);
  return args.length < 3 ? string : string.replace(args[1], args[2]);
}
var replace_default = replace;

// node_modules/lodash-es/rest.js
var FUNC_ERROR_TEXT10 = "Expected a function";
function rest(func, start) {
  if (typeof func != "function") {
    throw new TypeError(FUNC_ERROR_TEXT10);
  }
  start = start === void 0 ? start : toInteger_default(start);
  return baseRest_default(func, start);
}
var rest_default = rest;

// node_modules/lodash-es/result.js
function result(object, path2, defaultValue) {
  path2 = castPath_default(path2, object);
  var index3 = -1, length5 = path2.length;
  if (!length5) {
    length5 = 1;
    object = void 0;
  }
  while (++index3 < length5) {
    var value2 = object == null ? void 0 : object[toKey_default(path2[index3])];
    if (value2 === void 0) {
      index3 = length5;
      value2 = defaultValue;
    }
    object = isFunction_default(value2) ? value2.call(object) : value2;
  }
  return object;
}
var result_default = result;

// node_modules/lodash-es/reverse.js
var arrayProto5 = Array.prototype;
var nativeReverse = arrayProto5.reverse;
function reverse2(array2) {
  return array2 == null ? array2 : nativeReverse.call(array2);
}
var reverse_default2 = reverse2;

// node_modules/lodash-es/round.js
var round5 = createRound_default("round");
var round_default3 = round5;

// node_modules/lodash-es/_arraySample.js
function arraySample(array2) {
  var length5 = array2.length;
  return length5 ? array2[baseRandom_default(0, length5 - 1)] : void 0;
}
var arraySample_default = arraySample;

// node_modules/lodash-es/_baseSample.js
function baseSample(collection) {
  return arraySample_default(values_default4(collection));
}
var baseSample_default = baseSample;

// node_modules/lodash-es/sample.js
function sample(collection) {
  var func = isArray_default(collection) ? arraySample_default : baseSample_default;
  return func(collection);
}
var sample_default = sample;

// node_modules/lodash-es/_shuffleSelf.js
function shuffleSelf(array2, size5) {
  var index3 = -1, length5 = array2.length, lastIndex = length5 - 1;
  size5 = size5 === void 0 ? length5 : size5;
  while (++index3 < size5) {
    var rand = baseRandom_default(index3, lastIndex), value2 = array2[rand];
    array2[rand] = array2[index3];
    array2[index3] = value2;
  }
  array2.length = size5;
  return array2;
}
var shuffleSelf_default = shuffleSelf;

// node_modules/lodash-es/_arraySampleSize.js
function arraySampleSize(array2, n) {
  return shuffleSelf_default(copyArray_default(array2), baseClamp_default(n, 0, array2.length));
}
var arraySampleSize_default = arraySampleSize;

// node_modules/lodash-es/_baseSampleSize.js
function baseSampleSize(collection, n) {
  var array2 = values_default4(collection);
  return shuffleSelf_default(array2, baseClamp_default(n, 0, array2.length));
}
var baseSampleSize_default = baseSampleSize;

// node_modules/lodash-es/sampleSize.js
function sampleSize(collection, n, guard) {
  if (guard ? isIterateeCall_default(collection, n, guard) : n === void 0) {
    n = 1;
  } else {
    n = toInteger_default(n);
  }
  var func = isArray_default(collection) ? arraySampleSize_default : baseSampleSize_default;
  return func(collection, n);
}
var sampleSize_default = sampleSize;

// node_modules/lodash-es/set.js
function set8(object, path2, value2) {
  return object == null ? object : baseSet_default(object, path2, value2);
}
var set_default4 = set8;

// node_modules/lodash-es/setWith.js
function setWith(object, path2, value2, customizer) {
  customizer = typeof customizer == "function" ? customizer : void 0;
  return object == null ? object : baseSet_default(object, path2, value2, customizer);
}
var setWith_default = setWith;

// node_modules/lodash-es/_arrayShuffle.js
function arrayShuffle(array2) {
  return shuffleSelf_default(copyArray_default(array2));
}
var arrayShuffle_default = arrayShuffle;

// node_modules/lodash-es/_baseShuffle.js
function baseShuffle(collection) {
  return shuffleSelf_default(values_default4(collection));
}
var baseShuffle_default = baseShuffle;

// node_modules/lodash-es/shuffle.js
function shuffle2(collection) {
  var func = isArray_default(collection) ? arrayShuffle_default : baseShuffle_default;
  return func(collection);
}
var shuffle_default2 = shuffle2;

// node_modules/lodash-es/size.js
var mapTag10 = "[object Map]";
var setTag10 = "[object Set]";
function size4(collection) {
  if (collection == null) {
    return 0;
  }
  if (isArrayLike_default(collection)) {
    return isString_default(collection) ? stringSize_default(collection) : collection.length;
  }
  var tag = getTag_default(collection);
  if (tag == mapTag10 || tag == setTag10) {
    return collection.size;
  }
  return baseKeys_default(collection).length;
}
var size_default2 = size4;

// node_modules/lodash-es/slice.js
function slice3(array2, start, end) {
  var length5 = array2 == null ? 0 : array2.length;
  if (!length5) {
    return [];
  }
  if (end && typeof end != "number" && isIterateeCall_default(array2, start, end)) {
    start = 0;
    end = length5;
  } else {
    start = start == null ? 0 : toInteger_default(start);
    end = end === void 0 ? length5 : toInteger_default(end);
  }
  return baseSlice_default(array2, start, end);
}
var slice_default2 = slice3;

// node_modules/lodash-es/snakeCase.js
var snakeCase = createCompounder_default(function(result2, word2, index3) {
  return result2 + (index3 ? "_" : "") + word2.toLowerCase();
});
var snakeCase_default = snakeCase;

// node_modules/lodash-es/_baseSome.js
function baseSome(collection, predicate) {
  var result2;
  baseEach_default(collection, function(value2, index3, collection2) {
    result2 = predicate(value2, index3, collection2);
    return !result2;
  });
  return !!result2;
}
var baseSome_default = baseSome;

// node_modules/lodash-es/some.js
function some3(collection, predicate, guard) {
  var func = isArray_default(collection) ? arraySome_default : baseSome_default;
  if (guard && isIterateeCall_default(collection, predicate, guard)) {
    predicate = void 0;
  }
  return func(collection, baseIteratee_default(predicate, 3));
}
var some_default4 = some3;

// node_modules/lodash-es/sortBy.js
var sortBy = baseRest_default(function(collection, iteratees) {
  if (collection == null) {
    return [];
  }
  var length5 = iteratees.length;
  if (length5 > 1 && isIterateeCall_default(collection, iteratees[0], iteratees[1])) {
    iteratees = [];
  } else if (length5 > 2 && isIterateeCall_default(iteratees[0], iteratees[1], iteratees[2])) {
    iteratees = [iteratees[0]];
  }
  return baseOrderBy_default(collection, baseFlatten_default(iteratees, 1), []);
});
var sortBy_default = sortBy;

// node_modules/lodash-es/_baseSortedIndexBy.js
var MAX_ARRAY_LENGTH3 = 4294967295;
var MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH3 - 1;
var nativeFloor4 = Math.floor;
var nativeMin11 = Math.min;
function baseSortedIndexBy(array2, value2, iteratee2, retHighest) {
  var low = 0, high = array2 == null ? 0 : array2.length;
  if (high === 0) {
    return 0;
  }
  value2 = iteratee2(value2);
  var valIsNaN = value2 !== value2, valIsNull = value2 === null, valIsSymbol = isSymbol_default(value2), valIsUndefined = value2 === void 0;
  while (low < high) {
    var mid2 = nativeFloor4((low + high) / 2), computed = iteratee2(array2[mid2]), othIsDefined = computed !== void 0, othIsNull = computed === null, othIsReflexive = computed === computed, othIsSymbol = isSymbol_default(computed);
    if (valIsNaN) {
      var setLow = retHighest || othIsReflexive;
    } else if (valIsUndefined) {
      setLow = othIsReflexive && (retHighest || othIsDefined);
    } else if (valIsNull) {
      setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
    } else if (valIsSymbol) {
      setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
    } else if (othIsNull || othIsSymbol) {
      setLow = false;
    } else {
      setLow = retHighest ? computed <= value2 : computed < value2;
    }
    if (setLow) {
      low = mid2 + 1;
    } else {
      high = mid2;
    }
  }
  return nativeMin11(high, MAX_ARRAY_INDEX);
}
var baseSortedIndexBy_default = baseSortedIndexBy;

// node_modules/lodash-es/_baseSortedIndex.js
var MAX_ARRAY_LENGTH4 = 4294967295;
var HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH4 >>> 1;
function baseSortedIndex(array2, value2, retHighest) {
  var low = 0, high = array2 == null ? low : array2.length;
  if (typeof value2 == "number" && value2 === value2 && high <= HALF_MAX_ARRAY_LENGTH) {
    while (low < high) {
      var mid2 = low + high >>> 1, computed = array2[mid2];
      if (computed !== null && !isSymbol_default(computed) && (retHighest ? computed <= value2 : computed < value2)) {
        low = mid2 + 1;
      } else {
        high = mid2;
      }
    }
    return high;
  }
  return baseSortedIndexBy_default(array2, value2, identity_default8, retHighest);
}
var baseSortedIndex_default = baseSortedIndex;

// node_modules/lodash-es/sortedIndex.js
function sortedIndex2(array2, value2) {
  return baseSortedIndex_default(array2, value2);
}
var sortedIndex_default = sortedIndex2;

// node_modules/lodash-es/sortedIndexBy.js
function sortedIndexBy(array2, value2, iteratee2) {
  return baseSortedIndexBy_default(array2, value2, baseIteratee_default(iteratee2, 2));
}
var sortedIndexBy_default = sortedIndexBy;

// node_modules/lodash-es/sortedIndexOf.js
function sortedIndexOf(array2, value2) {
  var length5 = array2 == null ? 0 : array2.length;
  if (length5) {
    var index3 = baseSortedIndex_default(array2, value2);
    if (index3 < length5 && eq_default(array2[index3], value2)) {
      return index3;
    }
  }
  return -1;
}
var sortedIndexOf_default = sortedIndexOf;

// node_modules/lodash-es/sortedLastIndex.js
function sortedLastIndex(array2, value2) {
  return baseSortedIndex_default(array2, value2, true);
}
var sortedLastIndex_default = sortedLastIndex;

// node_modules/lodash-es/sortedLastIndexBy.js
function sortedLastIndexBy(array2, value2, iteratee2) {
  return baseSortedIndexBy_default(array2, value2, baseIteratee_default(iteratee2, 2), true);
}
var sortedLastIndexBy_default = sortedLastIndexBy;

// node_modules/lodash-es/sortedLastIndexOf.js
function sortedLastIndexOf(array2, value2) {
  var length5 = array2 == null ? 0 : array2.length;
  if (length5) {
    var index3 = baseSortedIndex_default(array2, value2, true) - 1;
    if (eq_default(array2[index3], value2)) {
      return index3;
    }
  }
  return -1;
}
var sortedLastIndexOf_default = sortedLastIndexOf;

// node_modules/lodash-es/_baseSortedUniq.js
function baseSortedUniq(array2, iteratee2) {
  var index3 = -1, length5 = array2.length, resIndex = 0, result2 = [];
  while (++index3 < length5) {
    var value2 = array2[index3], computed = iteratee2 ? iteratee2(value2) : value2;
    if (!index3 || !eq_default(computed, seen)) {
      var seen = computed;
      result2[resIndex++] = value2 === 0 ? 0 : value2;
    }
  }
  return result2;
}
var baseSortedUniq_default = baseSortedUniq;

// node_modules/lodash-es/sortedUniq.js
function sortedUniq(array2) {
  return array2 && array2.length ? baseSortedUniq_default(array2) : [];
}
var sortedUniq_default = sortedUniq;

// node_modules/lodash-es/sortedUniqBy.js
function sortedUniqBy(array2, iteratee2) {
  return array2 && array2.length ? baseSortedUniq_default(array2, baseIteratee_default(iteratee2, 2)) : [];
}
var sortedUniqBy_default = sortedUniqBy;

// node_modules/lodash-es/split.js
var MAX_ARRAY_LENGTH5 = 4294967295;
function split(string, separator, limit) {
  if (limit && typeof limit != "number" && isIterateeCall_default(string, separator, limit)) {
    separator = limit = void 0;
  }
  limit = limit === void 0 ? MAX_ARRAY_LENGTH5 : limit >>> 0;
  if (!limit) {
    return [];
  }
  string = toString_default(string);
  if (string && (typeof separator == "string" || separator != null && !isRegExp_default(separator))) {
    separator = baseToString_default(separator);
    if (!separator && hasUnicode_default(string)) {
      return castSlice_default(stringToArray_default(string), 0, limit);
    }
  }
  return string.split(separator, limit);
}
var split_default = split;

// node_modules/lodash-es/spread.js
var FUNC_ERROR_TEXT11 = "Expected a function";
var nativeMax14 = Math.max;
function spread(func, start) {
  if (typeof func != "function") {
    throw new TypeError(FUNC_ERROR_TEXT11);
  }
  start = start == null ? 0 : nativeMax14(toInteger_default(start), 0);
  return baseRest_default(function(args) {
    var array2 = args[start], otherArgs = castSlice_default(args, 0, start);
    if (array2) {
      arrayPush_default(otherArgs, array2);
    }
    return apply_default(func, this, otherArgs);
  });
}
var spread_default = spread;

// node_modules/lodash-es/startCase.js
var startCase = createCompounder_default(function(result2, word2, index3) {
  return result2 + (index3 ? " " : "") + upperFirst_default(word2);
});
var startCase_default = startCase;

// node_modules/lodash-es/startsWith.js
function startsWith2(string, target, position) {
  string = toString_default(string);
  position = position == null ? 0 : baseClamp_default(toInteger_default(position), 0, string.length);
  target = baseToString_default(target);
  return string.slice(position, position + target.length) == target;
}
var startsWith_default = startsWith2;

// node_modules/lodash-es/stubObject.js
function stubObject() {
  return {};
}
var stubObject_default = stubObject;

// node_modules/lodash-es/stubString.js
function stubString() {
  return "";
}
var stubString_default = stubString;

// node_modules/lodash-es/stubTrue.js
function stubTrue() {
  return true;
}
var stubTrue_default = stubTrue;

// node_modules/lodash-es/subtract.js
var subtract6 = createMathOperation_default(function(minuend, subtrahend) {
  return minuend - subtrahend;
}, 0);
var subtract_default = subtract6;

// node_modules/lodash-es/sum.js
function sum4(array2) {
  return array2 && array2.length ? baseSum_default(array2, identity_default8) : 0;
}
var sum_default2 = sum4;

// node_modules/lodash-es/sumBy.js
function sumBy(array2, iteratee2) {
  return array2 && array2.length ? baseSum_default(array2, baseIteratee_default(iteratee2, 2)) : 0;
}
var sumBy_default = sumBy;

// node_modules/lodash-es/tail.js
function tail(array2) {
  var length5 = array2 == null ? 0 : array2.length;
  return length5 ? baseSlice_default(array2, 1, length5) : [];
}
var tail_default = tail;

// node_modules/lodash-es/take.js
function take(array2, n, guard) {
  if (!(array2 && array2.length)) {
    return [];
  }
  n = guard || n === void 0 ? 1 : toInteger_default(n);
  return baseSlice_default(array2, 0, n < 0 ? 0 : n);
}
var take_default = take;

// node_modules/lodash-es/takeRight.js
function takeRight(array2, n, guard) {
  var length5 = array2 == null ? 0 : array2.length;
  if (!length5) {
    return [];
  }
  n = guard || n === void 0 ? 1 : toInteger_default(n);
  n = length5 - n;
  return baseSlice_default(array2, n < 0 ? 0 : n, length5);
}
var takeRight_default = takeRight;

// node_modules/lodash-es/takeRightWhile.js
function takeRightWhile(array2, predicate) {
  return array2 && array2.length ? baseWhile_default(array2, baseIteratee_default(predicate, 3), false, true) : [];
}
var takeRightWhile_default = takeRightWhile;

// node_modules/lodash-es/takeWhile.js
function takeWhile(array2, predicate) {
  return array2 && array2.length ? baseWhile_default(array2, baseIteratee_default(predicate, 3)) : [];
}
var takeWhile_default = takeWhile;

// node_modules/lodash-es/tap.js
function tap(value2, interceptor) {
  interceptor(value2);
  return value2;
}
var tap_default = tap;

// node_modules/lodash-es/_customDefaultsAssignIn.js
var objectProto30 = Object.prototype;
var hasOwnProperty24 = objectProto30.hasOwnProperty;
function customDefaultsAssignIn(objValue, srcValue, key, object) {
  if (objValue === void 0 || eq_default(objValue, objectProto30[key]) && !hasOwnProperty24.call(object, key)) {
    return srcValue;
  }
  return objValue;
}
var customDefaultsAssignIn_default = customDefaultsAssignIn;

// node_modules/lodash-es/_escapeStringChar.js
var stringEscapes = {
  "\\": "\\",
  "'": "'",
  "\n": "n",
  "\r": "r",
  "\u2028": "u2028",
  "\u2029": "u2029"
};
function escapeStringChar(chr) {
  return "\\" + stringEscapes[chr];
}
var escapeStringChar_default = escapeStringChar;

// node_modules/lodash-es/_reInterpolate.js
var reInterpolate = /<%=([\s\S]+?)%>/g;
var reInterpolate_default = reInterpolate;

// node_modules/lodash-es/_reEscape.js
var reEscape = /<%-([\s\S]+?)%>/g;
var reEscape_default = reEscape;

// node_modules/lodash-es/_reEvaluate.js
var reEvaluate = /<%([\s\S]+?)%>/g;
var reEvaluate_default = reEvaluate;

// node_modules/lodash-es/templateSettings.js
var templateSettings = {
  /**
   * Used to detect `data` property values to be HTML-escaped.
   *
   * @memberOf _.templateSettings
   * @type {RegExp}
   */
  "escape": reEscape_default,
  /**
   * Used to detect code to be evaluated.
   *
   * @memberOf _.templateSettings
   * @type {RegExp}
   */
  "evaluate": reEvaluate_default,
  /**
   * Used to detect `data` property values to inject.
   *
   * @memberOf _.templateSettings
   * @type {RegExp}
   */
  "interpolate": reInterpolate_default,
  /**
   * Used to reference the data object in the template text.
   *
   * @memberOf _.templateSettings
   * @type {string}
   */
  "variable": "",
  /**
   * Used to import variables into the compiled template.
   *
   * @memberOf _.templateSettings
   * @type {Object}
   */
  "imports": {
    /**
     * A reference to the `lodash` function.
     *
     * @memberOf _.templateSettings.imports
     * @type {Function}
     */
    "_": { "escape": escape_default }
  }
};
var templateSettings_default = templateSettings;

// node_modules/lodash-es/template.js
var INVALID_TEMPL_VAR_ERROR_TEXT = "Invalid `variable` option passed into `_.template`";
var reEmptyStringLeading = /\b__p \+= '';/g;
var reEmptyStringMiddle = /\b(__p \+=) '' \+/g;
var reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
var reForbiddenIdentifierChars = /[()=,{}\[\]\/\s]/;
var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
var reNoMatch = /($^)/;
var reUnescapedString = /['\n\r\u2028\u2029\\]/g;
var objectProto31 = Object.prototype;
var hasOwnProperty25 = objectProto31.hasOwnProperty;
function template(string, options, guard) {
  var settings = templateSettings_default.imports._.templateSettings || templateSettings_default;
  if (guard && isIterateeCall_default(string, options, guard)) {
    options = void 0;
  }
  string = toString_default(string);
  options = assignInWith_default({}, options, settings, customDefaultsAssignIn_default);
  var imports = assignInWith_default({}, options.imports, settings.imports, customDefaultsAssignIn_default), importsKeys = keys_default4(imports), importsValues = baseValues_default(imports, importsKeys);
  var isEscaping, isEvaluating, index3 = 0, interpolate4 = options.interpolate || reNoMatch, source = "__p += '";
  var reDelimiters = RegExp(
    (options.escape || reNoMatch).source + "|" + interpolate4.source + "|" + (interpolate4 === reInterpolate_default ? reEsTemplate : reNoMatch).source + "|" + (options.evaluate || reNoMatch).source + "|$",
    "g"
  );
  var sourceURL = hasOwnProperty25.call(options, "sourceURL") ? "//# sourceURL=" + (options.sourceURL + "").replace(/\s/g, " ") + "\n" : "";
  string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset2) {
    interpolateValue || (interpolateValue = esTemplateValue);
    source += string.slice(index3, offset2).replace(reUnescapedString, escapeStringChar_default);
    if (escapeValue) {
      isEscaping = true;
      source += "' +\n__e(" + escapeValue + ") +\n'";
    }
    if (evaluateValue) {
      isEvaluating = true;
      source += "';\n" + evaluateValue + ";\n__p += '";
    }
    if (interpolateValue) {
      source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
    }
    index3 = offset2 + match.length;
    return match;
  });
  source += "';\n";
  var variable = hasOwnProperty25.call(options, "variable") && options.variable;
  if (!variable) {
    source = "with (obj) {\n" + source + "\n}\n";
  } else if (reForbiddenIdentifierChars.test(variable)) {
    throw new Error(INVALID_TEMPL_VAR_ERROR_TEXT);
  }
  source = (isEvaluating ? source.replace(reEmptyStringLeading, "") : source).replace(reEmptyStringMiddle, "$1").replace(reEmptyStringTrailing, "$1;");
  source = "function(" + (variable || "obj") + ") {\n" + (variable ? "" : "obj || (obj = {});\n") + "var __t, __p = ''" + (isEscaping ? ", __e = _.escape" : "") + (isEvaluating ? ", __j = Array.prototype.join;\nfunction print() { __p += __j.call(arguments, '') }\n" : ";\n") + source + "return __p\n}";
  var result2 = attempt_default(function() {
    return Function(importsKeys, sourceURL + "return " + source).apply(void 0, importsValues);
  });
  result2.source = source;
  if (isError_default(result2)) {
    throw result2;
  }
  return result2;
}
var template_default = template;

// node_modules/lodash-es/throttle.js
var FUNC_ERROR_TEXT12 = "Expected a function";
function throttle(func, wait, options) {
  var leading = true, trailing = true;
  if (typeof func != "function") {
    throw new TypeError(FUNC_ERROR_TEXT12);
  }
  if (isObject_default(options)) {
    leading = "leading" in options ? !!options.leading : leading;
    trailing = "trailing" in options ? !!options.trailing : trailing;
  }
  return debounce_default4(func, wait, {
    "leading": leading,
    "maxWait": wait,
    "trailing": trailing
  });
}
var throttle_default4 = throttle;

// node_modules/lodash-es/thru.js
function thru(value2, interceptor) {
  return interceptor(value2);
}
var thru_default = thru;

// node_modules/lodash-es/times.js
var MAX_SAFE_INTEGER5 = 9007199254740991;
var MAX_ARRAY_LENGTH6 = 4294967295;
var nativeMin12 = Math.min;
function times(n, iteratee2) {
  n = toInteger_default(n);
  if (n < 1 || n > MAX_SAFE_INTEGER5) {
    return [];
  }
  var index3 = MAX_ARRAY_LENGTH6, length5 = nativeMin12(n, MAX_ARRAY_LENGTH6);
  iteratee2 = castFunction_default(iteratee2);
  n -= MAX_ARRAY_LENGTH6;
  var result2 = baseTimes_default(length5, iteratee2);
  while (++index3 < n) {
    iteratee2(index3);
  }
  return result2;
}
var times_default2 = times;

// node_modules/lodash-es/toIterator.js
function wrapperToIterator() {
  return this;
}
var toIterator_default = wrapperToIterator;

// node_modules/lodash-es/_baseWrapperValue.js
function baseWrapperValue(value2, actions) {
  var result2 = value2;
  if (result2 instanceof LazyWrapper_default) {
    result2 = result2.value();
  }
  return arrayReduce_default(actions, function(result3, action) {
    return action.func.apply(action.thisArg, arrayPush_default([result3], action.args));
  }, result2);
}
var baseWrapperValue_default = baseWrapperValue;

// node_modules/lodash-es/wrapperValue.js
function wrapperValue() {
  return baseWrapperValue_default(this.__wrapped__, this.__actions__);
}
var wrapperValue_default = wrapperValue;

// node_modules/lodash-es/toLower.js
function toLower(value2) {
  return toString_default(value2).toLowerCase();
}
var toLower_default = toLower;

// node_modules/lodash-es/toPath.js
function toPath(value2) {
  if (isArray_default(value2)) {
    return arrayMap_default(value2, toKey_default);
  }
  return isSymbol_default(value2) ? [value2] : copyArray_default(stringToPath_default(toString_default(value2)));
}
var toPath_default = toPath;

// node_modules/lodash-es/toSafeInteger.js
var MAX_SAFE_INTEGER6 = 9007199254740991;
function toSafeInteger(value2) {
  return value2 ? baseClamp_default(toInteger_default(value2), -MAX_SAFE_INTEGER6, MAX_SAFE_INTEGER6) : value2 === 0 ? value2 : 0;
}
var toSafeInteger_default = toSafeInteger;

// node_modules/lodash-es/toUpper.js
function toUpper(value2) {
  return toString_default(value2).toUpperCase();
}
var toUpper_default = toUpper;

// node_modules/lodash-es/transform.js
function transform2(object, iteratee2, accumulator) {
  var isArr = isArray_default(object), isArrLike = isArr || isBuffer_default(object) || isTypedArray_default(object);
  iteratee2 = baseIteratee_default(iteratee2, 4);
  if (accumulator == null) {
    var Ctor = object && object.constructor;
    if (isArrLike) {
      accumulator = isArr ? new Ctor() : [];
    } else if (isObject_default(object)) {
      accumulator = isFunction_default(Ctor) ? baseCreate_default(getPrototype_default(object)) : {};
    } else {
      accumulator = {};
    }
  }
  (isArrLike ? arrayEach_default : baseForOwn_default)(object, function(value2, index3, object2) {
    return iteratee2(accumulator, value2, index3, object2);
  });
  return accumulator;
}
var transform_default2 = transform2;

// node_modules/lodash-es/_charsEndIndex.js
function charsEndIndex(strSymbols, chrSymbols) {
  var index3 = strSymbols.length;
  while (index3-- && baseIndexOf_default(chrSymbols, strSymbols[index3], 0) > -1) {
  }
  return index3;
}
var charsEndIndex_default = charsEndIndex;

// node_modules/lodash-es/_charsStartIndex.js
function charsStartIndex(strSymbols, chrSymbols) {
  var index3 = -1, length5 = strSymbols.length;
  while (++index3 < length5 && baseIndexOf_default(chrSymbols, strSymbols[index3], 0) > -1) {
  }
  return index3;
}
var charsStartIndex_default = charsStartIndex;

// node_modules/lodash-es/trim.js
function trim(string, chars, guard) {
  string = toString_default(string);
  if (string && (guard || chars === void 0)) {
    return baseTrim_default(string);
  }
  if (!string || !(chars = baseToString_default(chars))) {
    return string;
  }
  var strSymbols = stringToArray_default(string), chrSymbols = stringToArray_default(chars), start = charsStartIndex_default(strSymbols, chrSymbols), end = charsEndIndex_default(strSymbols, chrSymbols) + 1;
  return castSlice_default(strSymbols, start, end).join("");
}
var trim_default = trim;

// node_modules/lodash-es/trimEnd.js
function trimEnd(string, chars, guard) {
  string = toString_default(string);
  if (string && (guard || chars === void 0)) {
    return string.slice(0, trimmedEndIndex_default(string) + 1);
  }
  if (!string || !(chars = baseToString_default(chars))) {
    return string;
  }
  var strSymbols = stringToArray_default(string), end = charsEndIndex_default(strSymbols, stringToArray_default(chars)) + 1;
  return castSlice_default(strSymbols, 0, end).join("");
}
var trimEnd_default = trimEnd;

// node_modules/lodash-es/trimStart.js
var reTrimStart3 = /^\s+/;
function trimStart(string, chars, guard) {
  string = toString_default(string);
  if (string && (guard || chars === void 0)) {
    return string.replace(reTrimStart3, "");
  }
  if (!string || !(chars = baseToString_default(chars))) {
    return string;
  }
  var strSymbols = stringToArray_default(string), start = charsStartIndex_default(strSymbols, stringToArray_default(chars));
  return castSlice_default(strSymbols, start).join("");
}
var trimStart_default = trimStart;

// node_modules/lodash-es/truncate.js
var DEFAULT_TRUNC_LENGTH = 30;
var DEFAULT_TRUNC_OMISSION = "...";
var reFlags2 = /\w*$/;
function truncate(string, options) {
  var length5 = DEFAULT_TRUNC_LENGTH, omission = DEFAULT_TRUNC_OMISSION;
  if (isObject_default(options)) {
    var separator = "separator" in options ? options.separator : separator;
    length5 = "length" in options ? toInteger_default(options.length) : length5;
    omission = "omission" in options ? baseToString_default(options.omission) : omission;
  }
  string = toString_default(string);
  var strLength = string.length;
  if (hasUnicode_default(string)) {
    var strSymbols = stringToArray_default(string);
    strLength = strSymbols.length;
  }
  if (length5 >= strLength) {
    return string;
  }
  var end = length5 - stringSize_default(omission);
  if (end < 1) {
    return omission;
  }
  var result2 = strSymbols ? castSlice_default(strSymbols, 0, end).join("") : string.slice(0, end);
  if (separator === void 0) {
    return result2 + omission;
  }
  if (strSymbols) {
    end += result2.length - end;
  }
  if (isRegExp_default(separator)) {
    if (string.slice(end).search(separator)) {
      var match, substring = result2;
      if (!separator.global) {
        separator = RegExp(separator.source, toString_default(reFlags2.exec(separator)) + "g");
      }
      separator.lastIndex = 0;
      while (match = separator.exec(substring)) {
        var newEnd = match.index;
      }
      result2 = result2.slice(0, newEnd === void 0 ? end : newEnd);
    }
  } else if (string.indexOf(baseToString_default(separator), end) != end) {
    var index3 = result2.lastIndexOf(separator);
    if (index3 > -1) {
      result2 = result2.slice(0, index3);
    }
  }
  return result2 + omission;
}
var truncate_default = truncate;

// node_modules/lodash-es/unary.js
function unary(func) {
  return ary_default(func, 1);
}
var unary_default = unary;

// node_modules/lodash-es/_unescapeHtmlChar.js
var htmlUnescapes = {
  "&amp;": "&",
  "&lt;": "<",
  "&gt;": ">",
  "&quot;": '"',
  "&#39;": "'"
};
var unescapeHtmlChar = basePropertyOf_default(htmlUnescapes);
var unescapeHtmlChar_default = unescapeHtmlChar;

// node_modules/lodash-es/unescape.js
var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g;
var reHasEscapedHtml = RegExp(reEscapedHtml.source);
function unescape(string) {
  string = toString_default(string);
  return string && reHasEscapedHtml.test(string) ? string.replace(reEscapedHtml, unescapeHtmlChar_default) : string;
}
var unescape_default = unescape;

// node_modules/lodash-es/_createSet.js
var INFINITY6 = 1 / 0;
var createSet = !(Set_default && 1 / setToArray_default(new Set_default([, -0]))[1] == INFINITY6) ? noop_default5 : function(values4) {
  return new Set_default(values4);
};
var createSet_default = createSet;

// node_modules/lodash-es/_baseUniq.js
var LARGE_ARRAY_SIZE3 = 200;
function baseUniq(array2, iteratee2, comparator) {
  var index3 = -1, includes2 = arrayIncludes_default, length5 = array2.length, isCommon = true, result2 = [], seen = result2;
  if (comparator) {
    isCommon = false;
    includes2 = arrayIncludesWith_default;
  } else if (length5 >= LARGE_ARRAY_SIZE3) {
    var set9 = iteratee2 ? null : createSet_default(array2);
    if (set9) {
      return setToArray_default(set9);
    }
    isCommon = false;
    includes2 = cacheHas_default;
    seen = new SetCache_default();
  } else {
    seen = iteratee2 ? [] : result2;
  }
  outer:
    while (++index3 < length5) {
      var value2 = array2[index3], computed = iteratee2 ? iteratee2(value2) : value2;
      value2 = comparator || value2 !== 0 ? value2 : 0;
      if (isCommon && computed === computed) {
        var seenIndex = seen.length;
        while (seenIndex--) {
          if (seen[seenIndex] === computed) {
            continue outer;
          }
        }
        if (iteratee2) {
          seen.push(computed);
        }
        result2.push(value2);
      } else if (!includes2(seen, computed, comparator)) {
        if (seen !== result2) {
          seen.push(computed);
        }
        result2.push(value2);
      }
    }
  return result2;
}
var baseUniq_default = baseUniq;

// node_modules/lodash-es/union.js
var union2 = baseRest_default(function(arrays) {
  return baseUniq_default(baseFlatten_default(arrays, 1, isArrayLikeObject_default, true));
});
var union_default4 = union2;

// node_modules/lodash-es/unionBy.js
var unionBy = baseRest_default(function(arrays) {
  var iteratee2 = last_default(arrays);
  if (isArrayLikeObject_default(iteratee2)) {
    iteratee2 = void 0;
  }
  return baseUniq_default(baseFlatten_default(arrays, 1, isArrayLikeObject_default, true), baseIteratee_default(iteratee2, 2));
});
var unionBy_default = unionBy;

// node_modules/lodash-es/unionWith.js
var unionWith = baseRest_default(function(arrays) {
  var comparator = last_default(arrays);
  comparator = typeof comparator == "function" ? comparator : void 0;
  return baseUniq_default(baseFlatten_default(arrays, 1, isArrayLikeObject_default, true), void 0, comparator);
});
var unionWith_default = unionWith;

// node_modules/lodash-es/uniq.js
function uniq4(array2) {
  return array2 && array2.length ? baseUniq_default(array2) : [];
}
var uniq_default = uniq4;

// node_modules/lodash-es/uniqBy.js
function uniqBy(array2, iteratee2) {
  return array2 && array2.length ? baseUniq_default(array2, baseIteratee_default(iteratee2, 2)) : [];
}
var uniqBy_default = uniqBy;

// node_modules/lodash-es/uniqWith.js
function uniqWith(array2, comparator) {
  comparator = typeof comparator == "function" ? comparator : void 0;
  return array2 && array2.length ? baseUniq_default(array2, void 0, comparator) : [];
}
var uniqWith_default = uniqWith;

// node_modules/lodash-es/uniqueId.js
var idCounter = 0;
function uniqueId2(prefix) {
  var id3 = ++idCounter;
  return toString_default(prefix) + id3;
}
var uniqueId_default = uniqueId2;

// node_modules/lodash-es/unset.js
function unset(object, path2) {
  return object == null ? true : baseUnset_default(object, path2);
}
var unset_default = unset;

// node_modules/lodash-es/unzip.js
var nativeMax15 = Math.max;
function unzip(array2) {
  if (!(array2 && array2.length)) {
    return [];
  }
  var length5 = 0;
  array2 = arrayFilter_default(array2, function(group3) {
    if (isArrayLikeObject_default(group3)) {
      length5 = nativeMax15(group3.length, length5);
      return true;
    }
  });
  return baseTimes_default(length5, function(index3) {
    return arrayMap_default(array2, baseProperty_default(index3));
  });
}
var unzip_default = unzip;

// node_modules/lodash-es/unzipWith.js
function unzipWith(array2, iteratee2) {
  if (!(array2 && array2.length)) {
    return [];
  }
  var result2 = unzip_default(array2);
  if (iteratee2 == null) {
    return result2;
  }
  return arrayMap_default(result2, function(group3) {
    return apply_default(iteratee2, void 0, group3);
  });
}
var unzipWith_default = unzipWith;

// node_modules/lodash-es/_baseUpdate.js
function baseUpdate(object, path2, updater, customizer) {
  return baseSet_default(object, path2, updater(baseGet_default(object, path2)), customizer);
}
var baseUpdate_default = baseUpdate;

// node_modules/lodash-es/update.js
function update2(object, path2, updater) {
  return object == null ? object : baseUpdate_default(object, path2, castFunction_default(updater));
}
var update_default = update2;

// node_modules/lodash-es/updateWith.js
function updateWith(object, path2, updater, customizer) {
  customizer = typeof customizer == "function" ? customizer : void 0;
  return object == null ? object : baseUpdate_default(object, path2, castFunction_default(updater), customizer);
}
var updateWith_default = updateWith;

// node_modules/lodash-es/upperCase.js
var upperCase = createCompounder_default(function(result2, word2, index3) {
  return result2 + (index3 ? " " : "") + word2.toUpperCase();
});
var upperCase_default = upperCase;

// node_modules/lodash-es/valuesIn.js
function valuesIn(object) {
  return object == null ? [] : baseValues_default(object, keysIn_default(object));
}
var valuesIn_default = valuesIn;

// node_modules/lodash-es/without.js
var without = baseRest_default(function(array2, values4) {
  return isArrayLikeObject_default(array2) ? baseDifference_default(array2, values4) : [];
});
var without_default = without;

// node_modules/lodash-es/wrap.js
function wrap(value2, wrapper) {
  return partial_default(castFunction_default(wrapper), value2);
}
var wrap_default = wrap;

// node_modules/lodash-es/wrapperAt.js
var wrapperAt = flatRest_default(function(paths) {
  var length5 = paths.length, start = length5 ? paths[0] : 0, value2 = this.__wrapped__, interceptor = function(object) {
    return baseAt_default(object, paths);
  };
  if (length5 > 1 || this.__actions__.length || !(value2 instanceof LazyWrapper_default) || !isIndex_default(start)) {
    return this.thru(interceptor);
  }
  value2 = value2.slice(start, +start + (length5 ? 1 : 0));
  value2.__actions__.push({
    "func": thru_default,
    "args": [interceptor],
    "thisArg": void 0
  });
  return new LodashWrapper_default(value2, this.__chain__).thru(function(array2) {
    if (length5 && !array2.length) {
      array2.push(void 0);
    }
    return array2;
  });
});
var wrapperAt_default = wrapperAt;

// node_modules/lodash-es/wrapperChain.js
function wrapperChain() {
  return chain_default(this);
}
var wrapperChain_default = wrapperChain;

// node_modules/lodash-es/wrapperReverse.js
function wrapperReverse() {
  var value2 = this.__wrapped__;
  if (value2 instanceof LazyWrapper_default) {
    var wrapped = value2;
    if (this.__actions__.length) {
      wrapped = new LazyWrapper_default(this);
    }
    wrapped = wrapped.reverse();
    wrapped.__actions__.push({
      "func": thru_default,
      "args": [reverse_default2],
      "thisArg": void 0
    });
    return new LodashWrapper_default(wrapped, this.__chain__);
  }
  return this.thru(reverse_default2);
}
var wrapperReverse_default = wrapperReverse;

// node_modules/lodash-es/_baseXor.js
function baseXor(arrays, iteratee2, comparator) {
  var length5 = arrays.length;
  if (length5 < 2) {
    return length5 ? baseUniq_default(arrays[0]) : [];
  }
  var index3 = -1, result2 = Array(length5);
  while (++index3 < length5) {
    var array2 = arrays[index3], othIndex = -1;
    while (++othIndex < length5) {
      if (othIndex != index3) {
        result2[index3] = baseDifference_default(result2[index3] || array2, arrays[othIndex], iteratee2, comparator);
      }
    }
  }
  return baseUniq_default(baseFlatten_default(result2, 1), iteratee2, comparator);
}
var baseXor_default = baseXor;

// node_modules/lodash-es/xor.js
var xor = baseRest_default(function(arrays) {
  return baseXor_default(arrayFilter_default(arrays, isArrayLikeObject_default));
});
var xor_default = xor;

// node_modules/lodash-es/xorBy.js
var xorBy = baseRest_default(function(arrays) {
  var iteratee2 = last_default(arrays);
  if (isArrayLikeObject_default(iteratee2)) {
    iteratee2 = void 0;
  }
  return baseXor_default(arrayFilter_default(arrays, isArrayLikeObject_default), baseIteratee_default(iteratee2, 2));
});
var xorBy_default = xorBy;

// node_modules/lodash-es/xorWith.js
var xorWith = baseRest_default(function(arrays) {
  var comparator = last_default(arrays);
  comparator = typeof comparator == "function" ? comparator : void 0;
  return baseXor_default(arrayFilter_default(arrays, isArrayLikeObject_default), void 0, comparator);
});
var xorWith_default = xorWith;

// node_modules/lodash-es/zip.js
var zip2 = baseRest_default(unzip_default);
var zip_default = zip2;

// node_modules/lodash-es/_baseZipObject.js
function baseZipObject(props, values4, assignFunc) {
  var index3 = -1, length5 = props.length, valsLength = values4.length, result2 = {};
  while (++index3 < length5) {
    var value2 = index3 < valsLength ? values4[index3] : void 0;
    assignFunc(result2, props[index3], value2);
  }
  return result2;
}
var baseZipObject_default = baseZipObject;

// node_modules/lodash-es/zipObject.js
function zipObject(props, values4) {
  return baseZipObject_default(props || [], values4 || [], assignValue_default);
}
var zipObject_default = zipObject;

// node_modules/lodash-es/zipObjectDeep.js
function zipObjectDeep(props, values4) {
  return baseZipObject_default(props || [], values4 || [], baseSet_default);
}
var zipObjectDeep_default = zipObjectDeep;

// node_modules/lodash-es/zipWith.js
var zipWith = baseRest_default(function(arrays) {
  var length5 = arrays.length, iteratee2 = length5 > 1 ? arrays[length5 - 1] : void 0;
  iteratee2 = typeof iteratee2 == "function" ? (arrays.pop(), iteratee2) : void 0;
  return unzipWith_default(arrays, iteratee2);
});
var zipWith_default = zipWith;

// node_modules/lodash-es/array.default.js
var array_default_default = {
  chunk: chunk_default,
  compact: compact_default,
  concat: concat_default,
  difference: difference_default4,
  differenceBy: differenceBy_default,
  differenceWith: differenceWith_default,
  drop: drop_default,
  dropRight: dropRight_default,
  dropRightWhile: dropRightWhile_default,
  dropWhile: dropWhile_default,
  fill: fill_default,
  findIndex: findIndex_default,
  findLastIndex: findLastIndex_default,
  first: head_default,
  flatten: flatten_default4,
  flattenDeep: flattenDeep_default,
  flattenDepth: flattenDepth_default,
  fromPairs: fromPairs_default,
  head: head_default,
  indexOf: indexOf_default,
  initial: initial_default,
  intersection: intersection_default,
  intersectionBy: intersectionBy_default,
  intersectionWith: intersectionWith_default,
  join: join_default,
  last: last_default,
  lastIndexOf: lastIndexOf_default,
  nth: nth_default,
  pull: pull_default4,
  pullAll: pullAll_default,
  pullAllBy: pullAllBy_default,
  pullAllWith: pullAllWith_default,
  pullAt: pullAt_default,
  remove: remove_default5,
  reverse: reverse_default2,
  slice: slice_default2,
  sortedIndex: sortedIndex_default,
  sortedIndexBy: sortedIndexBy_default,
  sortedIndexOf: sortedIndexOf_default,
  sortedLastIndex: sortedLastIndex_default,
  sortedLastIndexBy: sortedLastIndexBy_default,
  sortedLastIndexOf: sortedLastIndexOf_default,
  sortedUniq: sortedUniq_default,
  sortedUniqBy: sortedUniqBy_default,
  tail: tail_default,
  take: take_default,
  takeRight: takeRight_default,
  takeRightWhile: takeRightWhile_default,
  takeWhile: takeWhile_default,
  union: union_default4,
  unionBy: unionBy_default,
  unionWith: unionWith_default,
  uniq: uniq_default,
  uniqBy: uniqBy_default,
  uniqWith: uniqWith_default,
  unzip: unzip_default,
  unzipWith: unzipWith_default,
  without: without_default,
  xor: xor_default,
  xorBy: xorBy_default,
  xorWith: xorWith_default,
  zip: zip_default,
  zipObject: zipObject_default,
  zipObjectDeep: zipObjectDeep_default,
  zipWith: zipWith_default
};

// node_modules/lodash-es/collection.default.js
var collection_default_default = {
  countBy: countBy_default,
  each: forEach_default,
  eachRight: forEachRight_default,
  every: every_default4,
  filter: filter_default4,
  find: find_default6,
  findLast: findLast_default,
  flatMap: flatMap_default,
  flatMapDeep: flatMapDeep_default,
  flatMapDepth: flatMapDepth_default,
  forEach: forEach_default,
  forEachRight: forEachRight_default,
  groupBy: groupBy_default,
  includes: includes_default,
  invokeMap: invokeMap_default,
  keyBy: keyBy_default,
  map: map_default4,
  orderBy: orderBy_default,
  partition: partition_default2,
  reduce: reduce_default4,
  reduceRight: reduceRight_default,
  reject: reject_default,
  sample: sample_default,
  sampleSize: sampleSize_default,
  shuffle: shuffle_default2,
  size: size_default2,
  some: some_default4,
  sortBy: sortBy_default
};

// node_modules/lodash-es/date.default.js
var date_default_default = {
  now: now_default
};

// node_modules/lodash-es/function.default.js
var function_default_default = {
  after: after_default,
  ary: ary_default,
  before: before_default,
  bind: bind_default,
  bindKey: bindKey_default,
  curry: curry_default,
  curryRight: curryRight_default,
  debounce: debounce_default4,
  defer: defer_default,
  delay: delay_default,
  flip: flip_default,
  memoize: memoize_default4,
  negate: negate_default,
  once: once_default,
  overArgs: overArgs_default,
  partial: partial_default,
  partialRight: partialRight_default,
  rearg: rearg_default,
  rest: rest_default,
  spread: spread_default,
  throttle: throttle_default4,
  unary: unary_default,
  wrap: wrap_default
};

// node_modules/lodash-es/lang.default.js
var lang_default_default = {
  castArray: castArray_default,
  clone: clone_default4,
  cloneDeep: cloneDeep_default,
  cloneDeepWith: cloneDeepWith_default,
  cloneWith: cloneWith_default,
  conformsTo: conformsTo_default,
  eq: eq_default,
  gt: gt_default,
  gte: gte_default,
  isArguments: isArguments_default,
  isArray: isArray_default,
  isArrayBuffer: isArrayBuffer_default,
  isArrayLike: isArrayLike_default,
  isArrayLikeObject: isArrayLikeObject_default,
  isBoolean: isBoolean_default,
  isBuffer: isBuffer_default,
  isDate: isDate_default,
  isElement: isElement_default,
  isEmpty: isEmpty_default,
  isEqual: isEqual_default,
  isEqualWith: isEqualWith_default,
  isError: isError_default,
  isFinite: isFinite_default,
  isFunction: isFunction_default,
  isInteger: isInteger_default,
  isLength: isLength_default,
  isMap: isMap_default,
  isMatch: isMatch_default,
  isMatchWith: isMatchWith_default,
  isNaN: isNaN_default,
  isNative: isNative_default,
  isNil: isNil_default,
  isNull: isNull_default,
  isNumber: isNumber_default,
  isObject: isObject_default,
  isObjectLike: isObjectLike_default,
  isPlainObject: isPlainObject_default,
  isRegExp: isRegExp_default,
  isSafeInteger: isSafeInteger_default,
  isSet: isSet_default,
  isString: isString_default,
  isSymbol: isSymbol_default,
  isTypedArray: isTypedArray_default,
  isUndefined: isUndefined_default,
  isWeakMap: isWeakMap_default,
  isWeakSet: isWeakSet_default,
  lt: lt_default,
  lte: lte_default,
  toArray: toArray_default,
  toFinite: toFinite_default,
  toInteger: toInteger_default,
  toLength: toLength_default,
  toNumber: toNumber_default,
  toPlainObject: toPlainObject_default,
  toSafeInteger: toSafeInteger_default,
  toString: toString_default
};

// node_modules/lodash-es/math.default.js
var math_default_default = {
  add: add_default2,
  ceil: ceil_default,
  divide: divide_default,
  floor: floor_default,
  max: max_default4,
  maxBy: maxBy_default,
  mean: mean_default,
  meanBy: meanBy_default,
  min: min_default4,
  minBy: minBy_default,
  multiply: multiply_default,
  round: round_default3,
  subtract: subtract_default,
  sum: sum_default2,
  sumBy: sumBy_default
};

// node_modules/lodash-es/number.default.js
var number_default_default = {
  clamp: clamp_default4,
  inRange: inRange_default,
  random: random_default
};

// node_modules/lodash-es/object.default.js
var object_default_default = {
  assign: assign_default,
  assignIn: assignIn_default,
  assignInWith: assignInWith_default,
  assignWith: assignWith_default,
  at: at_default,
  create: create_default,
  defaults: defaults_default,
  defaultsDeep: defaultsDeep_default,
  entries: toPairs_default,
  entriesIn: toPairsIn_default,
  extend: assignIn_default,
  extendWith: assignInWith_default,
  findKey: findKey_default,
  findLastKey: findLastKey_default,
  forIn: forIn_default,
  forInRight: forInRight_default,
  forOwn: forOwn_default,
  forOwnRight: forOwnRight_default,
  functions: functions_default,
  functionsIn: functionsIn_default,
  get: get_default4,
  has: has_default4,
  hasIn: hasIn_default,
  invert: invert_default,
  invertBy: invertBy_default,
  invoke: invoke_default,
  keys: keys_default4,
  keysIn: keysIn_default,
  mapKeys: mapKeys_default,
  mapValues: mapValues_default,
  merge: merge_default,
  mergeWith: mergeWith_default,
  omit: omit_default4,
  omitBy: omitBy_default,
  pick: pick_default4,
  pickBy: pickBy_default,
  result: result_default,
  set: set_default4,
  setWith: setWith_default,
  toPairs: toPairs_default,
  toPairsIn: toPairsIn_default,
  transform: transform_default2,
  unset: unset_default,
  update: update_default,
  updateWith: updateWith_default,
  values: values_default4,
  valuesIn: valuesIn_default
};

// node_modules/lodash-es/seq.default.js
var seq_default_default = {
  at: wrapperAt_default,
  chain: chain_default,
  commit: commit_default,
  lodash: wrapperLodash_default,
  next: next_default,
  plant: plant_default,
  reverse: wrapperReverse_default,
  tap: tap_default,
  thru: thru_default,
  toIterator: toIterator_default,
  toJSON: wrapperValue_default,
  value: wrapperValue_default,
  valueOf: wrapperValue_default,
  wrapperChain: wrapperChain_default
};

// node_modules/lodash-es/string.default.js
var string_default_default = {
  camelCase: camelCase_default,
  capitalize: capitalize_default,
  deburr: deburr_default,
  endsWith: endsWith_default,
  escape: escape_default,
  escapeRegExp: escapeRegExp_default,
  kebabCase: kebabCase_default,
  lowerCase: lowerCase_default,
  lowerFirst: lowerFirst_default,
  pad: pad_default,
  padEnd: padEnd_default,
  padStart: padStart_default,
  parseInt: parseInt_default,
  repeat: repeat_default,
  replace: replace_default,
  snakeCase: snakeCase_default,
  split: split_default,
  startCase: startCase_default,
  startsWith: startsWith_default,
  template: template_default,
  templateSettings: templateSettings_default,
  toLower: toLower_default,
  toUpper: toUpper_default,
  trim: trim_default,
  trimEnd: trimEnd_default,
  trimStart: trimStart_default,
  truncate: truncate_default,
  unescape: unescape_default,
  upperCase: upperCase_default,
  upperFirst: upperFirst_default,
  words: words_default
};

// node_modules/lodash-es/util.default.js
var util_default_default = {
  attempt: attempt_default,
  bindAll: bindAll_default,
  cond: cond_default,
  conforms: conforms_default,
  constant: constant_default6,
  defaultTo: defaultTo_default,
  flow: flow_default,
  flowRight: flowRight_default,
  identity: identity_default8,
  iteratee: iteratee_default,
  matches: matches_default,
  matchesProperty: matchesProperty_default,
  method: method_default,
  methodOf: methodOf_default,
  mixin: mixin_default,
  noop: noop_default5,
  nthArg: nthArg_default,
  over: over_default,
  overEvery: overEvery_default,
  overSome: overSome_default,
  property: property_default,
  propertyOf: propertyOf_default,
  range: range_default,
  rangeRight: rangeRight_default,
  stubArray: stubArray_default,
  stubFalse: stubFalse_default,
  stubObject: stubObject_default,
  stubString: stubString_default,
  stubTrue: stubTrue_default,
  times: times_default2,
  toPath: toPath_default,
  uniqueId: uniqueId_default
};

// node_modules/lodash-es/_lazyClone.js
function lazyClone() {
  var result2 = new LazyWrapper_default(this.__wrapped__);
  result2.__actions__ = copyArray_default(this.__actions__);
  result2.__dir__ = this.__dir__;
  result2.__filtered__ = this.__filtered__;
  result2.__iteratees__ = copyArray_default(this.__iteratees__);
  result2.__takeCount__ = this.__takeCount__;
  result2.__views__ = copyArray_default(this.__views__);
  return result2;
}
var lazyClone_default = lazyClone;

// node_modules/lodash-es/_lazyReverse.js
function lazyReverse() {
  if (this.__filtered__) {
    var result2 = new LazyWrapper_default(this);
    result2.__dir__ = -1;
    result2.__filtered__ = true;
  } else {
    result2 = this.clone();
    result2.__dir__ *= -1;
  }
  return result2;
}
var lazyReverse_default = lazyReverse;

// node_modules/lodash-es/_getView.js
var nativeMax16 = Math.max;
var nativeMin13 = Math.min;
function getView(start, end, transforms) {
  var index3 = -1, length5 = transforms.length;
  while (++index3 < length5) {
    var data2 = transforms[index3], size5 = data2.size;
    switch (data2.type) {
      case "drop":
        start += size5;
        break;
      case "dropRight":
        end -= size5;
        break;
      case "take":
        end = nativeMin13(end, start + size5);
        break;
      case "takeRight":
        start = nativeMax16(start, end - size5);
        break;
    }
  }
  return { "start": start, "end": end };
}
var getView_default = getView;

// node_modules/lodash-es/_lazyValue.js
var LAZY_FILTER_FLAG = 1;
var LAZY_MAP_FLAG = 2;
var nativeMin14 = Math.min;
function lazyValue() {
  var array2 = this.__wrapped__.value(), dir = this.__dir__, isArr = isArray_default(array2), isRight = dir < 0, arrLength = isArr ? array2.length : 0, view = getView_default(0, arrLength, this.__views__), start = view.start, end = view.end, length5 = end - start, index3 = isRight ? end : start - 1, iteratees = this.__iteratees__, iterLength = iteratees.length, resIndex = 0, takeCount = nativeMin14(length5, this.__takeCount__);
  if (!isArr || !isRight && arrLength == length5 && takeCount == length5) {
    return baseWrapperValue_default(array2, this.__actions__);
  }
  var result2 = [];
  outer:
    while (length5-- && resIndex < takeCount) {
      index3 += dir;
      var iterIndex = -1, value2 = array2[index3];
      while (++iterIndex < iterLength) {
        var data2 = iteratees[iterIndex], iteratee2 = data2.iteratee, type = data2.type, computed = iteratee2(value2);
        if (type == LAZY_MAP_FLAG) {
          value2 = computed;
        } else if (!computed) {
          if (type == LAZY_FILTER_FLAG) {
            continue outer;
          } else {
            break outer;
          }
        }
      }
      result2[resIndex++] = value2;
    }
  return result2;
}
var lazyValue_default = lazyValue;

// node_modules/lodash-es/lodash.default.js
var VERSION = "4.17.21";
var WRAP_BIND_KEY_FLAG7 = 2;
var LAZY_FILTER_FLAG2 = 1;
var LAZY_WHILE_FLAG = 3;
var MAX_ARRAY_LENGTH7 = 4294967295;
var arrayProto6 = Array.prototype;
var objectProto32 = Object.prototype;
var hasOwnProperty26 = objectProto32.hasOwnProperty;
var symIterator2 = Symbol_default ? Symbol_default.iterator : void 0;
var nativeMax17 = Math.max;
var nativeMin15 = Math.min;
var mixin2 = function(func) {
  return function(object, source, options) {
    if (options == null) {
      var isObj = isObject_default(source), props = isObj && keys_default4(source), methodNames = props && props.length && baseFunctions_default(source, props);
      if (!(methodNames ? methodNames.length : isObj)) {
        options = source;
        source = object;
        object = this;
      }
    }
    return func(object, source, options);
  };
}(mixin_default);
wrapperLodash_default.after = function_default_default.after;
wrapperLodash_default.ary = function_default_default.ary;
wrapperLodash_default.assign = object_default_default.assign;
wrapperLodash_default.assignIn = object_default_default.assignIn;
wrapperLodash_default.assignInWith = object_default_default.assignInWith;
wrapperLodash_default.assignWith = object_default_default.assignWith;
wrapperLodash_default.at = object_default_default.at;
wrapperLodash_default.before = function_default_default.before;
wrapperLodash_default.bind = function_default_default.bind;
wrapperLodash_default.bindAll = util_default_default.bindAll;
wrapperLodash_default.bindKey = function_default_default.bindKey;
wrapperLodash_default.castArray = lang_default_default.castArray;
wrapperLodash_default.chain = seq_default_default.chain;
wrapperLodash_default.chunk = array_default_default.chunk;
wrapperLodash_default.compact = array_default_default.compact;
wrapperLodash_default.concat = array_default_default.concat;
wrapperLodash_default.cond = util_default_default.cond;
wrapperLodash_default.conforms = util_default_default.conforms;
wrapperLodash_default.constant = util_default_default.constant;
wrapperLodash_default.countBy = collection_default_default.countBy;
wrapperLodash_default.create = object_default_default.create;
wrapperLodash_default.curry = function_default_default.curry;
wrapperLodash_default.curryRight = function_default_default.curryRight;
wrapperLodash_default.debounce = function_default_default.debounce;
wrapperLodash_default.defaults = object_default_default.defaults;
wrapperLodash_default.defaultsDeep = object_default_default.defaultsDeep;
wrapperLodash_default.defer = function_default_default.defer;
wrapperLodash_default.delay = function_default_default.delay;
wrapperLodash_default.difference = array_default_default.difference;
wrapperLodash_default.differenceBy = array_default_default.differenceBy;
wrapperLodash_default.differenceWith = array_default_default.differenceWith;
wrapperLodash_default.drop = array_default_default.drop;
wrapperLodash_default.dropRight = array_default_default.dropRight;
wrapperLodash_default.dropRightWhile = array_default_default.dropRightWhile;
wrapperLodash_default.dropWhile = array_default_default.dropWhile;
wrapperLodash_default.fill = array_default_default.fill;
wrapperLodash_default.filter = collection_default_default.filter;
wrapperLodash_default.flatMap = collection_default_default.flatMap;
wrapperLodash_default.flatMapDeep = collection_default_default.flatMapDeep;
wrapperLodash_default.flatMapDepth = collection_default_default.flatMapDepth;
wrapperLodash_default.flatten = array_default_default.flatten;
wrapperLodash_default.flattenDeep = array_default_default.flattenDeep;
wrapperLodash_default.flattenDepth = array_default_default.flattenDepth;
wrapperLodash_default.flip = function_default_default.flip;
wrapperLodash_default.flow = util_default_default.flow;
wrapperLodash_default.flowRight = util_default_default.flowRight;
wrapperLodash_default.fromPairs = array_default_default.fromPairs;
wrapperLodash_default.functions = object_default_default.functions;
wrapperLodash_default.functionsIn = object_default_default.functionsIn;
wrapperLodash_default.groupBy = collection_default_default.groupBy;
wrapperLodash_default.initial = array_default_default.initial;
wrapperLodash_default.intersection = array_default_default.intersection;
wrapperLodash_default.intersectionBy = array_default_default.intersectionBy;
wrapperLodash_default.intersectionWith = array_default_default.intersectionWith;
wrapperLodash_default.invert = object_default_default.invert;
wrapperLodash_default.invertBy = object_default_default.invertBy;
wrapperLodash_default.invokeMap = collection_default_default.invokeMap;
wrapperLodash_default.iteratee = util_default_default.iteratee;
wrapperLodash_default.keyBy = collection_default_default.keyBy;
wrapperLodash_default.keys = keys_default4;
wrapperLodash_default.keysIn = object_default_default.keysIn;
wrapperLodash_default.map = collection_default_default.map;
wrapperLodash_default.mapKeys = object_default_default.mapKeys;
wrapperLodash_default.mapValues = object_default_default.mapValues;
wrapperLodash_default.matches = util_default_default.matches;
wrapperLodash_default.matchesProperty = util_default_default.matchesProperty;
wrapperLodash_default.memoize = function_default_default.memoize;
wrapperLodash_default.merge = object_default_default.merge;
wrapperLodash_default.mergeWith = object_default_default.mergeWith;
wrapperLodash_default.method = util_default_default.method;
wrapperLodash_default.methodOf = util_default_default.methodOf;
wrapperLodash_default.mixin = mixin2;
wrapperLodash_default.negate = negate_default;
wrapperLodash_default.nthArg = util_default_default.nthArg;
wrapperLodash_default.omit = object_default_default.omit;
wrapperLodash_default.omitBy = object_default_default.omitBy;
wrapperLodash_default.once = function_default_default.once;
wrapperLodash_default.orderBy = collection_default_default.orderBy;
wrapperLodash_default.over = util_default_default.over;
wrapperLodash_default.overArgs = function_default_default.overArgs;
wrapperLodash_default.overEvery = util_default_default.overEvery;
wrapperLodash_default.overSome = util_default_default.overSome;
wrapperLodash_default.partial = function_default_default.partial;
wrapperLodash_default.partialRight = function_default_default.partialRight;
wrapperLodash_default.partition = collection_default_default.partition;
wrapperLodash_default.pick = object_default_default.pick;
wrapperLodash_default.pickBy = object_default_default.pickBy;
wrapperLodash_default.property = util_default_default.property;
wrapperLodash_default.propertyOf = util_default_default.propertyOf;
wrapperLodash_default.pull = array_default_default.pull;
wrapperLodash_default.pullAll = array_default_default.pullAll;
wrapperLodash_default.pullAllBy = array_default_default.pullAllBy;
wrapperLodash_default.pullAllWith = array_default_default.pullAllWith;
wrapperLodash_default.pullAt = array_default_default.pullAt;
wrapperLodash_default.range = util_default_default.range;
wrapperLodash_default.rangeRight = util_default_default.rangeRight;
wrapperLodash_default.rearg = function_default_default.rearg;
wrapperLodash_default.reject = collection_default_default.reject;
wrapperLodash_default.remove = array_default_default.remove;
wrapperLodash_default.rest = function_default_default.rest;
wrapperLodash_default.reverse = array_default_default.reverse;
wrapperLodash_default.sampleSize = collection_default_default.sampleSize;
wrapperLodash_default.set = object_default_default.set;
wrapperLodash_default.setWith = object_default_default.setWith;
wrapperLodash_default.shuffle = collection_default_default.shuffle;
wrapperLodash_default.slice = array_default_default.slice;
wrapperLodash_default.sortBy = collection_default_default.sortBy;
wrapperLodash_default.sortedUniq = array_default_default.sortedUniq;
wrapperLodash_default.sortedUniqBy = array_default_default.sortedUniqBy;
wrapperLodash_default.split = string_default_default.split;
wrapperLodash_default.spread = function_default_default.spread;
wrapperLodash_default.tail = array_default_default.tail;
wrapperLodash_default.take = array_default_default.take;
wrapperLodash_default.takeRight = array_default_default.takeRight;
wrapperLodash_default.takeRightWhile = array_default_default.takeRightWhile;
wrapperLodash_default.takeWhile = array_default_default.takeWhile;
wrapperLodash_default.tap = seq_default_default.tap;
wrapperLodash_default.throttle = function_default_default.throttle;
wrapperLodash_default.thru = thru_default;
wrapperLodash_default.toArray = lang_default_default.toArray;
wrapperLodash_default.toPairs = object_default_default.toPairs;
wrapperLodash_default.toPairsIn = object_default_default.toPairsIn;
wrapperLodash_default.toPath = util_default_default.toPath;
wrapperLodash_default.toPlainObject = lang_default_default.toPlainObject;
wrapperLodash_default.transform = object_default_default.transform;
wrapperLodash_default.unary = function_default_default.unary;
wrapperLodash_default.union = array_default_default.union;
wrapperLodash_default.unionBy = array_default_default.unionBy;
wrapperLodash_default.unionWith = array_default_default.unionWith;
wrapperLodash_default.uniq = array_default_default.uniq;
wrapperLodash_default.uniqBy = array_default_default.uniqBy;
wrapperLodash_default.uniqWith = array_default_default.uniqWith;
wrapperLodash_default.unset = object_default_default.unset;
wrapperLodash_default.unzip = array_default_default.unzip;
wrapperLodash_default.unzipWith = array_default_default.unzipWith;
wrapperLodash_default.update = object_default_default.update;
wrapperLodash_default.updateWith = object_default_default.updateWith;
wrapperLodash_default.values = object_default_default.values;
wrapperLodash_default.valuesIn = object_default_default.valuesIn;
wrapperLodash_default.without = array_default_default.without;
wrapperLodash_default.words = string_default_default.words;
wrapperLodash_default.wrap = function_default_default.wrap;
wrapperLodash_default.xor = array_default_default.xor;
wrapperLodash_default.xorBy = array_default_default.xorBy;
wrapperLodash_default.xorWith = array_default_default.xorWith;
wrapperLodash_default.zip = array_default_default.zip;
wrapperLodash_default.zipObject = array_default_default.zipObject;
wrapperLodash_default.zipObjectDeep = array_default_default.zipObjectDeep;
wrapperLodash_default.zipWith = array_default_default.zipWith;
wrapperLodash_default.entries = object_default_default.toPairs;
wrapperLodash_default.entriesIn = object_default_default.toPairsIn;
wrapperLodash_default.extend = object_default_default.assignIn;
wrapperLodash_default.extendWith = object_default_default.assignInWith;
mixin2(wrapperLodash_default, wrapperLodash_default);
wrapperLodash_default.add = math_default_default.add;
wrapperLodash_default.attempt = util_default_default.attempt;
wrapperLodash_default.camelCase = string_default_default.camelCase;
wrapperLodash_default.capitalize = string_default_default.capitalize;
wrapperLodash_default.ceil = math_default_default.ceil;
wrapperLodash_default.clamp = number_default_default.clamp;
wrapperLodash_default.clone = lang_default_default.clone;
wrapperLodash_default.cloneDeep = lang_default_default.cloneDeep;
wrapperLodash_default.cloneDeepWith = lang_default_default.cloneDeepWith;
wrapperLodash_default.cloneWith = lang_default_default.cloneWith;
wrapperLodash_default.conformsTo = lang_default_default.conformsTo;
wrapperLodash_default.deburr = string_default_default.deburr;
wrapperLodash_default.defaultTo = util_default_default.defaultTo;
wrapperLodash_default.divide = math_default_default.divide;
wrapperLodash_default.endsWith = string_default_default.endsWith;
wrapperLodash_default.eq = lang_default_default.eq;
wrapperLodash_default.escape = string_default_default.escape;
wrapperLodash_default.escapeRegExp = string_default_default.escapeRegExp;
wrapperLodash_default.every = collection_default_default.every;
wrapperLodash_default.find = collection_default_default.find;
wrapperLodash_default.findIndex = array_default_default.findIndex;
wrapperLodash_default.findKey = object_default_default.findKey;
wrapperLodash_default.findLast = collection_default_default.findLast;
wrapperLodash_default.findLastIndex = array_default_default.findLastIndex;
wrapperLodash_default.findLastKey = object_default_default.findLastKey;
wrapperLodash_default.floor = math_default_default.floor;
wrapperLodash_default.forEach = collection_default_default.forEach;
wrapperLodash_default.forEachRight = collection_default_default.forEachRight;
wrapperLodash_default.forIn = object_default_default.forIn;
wrapperLodash_default.forInRight = object_default_default.forInRight;
wrapperLodash_default.forOwn = object_default_default.forOwn;
wrapperLodash_default.forOwnRight = object_default_default.forOwnRight;
wrapperLodash_default.get = object_default_default.get;
wrapperLodash_default.gt = lang_default_default.gt;
wrapperLodash_default.gte = lang_default_default.gte;
wrapperLodash_default.has = object_default_default.has;
wrapperLodash_default.hasIn = object_default_default.hasIn;
wrapperLodash_default.head = array_default_default.head;
wrapperLodash_default.identity = identity_default8;
wrapperLodash_default.includes = collection_default_default.includes;
wrapperLodash_default.indexOf = array_default_default.indexOf;
wrapperLodash_default.inRange = number_default_default.inRange;
wrapperLodash_default.invoke = object_default_default.invoke;
wrapperLodash_default.isArguments = lang_default_default.isArguments;
wrapperLodash_default.isArray = isArray_default;
wrapperLodash_default.isArrayBuffer = lang_default_default.isArrayBuffer;
wrapperLodash_default.isArrayLike = lang_default_default.isArrayLike;
wrapperLodash_default.isArrayLikeObject = lang_default_default.isArrayLikeObject;
wrapperLodash_default.isBoolean = lang_default_default.isBoolean;
wrapperLodash_default.isBuffer = lang_default_default.isBuffer;
wrapperLodash_default.isDate = lang_default_default.isDate;
wrapperLodash_default.isElement = lang_default_default.isElement;
wrapperLodash_default.isEmpty = lang_default_default.isEmpty;
wrapperLodash_default.isEqual = lang_default_default.isEqual;
wrapperLodash_default.isEqualWith = lang_default_default.isEqualWith;
wrapperLodash_default.isError = lang_default_default.isError;
wrapperLodash_default.isFinite = lang_default_default.isFinite;
wrapperLodash_default.isFunction = lang_default_default.isFunction;
wrapperLodash_default.isInteger = lang_default_default.isInteger;
wrapperLodash_default.isLength = lang_default_default.isLength;
wrapperLodash_default.isMap = lang_default_default.isMap;
wrapperLodash_default.isMatch = lang_default_default.isMatch;
wrapperLodash_default.isMatchWith = lang_default_default.isMatchWith;
wrapperLodash_default.isNaN = lang_default_default.isNaN;
wrapperLodash_default.isNative = lang_default_default.isNative;
wrapperLodash_default.isNil = lang_default_default.isNil;
wrapperLodash_default.isNull = lang_default_default.isNull;
wrapperLodash_default.isNumber = lang_default_default.isNumber;
wrapperLodash_default.isObject = isObject_default;
wrapperLodash_default.isObjectLike = lang_default_default.isObjectLike;
wrapperLodash_default.isPlainObject = lang_default_default.isPlainObject;
wrapperLodash_default.isRegExp = lang_default_default.isRegExp;
wrapperLodash_default.isSafeInteger = lang_default_default.isSafeInteger;
wrapperLodash_default.isSet = lang_default_default.isSet;
wrapperLodash_default.isString = lang_default_default.isString;
wrapperLodash_default.isSymbol = lang_default_default.isSymbol;
wrapperLodash_default.isTypedArray = lang_default_default.isTypedArray;
wrapperLodash_default.isUndefined = lang_default_default.isUndefined;
wrapperLodash_default.isWeakMap = lang_default_default.isWeakMap;
wrapperLodash_default.isWeakSet = lang_default_default.isWeakSet;
wrapperLodash_default.join = array_default_default.join;
wrapperLodash_default.kebabCase = string_default_default.kebabCase;
wrapperLodash_default.last = last_default;
wrapperLodash_default.lastIndexOf = array_default_default.lastIndexOf;
wrapperLodash_default.lowerCase = string_default_default.lowerCase;
wrapperLodash_default.lowerFirst = string_default_default.lowerFirst;
wrapperLodash_default.lt = lang_default_default.lt;
wrapperLodash_default.lte = lang_default_default.lte;
wrapperLodash_default.max = math_default_default.max;
wrapperLodash_default.maxBy = math_default_default.maxBy;
wrapperLodash_default.mean = math_default_default.mean;
wrapperLodash_default.meanBy = math_default_default.meanBy;
wrapperLodash_default.min = math_default_default.min;
wrapperLodash_default.minBy = math_default_default.minBy;
wrapperLodash_default.stubArray = util_default_default.stubArray;
wrapperLodash_default.stubFalse = util_default_default.stubFalse;
wrapperLodash_default.stubObject = util_default_default.stubObject;
wrapperLodash_default.stubString = util_default_default.stubString;
wrapperLodash_default.stubTrue = util_default_default.stubTrue;
wrapperLodash_default.multiply = math_default_default.multiply;
wrapperLodash_default.nth = array_default_default.nth;
wrapperLodash_default.noop = util_default_default.noop;
wrapperLodash_default.now = date_default_default.now;
wrapperLodash_default.pad = string_default_default.pad;
wrapperLodash_default.padEnd = string_default_default.padEnd;
wrapperLodash_default.padStart = string_default_default.padStart;
wrapperLodash_default.parseInt = string_default_default.parseInt;
wrapperLodash_default.random = number_default_default.random;
wrapperLodash_default.reduce = collection_default_default.reduce;
wrapperLodash_default.reduceRight = collection_default_default.reduceRight;
wrapperLodash_default.repeat = string_default_default.repeat;
wrapperLodash_default.replace = string_default_default.replace;
wrapperLodash_default.result = object_default_default.result;
wrapperLodash_default.round = math_default_default.round;
wrapperLodash_default.sample = collection_default_default.sample;
wrapperLodash_default.size = collection_default_default.size;
wrapperLodash_default.snakeCase = string_default_default.snakeCase;
wrapperLodash_default.some = collection_default_default.some;
wrapperLodash_default.sortedIndex = array_default_default.sortedIndex;
wrapperLodash_default.sortedIndexBy = array_default_default.sortedIndexBy;
wrapperLodash_default.sortedIndexOf = array_default_default.sortedIndexOf;
wrapperLodash_default.sortedLastIndex = array_default_default.sortedLastIndex;
wrapperLodash_default.sortedLastIndexBy = array_default_default.sortedLastIndexBy;
wrapperLodash_default.sortedLastIndexOf = array_default_default.sortedLastIndexOf;
wrapperLodash_default.startCase = string_default_default.startCase;
wrapperLodash_default.startsWith = string_default_default.startsWith;
wrapperLodash_default.subtract = math_default_default.subtract;
wrapperLodash_default.sum = math_default_default.sum;
wrapperLodash_default.sumBy = math_default_default.sumBy;
wrapperLodash_default.template = string_default_default.template;
wrapperLodash_default.times = util_default_default.times;
wrapperLodash_default.toFinite = lang_default_default.toFinite;
wrapperLodash_default.toInteger = toInteger_default;
wrapperLodash_default.toLength = lang_default_default.toLength;
wrapperLodash_default.toLower = string_default_default.toLower;
wrapperLodash_default.toNumber = lang_default_default.toNumber;
wrapperLodash_default.toSafeInteger = lang_default_default.toSafeInteger;
wrapperLodash_default.toString = lang_default_default.toString;
wrapperLodash_default.toUpper = string_default_default.toUpper;
wrapperLodash_default.trim = string_default_default.trim;
wrapperLodash_default.trimEnd = string_default_default.trimEnd;
wrapperLodash_default.trimStart = string_default_default.trimStart;
wrapperLodash_default.truncate = string_default_default.truncate;
wrapperLodash_default.unescape = string_default_default.unescape;
wrapperLodash_default.uniqueId = util_default_default.uniqueId;
wrapperLodash_default.upperCase = string_default_default.upperCase;
wrapperLodash_default.upperFirst = string_default_default.upperFirst;
wrapperLodash_default.each = collection_default_default.forEach;
wrapperLodash_default.eachRight = collection_default_default.forEachRight;
wrapperLodash_default.first = array_default_default.head;
mixin2(wrapperLodash_default, function() {
  var source = {};
  baseForOwn_default(wrapperLodash_default, function(func, methodName) {
    if (!hasOwnProperty26.call(wrapperLodash_default.prototype, methodName)) {
      source[methodName] = func;
    }
  });
  return source;
}(), { "chain": false });
wrapperLodash_default.VERSION = VERSION;
(wrapperLodash_default.templateSettings = string_default_default.templateSettings).imports._ = wrapperLodash_default;
arrayEach_default(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function(methodName) {
  wrapperLodash_default[methodName].placeholder = wrapperLodash_default;
});
arrayEach_default(["drop", "take"], function(methodName, index3) {
  LazyWrapper_default.prototype[methodName] = function(n) {
    n = n === void 0 ? 1 : nativeMax17(toInteger_default(n), 0);
    var result2 = this.__filtered__ && !index3 ? new LazyWrapper_default(this) : this.clone();
    if (result2.__filtered__) {
      result2.__takeCount__ = nativeMin15(n, result2.__takeCount__);
    } else {
      result2.__views__.push({
        "size": nativeMin15(n, MAX_ARRAY_LENGTH7),
        "type": methodName + (result2.__dir__ < 0 ? "Right" : "")
      });
    }
    return result2;
  };
  LazyWrapper_default.prototype[methodName + "Right"] = function(n) {
    return this.reverse()[methodName](n).reverse();
  };
});
arrayEach_default(["filter", "map", "takeWhile"], function(methodName, index3) {
  var type = index3 + 1, isFilter = type == LAZY_FILTER_FLAG2 || type == LAZY_WHILE_FLAG;
  LazyWrapper_default.prototype[methodName] = function(iteratee2) {
    var result2 = this.clone();
    result2.__iteratees__.push({
      "iteratee": baseIteratee_default(iteratee2, 3),
      "type": type
    });
    result2.__filtered__ = result2.__filtered__ || isFilter;
    return result2;
  };
});
arrayEach_default(["head", "last"], function(methodName, index3) {
  var takeName = "take" + (index3 ? "Right" : "");
  LazyWrapper_default.prototype[methodName] = function() {
    return this[takeName](1).value()[0];
  };
});
arrayEach_default(["initial", "tail"], function(methodName, index3) {
  var dropName = "drop" + (index3 ? "" : "Right");
  LazyWrapper_default.prototype[methodName] = function() {
    return this.__filtered__ ? new LazyWrapper_default(this) : this[dropName](1);
  };
});
LazyWrapper_default.prototype.compact = function() {
  return this.filter(identity_default8);
};
LazyWrapper_default.prototype.find = function(predicate) {
  return this.filter(predicate).head();
};
LazyWrapper_default.prototype.findLast = function(predicate) {
  return this.reverse().find(predicate);
};
LazyWrapper_default.prototype.invokeMap = baseRest_default(function(path2, args) {
  if (typeof path2 == "function") {
    return new LazyWrapper_default(this);
  }
  return this.map(function(value2) {
    return baseInvoke_default(value2, path2, args);
  });
});
LazyWrapper_default.prototype.reject = function(predicate) {
  return this.filter(negate_default(baseIteratee_default(predicate)));
};
LazyWrapper_default.prototype.slice = function(start, end) {
  start = toInteger_default(start);
  var result2 = this;
  if (result2.__filtered__ && (start > 0 || end < 0)) {
    return new LazyWrapper_default(result2);
  }
  if (start < 0) {
    result2 = result2.takeRight(-start);
  } else if (start) {
    result2 = result2.drop(start);
  }
  if (end !== void 0) {
    end = toInteger_default(end);
    result2 = end < 0 ? result2.dropRight(-end) : result2.take(end - start);
  }
  return result2;
};
LazyWrapper_default.prototype.takeRightWhile = function(predicate) {
  return this.reverse().takeWhile(predicate).reverse();
};
LazyWrapper_default.prototype.toArray = function() {
  return this.take(MAX_ARRAY_LENGTH7);
};
baseForOwn_default(LazyWrapper_default.prototype, function(func, methodName) {
  var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName), isTaker = /^(?:head|last)$/.test(methodName), lodashFunc = wrapperLodash_default[isTaker ? "take" + (methodName == "last" ? "Right" : "") : methodName], retUnwrapped = isTaker || /^find/.test(methodName);
  if (!lodashFunc) {
    return;
  }
  wrapperLodash_default.prototype[methodName] = function() {
    var value2 = this.__wrapped__, args = isTaker ? [1] : arguments, isLazy = value2 instanceof LazyWrapper_default, iteratee2 = args[0], useLazy = isLazy || isArray_default(value2);
    var interceptor = function(value3) {
      var result3 = lodashFunc.apply(wrapperLodash_default, arrayPush_default([value3], args));
      return isTaker && chainAll ? result3[0] : result3;
    };
    if (useLazy && checkIteratee && typeof iteratee2 == "function" && iteratee2.length != 1) {
      isLazy = useLazy = false;
    }
    var chainAll = this.__chain__, isHybrid = !!this.__actions__.length, isUnwrapped = retUnwrapped && !chainAll, onlyLazy = isLazy && !isHybrid;
    if (!retUnwrapped && useLazy) {
      value2 = onlyLazy ? value2 : new LazyWrapper_default(this);
      var result2 = func.apply(value2, args);
      result2.__actions__.push({ "func": thru_default, "args": [interceptor], "thisArg": void 0 });
      return new LodashWrapper_default(result2, chainAll);
    }
    if (isUnwrapped && onlyLazy) {
      return func.apply(this, args);
    }
    result2 = this.thru(interceptor);
    return isUnwrapped ? isTaker ? result2.value()[0] : result2.value() : result2;
  };
});
arrayEach_default(["pop", "push", "shift", "sort", "splice", "unshift"], function(methodName) {
  var func = arrayProto6[methodName], chainName = /^(?:push|sort|unshift)$/.test(methodName) ? "tap" : "thru", retUnwrapped = /^(?:pop|shift)$/.test(methodName);
  wrapperLodash_default.prototype[methodName] = function() {
    var args = arguments;
    if (retUnwrapped && !this.__chain__) {
      var value2 = this.value();
      return func.apply(isArray_default(value2) ? value2 : [], args);
    }
    return this[chainName](function(value3) {
      return func.apply(isArray_default(value3) ? value3 : [], args);
    });
  };
});
baseForOwn_default(LazyWrapper_default.prototype, function(func, methodName) {
  var lodashFunc = wrapperLodash_default[methodName];
  if (lodashFunc) {
    var key = lodashFunc.name + "";
    if (!hasOwnProperty26.call(realNames_default, key)) {
      realNames_default[key] = [];
    }
    realNames_default[key].push({ "name": methodName, "func": lodashFunc });
  }
});
realNames_default[createHybrid_default(void 0, WRAP_BIND_KEY_FLAG7).name] = [{
  "name": "wrapper",
  "func": void 0
}];
LazyWrapper_default.prototype.clone = lazyClone_default;
LazyWrapper_default.prototype.reverse = lazyReverse_default;
LazyWrapper_default.prototype.value = lazyValue_default;
wrapperLodash_default.prototype.at = seq_default_default.at;
wrapperLodash_default.prototype.chain = seq_default_default.wrapperChain;
wrapperLodash_default.prototype.commit = seq_default_default.commit;
wrapperLodash_default.prototype.next = seq_default_default.next;
wrapperLodash_default.prototype.plant = seq_default_default.plant;
wrapperLodash_default.prototype.reverse = seq_default_default.reverse;
wrapperLodash_default.prototype.toJSON = wrapperLodash_default.prototype.valueOf = wrapperLodash_default.prototype.value = seq_default_default.value;
wrapperLodash_default.prototype.first = wrapperLodash_default.prototype.head;
if (symIterator2) {
  wrapperLodash_default.prototype[symIterator2] = seq_default_default.toIterator;
}

// node_modules/@ant-design/plots/es/util/is-valid-element.js
var isValidElement = function(jsxCode) {
  var jsxRegex = /react|\.jsx|children:\[\(/i;
  return jsxRegex.test(jsxCode);
};

// node_modules/@ant-design/plots/es/hooks/useChart.js
var __assign3 = function() {
  __assign3 = Object.assign || function(t) {
    for (var s2, i = 1, n = arguments.length; i < n; i++) {
      s2 = arguments[i];
      for (var p2 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p2))
          t[p2] = s2[p2];
    }
    return t;
  };
  return __assign3.apply(this, arguments);
};
var __rest88 = function(s2, e) {
  var t = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
      t[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t[p2[i]] = s2[p2[i]];
    }
  return t;
};
function useChart(ChartClass, config) {
  var chart = (0, import_react3.useRef)();
  var chartOptions = (0, import_react3.useRef)();
  var container = (0, import_react3.useRef)(null);
  var onReady = config.onReady, onEvent = config.onEvent;
  var toDataURL = function(type, encoderOptions) {
    var _a2;
    if (type === void 0) {
      type = "image/png";
    }
    var canvas = (_a2 = container.current) === null || _a2 === void 0 ? void 0 : _a2.getElementsByTagName("canvas")[0];
    return canvas === null || canvas === void 0 ? void 0 : canvas.toDataURL(type, encoderOptions);
  };
  var downloadImage = function(name2, type, encoderOptions) {
    if (name2 === void 0) {
      name2 = "download";
    }
    if (type === void 0) {
      type = "image/png";
    }
    var imageName = name2;
    if (name2.indexOf(".") === -1) {
      imageName = "".concat(name2, ".").concat(type.split("/")[1]);
    }
    var base64 = toDataURL(type, encoderOptions);
    var a4 = document.createElement("a");
    a4.href = base64;
    a4.download = imageName;
    document.body.appendChild(a4);
    a4.click();
    document.body.removeChild(a4);
    a4 = null;
    return imageName;
  };
  var processConfig = function(cfg, flag) {
    if (flag === void 0) {
      flag = false;
    }
    var keys3 = Object.keys(cfg);
    var isTooltip = flag;
    keys3.forEach(function(key) {
      var current = cfg[key];
      if (key === "tooltip")
        isTooltip = true;
      if (isFunction_default(current) && isValidElement("".concat(current))) {
        cfg[key] = function() {
          var arg = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            arg[_i] = arguments[_i];
          }
          return createNode2(current.apply(void 0, arg), isTooltip);
        };
      } else {
        if (isArray_default(current)) {
          current.forEach(function(item) {
            processConfig(item, isTooltip);
          });
        } else if (isObject_default(current)) {
          processConfig(current, isTooltip);
        }
      }
    });
  };
  (0, import_react3.useEffect)(function() {
    if (chart.current && !isEqual_default(chartOptions.current, config)) {
      var changeData = false;
      if (chartOptions.current) {
        var _a2 = chartOptions.current, currentData = _a2.data, currentConfig = __rest88(_a2, ["data"]);
        var inputData = config.data, inputConfig = __rest88(config, ["data"]);
        changeData = isEqual_default(currentConfig, inputConfig);
      }
      chartOptions.current = cloneDeep_default(config);
      if (changeData) {
        chart.current.changeData(get_default4(config, "data"));
      } else {
        processConfig(config);
        chart.current.update(config);
        chart.current.render();
      }
    }
  }, [config]);
  (0, import_react3.useEffect)(function() {
    if (!container.current) {
      return function() {
        return null;
      };
    }
    if (!chartOptions.current) {
      chartOptions.current = cloneDeep_default(config);
    }
    processConfig(config);
    var chartInstance = new ChartClass(container.current, __assign3({}, config));
    chartInstance.toDataURL = toDataURL;
    chartInstance.downloadImage = downloadImage;
    chartInstance.render();
    chart.current = chartInstance;
    if (onReady) {
      onReady(chartInstance);
    }
    var handler = function(event) {
      if (onEvent) {
        onEvent(chartInstance, event);
      }
    };
    chartInstance.on("*", handler);
    return function() {
      if (chart.current) {
        chart.current.destroy();
        chart.current.off("*", handler);
        chart.current = void 0;
      }
    };
  }, []);
  return {
    chart,
    container
  };
}

// node_modules/@antv/g2-extension-plot/esm/utils/hierarchy/partition.js
var DEFAULT_OPTIONS6 = {
  field: "value",
  size: [1, 1],
  // width, height
  round: false,
  padding: 0,
  // Default desc.
  sort: (a4, b) => b.value - a4.value,
  as: ["x", "y"],
  // Whether to ignore parentValue. When set to true, the weight of the parent node is determined by the child element.
  ignoreParentValue: true
};
var NODE_INDEX_FIELD = "nodeIndex";
var CHILD_NODE_COUNT = "childNodeCount";
var NODE_ANCESTORS_FIELD = "nodeAncestor";
var INVALID_FIELD_ERR_MSG = "Invalid field: it must be a string!";
function getField(options, defaultField) {
  const { field: field3, fields } = options;
  if (is_string_default(field3)) {
    return field3;
  }
  if (is_array_default(field3)) {
    console.warn(INVALID_FIELD_ERR_MSG);
    return field3[0];
  }
  console.warn(`${INVALID_FIELD_ERR_MSG} will try to get fields instead.`);
  if (is_string_default(fields)) {
    return fields;
  }
  if (is_array_default(fields) && fields.length) {
    return fields[0];
  }
  if (defaultField) {
    return defaultField;
  }
  throw new TypeError(INVALID_FIELD_ERR_MSG);
}
function getAllNodes(root3) {
  const nodes = [];
  if (root3 && root3.each) {
    let parent2;
    let index3;
    root3.each((node) => {
      var _a2, _b;
      if (node.parent !== parent2) {
        parent2 = node.parent;
        index3 = 0;
      } else {
        index3 += 1;
      }
      const ancestors = filter_default((((_a2 = node.ancestors) === null || _a2 === void 0 ? void 0 : _a2.call(node)) || []).map((d2) => nodes.find((n) => n.name === d2.name) || d2), ({ depth }) => depth > 0 && depth < node.depth);
      node[NODE_ANCESTORS_FIELD] = ancestors;
      node[CHILD_NODE_COUNT] = ((_b = node.children) === null || _b === void 0 ? void 0 : _b.length) || 0;
      node[NODE_INDEX_FIELD] = index3;
      nodes.push(node);
    });
  } else if (root3 && root3.eachNode) {
    root3.eachNode((node) => {
      nodes.push(node);
    });
  }
  return nodes;
}
function partition2(data2, options) {
  options = mix({}, DEFAULT_OPTIONS6, options);
  const as = options.as;
  if (!is_array_default(as) || as.length !== 2) {
    throw new TypeError('Invalid as: it must be an array with 2 strings (e.g. [ "x", "y" ])!');
  }
  let field3;
  try {
    field3 = getField(options);
  } catch (e) {
    console.warn(e);
  }
  const partition3 = (data3) => partition_default().size(options.size).round(options.round).padding(options.padding)(
    /**
     * The sum function must be specified in the d3Hierarchy layout to compute node values by calling the specified value function
     * from the current node in post-order traversal order for the current node and for each descendant node and returning the current node.
     * for example:
     * { node: 'parent', value: 10, children: [{node: 'child1', value: 5}, {node: 'child2', value: 5}, ]}.
     * The computed value obtained by the parent is sum(node(parent)) + sum(node(child1)) + sum(node(child2)).
     * In the sum function, d is the data passed in by the user and children is the reserved field.
     */
    hierarchy(data3).sum((d2) => size(d2.children) ? options.ignoreParentValue ? 0 : d2[field3] - reduce_default(d2.children, (a4, b) => a4 + b[field3], 0) : d2[field3]).sort(options.sort)
  );
  const root3 = partition3(data2);
  const x3 = as[0];
  const y3 = as[1];
  root3.each((node) => {
    var _a2, _b;
    node[x3] = [node.x0, node.x1, node.x1, node.x0];
    node[y3] = [node.y1, node.y1, node.y0, node.y0];
    node.name = node.name || ((_a2 = node.data) === null || _a2 === void 0 ? void 0 : _a2.name) || ((_b = node.data) === null || _b === void 0 ? void 0 : _b.label);
    node.data.name = node.name;
    ["x0", "x1", "y0", "y1"].forEach((prop) => {
      if (as.indexOf(prop) === -1) {
        delete node[prop];
      }
    });
  });
  return getAllNodes(root3);
}

// node_modules/@antv/g2-extension-plot/esm/mark/sunburst.js
var __rest89 = function(s2, e) {
  var t = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
      t[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t[p2[i]] = s2[p2[i]];
    }
  return t;
};
var SUNBURST_TYPE = "sunburst";
var SUNBURST_TYPE_FIELD = "markType";
var SUNBURST_PATH_FIELD = "path";
var SUNBURST_ANCESTOR_FIELD = "ancestor-node";
function transformData(options) {
  const { data: data2, encode } = options;
  const { color: color2, value: value2 } = encode;
  const type = "partition";
  const nodes = partition2(data2, {
    field: value2,
    // @ts-ignore
    type: `hierarchy.${type}`,
    as: ["x", "y"]
  });
  const result2 = [];
  nodes.forEach((node) => {
    var _a2, _b, _c, _d;
    if (node.depth === 0) {
      return null;
    }
    let path2 = node.data.name;
    const pathList = [path2];
    let ancestorNode = Object.assign({}, node);
    while (ancestorNode.depth > 1) {
      path2 = `${(_a2 = ancestorNode.parent.data) === null || _a2 === void 0 ? void 0 : _a2.name} / ${path2}`;
      pathList.unshift((_b = ancestorNode.parent.data) === null || _b === void 0 ? void 0 : _b.name);
      ancestorNode = ancestorNode.parent;
    }
    const nodeInfo = Object.assign(Object.assign(Object.assign({}, pick_default(node.data, [value2])), { [SUNBURST_PATH_FIELD]: path2, [SUNBURST_ANCESTOR_FIELD]: ancestorNode.data.name }), node);
    if (color2 && color2 !== SUNBURST_ANCESTOR_FIELD) {
      nodeInfo[color2] = node.data[color2] || ((_d = (_c = node.parent) === null || _c === void 0 ? void 0 : _c.data) === null || _d === void 0 ? void 0 : _d[color2]);
    }
    result2.push(nodeInfo);
  });
  return result2.map((d2) => Object.assign(Object.assign({}, d2), { x: d2.x.slice(0, 2), y: [d2.y[2], d2.y[0]], fillOpacity: Math.pow(0.85, d2.depth) }));
}
var DEFAULT_OPTIONS7 = {
  id: SUNBURST_TYPE,
  encode: {
    x: "x",
    y: "y",
    key: SUNBURST_PATH_FIELD,
    color: SUNBURST_ANCESTOR_FIELD,
    value: "value"
  },
  axis: { x: false, y: false },
  style: {
    [SUNBURST_TYPE_FIELD]: SUNBURST_TYPE,
    stroke: "#fff",
    lineWidth: 0.5,
    fillOpacity: "fillOpacity",
    [CHILD_NODE_COUNT]: CHILD_NODE_COUNT,
    depth: "depth"
  },
  state: {
    active: { zIndex: 2, stroke: "#000" },
    inactive: { zIndex: 1, stroke: "#fff" }
  },
  legend: false,
  interaction: { drillDown: true },
  coordinate: {
    type: "polar",
    innerRadius: 0.2
  }
};
var Sunburst = (options) => {
  const { encode: encodeOption, data: data2 = [], legend } = options, resOptions = __rest89(options, ["encode", "data", "legend"]);
  const coordinate2 = Object.assign(Object.assign({}, resOptions.coordinate), {
    // Reac Bug InnerRadius = 0.
    innerRadius: Math.max(get_default(resOptions, ["coordinate", "innerRadius"], 0.2), 1e-5)
  });
  const encode = Object.assign(Object.assign({}, DEFAULT_OPTIONS7.encode), encodeOption);
  const { value: value2 } = encode;
  const rectData = transformData({ encode, data: data2 });
  return [
    deep_mix_default({}, DEFAULT_OPTIONS7, Object.assign(Object.assign({ type: "rect", data: rectData, encode, tooltip: {
      title: "path",
      items: [
        (d2) => {
          return {
            name: value2,
            value: d2[value2]
          };
        }
      ]
    } }, resOptions), { coordinate: coordinate2 }))
  ];
};
Sunburst.props = {};

// node_modules/@antv/g2-extension-plot/esm/interaction/drillDown.js
var __awaiter14 = function(thisArg, _arguments, P, generator) {
  function adopt(value2) {
    return value2 instanceof P ? value2 : new P(function(resolve) {
      resolve(value2);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject2) {
    function fulfilled(value2) {
      try {
        step2(generator.next(value2));
      } catch (e) {
        reject2(e);
      }
    }
    function rejected(value2) {
      try {
        step2(generator["throw"](value2));
      } catch (e) {
        reject2(e);
      }
    }
    function step2(result2) {
      result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
    }
    step2((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var getElementsSunburst = (plot2) => {
  return plot2.querySelectorAll(".element").filter((item) => get_default(item, ["style", SUNBURST_TYPE_FIELD]) === SUNBURST_TYPE);
};
function selectPlotArea2(root3) {
  return select(root3).select(`.${PLOT_CLASS_NAME}`).node();
}
var DEFAULT_BREADCRUMB = {
  rootText: "root",
  style: {
    fill: "rgba(0, 0, 0, 0.85)",
    fontSize: 12,
    y: 1
  },
  active: {
    fill: "rgba(0, 0, 0, 0.5)"
  }
};
function DrillDown(drillDownOptions = {}) {
  const { breadCrumb: textConfig = {}, fixedColor = true } = drillDownOptions;
  const breadCrumb = deep_mix_default({}, DEFAULT_BREADCRUMB, textConfig);
  return (context) => {
    const { update: update3, setState, container, view, options } = context;
    const plotArea = selectPlotArea2(container);
    const sunburstMark = options.marks.find(({ id: id3 }) => id3 === SUNBURST_TYPE);
    const { state } = sunburstMark;
    const textGroup = new Group2();
    plotArea.appendChild(textGroup);
    const drillDownClick = (path2, depth) => __awaiter14(this, void 0, void 0, function* () {
      textGroup.removeChildren();
      if (path2) {
        const rootText = new Text({
          style: Object.assign({
            x: 0,
            text: breadCrumb.rootText,
            // @ts-ignore
            depth: 0
          }, breadCrumb.style)
        });
        textGroup.appendChild(rootText);
        let name2 = "";
        const pathArray = path2 === null || path2 === void 0 ? void 0 : path2.split(" / ");
        let y3 = breadCrumb.style.y;
        let x3 = textGroup.getBBox().width;
        const maxWidth = plotArea.getBBox().width;
        const drillTexts = pathArray.map((text, index3) => {
          const textSeparator = new Text({
            style: Object.assign(Object.assign({ x: x3, text: " / " }, breadCrumb.style), { y: y3 })
          });
          textGroup.appendChild(textSeparator);
          x3 += textSeparator.getBBox().width;
          name2 = `${name2}${text} / `;
          const drillText = new Text({
            name: name2.replace(/\s\/\s$/, ""),
            style: Object.assign(Object.assign({
              text,
              x: x3,
              // @ts-ignore
              depth: index3 + 1
            }, breadCrumb.style), { y: y3 })
          });
          textGroup.appendChild(drillText);
          x3 += drillText.getBBox().width;
          if (x3 > maxWidth) {
            y3 = textGroup.getBBox().height;
            x3 = 0;
            textSeparator.attr({
              x: x3,
              y: y3
            });
            x3 += textSeparator.getBBox().width;
            drillText.attr({
              x: x3,
              y: y3
            });
            x3 += drillText.getBBox().width;
          }
          return drillText;
        });
        [rootText, ...drillTexts].forEach((item, index3) => {
          if (index3 === drillTexts.length)
            return;
          const originalAttrs = Object.assign({}, item.attributes);
          item.attr("cursor", "pointer");
          item.addEventListener("mouseenter", () => {
            item.attr(breadCrumb.active);
          });
          item.addEventListener("mouseleave", () => {
            item.attr(originalAttrs);
          });
          item.addEventListener("click", () => {
            drillDownClick(item.name, get_default(item, ["style", "depth"]));
          });
        });
      }
      setState("drillDown", (viewOptions) => {
        const { marks } = viewOptions;
        const newMarks = marks.map((mark2) => {
          if (mark2.id !== SUNBURST_TYPE && mark2.type !== "rect")
            return mark2;
          const { data: data2 } = mark2;
          const newScale = Object.fromEntries(["color"].map((channel) => [
            channel,
            { domain: view.scale[channel].getOptions().domain }
          ]));
          const newData = data2.filter((item) => {
            const key = item.path;
            if (fixedColor) {
              item[SUNBURST_ANCESTOR_FIELD] = key.split(" / ")[depth];
            }
            if (!path2)
              return true;
            const reg = new RegExp(`^${path2}.+`);
            return reg.test(key);
          });
          return deep_mix_default({}, mark2, fixedColor ? {
            data: newData
          } : {
            data: newData,
            scale: newScale
          });
        });
        return Object.assign(Object.assign({}, viewOptions), { marks: newMarks });
      });
      yield update3();
    });
    const createDrillClick = (e) => {
      const item = e.target;
      if (get_default(item, ["style", SUNBURST_TYPE_FIELD]) !== SUNBURST_TYPE || get_default(item, ["markType"]) !== "rect" || !get_default(item, ["style", CHILD_NODE_COUNT]))
        return;
      const path2 = get_default(item, ["__data__", "key"]);
      const depth = get_default(item, ["style", "depth"]);
      item.style.cursor = "pointer";
      drillDownClick(path2, depth);
    };
    plotArea.addEventListener("click", createDrillClick);
    const changeStyleKey = keys_default(Object.assign(Object.assign({}, state.active), state.inactive));
    const createActive = () => {
      const elements = getElementsSunburst(plotArea);
      elements.forEach((element) => {
        const childNodeCount = get_default(element, ["style", CHILD_NODE_COUNT]);
        const cursor = get_default(element, ["style", "cursor"]);
        if (cursor !== "pointer" && childNodeCount) {
          element.style.cursor = "pointer";
          const originalAttrs = pick_default(element.attributes, changeStyleKey);
          element.addEventListener("mouseenter", () => {
            element.attr(state.active);
          });
          element.addEventListener("mouseleave", () => {
            element.attr(deep_mix_default(originalAttrs, state.inactive));
          });
        }
      });
    };
    plotArea.addEventListener("mousemove", createActive);
    return () => {
      textGroup.remove();
      plotArea.removeEventListener("click", createDrillClick);
      plotArea.removeEventListener("mousemove", createActive);
    };
  };
}

// node_modules/@antv/g2-extension-plot/esm/lib.js
runtime.enableCSSParsing = false;
function plotlib2() {
  return {
    "interaction.drillDown": DrillDown,
    "mark.sunburst": Sunburst
  };
}

// node_modules/@ant-design/plots/es/core/base/chart.js
var __assign4 = function() {
  __assign4 = Object.assign || function(t) {
    for (var s2, i = 1, n = arguments.length; i < n; i++) {
      s2 = arguments[i];
      for (var p2 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p2))
          t[p2] = s2[p2];
    }
    return t;
  };
  return __assign4.apply(this, arguments);
};
var Chart3 = extend4(Runtime, __assign4(__assign4({}, stdlib()), plotlib2()));

// node_modules/@ant-design/plots/es/core/utils/transform.js
var transformOptions = function(params) {
  var options = filterTransformed(params);
  var _a2 = options.children, children = _a2 === void 0 ? [] : _a2;
  var rest2 = omit_default4(options, [].concat(VIEW_OPTIONS, CONFIG_SHAPE.map(function(item) {
    return item.key;
  })));
  var getCustomTransform = function(key) {
    var _a3;
    return (_a3 = SPECIAL_OPTIONS.find(function(option) {
      return option.key === key;
    })) === null || _a3 === void 0 ? void 0 : _a3.callback;
  };
  var updateOptions = function(origin, key, value2) {
    var callback = getCustomTransform(key);
    if (callback) {
      callback(origin, key, value2);
    } else {
      origin[key] = mergeWithArrayCoverage({}, origin[key], value2);
    }
  };
  var transformShape = function(config) {
    Object.keys(config).forEach(function(key) {
      var exist = CONFIG_SHAPE.find(function(item) {
        return item.key === key;
      });
      if (exist) {
        var type = exist.type, extend_keys = exist.extend_keys;
        if (type) {
          children.push(transformConfig(mergeWithArrayCoverage({}, pick_default4(config, extend_keys), { type }, config[key])));
        } else {
          if (isArray_default(config[key])) {
            config[key].forEach(function(annotation) {
              children.push(transformConfig(annotation));
            });
          }
        }
      }
    });
  };
  var transformConfig = function(config) {
    transformShape(config);
    Object.keys(TRANSFORM_OPTION_KEY).forEach(function(key) {
      var transformTarget = TRANSFORM_OPTION_KEY[key];
      if (config[key]) {
        if (isObject_default(transformTarget)) {
          var value2 = transformTarget.value, target = transformTarget.target;
          var transformValue = value2(config[key]);
          updateOptions(config, target, transformValue);
        } else {
          set_default4(config, transformTarget, config[key]);
        }
      }
    });
    return config;
  };
  children.forEach(function(child) {
    var config = mergeWithArrayCoverage({}, rest2, child);
    transformConfig(mergeWithArrayCoverage(child, config));
  });
  transformShape(options);
  deleteExcessKeys(options);
  return params;
};

// node_modules/@ant-design/plots/es/core/utils/delete-excess-keys.js
var __spreadArray6 = function(to, from, pack3) {
  if (pack3 || arguments.length === 2)
    for (var i = 0, l = from.length, ar; i < l; i++) {
      if (ar || !(i in from)) {
        if (!ar)
          ar = Array.prototype.slice.call(from, 0, i);
        ar[i] = from[i];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from));
};
var deleteExcessKeys = function(options) {
  var _a2 = options.children, children = _a2 === void 0 ? [] : _a2;
  var deleteKeys = Object.keys(TRANSFORM_OPTION_KEY).concat(CONFIG_SHAPE.map(function(item) {
    return item.key;
  }), COORDIANTE_OPTIONS);
  deleteKeys.forEach(function(key) {
    delete options[key];
  });
  children.forEach(function(child) {
    Object.keys(child).forEach(function(key) {
      if (deleteKeys.includes(key)) {
        delete child[key];
      }
    });
  });
  Object.keys(options).forEach(function(key) {
    if (!__spreadArray6(__spreadArray6([], VIEW_OPTIONS, true), ANNOTATION_LIST.map(function(item) {
      return item.key;
    }), true).includes(key)) {
      delete options[key];
    }
  });
  return options;
};

// node_modules/@ant-design/plots/es/core/utils/filter-transformed.js
var filterTransformed = function(params) {
  var options = params.options;
  var _a2 = options.children, children = _a2 === void 0 ? [] : _a2;
  children.forEach(function(child) {
    Object.keys(child).forEach(function(key) {
      if (isArray_default(child[key]) && key !== "data") {
        child[key] = child[key].filter(function(item) {
          return !item[TRANSFORM_SIGN];
        });
      }
    });
  });
  return options;
};

// node_modules/@ant-design/plots/es/core/utils/merge-with-array-coverage.js
var __spreadArray7 = function(to, from, pack3) {
  if (pack3 || arguments.length === 2)
    for (var i = 0, l = from.length, ar; i < l; i++) {
      if (ar || !(i in from)) {
        if (!ar)
          ar = Array.prototype.slice.call(from, 0, i);
        ar[i] = from[i];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from));
};
var arrayCoverage = function(objValue, srcValue) {
  if (isArray_default(srcValue)) {
    return srcValue;
  }
};
var mergeWithArrayCoverage = function() {
  var args = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }
  return mergeWith_default.apply(void 0, __spreadArray7(__spreadArray7([], args, false), [arrayCoverage], false));
};

// node_modules/@ant-design/plots/es/core/constants/index.js
var __assign5 = function() {
  __assign5 = Object.assign || function(t) {
    for (var s2, i = 1, n = arguments.length; i < n; i++) {
      s2 = arguments[i];
      for (var p2 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p2))
          t[p2] = s2[p2];
    }
    return t;
  };
  return __assign5.apply(this, arguments);
};
var __rest90 = function(s2, e) {
  var t = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
      t[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t[p2[i]] = s2[p2[i]];
    }
  return t;
};
var CHART_OPTIONS = ["renderer"];
var VIEW_OPTIONS = [
  "width",
  "height",
  "autoFit",
  "theme",
  "inset",
  "insetLeft",
  "insetRight",
  "insetTop",
  "insetBottom",
  "padding",
  "paddingTop",
  "paddingRight",
  "paddingBottom",
  "paddingLeft",
  "margin",
  "marginTop",
  "marginRight",
  "marginBottom",
  "marginLeft",
  "depth",
  "title",
  "clip",
  "children",
  "type",
  "data",
  "direction"
];
var TRANSFORM_SIGN = "__transform__";
var SKIP_DEL_CUSTOM_SIGN = "__skipDelCustomKeys__";
var commonCallback = function(type, value2) {
  if (isBoolean_default(value2)) {
    return {
      type,
      available: value2
    };
  }
  return __assign5({ type }, value2);
};
var TRANSFORM_OPTION_KEY = {
  /** encode */
  xField: "encode.x",
  yField: "encode.y",
  colorField: "encode.color",
  angleField: "encode.y",
  keyField: "encode.key",
  sizeField: "encode.size",
  shapeField: "encode.shape",
  seriesField: "encode.series",
  positionField: "encode.position",
  textField: "encode.text",
  valueField: "encode.value",
  binField: "encode.x",
  srcField: "encode.src",
  /**
   * @title 
   * @example
   *  1. stack: true -> transform: [{type: 'stackY'}]
   */
  stack: {
    target: "transform",
    value: function(value2) {
      return commonCallback("stackY", value2);
    }
  },
  /**
   * @title 
   * @example
   *  1. normalize: true -> transform: [{type: 'normalizeY'}]
   */
  normalize: {
    target: "transform",
    value: function(value2) {
      return commonCallback("normalizeY", value2);
    }
  },
  /**
   * @title 
   * @description  normalize
   * @example
   *  1. percent: true -> transform: [{type: 'normalizeY'}]
   */
  percent: {
    target: "transform",
    value: function(value2) {
      return commonCallback("normalizeY", value2);
    }
  },
  /**
   * @title 
   * @example
   *  1. group: true -> transform: [{type: 'dodgeX'}]
   */
  group: {
    target: "transform",
    value: function(value2) {
      return commonCallback("dodgeX", value2);
    }
  },
  /**
   * @title 
   * @example
   *  1. sort: true -> transform: [{type: 'sortX'}]
   */
  sort: {
    target: "transform",
    value: function(value2) {
      return commonCallback("sortX", value2);
    }
  },
  /**
   * @title 
   * @example
   *  1. symmetry: true -> transform: [{type: 'symmetryY'}]
   */
  symmetry: {
    target: "transform",
    value: function(value2) {
      return commonCallback("symmetryY", value2);
    }
  },
  /**
   * @title  y  y1 
   * @example
   *  1. diff: true -> transform: [{type: 'diffY'}]
   */
  diff: {
    target: "transform",
    value: function(value2) {
      return commonCallback("diffY", value2);
    }
  },
  meta: {
    target: "scale",
    value: function(value2) {
      return value2;
    }
  },
  label: {
    target: "labels",
    value: function(value2) {
      return value2;
    }
  },
  /**
   * @title 
   * @example
   *  1. shape: 'smooth' -> style: {shape: 'smooth'}
   */
  shape: "style.shape",
  /**
   * @title 
   * @description  boolean  
   */
  connectNulls: {
    target: "style",
    value: function(value2) {
      if (isBoolean_default(value2)) {
        return {
          connect: value2
        };
      }
      return value2;
    }
  }
};
var EXTEND_KEYS = [
  "xField",
  "yField",
  "seriesField",
  "colorField",
  "keyField",
  "positionField",
  "meta",
  "tooltip",
  "animate",
  "stack",
  "normalize",
  "percent",
  "group",
  "sort",
  "symmetry",
  "diff"
];
var CONFIG_SHAPE = [
  {
    key: "annotations",
    extend_keys: []
  },
  {
    key: "line",
    type: "line",
    extend_keys: EXTEND_KEYS
  },
  {
    key: "point",
    type: "point",
    extend_keys: EXTEND_KEYS
  },
  {
    key: "area",
    type: "area",
    extend_keys: EXTEND_KEYS
  }
];
var COORDIANTE_OPTIONS = [
  "radius",
  "innerRadius",
  "startAngle",
  "endAngle",
  "focusX",
  "focusY",
  "distortionX",
  "distortionY",
  "visual"
];
var SPECIAL_OPTIONS = [
  {
    key: "transform",
    callback: function(origin, key, value2) {
      var _a2;
      origin[key] = origin[key] || [];
      var _b = value2.available, available = _b === void 0 ? true : _b, rest2 = __rest90(value2, ["available"]);
      if (available) {
        origin[key].push(__assign5((_a2 = {}, _a2[TRANSFORM_SIGN] = true, _a2), rest2));
      } else {
        origin[key].splice(origin[key].indexOf(function(item) {
          return item.type === value2.type;
        }), 1);
      }
    }
  },
  {
    key: "labels",
    callback: function(origin, key, value2) {
      var _a2;
      if (!value2 || isArray_default(value2)) {
        origin[key] = value2 ? value2 : [];
        return;
      }
      if (!value2.text) {
        value2["text"] = origin["yField"];
      }
      origin[key] = origin[key] || [];
      origin[key].push(__assign5((_a2 = {}, _a2[TRANSFORM_SIGN] = true, _a2), value2));
    }
  }
];
var ANNOTATION_LIST = [
  {
    key: "conversionTag",
    shape: "ConversionTag"
  },
  {
    key: "axisText",
    shape: "BidirectionalBarAxisText"
  }
];

// node_modules/@ant-design/plots/es/core/annotation/shapes/Text.js
var __extends3 = function() {
  var extendStatics2 = function(d2, b) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b2) {
      d3.__proto__ = b2;
    } || function(d3, b2) {
      for (var p2 in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p2))
          d3[p2] = b2[p2];
    };
    return extendStatics2(d2, b);
  };
  return function(d2, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics2(d2, b);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var __assign6 = function() {
  __assign6 = Object.assign || function(t) {
    for (var s2, i = 1, n = arguments.length; i < n; i++) {
      s2 = arguments[i];
      for (var p2 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p2))
          t[p2] = s2[p2];
    }
    return t;
  };
  return __assign6.apply(this, arguments);
};
var __rest91 = function(s2, e) {
  var t = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
      t[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t[p2[i]] = s2[p2[i]];
    }
  return t;
};
var Text5 = (
  /** @class */
  function(_super) {
    __extends3(Text6, _super);
    function Text6(_a2) {
      if (_a2 === void 0) {
        _a2 = {};
      }
      var style = _a2.style, restOptions = __rest91(_a2, ["style"]);
      return _super.call(this, __assign6({ style: __assign6({ text: "", fontSize: 12, textBaseline: "middle", textAlign: "center", fill: "#000", fontStyle: "normal", fontVariant: "normal", fontWeight: "normal", lineWidth: 1 }, style) }, restOptions)) || this;
    }
    return Text6;
  }(Text)
);

// node_modules/@ant-design/plots/es/core/annotation/shapes/Polygon.js
var __extends4 = function() {
  var extendStatics2 = function(d2, b) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b2) {
      d3.__proto__ = b2;
    } || function(d3, b2) {
      for (var p2 in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p2))
          d3[p2] = b2[p2];
    };
    return extendStatics2(d2, b);
  };
  return function(d2, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics2(d2, b);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var __assign7 = function() {
  __assign7 = Object.assign || function(t) {
    for (var s2, i = 1, n = arguments.length; i < n; i++) {
      s2 = arguments[i];
      for (var p2 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p2))
          t[p2] = s2[p2];
    }
    return t;
  };
  return __assign7.apply(this, arguments);
};
var __rest92 = function(s2, e) {
  var t = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
      t[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t[p2[i]] = s2[p2[i]];
    }
  return t;
};
var Polygon4 = (
  /** @class */
  function(_super) {
    __extends4(Polygon5, _super);
    function Polygon5(_a2) {
      if (_a2 === void 0) {
        _a2 = {};
      }
      var style = _a2.style, restOptions = __rest92(_a2, ["style"]);
      return _super.call(this, __assign7({ style: __assign7({ fill: "#eee" }, style) }, restOptions)) || this;
    }
    return Polygon5;
  }(Polygon)
);

// node_modules/@ant-design/plots/es/core/annotation/core.js
var __extends5 = function() {
  var extendStatics2 = function(d2, b) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b2) {
      d3.__proto__ = b2;
    } || function(d3, b2) {
      for (var p2 in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p2))
          d3[p2] = b2[p2];
    };
    return extendStatics2(d2, b);
  };
  return function(d2, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics2(d2, b);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var Annotaion = (
  /** @class */
  function(_super) {
    __extends5(Annotaion3, _super);
    function Annotaion3(chart, config, defaultOptions) {
      var _this2 = _super.call(this, { style: mergeWithArrayCoverage(defaultOptions, config) }) || this;
      _this2.chart = chart;
      return _this2;
    }
    Annotaion3.prototype.connectedCallback = function() {
      this.render(this.attributes, this);
      this.bindEvents(this.attributes, this);
    };
    Annotaion3.prototype.disconnectedCallback = function() {
    };
    Annotaion3.prototype.attributeChangedCallback = function(name2) {
    };
    Annotaion3.prototype.update = function(attr2, animate2) {
      var _a2;
      this.attr(mergeWithArrayCoverage({}, this.attributes, attr2 || {}));
      return (_a2 = this.render) === null || _a2 === void 0 ? void 0 : _a2.call(this, this.attributes, this, animate2);
    };
    Annotaion3.prototype.clear = function() {
      this.removeChildren();
    };
    Annotaion3.prototype.getElementsLayout = function() {
      var canvas = this.chart.getContext().canvas;
      var elements = canvas.document.getElementsByClassName("element");
      var elementsLayout = [];
      elements.forEach(function(element) {
        var bbox = element.getBBox();
        var x3 = bbox.x, y3 = bbox.y, width = bbox.width, height = bbox.height;
        var data2 = element["__data__"];
        elementsLayout.push({
          bbox,
          x: x3,
          y: y3,
          width,
          height,
          key: data2.key,
          data: data2
        });
      });
      return elementsLayout;
    };
    Annotaion3.prototype.bindEvents = function(attributes, container) {
    };
    return Annotaion3;
  }(CustomElement)
);

// node_modules/@ant-design/plots/es/core/annotation/conversion-tag.js
var __extends6 = function() {
  var extendStatics2 = function(d2, b) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b2) {
      d3.__proto__ = b2;
    } || function(d3, b2) {
      for (var p2 in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p2))
          d3[p2] = b2[p2];
    };
    return extendStatics2(d2, b);
  };
  return function(d2, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics2(d2, b);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var __assign8 = function() {
  __assign8 = Object.assign || function(t) {
    for (var s2, i = 1, n = arguments.length; i < n; i++) {
      s2 = arguments[i];
      for (var p2 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p2))
          t[p2] = s2[p2];
    }
    return t;
  };
  return __assign8.apply(this, arguments);
};
var ConversionTag = (
  /** @class */
  function(_super) {
    __extends6(ConversionTag2, _super);
    function ConversionTag2(chart, options) {
      return _super.call(this, chart, options, { type: ConversionTag2.tag }) || this;
    }
    ConversionTag2.prototype.getConversionTagLayout = function() {
      var isVertical2 = this.direction === "vertical";
      var elementsLayout = this.getElementsLayout();
      var _a2 = elementsLayout[0], firstX = _a2.x, firstY = _a2.y, firstHeigt = _a2.height, firstWidth = _a2.width, firstData = _a2.data;
      var valuePath = ["items", 0, "value"];
      var preValue = get_default4(firstData, valuePath);
      var elementDistance = isVertical2 ? elementsLayout[1].y - firstY - firstHeigt : elementsLayout[1].x - firstX - firstWidth;
      var tagLayout = [];
      var _b = this.attributes, _c = _b.size, size5 = _c === void 0 ? 40 : _c, _d = _b.arrowSize, arrowSize = _d === void 0 ? 20 : _d, _e = _b.spacing, spacing = _e === void 0 ? 4 : _e;
      elementsLayout.forEach(function(element, index3) {
        if (index3 > 0) {
          var x3 = element.x, y3 = element.y, height = element.height, width = element.width, data2 = element.data, key = element.key;
          var currentValue = get_default4(data2, valuePath);
          var halfSize = size5 / 2;
          if (isVertical2) {
            var arrowVertexX = x3 + width / 2;
            var arrowVertexY = y3;
            tagLayout.push({
              points: [
                [arrowVertexX + halfSize, arrowVertexY - elementDistance + spacing],
                [arrowVertexX + halfSize, arrowVertexY - arrowSize - spacing],
                [arrowVertexX, arrowVertexY - spacing],
                [arrowVertexX - halfSize, arrowVertexY - arrowSize - spacing],
                [arrowVertexX - halfSize, arrowVertexY - elementDistance + spacing]
              ],
              center: [arrowVertexX, arrowVertexY - elementDistance / 2 - spacing],
              width: elementDistance,
              value: [preValue, currentValue],
              key
            });
          } else {
            var arrowVertexX = x3;
            var arrowVertexY = y3 + height / 2;
            tagLayout.push({
              points: [
                [x3 - elementDistance + spacing, arrowVertexY - halfSize],
                [x3 - arrowSize - spacing, arrowVertexY - halfSize],
                [arrowVertexX - spacing, arrowVertexY],
                [x3 - arrowSize - spacing, arrowVertexY + halfSize],
                [x3 - elementDistance + spacing, arrowVertexY + halfSize]
              ],
              center: [arrowVertexX - elementDistance / 2 - spacing, arrowVertexY],
              width: elementDistance,
              value: [preValue, currentValue],
              key
            });
          }
          preValue = currentValue;
        }
      });
      return tagLayout;
    };
    ConversionTag2.prototype.render = function() {
      this.setDirection();
      this.drawConversionTag();
    };
    ConversionTag2.prototype.setDirection = function() {
      var coordinate2 = this.chart.getCoordinate();
      var transformations = get_default4(coordinate2, "options.transformations");
      var direction3 = "horizontal";
      transformations.forEach(function(transformation) {
        if (transformation.includes("transpose")) {
          direction3 = "vertical";
        }
      });
      this.direction = direction3;
    };
    ConversionTag2.prototype.drawConversionTag = function() {
      var _this2 = this;
      var conversionLayout = this.getConversionTagLayout();
      var _a2 = this.attributes, style = _a2.style, _b = _a2.text, textStyle = _b.style, formatter2 = _b.formatter;
      conversionLayout.forEach(function(layout) {
        var points = layout.points, center2 = layout.center, value2 = layout.value, key = layout.key;
        var prev = value2[0], next = value2[1];
        var x3 = center2[0], y3 = center2[1];
        var polygon = new Polygon4({
          style: __assign8({ points, fill: "#eee" }, style),
          id: "polygon-".concat(key)
        });
        var text = new Text5({
          style: __assign8({ x: x3, y: y3, text: isFunction_default(formatter2) ? formatter2(prev, next) : (next / prev * 100).toFixed(2) + "%" }, textStyle),
          id: "text-".concat(key)
        });
        _this2.appendChild(polygon);
        _this2.appendChild(text);
      });
    };
    ConversionTag2.prototype.update = function() {
      var _this2 = this;
      var conversionLayout = this.getConversionTagLayout();
      conversionLayout.forEach(function(layout) {
        var points = layout.points, center2 = layout.center, key = layout.key;
        var x3 = center2[0], y3 = center2[1];
        var polygon = _this2.getElementById("polygon-".concat(key));
        var text = _this2.getElementById("text-".concat(key));
        polygon.setAttribute("points", points);
        text.setAttribute("x", x3);
        text.setAttribute("y", y3);
      });
    };
    ConversionTag2.tag = "ConversionTag";
    return ConversionTag2;
  }(Annotaion)
);

// node_modules/@ant-design/plots/es/core/plots/bidirectional-bar/constants.js
var VERTICAL_MARGIN = 32;
var HORIZONTAL_MARGIN = 16;
var AXIS_LABEL_PADDING = 48;

// node_modules/@ant-design/plots/es/core/annotation/bidirectional-bar-axis-text.js
var __extends7 = function() {
  var extendStatics2 = function(d2, b) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b2) {
      d3.__proto__ = b2;
    } || function(d3, b2) {
      for (var p2 in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p2))
          d3[p2] = b2[p2];
    };
    return extendStatics2(d2, b);
  };
  return function(d2, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics2(d2, b);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var __assign9 = function() {
  __assign9 = Object.assign || function(t) {
    for (var s2, i = 1, n = arguments.length; i < n; i++) {
      s2 = arguments[i];
      for (var p2 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p2))
          t[p2] = s2[p2];
    }
    return t;
  };
  return __assign9.apply(this, arguments);
};
var __rest93 = function(s2, e) {
  var t = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
      t[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t[p2[i]] = s2[p2[i]];
    }
  return t;
};
var BidirectionalBarAxisText = (
  /** @class */
  function(_super) {
    __extends7(BidirectionalBarAxisText2, _super);
    function BidirectionalBarAxisText2(chart, options) {
      return _super.call(this, chart, options, { type: BidirectionalBarAxisText2.tag }) || this;
    }
    BidirectionalBarAxisText2.prototype.render = function() {
      this.drawText();
    };
    BidirectionalBarAxisText2.prototype.getBidirectionalBarAxisTextLayout = function() {
      var layout = this.attributes.layout;
      var isVertical2 = layout === "vertical";
      var allElementsLayout = this.getElementsLayout();
      var elementsLayout = isVertical2 ? uniqBy_default(allElementsLayout, "x") : uniqBy_default(allElementsLayout, "y");
      var textPath = ["title"];
      var textLayout = [];
      var views = this.chart.getContext().views;
      var _a2 = get_default4(views, [0, "layout"]), viewWidth = _a2.width, viewHeight = _a2.height;
      elementsLayout.forEach(function(element) {
        var x3 = element.x, y3 = element.y, height = element.height, width = element.width, data2 = element.data, key = element.key;
        var text = get_default4(data2, textPath);
        if (isVertical2) {
          textLayout.push({
            x: x3 + width / 2,
            y: viewHeight,
            text,
            key
          });
        } else {
          textLayout.push({
            x: viewWidth,
            y: y3 + height / 2,
            text,
            key
          });
        }
      });
      if (uniqBy_default(textLayout, "text").length !== textLayout.length) {
        textLayout = Object.values(groupBy_default(textLayout, "text")).map(function(items) {
          var _a3;
          var sum5 = items.reduce(function(pre, cur) {
            return pre + (isVertical2 ? cur.x : cur.y);
          }, 0);
          return __assign9(__assign9({}, items[0]), (_a3 = {}, _a3[isVertical2 ? "x" : "y"] = sum5 / items.length, _a3));
        });
      }
      return textLayout;
    };
    BidirectionalBarAxisText2.prototype.transformLabelStyle = function(style) {
      var removeLabel = {};
      var reg = /^label[A-Z]/;
      Object.keys(style).forEach(function(key) {
        if (reg.test(key)) {
          removeLabel[key.replace("label", "").replace(/^[A-Z]/, function(match) {
            return match.toLowerCase();
          })] = style[key];
        }
      });
      return removeLabel;
    };
    BidirectionalBarAxisText2.prototype.drawText = function() {
      var _this2 = this;
      var axisLayout = this.getBidirectionalBarAxisTextLayout();
      var _a2 = this.attributes, viewLayout = _a2.layout, labelFormatter2 = _a2.labelFormatter, textStyle = __rest93(_a2, ["layout", "labelFormatter"]);
      axisLayout.forEach(function(layout) {
        var x3 = layout.x, y3 = layout.y, text = layout.text, key = layout.key;
        var textNode = new Text5({
          style: __assign9({ x: x3, y: y3, text: isFunction_default(labelFormatter2) ? labelFormatter2(text) : text, wordWrap: true, wordWrapWidth: viewLayout === "horizontal" ? VERTICAL_MARGIN * 2 : 120, maxLines: 2, textOverflow: "ellipsis" }, _this2.transformLabelStyle(textStyle)),
          id: "text-".concat(key)
        });
        _this2.appendChild(textNode);
      });
    };
    BidirectionalBarAxisText2.prototype.update = function() {
      var _this2 = this;
      var axisLayout = this.getBidirectionalBarAxisTextLayout();
      axisLayout.forEach(function(layout) {
        var x3 = layout.x, y3 = layout.y, key = layout.key;
        var text = _this2.getElementById("text-".concat(key));
        text.setAttribute("x", x3);
        text.setAttribute("y", y3);
      });
    };
    BidirectionalBarAxisText2.tag = "BidirectionalBarAxisText";
    return BidirectionalBarAxisText2;
  }(Annotaion)
);

// node_modules/@ant-design/plots/es/core/annotation/index.js
var Annotaion2 = { ConversionTag, BidirectionalBarAxisText };
var Controller2 = (
  /** @class */
  function() {
    function Controller3(chart, config) {
      this.container = /* @__PURE__ */ new Map();
      this.chart = chart;
      this.config = config;
      this.init();
    }
    Controller3.prototype.init = function() {
      var _this2 = this;
      ANNOTATION_LIST.forEach(function(annotation) {
        var _a2;
        var key = annotation.key, shape23 = annotation.shape;
        var annotationOptions = _this2.config[key];
        if (annotationOptions) {
          var annotationInstance = new Annotaion2[shape23](_this2.chart, annotationOptions);
          var canvas = _this2.chart.getContext().canvas;
          canvas.appendChild(annotationInstance);
          _this2.container.set(key, annotationInstance);
        } else {
          (_a2 = _this2.container.get(key)) === null || _a2 === void 0 ? void 0 : _a2.clear();
        }
      });
    };
    Controller3.prototype.update = function() {
      var _this2 = this;
      if (!this.container.size)
        return;
      ANNOTATION_LIST.forEach(function(annotation) {
        var key = annotation.key;
        var annotationInstance = _this2.container.get(key);
        annotationInstance === null || annotationInstance === void 0 ? void 0 : annotationInstance.update();
      });
    };
    return Controller3;
  }()
);

// node_modules/@ant-design/plots/es/core/base/index.js
var __extends8 = function() {
  var extendStatics2 = function(d2, b) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b2) {
      d3.__proto__ = b2;
    } || function(d3, b2) {
      for (var p2 in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p2))
          d3[p2] = b2[p2];
    };
    return extendStatics2(d2, b);
  };
  return function(d2, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics2(d2, b);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var __assign10 = function() {
  __assign10 = Object.assign || function(t) {
    for (var s2, i = 1, n = arguments.length; i < n; i++) {
      s2 = arguments[i];
      for (var p2 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p2))
          t[p2] = s2[p2];
    }
    return t;
  };
  return __assign10.apply(this, arguments);
};
var SOURCE_ATTRIBUTE_NAME = "data-chart-source-type";
var Plot = (
  /** @class */
  function(_super) {
    __extends8(Plot2, _super);
    function Plot2(container, options) {
      var _this2 = _super.call(this) || this;
      _this2.container = typeof container === "string" ? document.getElementById(container) : container;
      _this2.options = mergeWithArrayCoverage({}, _this2.getBaseOptions(), _this2.getDefaultOptions(), options);
      _this2.createG2();
      _this2.bindEvents();
      return _this2;
    }
    Plot2.prototype.getChartOptions = function() {
      return __assign10(__assign10({}, pick_default4(this.options, CHART_OPTIONS)), { container: this.container });
    };
    Plot2.prototype.getSpecOptions = function() {
      if (this.type === "base" || this[SKIP_DEL_CUSTOM_SIGN]) {
        return __assign10(__assign10({}, this.options), this.getChartOptions());
      }
      return this.options;
    };
    Plot2.prototype.createG2 = function() {
      if (!this.container) {
        throw Error("The container is not initialized!");
      }
      this.chart = new Chart3(this.getChartOptions());
      this.container.setAttribute(SOURCE_ATTRIBUTE_NAME, "Ant Design Charts");
    };
    Plot2.prototype.bindEvents = function() {
      var _this2 = this;
      if (this.chart) {
        this.chart.on("*", function(e) {
          if (e === null || e === void 0 ? void 0 : e.type) {
            _this2.emit(e.type, e);
          }
        });
      }
    };
    Plot2.prototype.getBaseOptions = function() {
      return { type: "view", autoFit: true };
    };
    Plot2.prototype.getDefaultOptions = function() {
    };
    Plot2.prototype.render = function() {
      var _this2 = this;
      if (this.type !== "base") {
        this.execAdaptor();
      }
      this.chart.options(this.getSpecOptions());
      this.chart.render().then(function() {
        _this2.annotation = new Controller2(_this2.chart, _this2.options);
      });
      this.bindSizeSensor();
    };
    Plot2.prototype.update = function(options) {
      this.updateOption(options);
    };
    Plot2.prototype.updateOption = function(options) {
      this.options = mergeWithArrayCoverage({}, this.options, options);
    };
    Plot2.prototype.changeData = function(data2) {
      this.chart.changeData(data2);
    };
    Plot2.prototype.changeSize = function(width, height) {
      this.chart.changeSize(width, height);
    };
    Plot2.prototype.destroy = function() {
      this.chart.destroy();
      this.off();
      this.container.removeAttribute(SOURCE_ATTRIBUTE_NAME);
    };
    Plot2.prototype.execAdaptor = function() {
      var adaptor33 = this.getSchemaAdaptor();
      adaptor33({
        chart: this.chart,
        options: this.options
      });
    };
    Plot2.prototype.triggerResize = function() {
      this.chart.forceFit();
    };
    Plot2.prototype.bindSizeSensor = function() {
      var _this2 = this;
      var _a2 = this.options.autoFit, autoFit = _a2 === void 0 ? true : _a2;
      if (autoFit) {
        this.chart.on(ChartEvent.AFTER_CHANGE_SIZE, function() {
          _this2.annotation.update();
        });
      }
    };
    return Plot2;
  }(esm_default)
);

// node_modules/@ant-design/plots/es/core/plots/base/index.js
var __extends9 = function() {
  var extendStatics2 = function(d2, b) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b2) {
      d3.__proto__ = b2;
    } || function(d3, b2) {
      for (var p2 in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p2))
          d3[p2] = b2[p2];
    };
    return extendStatics2(d2, b);
  };
  return function(d2, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics2(d2, b);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var Base2 = (
  /** @class */
  function(_super) {
    __extends9(Base3, _super);
    function Base3() {
      var _this2 = _super !== null && _super.apply(this, arguments) || this;
      _this2.type = "base";
      return _this2;
    }
    Base3.getDefaultOptions = function() {
      return {
        type: "view",
        children: [{ type: "line" }]
      };
    };
    Base3.prototype.getDefaultOptions = function() {
      return Base3.getDefaultOptions();
    };
    Base3.prototype.getSchemaAdaptor = function() {
      return function(params) {
        return params;
      };
    };
    return Base3;
  }(Plot)
);

// node_modules/@ant-design/plots/es/core/adaptor/shape-stack.js
var __assign11 = function() {
  __assign11 = Object.assign || function(t) {
    for (var s2, i = 1, n = arguments.length; i < n; i++) {
      s2 = arguments[i];
      for (var p2 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p2))
          t[p2] = s2[p2];
    }
    return t;
  };
  return __assign11.apply(this, arguments);
};
function shapeStack(params) {
  var options = params.options;
  var stack = options.stack, tooltip2 = options.tooltip, xField = options.xField;
  if (!stack)
    return params;
  var shapes = CONFIG_SHAPE.map(function(item) {
    return item.type;
  }).filter(function(item) {
    return !!item;
  });
  var hasStack = false;
  shapes.forEach(function(shape23) {
    if (options[shape23]) {
      hasStack = true;
      set_default4(options, [shape23, "stack"], __assign11({ y1: "y" }, typeof stack === "object" ? stack : {}));
    }
  });
  if (hasStack && !isBoolean_default(tooltip2) && !tooltip2) {
    set_default4(options, "tooltip", {
      title: xField,
      items: [
        {
          channel: "y"
        }
      ]
    });
  }
  return params;
}

// node_modules/@ant-design/plots/es/core/adaptor/mark.js
function mark(params) {
  return flow_default(shapeStack)(params);
}

// node_modules/@ant-design/plots/es/core/adaptor/coordinate.js
var __assign12 = function() {
  __assign12 = Object.assign || function(t) {
    for (var s2, i = 1, n = arguments.length; i < n; i++) {
      s2 = arguments[i];
      for (var p2 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p2))
          t[p2] = s2[p2];
    }
    return t;
  };
  return __assign12.apply(this, arguments);
};
function coordinate(params) {
  var options = params.options;
  var _a2 = options.coordinate, coordinate2 = _a2 === void 0 ? {} : _a2;
  set_default4(params, ["options", "coordinate"], __assign12(__assign12(__assign12({}, coordinate2), pick_default4(options, COORDIANTE_OPTIONS)), { outerRadius: get_default4(options, "radius") }));
  return params;
}

// node_modules/@ant-design/plots/es/core/adaptor/coordinate-layout.js
function coordinateLayout(params) {
  var _a2 = params.options.layout, layout = _a2 === void 0 ? "horizontal" : _a2;
  params.options.coordinate.transform = layout !== "horizontal" ? void 0 : [{ type: "transpose" }];
  return params;
}
function allCoordinateLayout(params) {
  coordinateLayout(params);
  var _a2 = params.options.layout, layout = _a2 === void 0 ? "horizontal" : _a2;
  params.options.children.forEach(function(item) {
    var _a3;
    if ((_a3 = item === null || item === void 0 ? void 0 : item.coordinate) === null || _a3 === void 0 ? void 0 : _a3.transform) {
      item.coordinate.transform = layout !== "horizontal" ? void 0 : [{ type: "transpose" }];
    }
  });
  return params;
}

// node_modules/@ant-design/plots/es/core/plots/area/adaptor.js
function adaptor2(params) {
  return flow_default(mark, transformOptions)(params);
}

// node_modules/@ant-design/plots/es/core/plots/area/index.js
var __extends10 = function() {
  var extendStatics2 = function(d2, b) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b2) {
      d3.__proto__ = b2;
    } || function(d3, b2) {
      for (var p2 in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p2))
          d3[p2] = b2[p2];
    };
    return extendStatics2(d2, b);
  };
  return function(d2, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics2(d2, b);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var Area3 = (
  /** @class */
  function(_super) {
    __extends10(Area4, _super);
    function Area4() {
      var _this2 = _super !== null && _super.apply(this, arguments) || this;
      _this2.type = "area";
      return _this2;
    }
    Area4.getDefaultOptions = function() {
      return {
        type: "view",
        children: [{ type: "area" }],
        scale: {
          y: { nice: true }
        },
        axis: {
          y: { title: false },
          x: { title: false }
        },
        interaction: {
          tooltip: {
            shared: true
          }
        }
      };
    };
    Area4.prototype.getDefaultOptions = function() {
      return Area4.getDefaultOptions();
    };
    Area4.prototype.getSchemaAdaptor = function() {
      return adaptor2;
    };
    return Area4;
  }(Plot)
);

// node_modules/@ant-design/plots/es/core/plots/bar/adaptor.js
var __assign13 = function() {
  __assign13 = Object.assign || function(t) {
    for (var s2, i = 1, n = arguments.length; i < n; i++) {
      s2 = arguments[i];
      for (var p2 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p2))
          t[p2] = s2[p2];
    }
    return t;
  };
  return __assign13.apply(this, arguments);
};
function adaptor3(params) {
  var background = function(params2) {
    var options = params2.options;
    if (get_default4(options, "children.length") > 1) {
      set_default4(options, "children", [{ type: "interval" }]);
    }
    var scale10 = options.scale, markBackground = options.markBackground, data2 = options.data, children = options.children;
    var domain = get_default4(scale10, "y.domain", []);
    if (markBackground && domain.length && isArray_default(data2)) {
      var domainMax_1 = "domainMax";
      var backgroundData = data2.map(function(item) {
        var _a2;
        return __assign13(__assign13({}, item), (_a2 = {}, _a2[domainMax_1] = domain[domain.length - 1], _a2));
      });
      children.unshift(__assign13({ type: "interval", data: backgroundData, yField: domainMax_1, tooltip: false, legend: false, style: {
        fill: "#eee"
      }, label: false }, markBackground));
    }
    return params2;
  };
  return flow_default(background, mark, transformOptions)(params);
}

// node_modules/@ant-design/plots/es/core/plots/bar/shape.js
var reisterShape = function() {
  var draw25DBar = function(style, context) {
    return function(points) {
      var _a2 = style.fill, fill2 = _a2 === void 0 ? "#2888FF" : _a2, stroke2 = style.stroke, _b = style.fillOpacity, fillOpacity = _b === void 0 ? 1 : _b, _c = style.strokeOpacity, strokeOpacity = _c === void 0 ? 0.2 : _c, _d = style.pitch, pitch = _d === void 0 ? 8 : _d;
      var p1 = points[0], p2 = points[1], p3 = points[2], p4 = points[3];
      var height = (p2[1] - p1[1]) / 2;
      var document2 = context.document;
      var g = document2.createElement("g", {});
      var top = document2.createElement("polygon", {
        style: {
          points: [p1, [p1[0] - pitch, p1[1] + height], [p3[0] - pitch, p1[1] + height], p4],
          fill: fill2,
          fillOpacity,
          stroke: stroke2,
          strokeOpacity,
          inset: 30
        }
      });
      var bottom = document2.createElement("polygon", {
        style: {
          points: [[p1[0] - pitch, p1[1] + height], p2, p3, [p3[0] - pitch, p1[1] + height]],
          fill: fill2,
          fillOpacity,
          stroke: stroke2,
          strokeOpacity
        }
      });
      var right2 = document2.createElement("polygon", {
        style: {
          points: [p1, [p1[0] - pitch, p1[1] + height], p2, [p1[0] + pitch, p1[1] + height]],
          fill: fill2,
          fillOpacity: fillOpacity - 0.2
        }
      });
      g.appendChild(top);
      g.appendChild(bottom);
      g.appendChild(right2);
      return g;
    };
  };
  register("shape.interval.bar25D", draw25DBar);
};

// node_modules/@ant-design/plots/es/core/plots/bar/index.js
var __extends11 = function() {
  var extendStatics2 = function(d2, b) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b2) {
      d3.__proto__ = b2;
    } || function(d3, b2) {
      for (var p2 in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p2))
          d3[p2] = b2[p2];
    };
    return extendStatics2(d2, b);
  };
  return function(d2, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics2(d2, b);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
reisterShape();
var Bar = (
  /** @class */
  function(_super) {
    __extends11(Bar2, _super);
    function Bar2() {
      var _this2 = _super !== null && _super.apply(this, arguments) || this;
      _this2.type = "Bar";
      return _this2;
    }
    Bar2.getDefaultOptions = function() {
      return {
        type: "view",
        coordinate: { transform: [{ type: "transpose" }] },
        children: [{ type: "interval" }],
        scale: {
          y: { nice: true }
        },
        axis: {
          y: { title: false },
          x: { title: false }
        },
        interaction: {
          tooltip: {
            shared: true
          },
          elementHighlightByColor: {
            background: true
          }
        }
      };
    };
    Bar2.prototype.getDefaultOptions = function() {
      return Bar2.getDefaultOptions();
    };
    Bar2.prototype.getSchemaAdaptor = function() {
      return adaptor3;
    };
    return Bar2;
  }(Plot)
);

// node_modules/@ant-design/plots/es/core/plots/column/shape.js
var reisterShape2 = function() {
  var draw25DColumn = function(style, context) {
    return function(points) {
      var _a2 = style.fill, fill2 = _a2 === void 0 ? "#2888FF" : _a2, stroke2 = style.stroke, _b = style.fillOpacity, fillOpacity = _b === void 0 ? 1 : _b, _c = style.strokeOpacity, strokeOpacity = _c === void 0 ? 0.2 : _c, _d = style.pitch, pitch = _d === void 0 ? 8 : _d;
      var x3 = points[1][0] - points[0][0];
      var x4 = x3 / 2 + points[0][0];
      var document2 = context.document;
      var g = document2.createElement("g", {});
      var left2 = document2.createElement("polygon", {
        style: {
          points: [
            [points[0][0], points[0][1]],
            [x4, points[1][1] + pitch],
            [x4, points[3][1] + pitch],
            [points[3][0], points[3][1]]
          ],
          fill: fill2,
          fillOpacity,
          stroke: stroke2,
          strokeOpacity,
          inset: 30
        }
      });
      var right2 = document2.createElement("polygon", {
        style: {
          points: [
            [x4, points[1][1] + pitch],
            [points[1][0], points[1][1]],
            [points[2][0], points[2][1]],
            [x4, points[2][1] + pitch]
          ],
          fill: fill2,
          fillOpacity,
          stroke: stroke2,
          strokeOpacity
        }
      });
      var top = document2.createElement("polygon", {
        style: {
          points: [
            [points[0][0], points[0][1]],
            [x4, points[1][1] - pitch],
            [points[1][0], points[1][1]],
            [x4, points[1][1] + pitch]
          ],
          fill: fill2,
          fillOpacity: fillOpacity - 0.2
        }
      });
      g.appendChild(right2);
      g.appendChild(left2);
      g.appendChild(top);
      return g;
    };
  };
  register("shape.interval.column25D", draw25DColumn);
};

// node_modules/@ant-design/plots/es/core/plots/column/index.js
var __extends12 = function() {
  var extendStatics2 = function(d2, b) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b2) {
      d3.__proto__ = b2;
    } || function(d3, b2) {
      for (var p2 in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p2))
          d3[p2] = b2[p2];
    };
    return extendStatics2(d2, b);
  };
  return function(d2, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics2(d2, b);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
reisterShape2();
var Column2 = (
  /** @class */
  function(_super) {
    __extends12(Column3, _super);
    function Column3() {
      var _this2 = _super !== null && _super.apply(this, arguments) || this;
      _this2.type = "column";
      return _this2;
    }
    Column3.getDefaultOptions = function() {
      return {
        type: "view",
        scale: {
          y: { nice: true }
        },
        interaction: {
          tooltip: {
            shared: true
          },
          elementHighlightByColor: {
            background: true
          }
        },
        axis: {
          y: { title: false },
          x: { title: false }
        },
        children: [
          {
            type: "interval"
          }
        ]
      };
    };
    Column3.prototype.getDefaultOptions = function() {
      return Column3.getDefaultOptions();
    };
    Column3.prototype.getSchemaAdaptor = function() {
      return adaptor3;
    };
    return Column3;
  }(Plot)
);

// node_modules/@ant-design/plots/es/core/plots/dual-axes/adaptor.js
function adaptor4(params) {
  var annotations = function(params2) {
    var options = params2.options;
    var _a2 = options.annotations, annotations2 = _a2 === void 0 ? [] : _a2, _b = options.children, children = _b === void 0 ? [] : _b, scale10 = options.scale;
    var sharedScale = false;
    if (get_default4(scale10, "y.key")) {
      return params2;
    }
    children.forEach(function(child, index3) {
      if (!get_default4(child, "scale.y.key")) {
        var scaleKey_1 = "child".concat(index3, "Scale");
        set_default4(child, "scale.y.key", scaleKey_1);
        var _a3 = child.annotations, childAnnotations = _a3 === void 0 ? [] : _a3;
        if (childAnnotations.length > 0) {
          set_default4(child, "scale.y.independent", false);
          childAnnotations.forEach(function(annotation) {
            set_default4(annotation, "scale.y.key", scaleKey_1);
          });
        }
        if (!sharedScale && annotations2.length > 0 && get_default4(child, "scale.y.independent") === void 0) {
          sharedScale = true;
          set_default4(child, "scale.y.independent", false);
          annotations2.forEach(function(annotation) {
            set_default4(annotation, "scale.y.key", scaleKey_1);
          });
        }
      }
    });
    return params2;
  };
  return flow_default(annotations, mark, transformOptions)(params);
}

// node_modules/@ant-design/plots/es/core/plots/dual-axes/index.js
var __extends13 = function() {
  var extendStatics2 = function(d2, b) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b2) {
      d3.__proto__ = b2;
    } || function(d3, b2) {
      for (var p2 in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p2))
          d3[p2] = b2[p2];
    };
    return extendStatics2(d2, b);
  };
  return function(d2, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics2(d2, b);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var DualAxes = (
  /** @class */
  function(_super) {
    __extends13(DualAxes2, _super);
    function DualAxes2() {
      var _this2 = _super !== null && _super.apply(this, arguments) || this;
      _this2.type = "DualAxes";
      return _this2;
    }
    DualAxes2.getDefaultOptions = function() {
      return {
        type: "view",
        axis: {
          y: { title: false, tick: false },
          x: { title: false }
        },
        scale: {
          y: {
            independent: true,
            nice: true
          }
        }
      };
    };
    DualAxes2.prototype.getDefaultOptions = function() {
      return DualAxes2.getDefaultOptions();
    };
    DualAxes2.prototype.getSchemaAdaptor = function() {
      return adaptor4;
    };
    return DualAxes2;
  }(Plot)
);

// node_modules/@ant-design/plots/es/core/plots/funnel/adaptor.js
function adaptor5(params) {
  var init = function(params2) {
    var options = params2.options;
    var xField = options.xField, colorField = options.colorField;
    if (!colorField) {
      set_default4(options, "colorField", xField);
    }
    return params2;
  };
  var transform3 = function(params2) {
    var options = params2.options;
    var compareField = options.compareField, transform4 = options.transform, _a2 = options.isTransposed, isTransposed = _a2 === void 0 ? true : _a2, coordinate2 = options.coordinate;
    if (!transform4) {
      if (compareField) {
        set_default4(options, "transform", []);
      } else {
        set_default4(options, "transform", [{ type: "symmetryY" }]);
      }
    }
    if (!coordinate2 && isTransposed) {
      set_default4(options, "coordinate", { transform: [{ type: "transpose" }] });
    }
    return params2;
  };
  var compare = function(params2) {
    var options = params2.options;
    var compareField = options.compareField, seriesField = options.seriesField, data2 = options.data, children = options.children, yField = options.yField, _a2 = options.isTransposed, isTransposed = _a2 === void 0 ? true : _a2;
    if (compareField || seriesField) {
      var groupedData = Object.values(groupBy_default(data2, function(item) {
        return item[compareField || seriesField];
      }));
      children[0].data = groupedData[0];
      children.push({
        type: "interval",
        data: groupedData[1],
        // @ts-ignore
        yField: function(item) {
          return -item[yField];
        }
      });
      delete options["compareField"];
      delete options.data;
    }
    if (seriesField) {
      set_default4(options, "type", "spaceFlex");
      set_default4(options, "ratio", [1, 1]);
      set_default4(options, "direction", isTransposed ? "row" : "col");
      delete options["seriesField"];
    }
    return params2;
  };
  var tooltip2 = function(params2) {
    var options = params2.options;
    var tooltip3 = options.tooltip, xField = options.xField, yField = options.yField;
    if (!tooltip3) {
      set_default4(options, "tooltip", {
        title: false,
        items: [
          function(d2) {
            return { name: d2[xField], value: d2[yField] };
          }
        ]
      });
    }
    return params2;
  };
  return flow_default(init, transform3, compare, tooltip2, mark, transformOptions)(params);
}

// node_modules/@ant-design/plots/es/core/plots/funnel/index.js
var __extends14 = function() {
  var extendStatics2 = function(d2, b) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b2) {
      d3.__proto__ = b2;
    } || function(d3, b2) {
      for (var p2 in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p2))
          d3[p2] = b2[p2];
    };
    return extendStatics2(d2, b);
  };
  return function(d2, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics2(d2, b);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var Funnel2 = (
  /** @class */
  function(_super) {
    __extends14(Funnel3, _super);
    function Funnel3() {
      var _this2 = _super !== null && _super.apply(this, arguments) || this;
      _this2.type = "column";
      return _this2;
    }
    Funnel3.getDefaultOptions = function() {
      return {
        type: "view",
        scale: { x: { padding: 0 } },
        animate: { enter: { type: "fadeIn" } },
        axis: false,
        shapeField: "funnel",
        label: {
          position: "inside",
          transform: [{ type: "contrastReverse" }]
        },
        children: [
          {
            type: "interval"
          }
        ]
      };
    };
    Funnel3.prototype.getDefaultOptions = function() {
      return Funnel3.getDefaultOptions();
    };
    Funnel3.prototype.getSchemaAdaptor = function() {
      return adaptor5;
    };
    return Funnel3;
  }(Plot)
);

// node_modules/@ant-design/plots/es/core/plots/line/adaptor.js
function adaptor6(params) {
  return flow_default(mark, transformOptions)(params);
}

// node_modules/@ant-design/plots/es/core/plots/line/index.js
var __extends15 = function() {
  var extendStatics2 = function(d2, b) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b2) {
      d3.__proto__ = b2;
    } || function(d3, b2) {
      for (var p2 in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p2))
          d3[p2] = b2[p2];
    };
    return extendStatics2(d2, b);
  };
  return function(d2, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics2(d2, b);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var Line6 = (
  /** @class */
  function(_super) {
    __extends15(Line7, _super);
    function Line7() {
      var _this2 = _super !== null && _super.apply(this, arguments) || this;
      _this2.type = "line";
      return _this2;
    }
    Line7.getDefaultOptions = function() {
      return {
        type: "view",
        scale: {
          y: { nice: true }
        },
        interaction: {
          tooltip: {
            shared: true
          }
        },
        axis: {
          y: { title: false },
          x: { title: false }
        },
        // - 
        // animate: {
        //   enter: { type: 'growInX' },
        // },
        children: [{ type: "line" }]
      };
    };
    Line7.prototype.getDefaultOptions = function() {
      return Line7.getDefaultOptions();
    };
    Line7.prototype.getSchemaAdaptor = function() {
      return adaptor6;
    };
    return Line7;
  }(Plot)
);

// node_modules/@ant-design/plots/es/core/plots/pie/adaptor.js
function adaptor7(params) {
  return flow_default(coordinate, transformOptions)(params);
}

// node_modules/@ant-design/plots/es/core/plots/pie/index.js
var __extends16 = function() {
  var extendStatics2 = function(d2, b) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b2) {
      d3.__proto__ = b2;
    } || function(d3, b2) {
      for (var p2 in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p2))
          d3[p2] = b2[p2];
    };
    return extendStatics2(d2, b);
  };
  return function(d2, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics2(d2, b);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var Pie = (
  /** @class */
  function(_super) {
    __extends16(Pie2, _super);
    function Pie2() {
      var _this2 = _super !== null && _super.apply(this, arguments) || this;
      _this2.type = "pie";
      return _this2;
    }
    Pie2.getDefaultOptions = function() {
      return {
        type: "view",
        children: [{ type: "interval" }],
        coordinate: { type: "theta" },
        transform: [{ type: "stackY", reverse: true }],
        animate: { enter: { type: "waveIn" } }
      };
    };
    Pie2.prototype.getDefaultOptions = function() {
      return Pie2.getDefaultOptions();
    };
    Pie2.prototype.getSchemaAdaptor = function() {
      return adaptor7;
    };
    return Pie2;
  }(Plot)
);

// node_modules/@ant-design/plots/es/core/plots/scatter/adaptor.js
function adaptor8(params) {
  return flow_default(mark, transformOptions)(params);
}

// node_modules/@ant-design/plots/es/core/plots/scatter/index.js
var __extends17 = function() {
  var extendStatics2 = function(d2, b) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b2) {
      d3.__proto__ = b2;
    } || function(d3, b2) {
      for (var p2 in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p2))
          d3[p2] = b2[p2];
    };
    return extendStatics2(d2, b);
  };
  return function(d2, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics2(d2, b);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var Scatter = (
  /** @class */
  function(_super) {
    __extends17(Scatter2, _super);
    function Scatter2() {
      var _this2 = _super !== null && _super.apply(this, arguments) || this;
      _this2.type = "scatter";
      return _this2;
    }
    Scatter2.getDefaultOptions = function() {
      return {
        axis: {
          y: { title: false },
          x: { title: false }
        },
        legend: {
          size: false
        },
        children: [{ type: "point" }]
      };
    };
    Scatter2.prototype.getDefaultOptions = function() {
      return Scatter2.getDefaultOptions();
    };
    Scatter2.prototype.getSchemaAdaptor = function() {
      return adaptor8;
    };
    return Scatter2;
  }(Plot)
);

// node_modules/@ant-design/plots/es/core/plots/radar/adaptor.js
function adaptor9(params) {
  var init = function(params2) {
    set_default4(params2, "options.coordinate", { type: get_default4(params2, "options.coordinateType", "polar") });
    return params2;
  };
  return flow_default(init, coordinate, transformOptions)(params);
}

// node_modules/@ant-design/plots/es/core/plots/radar/index.js
var __extends18 = function() {
  var extendStatics2 = function(d2, b) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b2) {
      d3.__proto__ = b2;
    } || function(d3, b2) {
      for (var p2 in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p2))
          d3[p2] = b2[p2];
    };
    return extendStatics2(d2, b);
  };
  return function(d2, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics2(d2, b);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var Radar2 = (
  /** @class */
  function(_super) {
    __extends18(Radar3, _super);
    function Radar3() {
      var _this2 = _super !== null && _super.apply(this, arguments) || this;
      _this2.type = "radar";
      return _this2;
    }
    Radar3.getDefaultOptions = function() {
      return {
        axis: {
          x: { grid: true, line: true },
          y: { zIndex: 1, title: false, line: true, nice: true }
        },
        meta: { x: { padding: 0.5, align: 0 } },
        interaction: { tooltip: { style: { crosshairsLineDash: [4, 4] } } },
        children: [{ type: "line" }],
        //   polar  radar 
        coordinateType: "polar"
      };
    };
    Radar3.prototype.getDefaultOptions = function() {
      return Radar3.getDefaultOptions();
    };
    Radar3.prototype.getSchemaAdaptor = function() {
      return adaptor9;
    };
    return Radar3;
  }(Plot)
);

// node_modules/@ant-design/plots/es/core/plots/stock/adaptor.js
var __assign14 = function() {
  __assign14 = Object.assign || function(t) {
    for (var s2, i = 1, n = arguments.length; i < n; i++) {
      s2 = arguments[i];
      for (var p2 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p2))
          t[p2] = s2[p2];
    }
    return t;
  };
  return __assign14.apply(this, arguments);
};
var Y_FIELD_KEY = "__stock-range__";
var TREND_FIELD = "trend";
var TREND_UP = "up";
var TREND_DOWN = "down";
function adaptor10(params) {
  var transformData2 = function(params2) {
    var _a2 = params2.options, data2 = _a2.data, yField = _a2.yField;
    params2.options.data = map_default4(data2, function(item) {
      var obj = item && __assign14({}, item);
      if (Array.isArray(yField) && obj) {
        var open_1 = yField[0], close_1 = yField[1], high = yField[2], low = yField[3];
        obj[TREND_FIELD] = obj[open_1] <= obj[close_1] ? TREND_UP : TREND_DOWN;
        obj[Y_FIELD_KEY] = [obj[open_1], obj[close_1], obj[high], obj[low]];
      }
      return obj;
    });
    return params2;
  };
  var init = function(params2) {
    var options = params2.options;
    var xField = options.xField, yField = options.yField, fallingFill = options.fallingFill, risingFill = options.risingFill;
    var open = yField[0], close = yField[1], high = yField[2], low = yField[3];
    params2.options.children = map_default4(params2.options.children, function(child, index3) {
      var isShadow = index3 === 0;
      return __assign14(__assign14({}, child), { tooltip: {
        title: function(d2) {
          return d2[xField] instanceof Date ? d2[xField].toLocaleString() : d2[xField];
        },
        items: [{ field: high }, { field: low }, { field: open }, { field: close }]
      }, encode: __assign14(__assign14({}, child.encode || {}), { y: isShadow ? [high, low] : [open, close], color: function(d2) {
        return Math.sign(d2[close] - d2[open]);
      } }), style: __assign14(__assign14({}, child.style || {}), { lineWidth: isShadow ? 1 : 10 }) });
    });
    delete options["yField"];
    params2.options.legend = {
      color: false
    };
    if (fallingFill) {
      set_default4(params2, "options.scale.color.range[0]", fallingFill);
    }
    if (risingFill) {
      set_default4(params2, "options.scale.color.range[2]", risingFill);
    }
    return params2;
  };
  return flow_default(transformData2, init, transformOptions)(params);
}

// node_modules/@ant-design/plots/es/core/plots/stock/index.js
var __extends19 = function() {
  var extendStatics2 = function(d2, b) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b2) {
      d3.__proto__ = b2;
    } || function(d3, b2) {
      for (var p2 in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p2))
          d3[p2] = b2[p2];
    };
    return extendStatics2(d2, b);
  };
  return function(d2, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics2(d2, b);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var DEFAULT_COLORS = ["#26a69a", "#999999", "#ef5350"];
var Stock = (
  /** @class */
  function(_super) {
    __extends19(Stock2, _super);
    function Stock2() {
      var _this2 = _super !== null && _super.apply(this, arguments) || this;
      _this2.type = "stock";
      return _this2;
    }
    Stock2.getDefaultOptions = function() {
      return {
        type: "view",
        scale: {
          color: {
            domain: [-1, 0, 1],
            range: DEFAULT_COLORS
          },
          y: { nice: true }
        },
        children: [
          // shadow
          {
            type: "link"
          },
          // real body
          {
            type: "link"
          }
        ],
        axis: {
          x: { title: false, grid: false },
          y: { title: false, grid: true, gridLineDash: null }
        },
        animate: { enter: { type: "scaleInY" } },
        interaction: {
          tooltip: {
            shared: true,
            marker: false,
            groupName: false,
            crosshairs: true
          }
        }
      };
    };
    Stock2.prototype.getDefaultOptions = function() {
      return Stock2.getDefaultOptions();
    };
    Stock2.prototype.getSchemaAdaptor = function() {
      return adaptor10;
    };
    return Stock2;
  }(Plot)
);

// node_modules/@ant-design/plots/es/core/plots/tiny-line/adaptor.js
function adaptor11(params) {
  return flow_default(mark, transformOptions)(params);
}

// node_modules/@ant-design/plots/es/core/plots/tiny-line/index.js
var __extends20 = function() {
  var extendStatics2 = function(d2, b) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b2) {
      d3.__proto__ = b2;
    } || function(d3, b2) {
      for (var p2 in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p2))
          d3[p2] = b2[p2];
    };
    return extendStatics2(d2, b);
  };
  return function(d2, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics2(d2, b);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var TinyLine = (
  /** @class */
  function(_super) {
    __extends20(TinyLine2, _super);
    function TinyLine2() {
      var _this2 = _super !== null && _super.apply(this, arguments) || this;
      _this2.type = "TinyLine";
      return _this2;
    }
    TinyLine2.getDefaultOptions = function() {
      return {
        type: "view",
        children: [{ type: "line", axis: false }],
        autoFit: false,
        animate: {
          enter: { type: "growInX", duration: 500 }
        },
        padding: 0,
        margin: 0,
        tooltip: false
      };
    };
    TinyLine2.prototype.getDefaultOptions = function() {
      return TinyLine2.getDefaultOptions();
    };
    TinyLine2.prototype.getSchemaAdaptor = function() {
      return adaptor11;
    };
    return TinyLine2;
  }(Plot)
);

// node_modules/@ant-design/plots/es/core/plots/tiny-area/adaptor.js
function adaptor12(params) {
  return flow_default(mark, transformOptions)(params);
}

// node_modules/@ant-design/plots/es/core/plots/tiny-area/index.js
var __extends21 = function() {
  var extendStatics2 = function(d2, b) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b2) {
      d3.__proto__ = b2;
    } || function(d3, b2) {
      for (var p2 in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p2))
          d3[p2] = b2[p2];
    };
    return extendStatics2(d2, b);
  };
  return function(d2, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics2(d2, b);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var TinyArea = (
  /** @class */
  function(_super) {
    __extends21(TinyArea2, _super);
    function TinyArea2() {
      var _this2 = _super !== null && _super.apply(this, arguments) || this;
      _this2.type = "TinyArea";
      return _this2;
    }
    TinyArea2.getDefaultOptions = function() {
      return {
        type: "view",
        animate: {
          enter: { type: "growInX", duration: 500 }
        },
        children: [{ type: "area", axis: false }],
        autoFit: false,
        padding: 0,
        margin: 0,
        tooltip: false
      };
    };
    TinyArea2.prototype.getDefaultOptions = function() {
      return TinyArea2.getDefaultOptions();
    };
    TinyArea2.prototype.getSchemaAdaptor = function() {
      return adaptor12;
    };
    return TinyArea2;
  }(Plot)
);

// node_modules/@ant-design/plots/es/core/plots/tiny-column/adaptor.js
function adaptor13(params) {
  return flow_default(mark, transformOptions)(params);
}

// node_modules/@ant-design/plots/es/core/plots/tiny-column/index.js
var __extends22 = function() {
  var extendStatics2 = function(d2, b) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b2) {
      d3.__proto__ = b2;
    } || function(d3, b2) {
      for (var p2 in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p2))
          d3[p2] = b2[p2];
    };
    return extendStatics2(d2, b);
  };
  return function(d2, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics2(d2, b);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var TinyColumn = (
  /** @class */
  function(_super) {
    __extends22(TinyColumn2, _super);
    function TinyColumn2() {
      var _this2 = _super !== null && _super.apply(this, arguments) || this;
      _this2.type = "TinyColumn";
      return _this2;
    }
    TinyColumn2.getDefaultOptions = function() {
      return {
        type: "view",
        children: [{ type: "interval", axis: false }],
        autoFit: false,
        padding: 0,
        margin: 0,
        tooltip: false
      };
    };
    TinyColumn2.prototype.getDefaultOptions = function() {
      return TinyColumn2.getDefaultOptions();
    };
    TinyColumn2.prototype.getSchemaAdaptor = function() {
      return adaptor13;
    };
    return TinyColumn2;
  }(Plot)
);

// node_modules/@ant-design/plots/es/core/plots/tiny-progress/adaptor.js
var __assign15 = function() {
  __assign15 = Object.assign || function(t) {
    for (var s2, i = 1, n = arguments.length; i < n; i++) {
      s2 = arguments[i];
      for (var p2 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p2))
          t[p2] = s2[p2];
    }
    return t;
  };
  return __assign15.apply(this, arguments);
};
function adaptor14(params) {
  var transformData2 = function(params2) {
    var options = params2.options;
    var percent = options.percent, _a2 = options.color, color2 = _a2 === void 0 ? [] : _a2;
    if (!percent)
      return params2;
    var transformOption = {
      scale: {
        color: { range: color2.length ? color2 : [] }
      },
      data: [1, percent]
    };
    Object.assign(options, __assign15({}, transformOption));
    return params2;
  };
  return flow_default(transformData2, mark, transformOptions)(params);
}

// node_modules/@ant-design/plots/es/core/plots/tiny-progress/index.js
var __extends23 = function() {
  var extendStatics2 = function(d2, b) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b2) {
      d3.__proto__ = b2;
    } || function(d3, b2) {
      for (var p2 in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p2))
          d3[p2] = b2[p2];
    };
    return extendStatics2(d2, b);
  };
  return function(d2, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics2(d2, b);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var TinyProgress = (
  /** @class */
  function(_super) {
    __extends23(TinyProgress2, _super);
    function TinyProgress2() {
      var _this2 = _super !== null && _super.apply(this, arguments) || this;
      _this2.type = "TinyProgress";
      return _this2;
    }
    TinyProgress2.getDefaultOptions = function() {
      return {
        type: "view",
        data: [],
        autoFit: false,
        margin: 0,
        padding: 0,
        tooltip: false,
        children: [
          {
            interaction: { tooltip: false },
            coordinate: { transform: [{ type: "transpose" }] },
            type: "interval",
            axis: false,
            legend: false,
            encode: { y: function(d2) {
              return d2;
            }, color: function(d2, idx) {
              return idx;
            } }
          }
        ]
      };
    };
    TinyProgress2.prototype.getDefaultOptions = function() {
      return TinyProgress2.getDefaultOptions();
    };
    TinyProgress2.prototype.getSchemaAdaptor = function() {
      return adaptor14;
    };
    return TinyProgress2;
  }(Plot)
);

// node_modules/@ant-design/plots/es/core/plots/tiny-ring/adaptor.js
var __assign16 = function() {
  __assign16 = Object.assign || function(t) {
    for (var s2, i = 1, n = arguments.length; i < n; i++) {
      s2 = arguments[i];
      for (var p2 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p2))
          t[p2] = s2[p2];
    }
    return t;
  };
  return __assign16.apply(this, arguments);
};
function adaptor15(params) {
  var radius = function(params2) {
    var options = params2.options;
    var _a2 = options.radius, radius2 = _a2 === void 0 ? 0.8 : _a2;
    set_default4(params2, "options.coordinate.innerRadius", radius2);
    return params2;
  };
  var transformData2 = function(params2) {
    var options = params2.options;
    var percent = options.percent, _a2 = options.color, color2 = _a2 === void 0 ? [] : _a2;
    if (!percent)
      return params2;
    var transformOption = {
      scale: {
        color: { range: color2.length ? color2 : [] }
      },
      data: [1, percent]
    };
    Object.assign(options, __assign16({}, transformOption));
    return params2;
  };
  return flow_default(radius, transformData2, mark, transformOptions)(params);
}

// node_modules/@ant-design/plots/es/core/plots/tiny-ring/index.js
var __extends24 = function() {
  var extendStatics2 = function(d2, b) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b2) {
      d3.__proto__ = b2;
    } || function(d3, b2) {
      for (var p2 in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p2))
          d3[p2] = b2[p2];
    };
    return extendStatics2(d2, b);
  };
  return function(d2, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics2(d2, b);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var TinyRing = (
  /** @class */
  function(_super) {
    __extends24(TinyRing2, _super);
    function TinyRing2() {
      var _this2 = _super !== null && _super.apply(this, arguments) || this;
      _this2.type = "TinyRing";
      return _this2;
    }
    TinyRing2.getDefaultOptions = function() {
      return {
        type: "view",
        data: [],
        autoFit: false,
        margin: 0,
        padding: 0,
        coordinate: { type: "theta" },
        animate: { enter: { type: "waveIn" } },
        interaction: { tooltip: false },
        tooltip: false,
        children: [
          {
            type: "interval",
            axis: false,
            legend: false,
            encode: { y: function(d2) {
              return d2;
            }, color: function(d2, idx) {
              return idx;
            } }
          }
        ]
      };
    };
    TinyRing2.prototype.getDefaultOptions = function() {
      return TinyRing2.getDefaultOptions();
    };
    TinyRing2.prototype.getSchemaAdaptor = function() {
      return adaptor15;
    };
    return TinyRing2;
  }(Plot)
);

// node_modules/@ant-design/plots/es/core/plots/rose/adaptor.js
function adaptor16(params) {
  return flow_default(coordinate, transformOptions)(params);
}

// node_modules/@ant-design/plots/es/core/plots/rose/index.js
var __extends25 = function() {
  var extendStatics2 = function(d2, b) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b2) {
      d3.__proto__ = b2;
    } || function(d3, b2) {
      for (var p2 in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p2))
          d3[p2] = b2[p2];
    };
    return extendStatics2(d2, b);
  };
  return function(d2, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics2(d2, b);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var Rose = (
  /** @class */
  function(_super) {
    __extends25(Rose2, _super);
    function Rose2() {
      var _this2 = _super !== null && _super.apply(this, arguments) || this;
      _this2.type = "rose";
      return _this2;
    }
    Rose2.getDefaultOptions = function() {
      return {
        type: "view",
        children: [{ type: "interval" }],
        coordinate: { type: "polar" },
        animate: { enter: { type: "waveIn" } }
      };
    };
    Rose2.prototype.getDefaultOptions = function() {
      return Rose2.getDefaultOptions();
    };
    Rose2.prototype.getSchemaAdaptor = function() {
      return adaptor16;
    };
    return Rose2;
  }(Plot)
);

// node_modules/@ant-design/plots/es/core/plots/waterfall/constants.js
var START_KEY = "__start__";
var END_KEY = "__end__";
var WATERFALL_VALUE = "__waterfall_value__";

// node_modules/@ant-design/plots/es/core/plots/waterfall/adaptor.js
var __assign17 = function() {
  __assign17 = Object.assign || function(t) {
    for (var s2, i = 1, n = arguments.length; i < n; i++) {
      s2 = arguments[i];
      for (var p2 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p2))
          t[p2] = s2[p2];
    }
    return t;
  };
  return __assign17.apply(this, arguments);
};
var __spreadArray8 = function(to, from, pack3) {
  if (pack3 || arguments.length === 2)
    for (var i = 0, l = from.length, ar; i < l; i++) {
      if (ar || !(i in from)) {
        if (!ar)
          ar = Array.prototype.slice.call(from, 0, i);
        ar[i] = from[i];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from));
};
function adaptor17(params) {
  var transformData2 = function(params2) {
    var options = params2.options;
    var _a2 = options.data, data2 = _a2 === void 0 ? [] : _a2, yField = options.yField;
    if (!data2.length)
      return params2;
    data2.reduce(function(prev, cur, index3) {
      var _a3;
      if (index3 === 0 || cur.isTotal) {
        cur[START_KEY] = 0;
        cur[END_KEY] = cur[yField];
        cur[WATERFALL_VALUE] = cur[yField];
      } else {
        var start = (_a3 = prev[END_KEY]) !== null && _a3 !== void 0 ? _a3 : prev[yField];
        cur[START_KEY] = start;
        cur[END_KEY] = start + cur[yField];
        cur[WATERFALL_VALUE] = prev[END_KEY];
      }
      return cur;
    }, []);
    Object.assign(options, { yField: [START_KEY, END_KEY] });
    return params2;
  };
  var link3 = function(params2) {
    var options = params2.options;
    var _a2 = options.data, data2 = _a2 === void 0 ? [] : _a2, xField = options.xField, children = options.children, linkStyle = options.linkStyle;
    var linkData = __spreadArray8([], data2, true);
    linkData.reduce(function(prev, cur, index3) {
      if (index3 > 0) {
        cur.x1 = prev[xField];
        cur.x2 = cur[xField];
        cur.y1 = prev[END_KEY];
      }
      return cur;
    }, []);
    linkData.shift();
    children.push({
      type: "link",
      xField: ["x1", "x2"],
      yField: "y1",
      //  scrollbar  link  interval
      zIndex: -1,
      data: linkData,
      style: __assign17({ stroke: "#697474" }, linkStyle),
      label: false,
      tooltip: false
    });
    return params2;
  };
  return flow_default(transformData2, link3, mark, transformOptions)(params);
}

// node_modules/@ant-design/plots/es/core/plots/waterfall/index.js
var __extends26 = function() {
  var extendStatics2 = function(d2, b) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b2) {
      d3.__proto__ = b2;
    } || function(d3, b2) {
      for (var p2 in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p2))
          d3[p2] = b2[p2];
    };
    return extendStatics2(d2, b);
  };
  return function(d2, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics2(d2, b);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var Waterfall = (
  /** @class */
  function(_super) {
    __extends26(Waterfall2, _super);
    function Waterfall2() {
      var _this2 = _super !== null && _super.apply(this, arguments) || this;
      _this2.type = "waterfall";
      return _this2;
    }
    Waterfall2.getDefaultOptions = function() {
      return {
        type: "view",
        legend: null,
        tooltip: {
          field: WATERFALL_VALUE,
          valueFormatter: "~s",
          name: "value"
        },
        axis: {
          y: {
            title: null,
            labelFormatter: "~s"
          },
          x: {
            title: null
          }
        },
        children: [
          {
            type: "interval",
            interaction: {
              elementHighlightByColor: {
                background: true
              }
            }
          }
        ]
      };
    };
    Waterfall2.prototype.getDefaultOptions = function() {
      return Waterfall2.getDefaultOptions();
    };
    Waterfall2.prototype.getSchemaAdaptor = function() {
      return adaptor17;
    };
    return Waterfall2;
  }(Plot)
);

// node_modules/@ant-design/plots/es/core/plots/histogram/adaptor.js
function adaptor18(params) {
  var transformHistogramConfig = function(params2) {
    var options = params2.options;
    var data2 = options.data, binNumber = options.binNumber, binWidth = options.binWidth, children = options.children, _a2 = options.channel, channel = _a2 === void 0 ? "count" : _a2;
    var targetTransform = get_default4(children, "[0].transform[0]", {});
    if (isNumber_default(binWidth)) {
      assign_default(targetTransform, { thresholds: ceil_default(divide_default(data2.length, binWidth)), y: channel });
      return params2;
    }
    if (isNumber_default(binNumber)) {
      assign_default(targetTransform, { thresholds: binNumber, y: channel });
      return params2;
    }
    return params2;
  };
  return flow_default(transformHistogramConfig, mark, transformOptions)(params);
}

// node_modules/@ant-design/plots/es/core/plots/histogram/index.js
var __extends27 = function() {
  var extendStatics2 = function(d2, b) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b2) {
      d3.__proto__ = b2;
    } || function(d3, b2) {
      for (var p2 in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p2))
          d3[p2] = b2[p2];
    };
    return extendStatics2(d2, b);
  };
  return function(d2, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics2(d2, b);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var Histogram = (
  /** @class */
  function(_super) {
    __extends27(Histogram2, _super);
    function Histogram2() {
      var _this2 = _super !== null && _super.apply(this, arguments) || this;
      _this2.type = "Histogram";
      return _this2;
    }
    Histogram2.getDefaultOptions = function() {
      return {
        type: "view",
        autoFit: true,
        axis: {
          y: { title: false },
          x: { title: false }
        },
        children: [
          {
            type: "rect",
            transform: [{ type: "binX", y: "count" }],
            interaction: {
              elementHighlightByColor: {
                background: true
              }
            }
          }
        ]
      };
    };
    Histogram2.prototype.getDefaultOptions = function() {
      return Histogram2.getDefaultOptions();
    };
    Histogram2.prototype.getSchemaAdaptor = function() {
      return adaptor18;
    };
    return Histogram2;
  }(Plot)
);

// node_modules/@ant-design/plots/es/core/plots/heatmap/adaptor.js
function adaptor19(params) {
  var tooltip2 = function(params2) {
    var options = params2.options;
    var tooltip3 = options.tooltip, colorField = options.colorField, sizeField = options.sizeField;
    if (!tooltip3.field) {
      tooltip3.field = colorField || sizeField;
    }
    return params2;
  };
  var transformMark = function(params2) {
    var options = params2.options;
    var mark2 = options.mark, children = options.children;
    if (mark2) {
      children[0].type = mark2;
    }
    return params2;
  };
  return flow_default(tooltip2, transformMark, mark, transformOptions)(params);
}

// node_modules/@ant-design/plots/es/core/plots/heatmap/index.js
var __extends28 = function() {
  var extendStatics2 = function(d2, b) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b2) {
      d3.__proto__ = b2;
    } || function(d3, b2) {
      for (var p2 in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p2))
          d3[p2] = b2[p2];
    };
    return extendStatics2(d2, b);
  };
  return function(d2, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics2(d2, b);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var Heatmap3 = (
  /** @class */
  function(_super) {
    __extends28(Heatmap4, _super);
    function Heatmap4() {
      var _this2 = _super !== null && _super.apply(this, arguments) || this;
      _this2.type = "heatmap";
      return _this2;
    }
    Heatmap4.getDefaultOptions = function() {
      return {
        type: "view",
        legend: null,
        tooltip: {
          valueFormatter: "~s"
        },
        axis: {
          y: {
            title: null,
            grid: true
          },
          x: {
            title: null,
            grid: true
          }
        },
        children: [
          {
            type: "point",
            interaction: {
              elementHighlightByColor: {
                background: true
              }
            }
          }
        ]
      };
    };
    Heatmap4.prototype.getDefaultOptions = function() {
      return Heatmap4.getDefaultOptions();
    };
    Heatmap4.prototype.getSchemaAdaptor = function() {
      return adaptor19;
    };
    return Heatmap4;
  }(Plot)
);

// node_modules/@ant-design/plots/es/core/plots/box/adaptor.js
function adaptor20(params) {
  var init = function(params2) {
    var _a2 = params2.options.boxType, boxType = _a2 === void 0 ? "box" : _a2;
    params2.options.children[0].type = boxType;
    return params2;
  };
  return flow_default(init, mark, transformOptions)(params);
}

// node_modules/@ant-design/plots/es/core/plots/box/index.js
var __extends29 = function() {
  var extendStatics2 = function(d2, b) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b2) {
      d3.__proto__ = b2;
    } || function(d3, b2) {
      for (var p2 in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p2))
          d3[p2] = b2[p2];
    };
    return extendStatics2(d2, b);
  };
  return function(d2, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics2(d2, b);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var Box3 = (
  /** @class */
  function(_super) {
    __extends29(Box4, _super);
    function Box4() {
      var _this2 = _super !== null && _super.apply(this, arguments) || this;
      _this2.type = "box";
      return _this2;
    }
    Box4.getDefaultOptions = function() {
      return {
        type: "view",
        children: [{ type: "box" }],
        axis: {
          y: { title: false },
          x: { title: false }
        },
        //  tooltip
        tooltip: {
          items: [
            { name: "min", channel: "y" },
            { name: "q1", channel: "y1" },
            { name: "q2", channel: "y2" },
            { name: "q3", channel: "y3" },
            { name: "max", channel: "y4" }
          ]
        }
      };
    };
    Box4.prototype.getDefaultOptions = function() {
      return Box4.getDefaultOptions();
    };
    Box4.prototype.getSchemaAdaptor = function() {
      return adaptor20;
    };
    return Box4;
  }(Plot)
);

// node_modules/@ant-design/plots/es/core/plots/sankey/adaptor.js
function adaptor21(params) {
  return flow_default(mark, transformOptions)(params);
}

// node_modules/@ant-design/plots/es/core/plots/sankey/index.js
var __extends30 = function() {
  var extendStatics2 = function(d2, b) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b2) {
      d3.__proto__ = b2;
    } || function(d3, b2) {
      for (var p2 in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p2))
          d3[p2] = b2[p2];
    };
    return extendStatics2(d2, b);
  };
  return function(d2, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics2(d2, b);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var Sankey4 = (
  /** @class */
  function(_super) {
    __extends30(Sankey5, _super);
    function Sankey5() {
      var _this2 = _super !== null && _super.apply(this, arguments) || this;
      _this2.type = "sankey";
      return _this2;
    }
    Sankey5.getDefaultOptions = function() {
      return { type: "view", children: [{ type: "sankey" }] };
    };
    Sankey5.prototype.getDefaultOptions = function() {
      return Sankey5.getDefaultOptions();
    };
    Sankey5.prototype.getSchemaAdaptor = function() {
      return adaptor21;
    };
    return Sankey5;
  }(Plot)
);

// node_modules/@ant-design/plots/es/core/plots/bullet/adaptor.js
var __assign18 = function() {
  __assign18 = Object.assign || function(t) {
    for (var s2, i = 1, n = arguments.length; i < n; i++) {
      s2 = arguments[i];
      for (var p2 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p2))
          t[p2] = s2[p2];
    }
    return t;
  };
  return __assign18.apply(this, arguments);
};
var DEFAULT_COLORS2 = ["#f0efff", "#5B8FF9", "#3D76DD"];
function getTransformData(data2, field3, xField, isSort) {
  if (isSort === void 0) {
    isSort = true;
  }
  var maxSize = 0;
  var isArrayData = false;
  var transformData2 = map_default4(data2, function(d2) {
    var _a2, _b;
    var fieldData = get_default4(d2, [field3]);
    if (isNil_default(fieldData))
      return [];
    if (isString_default(fieldData)) {
      var numberData = Number(fieldData);
      if (isNaN(numberData))
        return [];
      return _a2 = {}, _a2[xField] = d2[xField], _a2[field3] = numberData, _a2;
    }
    if (isArray_default(fieldData)) {
      isArrayData = true;
      maxSize = Math.max(maxSize, fieldData.length);
      return map_default4(isSort ? fieldData.sort(function(a4, b) {
        return b - a4;
      }) : fieldData, function(value2, index3) {
        var _a3;
        return _a3 = {}, _a3[xField] = d2[xField], _a3[field3] = value2, _a3.index = index3, _a3;
      });
    }
    maxSize = Math.max(1, maxSize);
    return _b = {}, _b[xField] = d2[xField], _b[field3] = fieldData, _b;
  }).flat();
  if (isArrayData) {
    return [
      transformData2.map(function(item) {
        return __assign18({ index: 0 }, item);
      }),
      maxSize
    ];
  }
  return [transformData2, maxSize];
}
function getFieldColor(maxSize, color2) {
  return new Array(maxSize).fill("").map(function(d2, i) {
    return isArray_default(color2) ? color2[i % color2.length] : color2;
  });
}
function adaptor22(params) {
  var init = function(params2) {
    var _a2 = params2.options, color2 = _a2.color, _b = _a2.rangeField, rangeField = _b === void 0 ? "ranges" : _b, _c = _a2.measureField, measureField = _c === void 0 ? "measures" : _c, _d = _a2.targetField, targetField = _d === void 0 ? "targets" : _d, _e = _a2.xField, xField = _e === void 0 ? "title" : _e, mapField = _a2.mapField, data2 = _a2.data;
    var _f = getTransformData(data2, rangeField, xField), rangesData = _f[0], rangesMaxSize = _f[1];
    var _g = getTransformData(data2, measureField, xField, false), measuresData = _g[0], measuresMaxSize = _g[1];
    var _h = getTransformData(data2, targetField, xField, false), targetsData = _h[0], targetsMaxSize = _h[1];
    var rangesColor = get_default4(color2, [rangeField], DEFAULT_COLORS2[0]);
    var measuresColor = get_default4(color2, [measureField], DEFAULT_COLORS2[1]);
    var targetsColor = get_default4(color2, [targetField], DEFAULT_COLORS2[2]);
    var colors = [
      getFieldColor(rangesMaxSize, rangesColor),
      getFieldColor(measuresMaxSize, measuresColor),
      getFieldColor(targetsMaxSize, targetsColor)
    ].flat();
    params2.options.children = map_default4(params2.options.children, function(c5, i) {
      var datas = [rangesData, measuresData, targetsData][i];
      var yField = [rangeField, measureField, targetField][i];
      return __assign18(__assign18({}, c5), {
        data: datas,
        encode: __assign18(__assign18({}, c5.encode || {}), { x: xField, y: yField, color: function(d2) {
          var index3 = d2.index;
          var mapString = isNumber_default(index3) ? "".concat(yField, "_").concat(index3) : yField;
          return mapField ? get_default4(mapField, [yField, index3], mapString) : mapString;
        } }),
        style: __assign18(__assign18({}, c5.style || {}), {
          // 
          zIndex: function(d2) {
            return -d2[yField];
          }
        }),
        // labels  yField
        labels: i !== 0 ? map_default4(c5.labels, function(l) {
          return __assign18(__assign18({}, l), { text: yField });
        }) : void 0
      });
    });
    params2.options.scale.color.range = colors;
    params2.options.legend.color.itemMarker = function(d2) {
      if (mapField && includes_default(mapField === null || mapField === void 0 ? void 0 : mapField[targetField], d2)) {
        return "line";
      }
      return (d2 === null || d2 === void 0 ? void 0 : d2.replace(/\_\d$/, "")) === targetField ? "line" : "square";
    };
    return params2;
  };
  var layoutAdaptor = function(params2) {
    var _a2 = params2.options.layout, layout = _a2 === void 0 ? "horizontal" : _a2;
    if (layout !== "horizontal") {
      set_default4(params2, "options.children[2].shapeField", "hyphen");
    }
    return params2;
  };
  var cfgAdaptor = function(params2) {
    var _a2 = params2.options, _b = _a2.range, range4 = _b === void 0 ? {} : _b, _c = _a2.measure, measure = _c === void 0 ? {} : _c, _d = _a2.target, target = _d === void 0 ? {} : _d, children = _a2.children;
    params2.options.children = [range4, measure, target].map(function(c5, i) {
      return mergeWithArrayCoverage(children[i], c5);
    });
    return params2;
  };
  return flow_default(init, layoutAdaptor, cfgAdaptor, allCoordinateLayout, transformOptions)(params);
}

// node_modules/@ant-design/plots/es/core/plots/bullet/index.js
var __extends31 = function() {
  var extendStatics2 = function(d2, b) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b2) {
      d3.__proto__ = b2;
    } || function(d3, b2) {
      for (var p2 in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p2))
          d3[p2] = b2[p2];
    };
    return extendStatics2(d2, b);
  };
  return function(d2, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics2(d2, b);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var Bullet = (
  /** @class */
  function(_super) {
    __extends31(Bullet2, _super);
    function Bullet2() {
      var _this2 = _super !== null && _super.apply(this, arguments) || this;
      _this2.type = "bullet";
      return _this2;
    }
    Bullet2.getDefaultOptions = function() {
      return {
        type: "view",
        scale: {
          color: {
            range: DEFAULT_COLORS2
          }
        },
        legend: {
          color: {
            itemMarker: function(d2) {
              return d2 === "target" ? "line" : "square";
            }
          }
        },
        axis: {
          y: { title: false },
          x: { title: false }
        },
        children: [
          {
            type: "interval",
            style: { maxWidth: 30 },
            axis: { y: { grid: true, gridLineWidth: 2 } }
          },
          {
            type: "interval",
            style: { maxWidth: 20 },
            transform: [{ type: "stackY" }]
          },
          {
            type: "point",
            encode: { size: 8, shape: "line" }
          }
        ],
        interaction: { tooltip: { shared: true } },
        coordinate: { transform: [{ type: "transpose" }] }
      };
    };
    Bullet2.prototype.getDefaultOptions = function() {
      return Bullet2.getDefaultOptions();
    };
    Bullet2.prototype.getSchemaAdaptor = function() {
      return adaptor22;
    };
    return Bullet2;
  }(Plot)
);

// node_modules/@ant-design/plots/es/core/plots/gauge/adaptor.js
function adaptor23(params) {
  var init = function(params2) {
    var data2 = params2.options.data;
    params2.options.data = {
      value: data2
    };
    return params2;
  };
  return flow_default(init, mark, transformOptions)(params);
}

// node_modules/@ant-design/plots/es/core/plots/gauge/index.js
var __extends32 = function() {
  var extendStatics2 = function(d2, b) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b2) {
      d3.__proto__ = b2;
    } || function(d3, b2) {
      for (var p2 in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p2))
          d3[p2] = b2[p2];
    };
    return extendStatics2(d2, b);
  };
  return function(d2, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics2(d2, b);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var Gauge2 = (
  /** @class */
  function(_super) {
    __extends32(Gauge3, _super);
    function Gauge3() {
      var _this2 = _super !== null && _super.apply(this, arguments) || this;
      _this2.type = "Gauge";
      return _this2;
    }
    Gauge3.getDefaultOptions = function() {
      return {
        type: "view",
        legend: false,
        children: [{ type: "gauge" }]
      };
    };
    Gauge3.prototype.getDefaultOptions = function() {
      return Gauge3.getDefaultOptions();
    };
    Gauge3.prototype.getSchemaAdaptor = function() {
      return adaptor23;
    };
    return Gauge3;
  }(Plot)
);

// node_modules/@ant-design/plots/es/core/plots/liquid/adaptor.js
function adaptor24(params) {
  var init = function(params2) {
    var percent = params2.options.percent;
    if (isNumber_default(percent)) {
      set_default4(params2, "options.data", percent);
    }
    return params2;
  };
  return flow_default(init, mark, transformOptions)(params);
}

// node_modules/@ant-design/plots/es/core/plots/liquid/index.js
var __extends33 = function() {
  var extendStatics2 = function(d2, b) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b2) {
      d3.__proto__ = b2;
    } || function(d3, b2) {
      for (var p2 in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p2))
          d3[p2] = b2[p2];
    };
    return extendStatics2(d2, b);
  };
  return function(d2, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics2(d2, b);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var Liquid3 = (
  /** @class */
  function(_super) {
    __extends33(Liquid4, _super);
    function Liquid4() {
      var _this2 = _super !== null && _super.apply(this, arguments) || this;
      _this2.type = "Liquid";
      return _this2;
    }
    Liquid4.getDefaultOptions = function() {
      return { type: "view", children: [{ type: "liquid" }] };
    };
    Liquid4.prototype.getDefaultOptions = function() {
      return Liquid4.getDefaultOptions();
    };
    Liquid4.prototype.getSchemaAdaptor = function() {
      return adaptor24;
    };
    return Liquid4;
  }(Plot)
);

// node_modules/@ant-design/plots/es/core/plots/wordCloud/adaptor.js
function adaptor25(params) {
  return flow_default(mark, transformOptions)(params);
}

// node_modules/@ant-design/plots/es/core/plots/wordCloud/index.js
var __extends34 = function() {
  var extendStatics2 = function(d2, b) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b2) {
      d3.__proto__ = b2;
    } || function(d3, b2) {
      for (var p2 in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p2))
          d3[p2] = b2[p2];
    };
    return extendStatics2(d2, b);
  };
  return function(d2, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics2(d2, b);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var WordCloud3 = (
  /** @class */
  function(_super) {
    __extends34(WordCloud4, _super);
    function WordCloud4() {
      var _this2 = _super !== null && _super.apply(this, arguments) || this;
      _this2.type = "WordCloud";
      return _this2;
    }
    WordCloud4.getDefaultOptions = function() {
      return { type: "view", legend: false, children: [{ type: "wordCloud" }] };
    };
    WordCloud4.prototype.getDefaultOptions = function() {
      return WordCloud4.getDefaultOptions();
    };
    WordCloud4.prototype.getSchemaAdaptor = function() {
      return adaptor25;
    };
    return WordCloud4;
  }(Plot)
);

// node_modules/@ant-design/plots/es/core/plots/treemap/adaptor.js
function adaptor26(params) {
  var init = function(params2) {
    var options = params2.options;
    var data2 = options.data;
    if (data2) {
      set_default4(options, "data", {
        value: data2
      });
    }
    return params2;
  };
  return flow_default(init, mark, transformOptions)(params);
}

// node_modules/@ant-design/plots/es/core/plots/treemap/index.js
var __extends35 = function() {
  var extendStatics2 = function(d2, b) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b2) {
      d3.__proto__ = b2;
    } || function(d3, b2) {
      for (var p2 in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p2))
          d3[p2] = b2[p2];
    };
    return extendStatics2(d2, b);
  };
  return function(d2, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics2(d2, b);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var Treemap2 = (
  /** @class */
  function(_super) {
    __extends35(Treemap3, _super);
    function Treemap3() {
      var _this2 = _super !== null && _super.apply(this, arguments) || this;
      _this2.type = "treemap";
      return _this2;
    }
    Treemap3.getDefaultOptions = function() {
      return {
        type: "view",
        children: [
          {
            type: "treemap"
          }
        ]
      };
    };
    Treemap3.prototype.getDefaultOptions = function() {
      return Treemap3.getDefaultOptions();
    };
    Treemap3.prototype.getSchemaAdaptor = function() {
      return adaptor26;
    };
    return Treemap3;
  }(Plot)
);

// node_modules/@ant-design/plots/es/core/plots/radial-bar/adaptor.js
var __assign19 = function() {
  __assign19 = Object.assign || function(t) {
    for (var s2, i = 1, n = arguments.length; i < n; i++) {
      s2 = arguments[i];
      for (var p2 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p2))
          t[p2] = s2[p2];
    }
    return t;
  };
  return __assign19.apply(this, arguments);
};
function adaptor27(params) {
  var coordinate2 = function(params2) {
    var options = params2.options;
    var startAngle = options.startAngle, maxAngle = options.maxAngle, coordinate3 = options.coordinate, radius = options.radius, innerRadius = options.innerRadius;
    var start = isNumber_default(startAngle) ? startAngle / (2 * Math.PI) * 360 : -90;
    var end = isNumber_default(maxAngle) ? (Number(maxAngle) + start) / 180 * Math.PI : Math.PI;
    set_default4(params2, ["options", "coordinate"], __assign19(__assign19(__assign19({}, coordinate3), pick_default4(options.coordinate, COORDIANTE_OPTIONS)), { endAngle: end, outerRadius: radius, innerRadius, startAngle: startAngle !== null && startAngle !== void 0 ? startAngle : -Math.PI / 2 }));
    return params2;
  };
  var tooltip2 = function(params2) {
    var options = params2.options;
    var tooltip3 = options.tooltip, xField = options.xField, yField = options.yField;
    if (!tooltip3) {
      set_default4(options, "tooltip", {
        title: false,
        items: [
          function(d2) {
            return { name: d2[xField], value: d2[yField] };
          }
        ]
      });
    }
    return params2;
  };
  var background = function(params2) {
    var options = params2.options;
    var markBackground = options.markBackground, children = options.children, scale10 = options.scale, coordinate3 = options.coordinate, xField = options.xField;
    var domain = get_default4(scale10, "y.domain", []);
    if (markBackground) {
      children.unshift(__assign19({
        type: "interval",
        xField,
        yField: domain[domain.length - 1],
        colorField: markBackground.color,
        scale: { color: { type: "identity" } },
        style: {
          fillOpacity: markBackground.opacity,
          fill: markBackground.color ? void 0 : "#e0e4ee"
          // fill
        },
        // 
        coordinate: __assign19(__assign19({}, coordinate3), { startAngle: -Math.PI / 2, endAngle: 3 / 2 * Math.PI }),
        animate: false
      }, markBackground));
    }
    return params2;
  };
  return flow_default(coordinate2, tooltip2, background, mark, transformOptions)(params);
}

// node_modules/@ant-design/plots/es/core/plots/radial-bar/index.js
var __extends36 = function() {
  var extendStatics2 = function(d2, b) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b2) {
      d3.__proto__ = b2;
    } || function(d3, b2) {
      for (var p2 in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p2))
          d3[p2] = b2[p2];
    };
    return extendStatics2(d2, b);
  };
  return function(d2, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics2(d2, b);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var RadialBar = (
  /** @class */
  function(_super) {
    __extends36(RadialBar3, _super);
    function RadialBar3() {
      var _this2 = _super !== null && _super.apply(this, arguments) || this;
      _this2.type = "radial";
      return _this2;
    }
    RadialBar3.getDefaultOptions = function() {
      return {
        type: "view",
        children: [{ type: "interval" }],
        coordinate: { type: "radial", innerRadius: 0.1, outerRadius: 1, endAngle: Math.PI },
        animate: { enter: { type: "waveIn", duration: 800 } },
        axis: {
          y: {
            nice: true,
            labelAutoHide: true,
            labelAutoRotate: false
          },
          x: {
            title: false,
            nice: true,
            labelAutoRotate: false,
            labelAutoHide: { type: "equidistance", cfg: { minGap: 6 } }
          }
        }
      };
    };
    RadialBar3.prototype.getDefaultOptions = function() {
      return RadialBar3.getDefaultOptions();
    };
    RadialBar3.prototype.getSchemaAdaptor = function() {
      return adaptor27;
    };
    return RadialBar3;
  }(Plot)
);

// node_modules/@ant-design/plots/es/core/plots/circlePacking/adaptor.js
function adaptor28(params) {
  return flow_default(transformOptions)(params);
}

// node_modules/@ant-design/plots/es/core/plots/circlePacking/index.js
var __extends37 = function() {
  var extendStatics2 = function(d2, b) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b2) {
      d3.__proto__ = b2;
    } || function(d3, b2) {
      for (var p2 in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p2))
          d3[p2] = b2[p2];
    };
    return extendStatics2(d2, b);
  };
  return function(d2, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics2(d2, b);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var CirclePacking = (
  /** @class */
  function(_super) {
    __extends37(CirclePacking2, _super);
    function CirclePacking2() {
      var _this2 = _super !== null && _super.apply(this, arguments) || this;
      _this2.type = "CirclePacking";
      return _this2;
    }
    CirclePacking2.getDefaultOptions = function() {
      return {
        legend: false,
        type: "view",
        children: [
          {
            type: "pack"
          }
        ]
      };
    };
    CirclePacking2.prototype.getDefaultOptions = function() {
      return CirclePacking2.getDefaultOptions();
    };
    CirclePacking2.prototype.getSchemaAdaptor = function() {
      return adaptor28;
    };
    return CirclePacking2;
  }(Plot)
);

// node_modules/@ant-design/plots/es/core/plots/violin/adaptor.js
var __assign20 = function() {
  __assign20 = Object.assign || function(t) {
    for (var s2, i = 1, n = arguments.length; i < n; i++) {
      s2 = arguments[i];
      for (var p2 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p2))
          t[p2] = s2[p2];
    }
    return t;
  };
  return __assign20.apply(this, arguments);
};
function adaptor29(params) {
  var customTransform = function(params2) {
    var options = params2.options;
    var xField = options.xField, yField = options.yField, seriesField = options.seriesField, children = options.children;
    var newChildren = children === null || children === void 0 ? void 0 : children.map(function(item) {
      return __assign20(__assign20({}, item), { xField, yField, seriesField, colorField: seriesField, data: item.type === "density" ? {
        transform: [
          {
            type: "kde",
            field: yField,
            groupBy: [xField, seriesField]
          }
        ]
      } : item.data });
    }).filter(function(item) {
      return options.violinType !== "density" || item.type === "density";
    });
    set_default4(options, "children", newChildren);
    if (options.violinType === "polar") {
      set_default4(options, "coordinate", { type: "polar" });
    }
    set_default4(options, "violinType", void 0);
    return params2;
  };
  return flow_default(customTransform, mark, transformOptions)(params);
}

// node_modules/@ant-design/plots/es/core/plots/violin/index.js
var __extends38 = function() {
  var extendStatics2 = function(d2, b) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b2) {
      d3.__proto__ = b2;
    } || function(d3, b2) {
      for (var p2 in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p2))
          d3[p2] = b2[p2];
    };
    return extendStatics2(d2, b);
  };
  return function(d2, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics2(d2, b);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var Violin2 = (
  /** @class */
  function(_super) {
    __extends38(Violin3, _super);
    function Violin3() {
      var _this2 = _super !== null && _super.apply(this, arguments) || this;
      _this2.type = "violin";
      return _this2;
    }
    Violin3.getDefaultOptions = function() {
      return {
        type: "view",
        children: [
          {
            type: "density",
            sizeField: "size",
            tooltip: false
          },
          {
            type: "boxplot",
            shapeField: "violin",
            style: {
              opacity: 0.5,
              point: false
            }
          }
        ],
        animate: { enter: { type: "fadeIn" } }
      };
    };
    Violin3.prototype.getDefaultOptions = function() {
      return Violin3.getDefaultOptions();
    };
    Violin3.prototype.getSchemaAdaptor = function() {
      return adaptor29;
    };
    return Violin3;
  }(Plot)
);

// node_modules/@ant-design/plots/es/core/plots/bidirectional-bar/adaptor.js
var __assign21 = function() {
  __assign21 = Object.assign || function(t) {
    for (var s2, i = 1, n = arguments.length; i < n; i++) {
      s2 = arguments[i];
      for (var p2 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p2))
          t[p2] = s2[p2];
    }
    return t;
  };
  return __assign21.apply(this, arguments);
};
var __spreadArray9 = function(to, from, pack3) {
  if (pack3 || arguments.length === 2)
    for (var i = 0, l = from.length, ar; i < l; i++) {
      if (ar || !(i in from)) {
        if (!ar)
          ar = Array.prototype.slice.call(from, 0, i);
        ar[i] = from[i];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from));
};
function adaptor30(params) {
  var field3 = function(params2) {
    var options = params2.options;
    var yField = options.yField, children = options.children;
    children.forEach(function(child, index3) {
      set_default4(child, "yField", yField[index3]);
    });
    return params2;
  };
  var data2 = function(params2) {
    var options = params2.options;
    var yField = options.yField, children = options.children, data3 = options.data;
    if (isPlainObject_default(data3))
      return params2;
    var transformData2 = isArray_default(get_default4(data3, [0])) ? data3 : [data3, data3];
    children.forEach(function(child, index3) {
      set_default4(child, "data", __spreadArray9([], transformData2[index3].map(function(item) {
        return __assign21({ groupKey: yField[index3] }, item);
      }), true));
    });
    return params2;
  };
  var tooltip2 = function(params2) {
    var options = params2.options;
    var _a2 = options.yField, y12 = _a2[0], y22 = _a2[1], tooltip3 = options.tooltip;
    if (!tooltip3) {
      set_default4(options, "tooltip", {
        items: [
          {
            field: y12,
            value: y12
          },
          {
            field: y22,
            value: y22
          }
        ]
      });
    }
    return params2;
  };
  var layout = function(params2) {
    var options = params2.options;
    var children = options.children, layout2 = options.layout, transform3 = options.coordinate.transform, _a2 = options.paddingBottom, paddingBottom = _a2 === void 0 ? AXIS_LABEL_PADDING : _a2, _b = options.paddingLeft, paddingLeft = _b === void 0 ? AXIS_LABEL_PADDING : _b, axis = options.axis;
    set_default4(options, "axisText", __assign21(__assign21({}, (axis === null || axis === void 0 ? void 0 : axis.x) || {}), { layout: layout2 }));
    var child1 = children[0], child2 = children[1];
    if (layout2 === "vertical") {
      set_default4(options, "direction", "col");
      set_default4(options, "paddingLeft", paddingLeft);
      set_default4(options, "coordinate.transform", transform3.filter(function(item) {
        return item.type !== "transpose";
      }));
      set_default4(child1, "paddingBottom", HORIZONTAL_MARGIN);
      set_default4(child2, "paddingTop", HORIZONTAL_MARGIN);
      set_default4(child2, "axis", {
        x: {
          position: "top"
        }
      });
      set_default4(child2, "scale", {
        y: {
          range: [0, 1]
        }
      });
    } else {
      set_default4(options, "paddingBottom", paddingBottom);
      set_default4(child1, "scale", {
        y: {
          range: [0, 1]
        }
      });
      var _c = child1.paddingRight, paddingRight = _c === void 0 ? VERTICAL_MARGIN : _c;
      var _d = child2.paddingLeft, paddingLeft_1 = _d === void 0 ? VERTICAL_MARGIN : _d;
      set_default4(child1, "paddingRight", paddingRight);
      set_default4(child1, "axis", {
        x: {
          position: "right"
        }
      });
      set_default4(child2, "paddingLeft", paddingLeft_1);
    }
    return params2;
  };
  return flow_default(field3, data2, tooltip2, layout, mark, transformOptions)(params);
}

// node_modules/@ant-design/plots/es/core/plots/bidirectional-bar/index.js
var __extends39 = function() {
  var extendStatics2 = function(d2, b) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b2) {
      d3.__proto__ = b2;
    } || function(d3, b2) {
      for (var p2 in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p2))
          d3[p2] = b2[p2];
    };
    return extendStatics2(d2, b);
  };
  return function(d2, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics2(d2, b);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var BidirectionalBar = (
  /** @class */
  function(_super) {
    __extends39(BidirectionalBar2, _super);
    function BidirectionalBar2() {
      var _this2 = _super !== null && _super.apply(this, arguments) || this;
      _this2.type = "BidirectionalBar";
      return _this2;
    }
    BidirectionalBar2.getDefaultOptions = function() {
      return {
        type: "spaceFlex",
        coordinate: { transform: [{ type: "transpose" }] },
        scale: {
          y: { nice: true }
        },
        direction: "row",
        layout: "horizontal",
        legend: false,
        axis: {
          y: {
            title: false
          },
          x: { title: false, label: false }
        },
        children: [{ type: "interval" }, { type: "interval" }]
      };
    };
    BidirectionalBar2.prototype.getDefaultOptions = function() {
      return BidirectionalBar2.getDefaultOptions();
    };
    BidirectionalBar2.prototype.getSchemaAdaptor = function() {
      return adaptor30;
    };
    return BidirectionalBar2;
  }(Plot)
);

// node_modules/@ant-design/plots/es/core/plots/venn/type.js
var DefaultTransformKey;
(function(DefaultTransformKey2) {
  DefaultTransformKey2["color"] = "key";
  DefaultTransformKey2["d"] = "path";
})(DefaultTransformKey || (DefaultTransformKey = {}));

// node_modules/@ant-design/plots/es/core/plots/venn/adaptor.js
function adaptor31(params) {
  var init = function(params2) {
    var options = params2.options;
    var data2 = options.data, setsField = options.setsField, sizeField = options.sizeField;
    if (isArray_default(data2)) {
      set_default4(options, "data", {
        type: "inline",
        value: data2,
        transform: [
          {
            type: "venn",
            sets: setsField,
            size: sizeField,
            as: [DefaultTransformKey.color, DefaultTransformKey.d]
          }
        ]
      });
      set_default4(options, "colorField", setsField);
      set_default4(options, ["children", "0", "encode", "d"], DefaultTransformKey.d);
    }
    set_default4(params2, "options", omit_default4(options, ["sizeField", "setsField"]));
    return params2;
  };
  return flow_default(init, transformOptions)(params);
}

// node_modules/@ant-design/plots/es/core/plots/venn/index.js
var __extends40 = function() {
  var extendStatics2 = function(d2, b) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b2) {
      d3.__proto__ = b2;
    } || function(d3, b2) {
      for (var p2 in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p2))
          d3[p2] = b2[p2];
    };
    return extendStatics2(d2, b);
  };
  return function(d2, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics2(d2, b);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var Venn2 = (
  /** @class */
  function(_super) {
    __extends40(Venn3, _super);
    function Venn3() {
      var _this2 = _super !== null && _super.apply(this, arguments) || this;
      _this2.type = "venn";
      return _this2;
    }
    Venn3.getDefaultOptions = function() {
      return {
        type: "view",
        children: [{ type: "path" }],
        legend: {
          color: { itemMarker: "circle" }
        },
        encode: { color: DefaultTransformKey.color, d: DefaultTransformKey.d }
      };
    };
    Venn3.prototype.getDefaultOptions = function() {
      return Venn3.getDefaultOptions();
    };
    Venn3.prototype.getSchemaAdaptor = function() {
      return adaptor31;
    };
    return Venn3;
  }(Plot)
);

// node_modules/@ant-design/plots/es/core/plots/sunburst/adaptor.js
function adaptor32(params) {
  var init = function(params2) {
    return params2;
  };
  return flow_default(init, coordinate, transformOptions)(params);
}

// node_modules/@ant-design/plots/es/core/plots/sunburst/index.js
var __extends41 = function() {
  var extendStatics2 = function(d2, b) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b2) {
      d3.__proto__ = b2;
    } || function(d3, b2) {
      for (var p2 in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p2))
          d3[p2] = b2[p2];
    };
    return extendStatics2(d2, b);
  };
  return function(d2, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics2(d2, b);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var Sunburst2 = (
  /** @class */
  function(_super) {
    __extends41(Sunburst3, _super);
    function Sunburst3() {
      var _this2 = _super !== null && _super.apply(this, arguments) || this;
      _this2.type = "Sunburst";
      return _this2;
    }
    Sunburst3.getDefaultOptions = function() {
      return { type: "view", children: [{ type: "sunburst" }] };
    };
    Sunburst3.prototype.getDefaultOptions = function() {
      return Sunburst3.getDefaultOptions();
    };
    Sunburst3.prototype.getSchemaAdaptor = function() {
      return adaptor32;
    };
    return Sunburst3;
  }(Plot)
);

// node_modules/@ant-design/plots/es/core/index.js
var Plots = {
  Base: Base2,
  Line: Line6,
  Column: Column2,
  Pie,
  Area: Area3,
  Bar,
  DualAxes,
  Funnel: Funnel2,
  Scatter,
  Radar: Radar2,
  Rose,
  Stock,
  TinyLine,
  TinyArea,
  TinyColumn,
  TinyProgress,
  TinyRing,
  Waterfall,
  Histogram,
  Heatmap: Heatmap3,
  Box: Box3,
  Sankey: Sankey4,
  Bullet,
  Gauge: Gauge2,
  Liquid: Liquid3,
  WordCloud: WordCloud3,
  Treemap: Treemap2,
  RadialBar,
  CirclePacking,
  Violin: Violin2,
  BidirectionalBar,
  Venn: Venn2,
  Mix: DualAxes,
  Sunburst: Sunburst2
};

// node_modules/@ant-design/plots/es/components/base/index.js
var __assign22 = function() {
  __assign22 = Object.assign || function(t) {
    for (var s2, i = 1, n = arguments.length; i < n; i++) {
      s2 = arguments[i];
      for (var p2 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p2))
          t[p2] = s2[p2];
    }
    return t;
  };
  return __assign22.apply(this, arguments);
};
var __rest94 = function(s2, e) {
  var t = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
      t[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t[p2[i]] = s2[p2[i]];
    }
  return t;
};
var BaseChart = (0, import_react4.forwardRef)(function(_a2, ref) {
  var _b = _a2.chartType, chartType = _b === void 0 ? "Base" : _b, config = __rest94(_a2, ["chartType"]);
  var _c = config.containerStyle, containerStyle = _c === void 0 ? {
    height: "inherit"
  } : _c, _d = config.containerAttributes, containerAttributes = _d === void 0 ? {} : _d, className2 = config.className, loading = config.loading, loadingTemplate = config.loadingTemplate, errorTemplate = config.errorTemplate, rest2 = __rest94(config, ["containerStyle", "containerAttributes", "className", "loading", "loadingTemplate", "errorTemplate"]);
  var _e = useChart(Plots[chartType], rest2), chart = _e.chart, container = _e.container;
  (0, import_react4.useImperativeHandle)(ref, function() {
    return chart.current;
  });
  return import_react4.default.createElement(
    ErrorBoundary,
    { errorTemplate },
    loading && import_react4.default.createElement(ChartLoading, { loadingTemplate }),
    import_react4.default.createElement("div", __assign22({ className: className2, style: containerStyle, ref: container }, containerAttributes))
  );
});

// node_modules/@ant-design/plots/es/components/area/index.js
var import_react5 = __toESM(require_react());
var __assign23 = function() {
  __assign23 = Object.assign || function(t) {
    for (var s2, i = 1, n = arguments.length; i < n; i++) {
      s2 = arguments[i];
      for (var p2 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p2))
          t[p2] = s2[p2];
    }
    return t;
  };
  return __assign23.apply(this, arguments);
};
var AreaChart = function(props) {
  return import_react5.default.createElement(BaseChart, __assign23({}, props, { chartType: "Area" }));
};
var area_default4 = AreaChart;

// node_modules/@ant-design/plots/es/components/bar/index.js
var import_react6 = __toESM(require_react());
var __assign24 = function() {
  __assign24 = Object.assign || function(t) {
    for (var s2, i = 1, n = arguments.length; i < n; i++) {
      s2 = arguments[i];
      for (var p2 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p2))
          t[p2] = s2[p2];
    }
    return t;
  };
  return __assign24.apply(this, arguments);
};
var BarChart2 = function(props) {
  return import_react6.default.createElement(BaseChart, __assign24({}, props, { chartType: "Bar" }));
};
var bar_default = BarChart2;

// node_modules/@ant-design/plots/es/components/column/index.js
var import_react7 = __toESM(require_react());
var __assign25 = function() {
  __assign25 = Object.assign || function(t) {
    for (var s2, i = 1, n = arguments.length; i < n; i++) {
      s2 = arguments[i];
      for (var p2 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p2))
          t[p2] = s2[p2];
    }
    return t;
  };
  return __assign25.apply(this, arguments);
};
var ColumnChart = function(props) {
  return import_react7.default.createElement(BaseChart, __assign25({}, props, { chartType: "Column" }));
};
var column_default = ColumnChart;

// node_modules/@ant-design/plots/es/components/dual-axes/index.js
var import_react8 = __toESM(require_react());
var __assign26 = function() {
  __assign26 = Object.assign || function(t) {
    for (var s2, i = 1, n = arguments.length; i < n; i++) {
      s2 = arguments[i];
      for (var p2 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p2))
          t[p2] = s2[p2];
    }
    return t;
  };
  return __assign26.apply(this, arguments);
};
var DualAxesChart = function(props) {
  return import_react8.default.createElement(BaseChart, __assign26({}, props, { chartType: "DualAxes" }));
};
var dual_axes_default = DualAxesChart;

// node_modules/@ant-design/plots/es/components/funnel/index.js
var import_react9 = __toESM(require_react());
var __assign27 = function() {
  __assign27 = Object.assign || function(t) {
    for (var s2, i = 1, n = arguments.length; i < n; i++) {
      s2 = arguments[i];
      for (var p2 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p2))
          t[p2] = s2[p2];
    }
    return t;
  };
  return __assign27.apply(this, arguments);
};
var FunnelChart = function(props) {
  return import_react9.default.createElement(BaseChart, __assign27({}, props, { chartType: "Funnel" }));
};
var funnel_default = FunnelChart;

// node_modules/@ant-design/plots/es/components/line/index.js
var import_react10 = __toESM(require_react());
var __assign28 = function() {
  __assign28 = Object.assign || function(t) {
    for (var s2, i = 1, n = arguments.length; i < n; i++) {
      s2 = arguments[i];
      for (var p2 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p2))
          t[p2] = s2[p2];
    }
    return t;
  };
  return __assign28.apply(this, arguments);
};
var LineChart2 = function(props) {
  return import_react10.default.createElement(BaseChart, __assign28({}, props, { chartType: "Line" }));
};
var line_default3 = LineChart2;

// node_modules/@ant-design/plots/es/components/pie/index.js
var import_react11 = __toESM(require_react());
var __assign29 = function() {
  __assign29 = Object.assign || function(t) {
    for (var s2, i = 1, n = arguments.length; i < n; i++) {
      s2 = arguments[i];
      for (var p2 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p2))
          t[p2] = s2[p2];
    }
    return t;
  };
  return __assign29.apply(this, arguments);
};
var PieChart = function(props) {
  return import_react11.default.createElement(BaseChart, __assign29({}, props, { chartType: "Pie" }));
};
var pie_default2 = PieChart;

// node_modules/@ant-design/plots/es/components/scatter/index.js
var import_react12 = __toESM(require_react());
var __assign30 = function() {
  __assign30 = Object.assign || function(t) {
    for (var s2, i = 1, n = arguments.length; i < n; i++) {
      s2 = arguments[i];
      for (var p2 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p2))
          t[p2] = s2[p2];
    }
    return t;
  };
  return __assign30.apply(this, arguments);
};
var ScatterChart = function(props) {
  return import_react12.default.createElement(BaseChart, __assign30({}, props, { chartType: "Scatter" }));
};
var scatter_default = ScatterChart;

// node_modules/@ant-design/plots/es/components/radar/index.js
var import_react13 = __toESM(require_react());
var __assign31 = function() {
  __assign31 = Object.assign || function(t) {
    for (var s2, i = 1, n = arguments.length; i < n; i++) {
      s2 = arguments[i];
      for (var p2 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p2))
          t[p2] = s2[p2];
    }
    return t;
  };
  return __assign31.apply(this, arguments);
};
var RadarChart = function(props) {
  return import_react13.default.createElement(BaseChart, __assign31({}, props, { chartType: "Radar" }));
};
var radar_default = RadarChart;

// node_modules/@ant-design/plots/es/components/tiny/line/index.js
var import_react14 = __toESM(require_react());
var __assign32 = function() {
  __assign32 = Object.assign || function(t) {
    for (var s2, i = 1, n = arguments.length; i < n; i++) {
      s2 = arguments[i];
      for (var p2 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p2))
          t[p2] = s2[p2];
    }
    return t;
  };
  return __assign32.apply(this, arguments);
};
var TinyLineChart = function(props) {
  return import_react14.default.createElement(BaseChart, __assign32({}, props, { chartType: "TinyLine" }));
};
var line_default4 = TinyLineChart;

// node_modules/@ant-design/plots/es/components/tiny/area/index.js
var import_react15 = __toESM(require_react());
var __assign33 = function() {
  __assign33 = Object.assign || function(t) {
    for (var s2, i = 1, n = arguments.length; i < n; i++) {
      s2 = arguments[i];
      for (var p2 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p2))
          t[p2] = s2[p2];
    }
    return t;
  };
  return __assign33.apply(this, arguments);
};
var TinyAreaChart = function(props) {
  return import_react15.default.createElement(BaseChart, __assign33({}, props, { chartType: "TinyArea" }));
};
var area_default5 = TinyAreaChart;

// node_modules/@ant-design/plots/es/components/tiny/column/index.js
var import_react16 = __toESM(require_react());
var __assign34 = function() {
  __assign34 = Object.assign || function(t) {
    for (var s2, i = 1, n = arguments.length; i < n; i++) {
      s2 = arguments[i];
      for (var p2 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p2))
          t[p2] = s2[p2];
    }
    return t;
  };
  return __assign34.apply(this, arguments);
};
var TinyLineChart2 = function(props) {
  return import_react16.default.createElement(BaseChart, __assign34({}, props, { chartType: "TinyColumn" }));
};
var column_default2 = TinyLineChart2;

// node_modules/@ant-design/plots/es/components/tiny/progress/index.js
var import_react17 = __toESM(require_react());
var __assign35 = function() {
  __assign35 = Object.assign || function(t) {
    for (var s2, i = 1, n = arguments.length; i < n; i++) {
      s2 = arguments[i];
      for (var p2 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p2))
          t[p2] = s2[p2];
    }
    return t;
  };
  return __assign35.apply(this, arguments);
};
var TinyProgressChart = function(props) {
  return import_react17.default.createElement(BaseChart, __assign35({}, props, { chartType: "TinyProgress" }));
};
var progress_default = TinyProgressChart;

// node_modules/@ant-design/plots/es/components/tiny/ring/index.js
var import_react18 = __toESM(require_react());
var __assign36 = function() {
  __assign36 = Object.assign || function(t) {
    for (var s2, i = 1, n = arguments.length; i < n; i++) {
      s2 = arguments[i];
      for (var p2 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p2))
          t[p2] = s2[p2];
    }
    return t;
  };
  return __assign36.apply(this, arguments);
};
var TinyRingChart = function(props) {
  return import_react18.default.createElement(BaseChart, __assign36({}, props, { chartType: "TinyRing" }));
};
var ring_default = TinyRingChart;

// node_modules/@ant-design/plots/es/components/tiny/index.js
var Tiny = { Line: line_default4, Area: area_default5, Column: column_default2, Progress: progress_default, Ring: ring_default };

// node_modules/@ant-design/plots/es/components/rose/index.js
var import_react19 = __toESM(require_react());
var __assign37 = function() {
  __assign37 = Object.assign || function(t) {
    for (var s2, i = 1, n = arguments.length; i < n; i++) {
      s2 = arguments[i];
      for (var p2 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p2))
          t[p2] = s2[p2];
    }
    return t;
  };
  return __assign37.apply(this, arguments);
};
var RoseChart = function(props) {
  return import_react19.default.createElement(BaseChart, __assign37({}, props, { chartType: "Rose" }));
};
var rose_default = RoseChart;

// node_modules/@ant-design/plots/es/components/waterfall/index.js
var import_react20 = __toESM(require_react());
var __assign38 = function() {
  __assign38 = Object.assign || function(t) {
    for (var s2, i = 1, n = arguments.length; i < n; i++) {
      s2 = arguments[i];
      for (var p2 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p2))
          t[p2] = s2[p2];
    }
    return t;
  };
  return __assign38.apply(this, arguments);
};
var WaterfallChart = function(props) {
  return import_react20.default.createElement(BaseChart, __assign38({}, props, { chartType: "Waterfall" }));
};
var waterfall_default = WaterfallChart;

// node_modules/@ant-design/plots/es/components/histogram/index.js
var import_react21 = __toESM(require_react());
var __assign39 = function() {
  __assign39 = Object.assign || function(t) {
    for (var s2, i = 1, n = arguments.length; i < n; i++) {
      s2 = arguments[i];
      for (var p2 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p2))
          t[p2] = s2[p2];
    }
    return t;
  };
  return __assign39.apply(this, arguments);
};
var HistogramChart = function(props) {
  return import_react21.default.createElement(BaseChart, __assign39({}, props, { chartType: "Histogram" }));
};
var histogram_default = HistogramChart;

// node_modules/@ant-design/plots/es/components/heatmap/index.js
var import_react22 = __toESM(require_react());
var __assign40 = function() {
  __assign40 = Object.assign || function(t) {
    for (var s2, i = 1, n = arguments.length; i < n; i++) {
      s2 = arguments[i];
      for (var p2 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p2))
          t[p2] = s2[p2];
    }
    return t;
  };
  return __assign40.apply(this, arguments);
};
var HeatmapChart = function(props) {
  return import_react22.default.createElement(BaseChart, __assign40({}, props, { chartType: "Heatmap" }));
};
var heatmap_default = HeatmapChart;

// node_modules/@ant-design/plots/es/components/box/index.js
var import_react23 = __toESM(require_react());
var __assign41 = function() {
  __assign41 = Object.assign || function(t) {
    for (var s2, i = 1, n = arguments.length; i < n; i++) {
      s2 = arguments[i];
      for (var p2 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p2))
          t[p2] = s2[p2];
    }
    return t;
  };
  return __assign41.apply(this, arguments);
};
var BoxChart = function(props) {
  return import_react23.default.createElement(BaseChart, __assign41({}, props, { chartType: "Box" }));
};
var box_default = BoxChart;

// node_modules/@ant-design/plots/es/components/sankey/index.js
var import_react24 = __toESM(require_react());
var __assign42 = function() {
  __assign42 = Object.assign || function(t) {
    for (var s2, i = 1, n = arguments.length; i < n; i++) {
      s2 = arguments[i];
      for (var p2 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p2))
          t[p2] = s2[p2];
    }
    return t;
  };
  return __assign42.apply(this, arguments);
};
var SankeyChart = function(props) {
  return import_react24.default.createElement(BaseChart, __assign42({}, props, { chartType: "Sankey" }));
};
var sankey_default = SankeyChart;

// node_modules/@ant-design/plots/es/components/stock/index.js
var import_react25 = __toESM(require_react());
var __assign43 = function() {
  __assign43 = Object.assign || function(t) {
    for (var s2, i = 1, n = arguments.length; i < n; i++) {
      s2 = arguments[i];
      for (var p2 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p2))
          t[p2] = s2[p2];
    }
    return t;
  };
  return __assign43.apply(this, arguments);
};
var StockChart = function(props) {
  return import_react25.default.createElement(BaseChart, __assign43({}, props, { chartType: "Stock" }));
};
var stock_default = StockChart;

// node_modules/@ant-design/plots/es/components/bullet/index.js
var import_react26 = __toESM(require_react());
var __assign44 = function() {
  __assign44 = Object.assign || function(t) {
    for (var s2, i = 1, n = arguments.length; i < n; i++) {
      s2 = arguments[i];
      for (var p2 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p2))
          t[p2] = s2[p2];
    }
    return t;
  };
  return __assign44.apply(this, arguments);
};
var BulletChart = function(props) {
  return import_react26.default.createElement(BaseChart, __assign44({}, props, { chartType: "Bullet" }));
};
var bullet_default = BulletChart;

// node_modules/@ant-design/plots/es/components/gauge/index.js
var import_react27 = __toESM(require_react());
var __assign45 = function() {
  __assign45 = Object.assign || function(t) {
    for (var s2, i = 1, n = arguments.length; i < n; i++) {
      s2 = arguments[i];
      for (var p2 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p2))
          t[p2] = s2[p2];
    }
    return t;
  };
  return __assign45.apply(this, arguments);
};
var GaugeChart = function(props) {
  return import_react27.default.createElement(BaseChart, __assign45({}, props, { chartType: "Gauge" }));
};
var gauge_default = GaugeChart;

// node_modules/@ant-design/plots/es/components/liquid/index.js
var import_react28 = __toESM(require_react());
var __assign46 = function() {
  __assign46 = Object.assign || function(t) {
    for (var s2, i = 1, n = arguments.length; i < n; i++) {
      s2 = arguments[i];
      for (var p2 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p2))
          t[p2] = s2[p2];
    }
    return t;
  };
  return __assign46.apply(this, arguments);
};
var LiquidChart = function(props) {
  return import_react28.default.createElement(BaseChart, __assign46({}, props, { chartType: "Liquid" }));
};
var liquid_default = LiquidChart;

// node_modules/@ant-design/plots/es/components/wordCloud/index.js
var import_react29 = __toESM(require_react());
var __assign47 = function() {
  __assign47 = Object.assign || function(t) {
    for (var s2, i = 1, n = arguments.length; i < n; i++) {
      s2 = arguments[i];
      for (var p2 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p2))
          t[p2] = s2[p2];
    }
    return t;
  };
  return __assign47.apply(this, arguments);
};
var WordCloudChart = function(props) {
  return import_react29.default.createElement(BaseChart, __assign47({}, props, { chartType: "WordCloud" }));
};
var wordCloud_default = WordCloudChart;

// node_modules/@ant-design/plots/es/components/treemap/index.js
var import_react30 = __toESM(require_react());
var __assign48 = function() {
  __assign48 = Object.assign || function(t) {
    for (var s2, i = 1, n = arguments.length; i < n; i++) {
      s2 = arguments[i];
      for (var p2 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p2))
          t[p2] = s2[p2];
    }
    return t;
  };
  return __assign48.apply(this, arguments);
};
var TreemapChart = function(props) {
  return import_react30.default.createElement(BaseChart, __assign48({}, props, { chartType: "Treemap" }));
};
var treemap_default2 = TreemapChart;

// node_modules/@ant-design/plots/es/components/radial-bar/index.js
var import_react31 = __toESM(require_react());
var __assign49 = function() {
  __assign49 = Object.assign || function(t) {
    for (var s2, i = 1, n = arguments.length; i < n; i++) {
      s2 = arguments[i];
      for (var p2 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p2))
          t[p2] = s2[p2];
    }
    return t;
  };
  return __assign49.apply(this, arguments);
};
var RadialBar2 = function(props) {
  return import_react31.default.createElement(BaseChart, __assign49({}, props, { chartType: "RadialBar" }));
};
var radial_bar_default = RadialBar2;

// node_modules/@ant-design/plots/es/components/circlePacking/index.js
var import_react32 = __toESM(require_react());
var __assign50 = function() {
  __assign50 = Object.assign || function(t) {
    for (var s2, i = 1, n = arguments.length; i < n; i++) {
      s2 = arguments[i];
      for (var p2 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p2))
          t[p2] = s2[p2];
    }
    return t;
  };
  return __assign50.apply(this, arguments);
};
var CirclePackingChart = function(props) {
  return import_react32.default.createElement(BaseChart, __assign50({}, props, { chartType: "CirclePacking" }));
};
var circlePacking_default = CirclePackingChart;

// node_modules/@ant-design/plots/es/components/violin/index.js
var import_react33 = __toESM(require_react());
var __assign51 = function() {
  __assign51 = Object.assign || function(t) {
    for (var s2, i = 1, n = arguments.length; i < n; i++) {
      s2 = arguments[i];
      for (var p2 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p2))
          t[p2] = s2[p2];
    }
    return t;
  };
  return __assign51.apply(this, arguments);
};
var ViolinChart = function(props) {
  return import_react33.default.createElement(BaseChart, __assign51({}, props, { chartType: "Violin" }));
};
var violin_default = ViolinChart;

// node_modules/@ant-design/plots/es/components/bidirectional-bar/index.js
var import_react34 = __toESM(require_react());
var __assign52 = function() {
  __assign52 = Object.assign || function(t) {
    for (var s2, i = 1, n = arguments.length; i < n; i++) {
      s2 = arguments[i];
      for (var p2 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p2))
          t[p2] = s2[p2];
    }
    return t;
  };
  return __assign52.apply(this, arguments);
};
var BidirectionalBarChart = function(props) {
  return import_react34.default.createElement(BaseChart, __assign52({}, props, { chartType: "BidirectionalBar" }));
};
var bidirectional_bar_default = BidirectionalBarChart;

// node_modules/@ant-design/plots/es/components/venn/index.js
var import_react35 = __toESM(require_react());
var __assign53 = function() {
  __assign53 = Object.assign || function(t) {
    for (var s2, i = 1, n = arguments.length; i < n; i++) {
      s2 = arguments[i];
      for (var p2 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p2))
          t[p2] = s2[p2];
    }
    return t;
  };
  return __assign53.apply(this, arguments);
};
var VennChart = function(props) {
  return import_react35.default.createElement(BaseChart, __assign53({}, props, { chartType: "Venn" }));
};
var venn_default = VennChart;

// node_modules/@ant-design/plots/es/components/mix/index.js
var import_react36 = __toESM(require_react());
var __assign54 = function() {
  __assign54 = Object.assign || function(t) {
    for (var s2, i = 1, n = arguments.length; i < n; i++) {
      s2 = arguments[i];
      for (var p2 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p2))
          t[p2] = s2[p2];
    }
    return t;
  };
  return __assign54.apply(this, arguments);
};
var MixChart = function(props) {
  return import_react36.default.createElement(BaseChart, __assign54({}, props, { chartType: "Mix" }));
};
var mix_default = MixChart;

// node_modules/@ant-design/plots/es/components/sunburst/index.js
var import_react37 = __toESM(require_react());
var __assign55 = function() {
  __assign55 = Object.assign || function(t) {
    for (var s2, i = 1, n = arguments.length; i < n; i++) {
      s2 = arguments[i];
      for (var p2 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p2))
          t[p2] = s2[p2];
    }
    return t;
  };
  return __assign55.apply(this, arguments);
};
var SunburstChart = function(props) {
  return import_react37.default.createElement(BaseChart, __assign55({}, props, { chartType: "Sunburst" }));
};
var sunburst_default = SunburstChart;
export {
  area_default4 as Area,
  bar_default as Bar,
  BaseChart as Base,
  bidirectional_bar_default as BidirectionalBar,
  box_default as Box,
  bullet_default as Bullet,
  circlePacking_default as CirclePacking,
  column_default as Column,
  dual_axes_default as DualAxes,
  funnel_default as Funnel,
  esm_exports as G2,
  gauge_default as Gauge,
  heatmap_default as Heatmap,
  histogram_default as Histogram,
  line_default3 as Line,
  liquid_default as Liquid,
  mix_default as Mix,
  pie_default2 as Pie,
  radar_default as Radar,
  radial_bar_default as RadialBar,
  rose_default as Rose,
  sankey_default as Sankey,
  scatter_default as Scatter,
  stock_default as Stock,
  sunburst_default as Sunburst,
  Tiny,
  treemap_default2 as Treemap,
  venn_default as Venn,
  violin_default as Violin,
  waterfall_default as Waterfall,
  wordCloud_default as WordCloud
};
/*! Bundled license information:

lodash-es/lodash.default.js:
  (**
   * @license
   * Lodash (Custom Build) <https://lodash.com/>
   * Build: `lodash modularize exports="es" -o ./`
   * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
   * Released under MIT license <https://lodash.com/license>
   * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
   * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
   *)

lodash-es/lodash.js:
  (**
   * @license
   * Lodash (Custom Build) <https://lodash.com/>
   * Build: `lodash modularize exports="es" -o ./`
   * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
   * Released under MIT license <https://lodash.com/license>
   * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
   * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
   *)
*/
//# sourceMappingURL=@ant-design_plots.js.map
